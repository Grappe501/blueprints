
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model County
 * 
 */
export type County = $Result.DefaultSelection<Prisma.$CountyPayload>
/**
 * Model Issue
 * 
 */
export type Issue = $Result.DefaultSelection<Prisma.$IssuePayload>
/**
 * Model CountyIssue
 * 
 */
export type CountyIssue = $Result.DefaultSelection<Prisma.$CountyIssuePayload>
/**
 * Model BlueprintSection
 * 
 */
export type BlueprintSection = $Result.DefaultSelection<Prisma.$BlueprintSectionPayload>
/**
 * Model Quote
 * 
 */
export type Quote = $Result.DefaultSelection<Prisma.$QuotePayload>
/**
 * Model Asset
 * 
 */
export type Asset = $Result.DefaultSelection<Prisma.$AssetPayload>
/**
 * Model GlossaryTerm
 * 
 */
export type GlossaryTerm = $Result.DefaultSelection<Prisma.$GlossaryTermPayload>
/**
 * Model SourceDocument
 * 
 */
export type SourceDocument = $Result.DefaultSelection<Prisma.$SourceDocumentPayload>
/**
 * Model SourceChunk
 * 
 */
export type SourceChunk = $Result.DefaultSelection<Prisma.$SourceChunkPayload>
/**
 * Model SourceDocumentLink
 * 
 */
export type SourceDocumentLink = $Result.DefaultSelection<Prisma.$SourceDocumentLinkPayload>
/**
 * Model GeoCounty
 * 
 */
export type GeoCounty = $Result.DefaultSelection<Prisma.$GeoCountyPayload>
/**
 * Model GeoZip
 * 
 */
export type GeoZip = $Result.DefaultSelection<Prisma.$GeoZipPayload>
/**
 * Model GeoPrecinct
 * 
 */
export type GeoPrecinct = $Result.DefaultSelection<Prisma.$GeoPrecinctPayload>
/**
 * Model GeoDistrict
 * 
 */
export type GeoDistrict = $Result.DefaultSelection<Prisma.$GeoDistrictPayload>
/**
 * Model GeoCrosswalk
 * 
 */
export type GeoCrosswalk = $Result.DefaultSelection<Prisma.$GeoCrosswalkPayload>
/**
 * Model CensusMetric
 * 
 */
export type CensusMetric = $Result.DefaultSelection<Prisma.$CensusMetricPayload>
/**
 * Model BLSMetric
 * 
 */
export type BLSMetric = $Result.DefaultSelection<Prisma.$BLSMetricPayload>
/**
 * Model CivicsOfficial
 * 
 */
export type CivicsOfficial = $Result.DefaultSelection<Prisma.$CivicsOfficialPayload>
/**
 * Model Election
 * 
 */
export type Election = $Result.DefaultSelection<Prisma.$ElectionPayload>
/**
 * Model ElectionResult
 * 
 */
export type ElectionResult = $Result.DefaultSelection<Prisma.$ElectionResultPayload>
/**
 * Model AIPrompt
 * 
 */
export type AIPrompt = $Result.DefaultSelection<Prisma.$AIPromptPayload>
/**
 * Model AIRun
 * 
 */
export type AIRun = $Result.DefaultSelection<Prisma.$AIRunPayload>
/**
 * Model AIRunInputSource
 * 
 */
export type AIRunInputSource = $Result.DefaultSelection<Prisma.$AIRunInputSourcePayload>
/**
 * Model AIOutput
 * 
 */
export type AIOutput = $Result.DefaultSelection<Prisma.$AIOutputPayload>
/**
 * Model AIOutputSection
 * 
 */
export type AIOutputSection = $Result.DefaultSelection<Prisma.$AIOutputSectionPayload>
/**
 * Model AIOutputScope
 * 
 */
export type AIOutputScope = $Result.DefaultSelection<Prisma.$AIOutputScopePayload>
/**
 * Model Citation
 * 
 */
export type Citation = $Result.DefaultSelection<Prisma.$CitationPayload>
/**
 * Model SurveyForm
 * 
 */
export type SurveyForm = $Result.DefaultSelection<Prisma.$SurveyFormPayload>
/**
 * Model SurveyQuestion
 * 
 */
export type SurveyQuestion = $Result.DefaultSelection<Prisma.$SurveyQuestionPayload>
/**
 * Model SurveyQuestionOption
 * 
 */
export type SurveyQuestionOption = $Result.DefaultSelection<Prisma.$SurveyQuestionOptionPayload>
/**
 * Model SurveyResponse
 * 
 */
export type SurveyResponse = $Result.DefaultSelection<Prisma.$SurveyResponsePayload>
/**
 * Model SurveyResponseItem
 * 
 */
export type SurveyResponseItem = $Result.DefaultSelection<Prisma.$SurveyResponseItemPayload>
/**
 * Model SurveyResponseItemOption
 * 
 */
export type SurveyResponseItemOption = $Result.DefaultSelection<Prisma.$SurveyResponseItemOptionPayload>
/**
 * Model MediaAsset
 * 
 */
export type MediaAsset = $Result.DefaultSelection<Prisma.$MediaAssetPayload>
/**
 * Model Transcript
 * 
 */
export type Transcript = $Result.DefaultSelection<Prisma.$TranscriptPayload>
/**
 * Model AIAnalysis
 * 
 */
export type AIAnalysis = $Result.DefaultSelection<Prisma.$AIAnalysisPayload>
/**
 * Model VoterRegistration
 * 
 */
export type VoterRegistration = $Result.DefaultSelection<Prisma.$VoterRegistrationPayload>
/**
 * Model VoteHistory
 * 
 */
export type VoteHistory = $Result.DefaultSelection<Prisma.$VoteHistoryPayload>
/**
 * Model Segment
 * 
 */
export type Segment = $Result.DefaultSelection<Prisma.$SegmentPayload>
/**
 * Model SegmentMember
 * 
 */
export type SegmentMember = $Result.DefaultSelection<Prisma.$SegmentMemberPayload>
/**
 * Model ImportJob
 * 
 */
export type ImportJob = $Result.DefaultSelection<Prisma.$ImportJobPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const PublishStatus: {
  draft: 'draft',
  reviewed: 'reviewed',
  published: 'published'
};

export type PublishStatus = (typeof PublishStatus)[keyof typeof PublishStatus]


export const YesNoUnknown: {
  yes: 'yes',
  no: 'no',
  unknown: 'unknown'
};

export type YesNoUnknown = (typeof YesNoUnknown)[keyof typeof YesNoUnknown]


export const AssetType: {
  photo: 'photo',
  document: 'document',
  audio: 'audio',
  video: 'video',
  other: 'other'
};

export type AssetType = (typeof AssetType)[keyof typeof AssetType]


export const CrosswalkType: {
  zip_to_county: 'zip_to_county',
  precinct_to_district: 'precinct_to_district',
  precinct_to_county: 'precinct_to_county',
  zip_to_district: 'zip_to_district',
  other: 'other'
};

export type CrosswalkType = (typeof CrosswalkType)[keyof typeof CrosswalkType]


export const AIRunStatus: {
  queued: 'queued',
  running: 'running',
  succeeded: 'succeeded',
  failed: 'failed',
  canceled: 'canceled'
};

export type AIRunStatus = (typeof AIRunStatus)[keyof typeof AIRunStatus]


export const AIOutputType: {
  county_brief: 'county_brief',
  issue_brief: 'issue_brief',
  zip_snapshot: 'zip_snapshot',
  talking_points: 'talking_points',
  action_options: 'action_options',
  glossary_draft: 'glossary_draft',
  other: 'other'
};

export type AIOutputType = (typeof AIOutputType)[keyof typeof AIOutputType]


export const AIScopeType: {
  county: 'county',
  issue: 'issue',
  zip: 'zip',
  district: 'district',
  statewide: 'statewide',
  custom: 'custom'
};

export type AIScopeType = (typeof AIScopeType)[keyof typeof AIScopeType]


export const AIRunInputKind: {
  source_document: 'source_document',
  dataset: 'dataset',
  manual_note: 'manual_note',
  other: 'other'
};

export type AIRunInputKind = (typeof AIRunInputKind)[keyof typeof AIRunInputKind]


export const SurveyFormStatus: {
  draft: 'draft',
  active: 'active',
  closed: 'closed',
  archived: 'archived'
};

export type SurveyFormStatus = (typeof SurveyFormStatus)[keyof typeof SurveyFormStatus]


export const SurveyQuestionType: {
  text: 'text',
  long_text: 'long_text',
  number: 'number',
  boolean: 'boolean',
  single_select: 'single_select',
  multi_select: 'multi_select',
  rating: 'rating'
};

export type SurveyQuestionType = (typeof SurveyQuestionType)[keyof typeof SurveyQuestionType]


export const AnalysisType: {
  transcription_summary: 'transcription_summary',
  sentiment_estimate: 'sentiment_estimate',
  emotion_tags_estimate: 'emotion_tags_estimate',
  speaking_rate_estimate: 'speaking_rate_estimate',
  other: 'other'
};

export type AnalysisType = (typeof AnalysisType)[keyof typeof AnalysisType]


export const ImportJobKind: {
  voter_registration: 'voter_registration',
  vote_history: 'vote_history',
  other: 'other'
};

export type ImportJobKind = (typeof ImportJobKind)[keyof typeof ImportJobKind]


export const ImportJobStatus: {
  queued: 'queued',
  running: 'running',
  succeeded: 'succeeded',
  failed: 'failed'
};

export type ImportJobStatus = (typeof ImportJobStatus)[keyof typeof ImportJobStatus]

}

export type PublishStatus = $Enums.PublishStatus

export const PublishStatus: typeof $Enums.PublishStatus

export type YesNoUnknown = $Enums.YesNoUnknown

export const YesNoUnknown: typeof $Enums.YesNoUnknown

export type AssetType = $Enums.AssetType

export const AssetType: typeof $Enums.AssetType

export type CrosswalkType = $Enums.CrosswalkType

export const CrosswalkType: typeof $Enums.CrosswalkType

export type AIRunStatus = $Enums.AIRunStatus

export const AIRunStatus: typeof $Enums.AIRunStatus

export type AIOutputType = $Enums.AIOutputType

export const AIOutputType: typeof $Enums.AIOutputType

export type AIScopeType = $Enums.AIScopeType

export const AIScopeType: typeof $Enums.AIScopeType

export type AIRunInputKind = $Enums.AIRunInputKind

export const AIRunInputKind: typeof $Enums.AIRunInputKind

export type SurveyFormStatus = $Enums.SurveyFormStatus

export const SurveyFormStatus: typeof $Enums.SurveyFormStatus

export type SurveyQuestionType = $Enums.SurveyQuestionType

export const SurveyQuestionType: typeof $Enums.SurveyQuestionType

export type AnalysisType = $Enums.AnalysisType

export const AnalysisType: typeof $Enums.AnalysisType

export type ImportJobKind = $Enums.ImportJobKind

export const ImportJobKind: typeof $Enums.ImportJobKind

export type ImportJobStatus = $Enums.ImportJobStatus

export const ImportJobStatus: typeof $Enums.ImportJobStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Counties
 * const counties = await prisma.county.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Counties
   * const counties = await prisma.county.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.county`: Exposes CRUD operations for the **County** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Counties
    * const counties = await prisma.county.findMany()
    * ```
    */
  get county(): Prisma.CountyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.issue`: Exposes CRUD operations for the **Issue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Issues
    * const issues = await prisma.issue.findMany()
    * ```
    */
  get issue(): Prisma.IssueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.countyIssue`: Exposes CRUD operations for the **CountyIssue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CountyIssues
    * const countyIssues = await prisma.countyIssue.findMany()
    * ```
    */
  get countyIssue(): Prisma.CountyIssueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blueprintSection`: Exposes CRUD operations for the **BlueprintSection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlueprintSections
    * const blueprintSections = await prisma.blueprintSection.findMany()
    * ```
    */
  get blueprintSection(): Prisma.BlueprintSectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quote`: Exposes CRUD operations for the **Quote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quotes
    * const quotes = await prisma.quote.findMany()
    * ```
    */
  get quote(): Prisma.QuoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.asset`: Exposes CRUD operations for the **Asset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Assets
    * const assets = await prisma.asset.findMany()
    * ```
    */
  get asset(): Prisma.AssetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.glossaryTerm`: Exposes CRUD operations for the **GlossaryTerm** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GlossaryTerms
    * const glossaryTerms = await prisma.glossaryTerm.findMany()
    * ```
    */
  get glossaryTerm(): Prisma.GlossaryTermDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sourceDocument`: Exposes CRUD operations for the **SourceDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SourceDocuments
    * const sourceDocuments = await prisma.sourceDocument.findMany()
    * ```
    */
  get sourceDocument(): Prisma.SourceDocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sourceChunk`: Exposes CRUD operations for the **SourceChunk** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SourceChunks
    * const sourceChunks = await prisma.sourceChunk.findMany()
    * ```
    */
  get sourceChunk(): Prisma.SourceChunkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sourceDocumentLink`: Exposes CRUD operations for the **SourceDocumentLink** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SourceDocumentLinks
    * const sourceDocumentLinks = await prisma.sourceDocumentLink.findMany()
    * ```
    */
  get sourceDocumentLink(): Prisma.SourceDocumentLinkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.geoCounty`: Exposes CRUD operations for the **GeoCounty** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GeoCounties
    * const geoCounties = await prisma.geoCounty.findMany()
    * ```
    */
  get geoCounty(): Prisma.GeoCountyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.geoZip`: Exposes CRUD operations for the **GeoZip** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GeoZips
    * const geoZips = await prisma.geoZip.findMany()
    * ```
    */
  get geoZip(): Prisma.GeoZipDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.geoPrecinct`: Exposes CRUD operations for the **GeoPrecinct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GeoPrecincts
    * const geoPrecincts = await prisma.geoPrecinct.findMany()
    * ```
    */
  get geoPrecinct(): Prisma.GeoPrecinctDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.geoDistrict`: Exposes CRUD operations for the **GeoDistrict** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GeoDistricts
    * const geoDistricts = await prisma.geoDistrict.findMany()
    * ```
    */
  get geoDistrict(): Prisma.GeoDistrictDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.geoCrosswalk`: Exposes CRUD operations for the **GeoCrosswalk** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GeoCrosswalks
    * const geoCrosswalks = await prisma.geoCrosswalk.findMany()
    * ```
    */
  get geoCrosswalk(): Prisma.GeoCrosswalkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.censusMetric`: Exposes CRUD operations for the **CensusMetric** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CensusMetrics
    * const censusMetrics = await prisma.censusMetric.findMany()
    * ```
    */
  get censusMetric(): Prisma.CensusMetricDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bLSMetric`: Exposes CRUD operations for the **BLSMetric** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BLSMetrics
    * const bLSMetrics = await prisma.bLSMetric.findMany()
    * ```
    */
  get bLSMetric(): Prisma.BLSMetricDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.civicsOfficial`: Exposes CRUD operations for the **CivicsOfficial** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CivicsOfficials
    * const civicsOfficials = await prisma.civicsOfficial.findMany()
    * ```
    */
  get civicsOfficial(): Prisma.CivicsOfficialDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.election`: Exposes CRUD operations for the **Election** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Elections
    * const elections = await prisma.election.findMany()
    * ```
    */
  get election(): Prisma.ElectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.electionResult`: Exposes CRUD operations for the **ElectionResult** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ElectionResults
    * const electionResults = await prisma.electionResult.findMany()
    * ```
    */
  get electionResult(): Prisma.ElectionResultDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aIPrompt`: Exposes CRUD operations for the **AIPrompt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIPrompts
    * const aIPrompts = await prisma.aIPrompt.findMany()
    * ```
    */
  get aIPrompt(): Prisma.AIPromptDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aIRun`: Exposes CRUD operations for the **AIRun** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIRuns
    * const aIRuns = await prisma.aIRun.findMany()
    * ```
    */
  get aIRun(): Prisma.AIRunDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aIRunInputSource`: Exposes CRUD operations for the **AIRunInputSource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIRunInputSources
    * const aIRunInputSources = await prisma.aIRunInputSource.findMany()
    * ```
    */
  get aIRunInputSource(): Prisma.AIRunInputSourceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aIOutput`: Exposes CRUD operations for the **AIOutput** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIOutputs
    * const aIOutputs = await prisma.aIOutput.findMany()
    * ```
    */
  get aIOutput(): Prisma.AIOutputDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aIOutputSection`: Exposes CRUD operations for the **AIOutputSection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIOutputSections
    * const aIOutputSections = await prisma.aIOutputSection.findMany()
    * ```
    */
  get aIOutputSection(): Prisma.AIOutputSectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aIOutputScope`: Exposes CRUD operations for the **AIOutputScope** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIOutputScopes
    * const aIOutputScopes = await prisma.aIOutputScope.findMany()
    * ```
    */
  get aIOutputScope(): Prisma.AIOutputScopeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.citation`: Exposes CRUD operations for the **Citation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Citations
    * const citations = await prisma.citation.findMany()
    * ```
    */
  get citation(): Prisma.CitationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.surveyForm`: Exposes CRUD operations for the **SurveyForm** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SurveyForms
    * const surveyForms = await prisma.surveyForm.findMany()
    * ```
    */
  get surveyForm(): Prisma.SurveyFormDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.surveyQuestion`: Exposes CRUD operations for the **SurveyQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SurveyQuestions
    * const surveyQuestions = await prisma.surveyQuestion.findMany()
    * ```
    */
  get surveyQuestion(): Prisma.SurveyQuestionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.surveyQuestionOption`: Exposes CRUD operations for the **SurveyQuestionOption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SurveyQuestionOptions
    * const surveyQuestionOptions = await prisma.surveyQuestionOption.findMany()
    * ```
    */
  get surveyQuestionOption(): Prisma.SurveyQuestionOptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.surveyResponse`: Exposes CRUD operations for the **SurveyResponse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SurveyResponses
    * const surveyResponses = await prisma.surveyResponse.findMany()
    * ```
    */
  get surveyResponse(): Prisma.SurveyResponseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.surveyResponseItem`: Exposes CRUD operations for the **SurveyResponseItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SurveyResponseItems
    * const surveyResponseItems = await prisma.surveyResponseItem.findMany()
    * ```
    */
  get surveyResponseItem(): Prisma.SurveyResponseItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.surveyResponseItemOption`: Exposes CRUD operations for the **SurveyResponseItemOption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SurveyResponseItemOptions
    * const surveyResponseItemOptions = await prisma.surveyResponseItemOption.findMany()
    * ```
    */
  get surveyResponseItemOption(): Prisma.SurveyResponseItemOptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mediaAsset`: Exposes CRUD operations for the **MediaAsset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MediaAssets
    * const mediaAssets = await prisma.mediaAsset.findMany()
    * ```
    */
  get mediaAsset(): Prisma.MediaAssetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transcript`: Exposes CRUD operations for the **Transcript** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transcripts
    * const transcripts = await prisma.transcript.findMany()
    * ```
    */
  get transcript(): Prisma.TranscriptDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aIAnalysis`: Exposes CRUD operations for the **AIAnalysis** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIAnalyses
    * const aIAnalyses = await prisma.aIAnalysis.findMany()
    * ```
    */
  get aIAnalysis(): Prisma.AIAnalysisDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.voterRegistration`: Exposes CRUD operations for the **VoterRegistration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VoterRegistrations
    * const voterRegistrations = await prisma.voterRegistration.findMany()
    * ```
    */
  get voterRegistration(): Prisma.VoterRegistrationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.voteHistory`: Exposes CRUD operations for the **VoteHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VoteHistories
    * const voteHistories = await prisma.voteHistory.findMany()
    * ```
    */
  get voteHistory(): Prisma.VoteHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.segment`: Exposes CRUD operations for the **Segment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Segments
    * const segments = await prisma.segment.findMany()
    * ```
    */
  get segment(): Prisma.SegmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.segmentMember`: Exposes CRUD operations for the **SegmentMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SegmentMembers
    * const segmentMembers = await prisma.segmentMember.findMany()
    * ```
    */
  get segmentMember(): Prisma.SegmentMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.importJob`: Exposes CRUD operations for the **ImportJob** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ImportJobs
    * const importJobs = await prisma.importJob.findMany()
    * ```
    */
  get importJob(): Prisma.ImportJobDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.2
   * Query Engine version: c2990dca591cba766e3b7ef5d9e8a84796e47ab7
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    County: 'County',
    Issue: 'Issue',
    CountyIssue: 'CountyIssue',
    BlueprintSection: 'BlueprintSection',
    Quote: 'Quote',
    Asset: 'Asset',
    GlossaryTerm: 'GlossaryTerm',
    SourceDocument: 'SourceDocument',
    SourceChunk: 'SourceChunk',
    SourceDocumentLink: 'SourceDocumentLink',
    GeoCounty: 'GeoCounty',
    GeoZip: 'GeoZip',
    GeoPrecinct: 'GeoPrecinct',
    GeoDistrict: 'GeoDistrict',
    GeoCrosswalk: 'GeoCrosswalk',
    CensusMetric: 'CensusMetric',
    BLSMetric: 'BLSMetric',
    CivicsOfficial: 'CivicsOfficial',
    Election: 'Election',
    ElectionResult: 'ElectionResult',
    AIPrompt: 'AIPrompt',
    AIRun: 'AIRun',
    AIRunInputSource: 'AIRunInputSource',
    AIOutput: 'AIOutput',
    AIOutputSection: 'AIOutputSection',
    AIOutputScope: 'AIOutputScope',
    Citation: 'Citation',
    SurveyForm: 'SurveyForm',
    SurveyQuestion: 'SurveyQuestion',
    SurveyQuestionOption: 'SurveyQuestionOption',
    SurveyResponse: 'SurveyResponse',
    SurveyResponseItem: 'SurveyResponseItem',
    SurveyResponseItemOption: 'SurveyResponseItemOption',
    MediaAsset: 'MediaAsset',
    Transcript: 'Transcript',
    AIAnalysis: 'AIAnalysis',
    VoterRegistration: 'VoterRegistration',
    VoteHistory: 'VoteHistory',
    Segment: 'Segment',
    SegmentMember: 'SegmentMember',
    ImportJob: 'ImportJob',
    AuditLog: 'AuditLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "county" | "issue" | "countyIssue" | "blueprintSection" | "quote" | "asset" | "glossaryTerm" | "sourceDocument" | "sourceChunk" | "sourceDocumentLink" | "geoCounty" | "geoZip" | "geoPrecinct" | "geoDistrict" | "geoCrosswalk" | "censusMetric" | "bLSMetric" | "civicsOfficial" | "election" | "electionResult" | "aIPrompt" | "aIRun" | "aIRunInputSource" | "aIOutput" | "aIOutputSection" | "aIOutputScope" | "citation" | "surveyForm" | "surveyQuestion" | "surveyQuestionOption" | "surveyResponse" | "surveyResponseItem" | "surveyResponseItemOption" | "mediaAsset" | "transcript" | "aIAnalysis" | "voterRegistration" | "voteHistory" | "segment" | "segmentMember" | "importJob" | "auditLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      County: {
        payload: Prisma.$CountyPayload<ExtArgs>
        fields: Prisma.CountyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CountyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CountyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountyPayload>
          }
          findFirst: {
            args: Prisma.CountyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CountyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountyPayload>
          }
          findMany: {
            args: Prisma.CountyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountyPayload>[]
          }
          create: {
            args: Prisma.CountyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountyPayload>
          }
          createMany: {
            args: Prisma.CountyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CountyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountyPayload>[]
          }
          delete: {
            args: Prisma.CountyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountyPayload>
          }
          update: {
            args: Prisma.CountyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountyPayload>
          }
          deleteMany: {
            args: Prisma.CountyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CountyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CountyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountyPayload>[]
          }
          upsert: {
            args: Prisma.CountyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountyPayload>
          }
          aggregate: {
            args: Prisma.CountyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCounty>
          }
          groupBy: {
            args: Prisma.CountyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CountyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CountyCountArgs<ExtArgs>
            result: $Utils.Optional<CountyCountAggregateOutputType> | number
          }
        }
      }
      Issue: {
        payload: Prisma.$IssuePayload<ExtArgs>
        fields: Prisma.IssueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IssueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IssueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssuePayload>
          }
          findFirst: {
            args: Prisma.IssueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IssueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssuePayload>
          }
          findMany: {
            args: Prisma.IssueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssuePayload>[]
          }
          create: {
            args: Prisma.IssueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssuePayload>
          }
          createMany: {
            args: Prisma.IssueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IssueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssuePayload>[]
          }
          delete: {
            args: Prisma.IssueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssuePayload>
          }
          update: {
            args: Prisma.IssueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssuePayload>
          }
          deleteMany: {
            args: Prisma.IssueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IssueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IssueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssuePayload>[]
          }
          upsert: {
            args: Prisma.IssueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssuePayload>
          }
          aggregate: {
            args: Prisma.IssueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIssue>
          }
          groupBy: {
            args: Prisma.IssueGroupByArgs<ExtArgs>
            result: $Utils.Optional<IssueGroupByOutputType>[]
          }
          count: {
            args: Prisma.IssueCountArgs<ExtArgs>
            result: $Utils.Optional<IssueCountAggregateOutputType> | number
          }
        }
      }
      CountyIssue: {
        payload: Prisma.$CountyIssuePayload<ExtArgs>
        fields: Prisma.CountyIssueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CountyIssueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountyIssuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CountyIssueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountyIssuePayload>
          }
          findFirst: {
            args: Prisma.CountyIssueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountyIssuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CountyIssueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountyIssuePayload>
          }
          findMany: {
            args: Prisma.CountyIssueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountyIssuePayload>[]
          }
          create: {
            args: Prisma.CountyIssueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountyIssuePayload>
          }
          createMany: {
            args: Prisma.CountyIssueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CountyIssueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountyIssuePayload>[]
          }
          delete: {
            args: Prisma.CountyIssueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountyIssuePayload>
          }
          update: {
            args: Prisma.CountyIssueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountyIssuePayload>
          }
          deleteMany: {
            args: Prisma.CountyIssueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CountyIssueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CountyIssueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountyIssuePayload>[]
          }
          upsert: {
            args: Prisma.CountyIssueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountyIssuePayload>
          }
          aggregate: {
            args: Prisma.CountyIssueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCountyIssue>
          }
          groupBy: {
            args: Prisma.CountyIssueGroupByArgs<ExtArgs>
            result: $Utils.Optional<CountyIssueGroupByOutputType>[]
          }
          count: {
            args: Prisma.CountyIssueCountArgs<ExtArgs>
            result: $Utils.Optional<CountyIssueCountAggregateOutputType> | number
          }
        }
      }
      BlueprintSection: {
        payload: Prisma.$BlueprintSectionPayload<ExtArgs>
        fields: Prisma.BlueprintSectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlueprintSectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlueprintSectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlueprintSectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlueprintSectionPayload>
          }
          findFirst: {
            args: Prisma.BlueprintSectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlueprintSectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlueprintSectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlueprintSectionPayload>
          }
          findMany: {
            args: Prisma.BlueprintSectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlueprintSectionPayload>[]
          }
          create: {
            args: Prisma.BlueprintSectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlueprintSectionPayload>
          }
          createMany: {
            args: Prisma.BlueprintSectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlueprintSectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlueprintSectionPayload>[]
          }
          delete: {
            args: Prisma.BlueprintSectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlueprintSectionPayload>
          }
          update: {
            args: Prisma.BlueprintSectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlueprintSectionPayload>
          }
          deleteMany: {
            args: Prisma.BlueprintSectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlueprintSectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BlueprintSectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlueprintSectionPayload>[]
          }
          upsert: {
            args: Prisma.BlueprintSectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlueprintSectionPayload>
          }
          aggregate: {
            args: Prisma.BlueprintSectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlueprintSection>
          }
          groupBy: {
            args: Prisma.BlueprintSectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlueprintSectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlueprintSectionCountArgs<ExtArgs>
            result: $Utils.Optional<BlueprintSectionCountAggregateOutputType> | number
          }
        }
      }
      Quote: {
        payload: Prisma.$QuotePayload<ExtArgs>
        fields: Prisma.QuoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          findFirst: {
            args: Prisma.QuoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          findMany: {
            args: Prisma.QuoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>[]
          }
          create: {
            args: Prisma.QuoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          createMany: {
            args: Prisma.QuoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>[]
          }
          delete: {
            args: Prisma.QuoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          update: {
            args: Prisma.QuoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          deleteMany: {
            args: Prisma.QuoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>[]
          }
          upsert: {
            args: Prisma.QuoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          aggregate: {
            args: Prisma.QuoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuote>
          }
          groupBy: {
            args: Prisma.QuoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuoteCountArgs<ExtArgs>
            result: $Utils.Optional<QuoteCountAggregateOutputType> | number
          }
        }
      }
      Asset: {
        payload: Prisma.$AssetPayload<ExtArgs>
        fields: Prisma.AssetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          findFirst: {
            args: Prisma.AssetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          findMany: {
            args: Prisma.AssetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>[]
          }
          create: {
            args: Prisma.AssetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          createMany: {
            args: Prisma.AssetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>[]
          }
          delete: {
            args: Prisma.AssetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          update: {
            args: Prisma.AssetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          deleteMany: {
            args: Prisma.AssetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AssetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>[]
          }
          upsert: {
            args: Prisma.AssetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          aggregate: {
            args: Prisma.AssetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAsset>
          }
          groupBy: {
            args: Prisma.AssetGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssetGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssetCountArgs<ExtArgs>
            result: $Utils.Optional<AssetCountAggregateOutputType> | number
          }
        }
      }
      GlossaryTerm: {
        payload: Prisma.$GlossaryTermPayload<ExtArgs>
        fields: Prisma.GlossaryTermFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GlossaryTermFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlossaryTermPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GlossaryTermFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlossaryTermPayload>
          }
          findFirst: {
            args: Prisma.GlossaryTermFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlossaryTermPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GlossaryTermFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlossaryTermPayload>
          }
          findMany: {
            args: Prisma.GlossaryTermFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlossaryTermPayload>[]
          }
          create: {
            args: Prisma.GlossaryTermCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlossaryTermPayload>
          }
          createMany: {
            args: Prisma.GlossaryTermCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GlossaryTermCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlossaryTermPayload>[]
          }
          delete: {
            args: Prisma.GlossaryTermDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlossaryTermPayload>
          }
          update: {
            args: Prisma.GlossaryTermUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlossaryTermPayload>
          }
          deleteMany: {
            args: Prisma.GlossaryTermDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GlossaryTermUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GlossaryTermUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlossaryTermPayload>[]
          }
          upsert: {
            args: Prisma.GlossaryTermUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlossaryTermPayload>
          }
          aggregate: {
            args: Prisma.GlossaryTermAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGlossaryTerm>
          }
          groupBy: {
            args: Prisma.GlossaryTermGroupByArgs<ExtArgs>
            result: $Utils.Optional<GlossaryTermGroupByOutputType>[]
          }
          count: {
            args: Prisma.GlossaryTermCountArgs<ExtArgs>
            result: $Utils.Optional<GlossaryTermCountAggregateOutputType> | number
          }
        }
      }
      SourceDocument: {
        payload: Prisma.$SourceDocumentPayload<ExtArgs>
        fields: Prisma.SourceDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SourceDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SourceDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceDocumentPayload>
          }
          findFirst: {
            args: Prisma.SourceDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SourceDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceDocumentPayload>
          }
          findMany: {
            args: Prisma.SourceDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceDocumentPayload>[]
          }
          create: {
            args: Prisma.SourceDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceDocumentPayload>
          }
          createMany: {
            args: Prisma.SourceDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SourceDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceDocumentPayload>[]
          }
          delete: {
            args: Prisma.SourceDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceDocumentPayload>
          }
          update: {
            args: Prisma.SourceDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceDocumentPayload>
          }
          deleteMany: {
            args: Prisma.SourceDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SourceDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SourceDocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceDocumentPayload>[]
          }
          upsert: {
            args: Prisma.SourceDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceDocumentPayload>
          }
          aggregate: {
            args: Prisma.SourceDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSourceDocument>
          }
          groupBy: {
            args: Prisma.SourceDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<SourceDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.SourceDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<SourceDocumentCountAggregateOutputType> | number
          }
        }
      }
      SourceChunk: {
        payload: Prisma.$SourceChunkPayload<ExtArgs>
        fields: Prisma.SourceChunkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SourceChunkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceChunkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SourceChunkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceChunkPayload>
          }
          findFirst: {
            args: Prisma.SourceChunkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceChunkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SourceChunkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceChunkPayload>
          }
          findMany: {
            args: Prisma.SourceChunkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceChunkPayload>[]
          }
          create: {
            args: Prisma.SourceChunkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceChunkPayload>
          }
          createMany: {
            args: Prisma.SourceChunkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SourceChunkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceChunkPayload>[]
          }
          delete: {
            args: Prisma.SourceChunkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceChunkPayload>
          }
          update: {
            args: Prisma.SourceChunkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceChunkPayload>
          }
          deleteMany: {
            args: Prisma.SourceChunkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SourceChunkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SourceChunkUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceChunkPayload>[]
          }
          upsert: {
            args: Prisma.SourceChunkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceChunkPayload>
          }
          aggregate: {
            args: Prisma.SourceChunkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSourceChunk>
          }
          groupBy: {
            args: Prisma.SourceChunkGroupByArgs<ExtArgs>
            result: $Utils.Optional<SourceChunkGroupByOutputType>[]
          }
          count: {
            args: Prisma.SourceChunkCountArgs<ExtArgs>
            result: $Utils.Optional<SourceChunkCountAggregateOutputType> | number
          }
        }
      }
      SourceDocumentLink: {
        payload: Prisma.$SourceDocumentLinkPayload<ExtArgs>
        fields: Prisma.SourceDocumentLinkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SourceDocumentLinkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceDocumentLinkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SourceDocumentLinkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceDocumentLinkPayload>
          }
          findFirst: {
            args: Prisma.SourceDocumentLinkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceDocumentLinkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SourceDocumentLinkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceDocumentLinkPayload>
          }
          findMany: {
            args: Prisma.SourceDocumentLinkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceDocumentLinkPayload>[]
          }
          create: {
            args: Prisma.SourceDocumentLinkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceDocumentLinkPayload>
          }
          createMany: {
            args: Prisma.SourceDocumentLinkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SourceDocumentLinkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceDocumentLinkPayload>[]
          }
          delete: {
            args: Prisma.SourceDocumentLinkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceDocumentLinkPayload>
          }
          update: {
            args: Prisma.SourceDocumentLinkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceDocumentLinkPayload>
          }
          deleteMany: {
            args: Prisma.SourceDocumentLinkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SourceDocumentLinkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SourceDocumentLinkUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceDocumentLinkPayload>[]
          }
          upsert: {
            args: Prisma.SourceDocumentLinkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceDocumentLinkPayload>
          }
          aggregate: {
            args: Prisma.SourceDocumentLinkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSourceDocumentLink>
          }
          groupBy: {
            args: Prisma.SourceDocumentLinkGroupByArgs<ExtArgs>
            result: $Utils.Optional<SourceDocumentLinkGroupByOutputType>[]
          }
          count: {
            args: Prisma.SourceDocumentLinkCountArgs<ExtArgs>
            result: $Utils.Optional<SourceDocumentLinkCountAggregateOutputType> | number
          }
        }
      }
      GeoCounty: {
        payload: Prisma.$GeoCountyPayload<ExtArgs>
        fields: Prisma.GeoCountyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GeoCountyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeoCountyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GeoCountyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeoCountyPayload>
          }
          findFirst: {
            args: Prisma.GeoCountyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeoCountyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GeoCountyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeoCountyPayload>
          }
          findMany: {
            args: Prisma.GeoCountyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeoCountyPayload>[]
          }
          create: {
            args: Prisma.GeoCountyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeoCountyPayload>
          }
          createMany: {
            args: Prisma.GeoCountyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GeoCountyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeoCountyPayload>[]
          }
          delete: {
            args: Prisma.GeoCountyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeoCountyPayload>
          }
          update: {
            args: Prisma.GeoCountyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeoCountyPayload>
          }
          deleteMany: {
            args: Prisma.GeoCountyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GeoCountyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GeoCountyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeoCountyPayload>[]
          }
          upsert: {
            args: Prisma.GeoCountyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeoCountyPayload>
          }
          aggregate: {
            args: Prisma.GeoCountyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGeoCounty>
          }
          groupBy: {
            args: Prisma.GeoCountyGroupByArgs<ExtArgs>
            result: $Utils.Optional<GeoCountyGroupByOutputType>[]
          }
          count: {
            args: Prisma.GeoCountyCountArgs<ExtArgs>
            result: $Utils.Optional<GeoCountyCountAggregateOutputType> | number
          }
        }
      }
      GeoZip: {
        payload: Prisma.$GeoZipPayload<ExtArgs>
        fields: Prisma.GeoZipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GeoZipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeoZipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GeoZipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeoZipPayload>
          }
          findFirst: {
            args: Prisma.GeoZipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeoZipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GeoZipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeoZipPayload>
          }
          findMany: {
            args: Prisma.GeoZipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeoZipPayload>[]
          }
          create: {
            args: Prisma.GeoZipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeoZipPayload>
          }
          createMany: {
            args: Prisma.GeoZipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GeoZipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeoZipPayload>[]
          }
          delete: {
            args: Prisma.GeoZipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeoZipPayload>
          }
          update: {
            args: Prisma.GeoZipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeoZipPayload>
          }
          deleteMany: {
            args: Prisma.GeoZipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GeoZipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GeoZipUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeoZipPayload>[]
          }
          upsert: {
            args: Prisma.GeoZipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeoZipPayload>
          }
          aggregate: {
            args: Prisma.GeoZipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGeoZip>
          }
          groupBy: {
            args: Prisma.GeoZipGroupByArgs<ExtArgs>
            result: $Utils.Optional<GeoZipGroupByOutputType>[]
          }
          count: {
            args: Prisma.GeoZipCountArgs<ExtArgs>
            result: $Utils.Optional<GeoZipCountAggregateOutputType> | number
          }
        }
      }
      GeoPrecinct: {
        payload: Prisma.$GeoPrecinctPayload<ExtArgs>
        fields: Prisma.GeoPrecinctFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GeoPrecinctFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeoPrecinctPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GeoPrecinctFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeoPrecinctPayload>
          }
          findFirst: {
            args: Prisma.GeoPrecinctFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeoPrecinctPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GeoPrecinctFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeoPrecinctPayload>
          }
          findMany: {
            args: Prisma.GeoPrecinctFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeoPrecinctPayload>[]
          }
          create: {
            args: Prisma.GeoPrecinctCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeoPrecinctPayload>
          }
          createMany: {
            args: Prisma.GeoPrecinctCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GeoPrecinctCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeoPrecinctPayload>[]
          }
          delete: {
            args: Prisma.GeoPrecinctDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeoPrecinctPayload>
          }
          update: {
            args: Prisma.GeoPrecinctUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeoPrecinctPayload>
          }
          deleteMany: {
            args: Prisma.GeoPrecinctDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GeoPrecinctUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GeoPrecinctUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeoPrecinctPayload>[]
          }
          upsert: {
            args: Prisma.GeoPrecinctUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeoPrecinctPayload>
          }
          aggregate: {
            args: Prisma.GeoPrecinctAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGeoPrecinct>
          }
          groupBy: {
            args: Prisma.GeoPrecinctGroupByArgs<ExtArgs>
            result: $Utils.Optional<GeoPrecinctGroupByOutputType>[]
          }
          count: {
            args: Prisma.GeoPrecinctCountArgs<ExtArgs>
            result: $Utils.Optional<GeoPrecinctCountAggregateOutputType> | number
          }
        }
      }
      GeoDistrict: {
        payload: Prisma.$GeoDistrictPayload<ExtArgs>
        fields: Prisma.GeoDistrictFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GeoDistrictFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeoDistrictPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GeoDistrictFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeoDistrictPayload>
          }
          findFirst: {
            args: Prisma.GeoDistrictFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeoDistrictPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GeoDistrictFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeoDistrictPayload>
          }
          findMany: {
            args: Prisma.GeoDistrictFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeoDistrictPayload>[]
          }
          create: {
            args: Prisma.GeoDistrictCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeoDistrictPayload>
          }
          createMany: {
            args: Prisma.GeoDistrictCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GeoDistrictCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeoDistrictPayload>[]
          }
          delete: {
            args: Prisma.GeoDistrictDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeoDistrictPayload>
          }
          update: {
            args: Prisma.GeoDistrictUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeoDistrictPayload>
          }
          deleteMany: {
            args: Prisma.GeoDistrictDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GeoDistrictUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GeoDistrictUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeoDistrictPayload>[]
          }
          upsert: {
            args: Prisma.GeoDistrictUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeoDistrictPayload>
          }
          aggregate: {
            args: Prisma.GeoDistrictAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGeoDistrict>
          }
          groupBy: {
            args: Prisma.GeoDistrictGroupByArgs<ExtArgs>
            result: $Utils.Optional<GeoDistrictGroupByOutputType>[]
          }
          count: {
            args: Prisma.GeoDistrictCountArgs<ExtArgs>
            result: $Utils.Optional<GeoDistrictCountAggregateOutputType> | number
          }
        }
      }
      GeoCrosswalk: {
        payload: Prisma.$GeoCrosswalkPayload<ExtArgs>
        fields: Prisma.GeoCrosswalkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GeoCrosswalkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeoCrosswalkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GeoCrosswalkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeoCrosswalkPayload>
          }
          findFirst: {
            args: Prisma.GeoCrosswalkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeoCrosswalkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GeoCrosswalkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeoCrosswalkPayload>
          }
          findMany: {
            args: Prisma.GeoCrosswalkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeoCrosswalkPayload>[]
          }
          create: {
            args: Prisma.GeoCrosswalkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeoCrosswalkPayload>
          }
          createMany: {
            args: Prisma.GeoCrosswalkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GeoCrosswalkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeoCrosswalkPayload>[]
          }
          delete: {
            args: Prisma.GeoCrosswalkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeoCrosswalkPayload>
          }
          update: {
            args: Prisma.GeoCrosswalkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeoCrosswalkPayload>
          }
          deleteMany: {
            args: Prisma.GeoCrosswalkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GeoCrosswalkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GeoCrosswalkUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeoCrosswalkPayload>[]
          }
          upsert: {
            args: Prisma.GeoCrosswalkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeoCrosswalkPayload>
          }
          aggregate: {
            args: Prisma.GeoCrosswalkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGeoCrosswalk>
          }
          groupBy: {
            args: Prisma.GeoCrosswalkGroupByArgs<ExtArgs>
            result: $Utils.Optional<GeoCrosswalkGroupByOutputType>[]
          }
          count: {
            args: Prisma.GeoCrosswalkCountArgs<ExtArgs>
            result: $Utils.Optional<GeoCrosswalkCountAggregateOutputType> | number
          }
        }
      }
      CensusMetric: {
        payload: Prisma.$CensusMetricPayload<ExtArgs>
        fields: Prisma.CensusMetricFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CensusMetricFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusMetricPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CensusMetricFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusMetricPayload>
          }
          findFirst: {
            args: Prisma.CensusMetricFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusMetricPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CensusMetricFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusMetricPayload>
          }
          findMany: {
            args: Prisma.CensusMetricFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusMetricPayload>[]
          }
          create: {
            args: Prisma.CensusMetricCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusMetricPayload>
          }
          createMany: {
            args: Prisma.CensusMetricCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CensusMetricCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusMetricPayload>[]
          }
          delete: {
            args: Prisma.CensusMetricDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusMetricPayload>
          }
          update: {
            args: Prisma.CensusMetricUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusMetricPayload>
          }
          deleteMany: {
            args: Prisma.CensusMetricDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CensusMetricUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CensusMetricUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusMetricPayload>[]
          }
          upsert: {
            args: Prisma.CensusMetricUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CensusMetricPayload>
          }
          aggregate: {
            args: Prisma.CensusMetricAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCensusMetric>
          }
          groupBy: {
            args: Prisma.CensusMetricGroupByArgs<ExtArgs>
            result: $Utils.Optional<CensusMetricGroupByOutputType>[]
          }
          count: {
            args: Prisma.CensusMetricCountArgs<ExtArgs>
            result: $Utils.Optional<CensusMetricCountAggregateOutputType> | number
          }
        }
      }
      BLSMetric: {
        payload: Prisma.$BLSMetricPayload<ExtArgs>
        fields: Prisma.BLSMetricFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BLSMetricFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BLSMetricPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BLSMetricFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BLSMetricPayload>
          }
          findFirst: {
            args: Prisma.BLSMetricFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BLSMetricPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BLSMetricFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BLSMetricPayload>
          }
          findMany: {
            args: Prisma.BLSMetricFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BLSMetricPayload>[]
          }
          create: {
            args: Prisma.BLSMetricCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BLSMetricPayload>
          }
          createMany: {
            args: Prisma.BLSMetricCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BLSMetricCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BLSMetricPayload>[]
          }
          delete: {
            args: Prisma.BLSMetricDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BLSMetricPayload>
          }
          update: {
            args: Prisma.BLSMetricUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BLSMetricPayload>
          }
          deleteMany: {
            args: Prisma.BLSMetricDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BLSMetricUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BLSMetricUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BLSMetricPayload>[]
          }
          upsert: {
            args: Prisma.BLSMetricUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BLSMetricPayload>
          }
          aggregate: {
            args: Prisma.BLSMetricAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBLSMetric>
          }
          groupBy: {
            args: Prisma.BLSMetricGroupByArgs<ExtArgs>
            result: $Utils.Optional<BLSMetricGroupByOutputType>[]
          }
          count: {
            args: Prisma.BLSMetricCountArgs<ExtArgs>
            result: $Utils.Optional<BLSMetricCountAggregateOutputType> | number
          }
        }
      }
      CivicsOfficial: {
        payload: Prisma.$CivicsOfficialPayload<ExtArgs>
        fields: Prisma.CivicsOfficialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CivicsOfficialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CivicsOfficialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CivicsOfficialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CivicsOfficialPayload>
          }
          findFirst: {
            args: Prisma.CivicsOfficialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CivicsOfficialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CivicsOfficialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CivicsOfficialPayload>
          }
          findMany: {
            args: Prisma.CivicsOfficialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CivicsOfficialPayload>[]
          }
          create: {
            args: Prisma.CivicsOfficialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CivicsOfficialPayload>
          }
          createMany: {
            args: Prisma.CivicsOfficialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CivicsOfficialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CivicsOfficialPayload>[]
          }
          delete: {
            args: Prisma.CivicsOfficialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CivicsOfficialPayload>
          }
          update: {
            args: Prisma.CivicsOfficialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CivicsOfficialPayload>
          }
          deleteMany: {
            args: Prisma.CivicsOfficialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CivicsOfficialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CivicsOfficialUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CivicsOfficialPayload>[]
          }
          upsert: {
            args: Prisma.CivicsOfficialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CivicsOfficialPayload>
          }
          aggregate: {
            args: Prisma.CivicsOfficialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCivicsOfficial>
          }
          groupBy: {
            args: Prisma.CivicsOfficialGroupByArgs<ExtArgs>
            result: $Utils.Optional<CivicsOfficialGroupByOutputType>[]
          }
          count: {
            args: Prisma.CivicsOfficialCountArgs<ExtArgs>
            result: $Utils.Optional<CivicsOfficialCountAggregateOutputType> | number
          }
        }
      }
      Election: {
        payload: Prisma.$ElectionPayload<ExtArgs>
        fields: Prisma.ElectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ElectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ElectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElectionPayload>
          }
          findFirst: {
            args: Prisma.ElectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ElectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElectionPayload>
          }
          findMany: {
            args: Prisma.ElectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElectionPayload>[]
          }
          create: {
            args: Prisma.ElectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElectionPayload>
          }
          createMany: {
            args: Prisma.ElectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ElectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElectionPayload>[]
          }
          delete: {
            args: Prisma.ElectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElectionPayload>
          }
          update: {
            args: Prisma.ElectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElectionPayload>
          }
          deleteMany: {
            args: Prisma.ElectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ElectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ElectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElectionPayload>[]
          }
          upsert: {
            args: Prisma.ElectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElectionPayload>
          }
          aggregate: {
            args: Prisma.ElectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateElection>
          }
          groupBy: {
            args: Prisma.ElectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ElectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ElectionCountArgs<ExtArgs>
            result: $Utils.Optional<ElectionCountAggregateOutputType> | number
          }
        }
      }
      ElectionResult: {
        payload: Prisma.$ElectionResultPayload<ExtArgs>
        fields: Prisma.ElectionResultFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ElectionResultFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElectionResultPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ElectionResultFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElectionResultPayload>
          }
          findFirst: {
            args: Prisma.ElectionResultFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElectionResultPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ElectionResultFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElectionResultPayload>
          }
          findMany: {
            args: Prisma.ElectionResultFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElectionResultPayload>[]
          }
          create: {
            args: Prisma.ElectionResultCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElectionResultPayload>
          }
          createMany: {
            args: Prisma.ElectionResultCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ElectionResultCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElectionResultPayload>[]
          }
          delete: {
            args: Prisma.ElectionResultDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElectionResultPayload>
          }
          update: {
            args: Prisma.ElectionResultUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElectionResultPayload>
          }
          deleteMany: {
            args: Prisma.ElectionResultDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ElectionResultUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ElectionResultUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElectionResultPayload>[]
          }
          upsert: {
            args: Prisma.ElectionResultUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElectionResultPayload>
          }
          aggregate: {
            args: Prisma.ElectionResultAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateElectionResult>
          }
          groupBy: {
            args: Prisma.ElectionResultGroupByArgs<ExtArgs>
            result: $Utils.Optional<ElectionResultGroupByOutputType>[]
          }
          count: {
            args: Prisma.ElectionResultCountArgs<ExtArgs>
            result: $Utils.Optional<ElectionResultCountAggregateOutputType> | number
          }
        }
      }
      AIPrompt: {
        payload: Prisma.$AIPromptPayload<ExtArgs>
        fields: Prisma.AIPromptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIPromptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIPromptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIPromptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIPromptPayload>
          }
          findFirst: {
            args: Prisma.AIPromptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIPromptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIPromptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIPromptPayload>
          }
          findMany: {
            args: Prisma.AIPromptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIPromptPayload>[]
          }
          create: {
            args: Prisma.AIPromptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIPromptPayload>
          }
          createMany: {
            args: Prisma.AIPromptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIPromptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIPromptPayload>[]
          }
          delete: {
            args: Prisma.AIPromptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIPromptPayload>
          }
          update: {
            args: Prisma.AIPromptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIPromptPayload>
          }
          deleteMany: {
            args: Prisma.AIPromptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIPromptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AIPromptUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIPromptPayload>[]
          }
          upsert: {
            args: Prisma.AIPromptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIPromptPayload>
          }
          aggregate: {
            args: Prisma.AIPromptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIPrompt>
          }
          groupBy: {
            args: Prisma.AIPromptGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIPromptGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIPromptCountArgs<ExtArgs>
            result: $Utils.Optional<AIPromptCountAggregateOutputType> | number
          }
        }
      }
      AIRun: {
        payload: Prisma.$AIRunPayload<ExtArgs>
        fields: Prisma.AIRunFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIRunFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIRunPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIRunFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIRunPayload>
          }
          findFirst: {
            args: Prisma.AIRunFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIRunPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIRunFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIRunPayload>
          }
          findMany: {
            args: Prisma.AIRunFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIRunPayload>[]
          }
          create: {
            args: Prisma.AIRunCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIRunPayload>
          }
          createMany: {
            args: Prisma.AIRunCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIRunCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIRunPayload>[]
          }
          delete: {
            args: Prisma.AIRunDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIRunPayload>
          }
          update: {
            args: Prisma.AIRunUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIRunPayload>
          }
          deleteMany: {
            args: Prisma.AIRunDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIRunUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AIRunUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIRunPayload>[]
          }
          upsert: {
            args: Prisma.AIRunUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIRunPayload>
          }
          aggregate: {
            args: Prisma.AIRunAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIRun>
          }
          groupBy: {
            args: Prisma.AIRunGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIRunGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIRunCountArgs<ExtArgs>
            result: $Utils.Optional<AIRunCountAggregateOutputType> | number
          }
        }
      }
      AIRunInputSource: {
        payload: Prisma.$AIRunInputSourcePayload<ExtArgs>
        fields: Prisma.AIRunInputSourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIRunInputSourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIRunInputSourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIRunInputSourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIRunInputSourcePayload>
          }
          findFirst: {
            args: Prisma.AIRunInputSourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIRunInputSourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIRunInputSourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIRunInputSourcePayload>
          }
          findMany: {
            args: Prisma.AIRunInputSourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIRunInputSourcePayload>[]
          }
          create: {
            args: Prisma.AIRunInputSourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIRunInputSourcePayload>
          }
          createMany: {
            args: Prisma.AIRunInputSourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIRunInputSourceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIRunInputSourcePayload>[]
          }
          delete: {
            args: Prisma.AIRunInputSourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIRunInputSourcePayload>
          }
          update: {
            args: Prisma.AIRunInputSourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIRunInputSourcePayload>
          }
          deleteMany: {
            args: Prisma.AIRunInputSourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIRunInputSourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AIRunInputSourceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIRunInputSourcePayload>[]
          }
          upsert: {
            args: Prisma.AIRunInputSourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIRunInputSourcePayload>
          }
          aggregate: {
            args: Prisma.AIRunInputSourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIRunInputSource>
          }
          groupBy: {
            args: Prisma.AIRunInputSourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIRunInputSourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIRunInputSourceCountArgs<ExtArgs>
            result: $Utils.Optional<AIRunInputSourceCountAggregateOutputType> | number
          }
        }
      }
      AIOutput: {
        payload: Prisma.$AIOutputPayload<ExtArgs>
        fields: Prisma.AIOutputFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIOutputFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIOutputPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIOutputFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIOutputPayload>
          }
          findFirst: {
            args: Prisma.AIOutputFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIOutputPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIOutputFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIOutputPayload>
          }
          findMany: {
            args: Prisma.AIOutputFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIOutputPayload>[]
          }
          create: {
            args: Prisma.AIOutputCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIOutputPayload>
          }
          createMany: {
            args: Prisma.AIOutputCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIOutputCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIOutputPayload>[]
          }
          delete: {
            args: Prisma.AIOutputDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIOutputPayload>
          }
          update: {
            args: Prisma.AIOutputUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIOutputPayload>
          }
          deleteMany: {
            args: Prisma.AIOutputDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIOutputUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AIOutputUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIOutputPayload>[]
          }
          upsert: {
            args: Prisma.AIOutputUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIOutputPayload>
          }
          aggregate: {
            args: Prisma.AIOutputAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIOutput>
          }
          groupBy: {
            args: Prisma.AIOutputGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIOutputGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIOutputCountArgs<ExtArgs>
            result: $Utils.Optional<AIOutputCountAggregateOutputType> | number
          }
        }
      }
      AIOutputSection: {
        payload: Prisma.$AIOutputSectionPayload<ExtArgs>
        fields: Prisma.AIOutputSectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIOutputSectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIOutputSectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIOutputSectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIOutputSectionPayload>
          }
          findFirst: {
            args: Prisma.AIOutputSectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIOutputSectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIOutputSectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIOutputSectionPayload>
          }
          findMany: {
            args: Prisma.AIOutputSectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIOutputSectionPayload>[]
          }
          create: {
            args: Prisma.AIOutputSectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIOutputSectionPayload>
          }
          createMany: {
            args: Prisma.AIOutputSectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIOutputSectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIOutputSectionPayload>[]
          }
          delete: {
            args: Prisma.AIOutputSectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIOutputSectionPayload>
          }
          update: {
            args: Prisma.AIOutputSectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIOutputSectionPayload>
          }
          deleteMany: {
            args: Prisma.AIOutputSectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIOutputSectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AIOutputSectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIOutputSectionPayload>[]
          }
          upsert: {
            args: Prisma.AIOutputSectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIOutputSectionPayload>
          }
          aggregate: {
            args: Prisma.AIOutputSectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIOutputSection>
          }
          groupBy: {
            args: Prisma.AIOutputSectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIOutputSectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIOutputSectionCountArgs<ExtArgs>
            result: $Utils.Optional<AIOutputSectionCountAggregateOutputType> | number
          }
        }
      }
      AIOutputScope: {
        payload: Prisma.$AIOutputScopePayload<ExtArgs>
        fields: Prisma.AIOutputScopeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIOutputScopeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIOutputScopePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIOutputScopeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIOutputScopePayload>
          }
          findFirst: {
            args: Prisma.AIOutputScopeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIOutputScopePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIOutputScopeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIOutputScopePayload>
          }
          findMany: {
            args: Prisma.AIOutputScopeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIOutputScopePayload>[]
          }
          create: {
            args: Prisma.AIOutputScopeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIOutputScopePayload>
          }
          createMany: {
            args: Prisma.AIOutputScopeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIOutputScopeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIOutputScopePayload>[]
          }
          delete: {
            args: Prisma.AIOutputScopeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIOutputScopePayload>
          }
          update: {
            args: Prisma.AIOutputScopeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIOutputScopePayload>
          }
          deleteMany: {
            args: Prisma.AIOutputScopeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIOutputScopeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AIOutputScopeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIOutputScopePayload>[]
          }
          upsert: {
            args: Prisma.AIOutputScopeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIOutputScopePayload>
          }
          aggregate: {
            args: Prisma.AIOutputScopeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIOutputScope>
          }
          groupBy: {
            args: Prisma.AIOutputScopeGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIOutputScopeGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIOutputScopeCountArgs<ExtArgs>
            result: $Utils.Optional<AIOutputScopeCountAggregateOutputType> | number
          }
        }
      }
      Citation: {
        payload: Prisma.$CitationPayload<ExtArgs>
        fields: Prisma.CitationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CitationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CitationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CitationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CitationPayload>
          }
          findFirst: {
            args: Prisma.CitationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CitationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CitationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CitationPayload>
          }
          findMany: {
            args: Prisma.CitationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CitationPayload>[]
          }
          create: {
            args: Prisma.CitationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CitationPayload>
          }
          createMany: {
            args: Prisma.CitationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CitationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CitationPayload>[]
          }
          delete: {
            args: Prisma.CitationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CitationPayload>
          }
          update: {
            args: Prisma.CitationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CitationPayload>
          }
          deleteMany: {
            args: Prisma.CitationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CitationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CitationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CitationPayload>[]
          }
          upsert: {
            args: Prisma.CitationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CitationPayload>
          }
          aggregate: {
            args: Prisma.CitationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCitation>
          }
          groupBy: {
            args: Prisma.CitationGroupByArgs<ExtArgs>
            result: $Utils.Optional<CitationGroupByOutputType>[]
          }
          count: {
            args: Prisma.CitationCountArgs<ExtArgs>
            result: $Utils.Optional<CitationCountAggregateOutputType> | number
          }
        }
      }
      SurveyForm: {
        payload: Prisma.$SurveyFormPayload<ExtArgs>
        fields: Prisma.SurveyFormFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SurveyFormFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyFormPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SurveyFormFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyFormPayload>
          }
          findFirst: {
            args: Prisma.SurveyFormFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyFormPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SurveyFormFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyFormPayload>
          }
          findMany: {
            args: Prisma.SurveyFormFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyFormPayload>[]
          }
          create: {
            args: Prisma.SurveyFormCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyFormPayload>
          }
          createMany: {
            args: Prisma.SurveyFormCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SurveyFormCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyFormPayload>[]
          }
          delete: {
            args: Prisma.SurveyFormDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyFormPayload>
          }
          update: {
            args: Prisma.SurveyFormUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyFormPayload>
          }
          deleteMany: {
            args: Prisma.SurveyFormDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SurveyFormUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SurveyFormUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyFormPayload>[]
          }
          upsert: {
            args: Prisma.SurveyFormUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyFormPayload>
          }
          aggregate: {
            args: Prisma.SurveyFormAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSurveyForm>
          }
          groupBy: {
            args: Prisma.SurveyFormGroupByArgs<ExtArgs>
            result: $Utils.Optional<SurveyFormGroupByOutputType>[]
          }
          count: {
            args: Prisma.SurveyFormCountArgs<ExtArgs>
            result: $Utils.Optional<SurveyFormCountAggregateOutputType> | number
          }
        }
      }
      SurveyQuestion: {
        payload: Prisma.$SurveyQuestionPayload<ExtArgs>
        fields: Prisma.SurveyQuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SurveyQuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyQuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SurveyQuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyQuestionPayload>
          }
          findFirst: {
            args: Prisma.SurveyQuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyQuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SurveyQuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyQuestionPayload>
          }
          findMany: {
            args: Prisma.SurveyQuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyQuestionPayload>[]
          }
          create: {
            args: Prisma.SurveyQuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyQuestionPayload>
          }
          createMany: {
            args: Prisma.SurveyQuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SurveyQuestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyQuestionPayload>[]
          }
          delete: {
            args: Prisma.SurveyQuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyQuestionPayload>
          }
          update: {
            args: Prisma.SurveyQuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyQuestionPayload>
          }
          deleteMany: {
            args: Prisma.SurveyQuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SurveyQuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SurveyQuestionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyQuestionPayload>[]
          }
          upsert: {
            args: Prisma.SurveyQuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyQuestionPayload>
          }
          aggregate: {
            args: Prisma.SurveyQuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSurveyQuestion>
          }
          groupBy: {
            args: Prisma.SurveyQuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SurveyQuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SurveyQuestionCountArgs<ExtArgs>
            result: $Utils.Optional<SurveyQuestionCountAggregateOutputType> | number
          }
        }
      }
      SurveyQuestionOption: {
        payload: Prisma.$SurveyQuestionOptionPayload<ExtArgs>
        fields: Prisma.SurveyQuestionOptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SurveyQuestionOptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyQuestionOptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SurveyQuestionOptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyQuestionOptionPayload>
          }
          findFirst: {
            args: Prisma.SurveyQuestionOptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyQuestionOptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SurveyQuestionOptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyQuestionOptionPayload>
          }
          findMany: {
            args: Prisma.SurveyQuestionOptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyQuestionOptionPayload>[]
          }
          create: {
            args: Prisma.SurveyQuestionOptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyQuestionOptionPayload>
          }
          createMany: {
            args: Prisma.SurveyQuestionOptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SurveyQuestionOptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyQuestionOptionPayload>[]
          }
          delete: {
            args: Prisma.SurveyQuestionOptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyQuestionOptionPayload>
          }
          update: {
            args: Prisma.SurveyQuestionOptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyQuestionOptionPayload>
          }
          deleteMany: {
            args: Prisma.SurveyQuestionOptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SurveyQuestionOptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SurveyQuestionOptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyQuestionOptionPayload>[]
          }
          upsert: {
            args: Prisma.SurveyQuestionOptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyQuestionOptionPayload>
          }
          aggregate: {
            args: Prisma.SurveyQuestionOptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSurveyQuestionOption>
          }
          groupBy: {
            args: Prisma.SurveyQuestionOptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SurveyQuestionOptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SurveyQuestionOptionCountArgs<ExtArgs>
            result: $Utils.Optional<SurveyQuestionOptionCountAggregateOutputType> | number
          }
        }
      }
      SurveyResponse: {
        payload: Prisma.$SurveyResponsePayload<ExtArgs>
        fields: Prisma.SurveyResponseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SurveyResponseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyResponsePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SurveyResponseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyResponsePayload>
          }
          findFirst: {
            args: Prisma.SurveyResponseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyResponsePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SurveyResponseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyResponsePayload>
          }
          findMany: {
            args: Prisma.SurveyResponseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyResponsePayload>[]
          }
          create: {
            args: Prisma.SurveyResponseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyResponsePayload>
          }
          createMany: {
            args: Prisma.SurveyResponseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SurveyResponseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyResponsePayload>[]
          }
          delete: {
            args: Prisma.SurveyResponseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyResponsePayload>
          }
          update: {
            args: Prisma.SurveyResponseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyResponsePayload>
          }
          deleteMany: {
            args: Prisma.SurveyResponseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SurveyResponseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SurveyResponseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyResponsePayload>[]
          }
          upsert: {
            args: Prisma.SurveyResponseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyResponsePayload>
          }
          aggregate: {
            args: Prisma.SurveyResponseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSurveyResponse>
          }
          groupBy: {
            args: Prisma.SurveyResponseGroupByArgs<ExtArgs>
            result: $Utils.Optional<SurveyResponseGroupByOutputType>[]
          }
          count: {
            args: Prisma.SurveyResponseCountArgs<ExtArgs>
            result: $Utils.Optional<SurveyResponseCountAggregateOutputType> | number
          }
        }
      }
      SurveyResponseItem: {
        payload: Prisma.$SurveyResponseItemPayload<ExtArgs>
        fields: Prisma.SurveyResponseItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SurveyResponseItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyResponseItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SurveyResponseItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyResponseItemPayload>
          }
          findFirst: {
            args: Prisma.SurveyResponseItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyResponseItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SurveyResponseItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyResponseItemPayload>
          }
          findMany: {
            args: Prisma.SurveyResponseItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyResponseItemPayload>[]
          }
          create: {
            args: Prisma.SurveyResponseItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyResponseItemPayload>
          }
          createMany: {
            args: Prisma.SurveyResponseItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SurveyResponseItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyResponseItemPayload>[]
          }
          delete: {
            args: Prisma.SurveyResponseItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyResponseItemPayload>
          }
          update: {
            args: Prisma.SurveyResponseItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyResponseItemPayload>
          }
          deleteMany: {
            args: Prisma.SurveyResponseItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SurveyResponseItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SurveyResponseItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyResponseItemPayload>[]
          }
          upsert: {
            args: Prisma.SurveyResponseItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyResponseItemPayload>
          }
          aggregate: {
            args: Prisma.SurveyResponseItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSurveyResponseItem>
          }
          groupBy: {
            args: Prisma.SurveyResponseItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<SurveyResponseItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.SurveyResponseItemCountArgs<ExtArgs>
            result: $Utils.Optional<SurveyResponseItemCountAggregateOutputType> | number
          }
        }
      }
      SurveyResponseItemOption: {
        payload: Prisma.$SurveyResponseItemOptionPayload<ExtArgs>
        fields: Prisma.SurveyResponseItemOptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SurveyResponseItemOptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyResponseItemOptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SurveyResponseItemOptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyResponseItemOptionPayload>
          }
          findFirst: {
            args: Prisma.SurveyResponseItemOptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyResponseItemOptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SurveyResponseItemOptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyResponseItemOptionPayload>
          }
          findMany: {
            args: Prisma.SurveyResponseItemOptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyResponseItemOptionPayload>[]
          }
          create: {
            args: Prisma.SurveyResponseItemOptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyResponseItemOptionPayload>
          }
          createMany: {
            args: Prisma.SurveyResponseItemOptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SurveyResponseItemOptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyResponseItemOptionPayload>[]
          }
          delete: {
            args: Prisma.SurveyResponseItemOptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyResponseItemOptionPayload>
          }
          update: {
            args: Prisma.SurveyResponseItemOptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyResponseItemOptionPayload>
          }
          deleteMany: {
            args: Prisma.SurveyResponseItemOptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SurveyResponseItemOptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SurveyResponseItemOptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyResponseItemOptionPayload>[]
          }
          upsert: {
            args: Prisma.SurveyResponseItemOptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyResponseItemOptionPayload>
          }
          aggregate: {
            args: Prisma.SurveyResponseItemOptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSurveyResponseItemOption>
          }
          groupBy: {
            args: Prisma.SurveyResponseItemOptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SurveyResponseItemOptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SurveyResponseItemOptionCountArgs<ExtArgs>
            result: $Utils.Optional<SurveyResponseItemOptionCountAggregateOutputType> | number
          }
        }
      }
      MediaAsset: {
        payload: Prisma.$MediaAssetPayload<ExtArgs>
        fields: Prisma.MediaAssetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MediaAssetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAssetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MediaAssetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAssetPayload>
          }
          findFirst: {
            args: Prisma.MediaAssetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAssetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MediaAssetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAssetPayload>
          }
          findMany: {
            args: Prisma.MediaAssetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAssetPayload>[]
          }
          create: {
            args: Prisma.MediaAssetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAssetPayload>
          }
          createMany: {
            args: Prisma.MediaAssetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MediaAssetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAssetPayload>[]
          }
          delete: {
            args: Prisma.MediaAssetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAssetPayload>
          }
          update: {
            args: Prisma.MediaAssetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAssetPayload>
          }
          deleteMany: {
            args: Prisma.MediaAssetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MediaAssetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MediaAssetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAssetPayload>[]
          }
          upsert: {
            args: Prisma.MediaAssetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAssetPayload>
          }
          aggregate: {
            args: Prisma.MediaAssetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMediaAsset>
          }
          groupBy: {
            args: Prisma.MediaAssetGroupByArgs<ExtArgs>
            result: $Utils.Optional<MediaAssetGroupByOutputType>[]
          }
          count: {
            args: Prisma.MediaAssetCountArgs<ExtArgs>
            result: $Utils.Optional<MediaAssetCountAggregateOutputType> | number
          }
        }
      }
      Transcript: {
        payload: Prisma.$TranscriptPayload<ExtArgs>
        fields: Prisma.TranscriptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TranscriptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TranscriptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptPayload>
          }
          findFirst: {
            args: Prisma.TranscriptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TranscriptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptPayload>
          }
          findMany: {
            args: Prisma.TranscriptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptPayload>[]
          }
          create: {
            args: Prisma.TranscriptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptPayload>
          }
          createMany: {
            args: Prisma.TranscriptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TranscriptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptPayload>[]
          }
          delete: {
            args: Prisma.TranscriptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptPayload>
          }
          update: {
            args: Prisma.TranscriptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptPayload>
          }
          deleteMany: {
            args: Prisma.TranscriptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TranscriptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TranscriptUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptPayload>[]
          }
          upsert: {
            args: Prisma.TranscriptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptPayload>
          }
          aggregate: {
            args: Prisma.TranscriptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTranscript>
          }
          groupBy: {
            args: Prisma.TranscriptGroupByArgs<ExtArgs>
            result: $Utils.Optional<TranscriptGroupByOutputType>[]
          }
          count: {
            args: Prisma.TranscriptCountArgs<ExtArgs>
            result: $Utils.Optional<TranscriptCountAggregateOutputType> | number
          }
        }
      }
      AIAnalysis: {
        payload: Prisma.$AIAnalysisPayload<ExtArgs>
        fields: Prisma.AIAnalysisFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIAnalysisFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIAnalysisPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIAnalysisFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIAnalysisPayload>
          }
          findFirst: {
            args: Prisma.AIAnalysisFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIAnalysisPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIAnalysisFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIAnalysisPayload>
          }
          findMany: {
            args: Prisma.AIAnalysisFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIAnalysisPayload>[]
          }
          create: {
            args: Prisma.AIAnalysisCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIAnalysisPayload>
          }
          createMany: {
            args: Prisma.AIAnalysisCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIAnalysisCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIAnalysisPayload>[]
          }
          delete: {
            args: Prisma.AIAnalysisDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIAnalysisPayload>
          }
          update: {
            args: Prisma.AIAnalysisUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIAnalysisPayload>
          }
          deleteMany: {
            args: Prisma.AIAnalysisDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIAnalysisUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AIAnalysisUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIAnalysisPayload>[]
          }
          upsert: {
            args: Prisma.AIAnalysisUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIAnalysisPayload>
          }
          aggregate: {
            args: Prisma.AIAnalysisAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIAnalysis>
          }
          groupBy: {
            args: Prisma.AIAnalysisGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIAnalysisGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIAnalysisCountArgs<ExtArgs>
            result: $Utils.Optional<AIAnalysisCountAggregateOutputType> | number
          }
        }
      }
      VoterRegistration: {
        payload: Prisma.$VoterRegistrationPayload<ExtArgs>
        fields: Prisma.VoterRegistrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VoterRegistrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoterRegistrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VoterRegistrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoterRegistrationPayload>
          }
          findFirst: {
            args: Prisma.VoterRegistrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoterRegistrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VoterRegistrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoterRegistrationPayload>
          }
          findMany: {
            args: Prisma.VoterRegistrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoterRegistrationPayload>[]
          }
          create: {
            args: Prisma.VoterRegistrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoterRegistrationPayload>
          }
          createMany: {
            args: Prisma.VoterRegistrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VoterRegistrationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoterRegistrationPayload>[]
          }
          delete: {
            args: Prisma.VoterRegistrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoterRegistrationPayload>
          }
          update: {
            args: Prisma.VoterRegistrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoterRegistrationPayload>
          }
          deleteMany: {
            args: Prisma.VoterRegistrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VoterRegistrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VoterRegistrationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoterRegistrationPayload>[]
          }
          upsert: {
            args: Prisma.VoterRegistrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoterRegistrationPayload>
          }
          aggregate: {
            args: Prisma.VoterRegistrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVoterRegistration>
          }
          groupBy: {
            args: Prisma.VoterRegistrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<VoterRegistrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.VoterRegistrationCountArgs<ExtArgs>
            result: $Utils.Optional<VoterRegistrationCountAggregateOutputType> | number
          }
        }
      }
      VoteHistory: {
        payload: Prisma.$VoteHistoryPayload<ExtArgs>
        fields: Prisma.VoteHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VoteHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoteHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VoteHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoteHistoryPayload>
          }
          findFirst: {
            args: Prisma.VoteHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoteHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VoteHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoteHistoryPayload>
          }
          findMany: {
            args: Prisma.VoteHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoteHistoryPayload>[]
          }
          create: {
            args: Prisma.VoteHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoteHistoryPayload>
          }
          createMany: {
            args: Prisma.VoteHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VoteHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoteHistoryPayload>[]
          }
          delete: {
            args: Prisma.VoteHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoteHistoryPayload>
          }
          update: {
            args: Prisma.VoteHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoteHistoryPayload>
          }
          deleteMany: {
            args: Prisma.VoteHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VoteHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VoteHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoteHistoryPayload>[]
          }
          upsert: {
            args: Prisma.VoteHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoteHistoryPayload>
          }
          aggregate: {
            args: Prisma.VoteHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVoteHistory>
          }
          groupBy: {
            args: Prisma.VoteHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<VoteHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.VoteHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<VoteHistoryCountAggregateOutputType> | number
          }
        }
      }
      Segment: {
        payload: Prisma.$SegmentPayload<ExtArgs>
        fields: Prisma.SegmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SegmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SegmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentPayload>
          }
          findFirst: {
            args: Prisma.SegmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SegmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentPayload>
          }
          findMany: {
            args: Prisma.SegmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentPayload>[]
          }
          create: {
            args: Prisma.SegmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentPayload>
          }
          createMany: {
            args: Prisma.SegmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SegmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentPayload>[]
          }
          delete: {
            args: Prisma.SegmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentPayload>
          }
          update: {
            args: Prisma.SegmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentPayload>
          }
          deleteMany: {
            args: Prisma.SegmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SegmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SegmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentPayload>[]
          }
          upsert: {
            args: Prisma.SegmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentPayload>
          }
          aggregate: {
            args: Prisma.SegmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSegment>
          }
          groupBy: {
            args: Prisma.SegmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<SegmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.SegmentCountArgs<ExtArgs>
            result: $Utils.Optional<SegmentCountAggregateOutputType> | number
          }
        }
      }
      SegmentMember: {
        payload: Prisma.$SegmentMemberPayload<ExtArgs>
        fields: Prisma.SegmentMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SegmentMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SegmentMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentMemberPayload>
          }
          findFirst: {
            args: Prisma.SegmentMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SegmentMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentMemberPayload>
          }
          findMany: {
            args: Prisma.SegmentMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentMemberPayload>[]
          }
          create: {
            args: Prisma.SegmentMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentMemberPayload>
          }
          createMany: {
            args: Prisma.SegmentMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SegmentMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentMemberPayload>[]
          }
          delete: {
            args: Prisma.SegmentMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentMemberPayload>
          }
          update: {
            args: Prisma.SegmentMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentMemberPayload>
          }
          deleteMany: {
            args: Prisma.SegmentMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SegmentMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SegmentMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentMemberPayload>[]
          }
          upsert: {
            args: Prisma.SegmentMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentMemberPayload>
          }
          aggregate: {
            args: Prisma.SegmentMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSegmentMember>
          }
          groupBy: {
            args: Prisma.SegmentMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<SegmentMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.SegmentMemberCountArgs<ExtArgs>
            result: $Utils.Optional<SegmentMemberCountAggregateOutputType> | number
          }
        }
      }
      ImportJob: {
        payload: Prisma.$ImportJobPayload<ExtArgs>
        fields: Prisma.ImportJobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ImportJobFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportJobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ImportJobFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportJobPayload>
          }
          findFirst: {
            args: Prisma.ImportJobFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportJobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ImportJobFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportJobPayload>
          }
          findMany: {
            args: Prisma.ImportJobFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportJobPayload>[]
          }
          create: {
            args: Prisma.ImportJobCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportJobPayload>
          }
          createMany: {
            args: Prisma.ImportJobCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ImportJobCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportJobPayload>[]
          }
          delete: {
            args: Prisma.ImportJobDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportJobPayload>
          }
          update: {
            args: Prisma.ImportJobUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportJobPayload>
          }
          deleteMany: {
            args: Prisma.ImportJobDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ImportJobUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ImportJobUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportJobPayload>[]
          }
          upsert: {
            args: Prisma.ImportJobUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportJobPayload>
          }
          aggregate: {
            args: Prisma.ImportJobAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImportJob>
          }
          groupBy: {
            args: Prisma.ImportJobGroupByArgs<ExtArgs>
            result: $Utils.Optional<ImportJobGroupByOutputType>[]
          }
          count: {
            args: Prisma.ImportJobCountArgs<ExtArgs>
            result: $Utils.Optional<ImportJobCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    county?: CountyOmit
    issue?: IssueOmit
    countyIssue?: CountyIssueOmit
    blueprintSection?: BlueprintSectionOmit
    quote?: QuoteOmit
    asset?: AssetOmit
    glossaryTerm?: GlossaryTermOmit
    sourceDocument?: SourceDocumentOmit
    sourceChunk?: SourceChunkOmit
    sourceDocumentLink?: SourceDocumentLinkOmit
    geoCounty?: GeoCountyOmit
    geoZip?: GeoZipOmit
    geoPrecinct?: GeoPrecinctOmit
    geoDistrict?: GeoDistrictOmit
    geoCrosswalk?: GeoCrosswalkOmit
    censusMetric?: CensusMetricOmit
    bLSMetric?: BLSMetricOmit
    civicsOfficial?: CivicsOfficialOmit
    election?: ElectionOmit
    electionResult?: ElectionResultOmit
    aIPrompt?: AIPromptOmit
    aIRun?: AIRunOmit
    aIRunInputSource?: AIRunInputSourceOmit
    aIOutput?: AIOutputOmit
    aIOutputSection?: AIOutputSectionOmit
    aIOutputScope?: AIOutputScopeOmit
    citation?: CitationOmit
    surveyForm?: SurveyFormOmit
    surveyQuestion?: SurveyQuestionOmit
    surveyQuestionOption?: SurveyQuestionOptionOmit
    surveyResponse?: SurveyResponseOmit
    surveyResponseItem?: SurveyResponseItemOmit
    surveyResponseItemOption?: SurveyResponseItemOptionOmit
    mediaAsset?: MediaAssetOmit
    transcript?: TranscriptOmit
    aIAnalysis?: AIAnalysisOmit
    voterRegistration?: VoterRegistrationOmit
    voteHistory?: VoteHistoryOmit
    segment?: SegmentOmit
    segmentMember?: SegmentMemberOmit
    importJob?: ImportJobOmit
    auditLog?: AuditLogOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CountyCountOutputType
   */

  export type CountyCountOutputType = {
    blueprintSections: number
    quotes: number
    assets: number
    countyIssues: number
    censusMetrics: number
    blsMetrics: number
    civicsOfficials: number
    electionResults: number
    surveyForms: number
    surveyResponses: number
    aiOutputScopes: number
    sourceLinks: number
  }

  export type CountyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blueprintSections?: boolean | CountyCountOutputTypeCountBlueprintSectionsArgs
    quotes?: boolean | CountyCountOutputTypeCountQuotesArgs
    assets?: boolean | CountyCountOutputTypeCountAssetsArgs
    countyIssues?: boolean | CountyCountOutputTypeCountCountyIssuesArgs
    censusMetrics?: boolean | CountyCountOutputTypeCountCensusMetricsArgs
    blsMetrics?: boolean | CountyCountOutputTypeCountBlsMetricsArgs
    civicsOfficials?: boolean | CountyCountOutputTypeCountCivicsOfficialsArgs
    electionResults?: boolean | CountyCountOutputTypeCountElectionResultsArgs
    surveyForms?: boolean | CountyCountOutputTypeCountSurveyFormsArgs
    surveyResponses?: boolean | CountyCountOutputTypeCountSurveyResponsesArgs
    aiOutputScopes?: boolean | CountyCountOutputTypeCountAiOutputScopesArgs
    sourceLinks?: boolean | CountyCountOutputTypeCountSourceLinksArgs
  }

  // Custom InputTypes
  /**
   * CountyCountOutputType without action
   */
  export type CountyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountyCountOutputType
     */
    select?: CountyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CountyCountOutputType without action
   */
  export type CountyCountOutputTypeCountBlueprintSectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlueprintSectionWhereInput
  }

  /**
   * CountyCountOutputType without action
   */
  export type CountyCountOutputTypeCountQuotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuoteWhereInput
  }

  /**
   * CountyCountOutputType without action
   */
  export type CountyCountOutputTypeCountAssetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetWhereInput
  }

  /**
   * CountyCountOutputType without action
   */
  export type CountyCountOutputTypeCountCountyIssuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CountyIssueWhereInput
  }

  /**
   * CountyCountOutputType without action
   */
  export type CountyCountOutputTypeCountCensusMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CensusMetricWhereInput
  }

  /**
   * CountyCountOutputType without action
   */
  export type CountyCountOutputTypeCountBlsMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BLSMetricWhereInput
  }

  /**
   * CountyCountOutputType without action
   */
  export type CountyCountOutputTypeCountCivicsOfficialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CivicsOfficialWhereInput
  }

  /**
   * CountyCountOutputType without action
   */
  export type CountyCountOutputTypeCountElectionResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ElectionResultWhereInput
  }

  /**
   * CountyCountOutputType without action
   */
  export type CountyCountOutputTypeCountSurveyFormsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyFormWhereInput
  }

  /**
   * CountyCountOutputType without action
   */
  export type CountyCountOutputTypeCountSurveyResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyResponseWhereInput
  }

  /**
   * CountyCountOutputType without action
   */
  export type CountyCountOutputTypeCountAiOutputScopesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIOutputScopeWhereInput
  }

  /**
   * CountyCountOutputType without action
   */
  export type CountyCountOutputTypeCountSourceLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SourceDocumentLinkWhereInput
  }


  /**
   * Count Type IssueCountOutputType
   */

  export type IssueCountOutputType = {
    countyIssues: number
    blueprintSections: number
    quotes: number
    assets: number
    aiOutputScopes: number
    sourceLinks: number
  }

  export type IssueCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    countyIssues?: boolean | IssueCountOutputTypeCountCountyIssuesArgs
    blueprintSections?: boolean | IssueCountOutputTypeCountBlueprintSectionsArgs
    quotes?: boolean | IssueCountOutputTypeCountQuotesArgs
    assets?: boolean | IssueCountOutputTypeCountAssetsArgs
    aiOutputScopes?: boolean | IssueCountOutputTypeCountAiOutputScopesArgs
    sourceLinks?: boolean | IssueCountOutputTypeCountSourceLinksArgs
  }

  // Custom InputTypes
  /**
   * IssueCountOutputType without action
   */
  export type IssueCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IssueCountOutputType
     */
    select?: IssueCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * IssueCountOutputType without action
   */
  export type IssueCountOutputTypeCountCountyIssuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CountyIssueWhereInput
  }

  /**
   * IssueCountOutputType without action
   */
  export type IssueCountOutputTypeCountBlueprintSectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlueprintSectionWhereInput
  }

  /**
   * IssueCountOutputType without action
   */
  export type IssueCountOutputTypeCountQuotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuoteWhereInput
  }

  /**
   * IssueCountOutputType without action
   */
  export type IssueCountOutputTypeCountAssetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetWhereInput
  }

  /**
   * IssueCountOutputType without action
   */
  export type IssueCountOutputTypeCountAiOutputScopesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIOutputScopeWhereInput
  }

  /**
   * IssueCountOutputType without action
   */
  export type IssueCountOutputTypeCountSourceLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SourceDocumentLinkWhereInput
  }


  /**
   * Count Type BlueprintSectionCountOutputType
   */

  export type BlueprintSectionCountOutputType = {
    sourceLinks: number
  }

  export type BlueprintSectionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sourceLinks?: boolean | BlueprintSectionCountOutputTypeCountSourceLinksArgs
  }

  // Custom InputTypes
  /**
   * BlueprintSectionCountOutputType without action
   */
  export type BlueprintSectionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlueprintSectionCountOutputType
     */
    select?: BlueprintSectionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BlueprintSectionCountOutputType without action
   */
  export type BlueprintSectionCountOutputTypeCountSourceLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SourceDocumentLinkWhereInput
  }


  /**
   * Count Type QuoteCountOutputType
   */

  export type QuoteCountOutputType = {
    sourceLinks: number
  }

  export type QuoteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sourceLinks?: boolean | QuoteCountOutputTypeCountSourceLinksArgs
  }

  // Custom InputTypes
  /**
   * QuoteCountOutputType without action
   */
  export type QuoteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteCountOutputType
     */
    select?: QuoteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuoteCountOutputType without action
   */
  export type QuoteCountOutputTypeCountSourceLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SourceDocumentLinkWhereInput
  }


  /**
   * Count Type AssetCountOutputType
   */

  export type AssetCountOutputType = {
    sourceLinks: number
  }

  export type AssetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sourceLinks?: boolean | AssetCountOutputTypeCountSourceLinksArgs
  }

  // Custom InputTypes
  /**
   * AssetCountOutputType without action
   */
  export type AssetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetCountOutputType
     */
    select?: AssetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AssetCountOutputType without action
   */
  export type AssetCountOutputTypeCountSourceLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SourceDocumentLinkWhereInput
  }


  /**
   * Count Type SourceDocumentCountOutputType
   */

  export type SourceDocumentCountOutputType = {
    chunks: number
    citations: number
    runInputs: number
    sourceLinks: number
  }

  export type SourceDocumentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chunks?: boolean | SourceDocumentCountOutputTypeCountChunksArgs
    citations?: boolean | SourceDocumentCountOutputTypeCountCitationsArgs
    runInputs?: boolean | SourceDocumentCountOutputTypeCountRunInputsArgs
    sourceLinks?: boolean | SourceDocumentCountOutputTypeCountSourceLinksArgs
  }

  // Custom InputTypes
  /**
   * SourceDocumentCountOutputType without action
   */
  export type SourceDocumentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceDocumentCountOutputType
     */
    select?: SourceDocumentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SourceDocumentCountOutputType without action
   */
  export type SourceDocumentCountOutputTypeCountChunksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SourceChunkWhereInput
  }

  /**
   * SourceDocumentCountOutputType without action
   */
  export type SourceDocumentCountOutputTypeCountCitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CitationWhereInput
  }

  /**
   * SourceDocumentCountOutputType without action
   */
  export type SourceDocumentCountOutputTypeCountRunInputsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIRunInputSourceWhereInput
  }

  /**
   * SourceDocumentCountOutputType without action
   */
  export type SourceDocumentCountOutputTypeCountSourceLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SourceDocumentLinkWhereInput
  }


  /**
   * Count Type SourceChunkCountOutputType
   */

  export type SourceChunkCountOutputType = {
    citations: number
  }

  export type SourceChunkCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    citations?: boolean | SourceChunkCountOutputTypeCountCitationsArgs
  }

  // Custom InputTypes
  /**
   * SourceChunkCountOutputType without action
   */
  export type SourceChunkCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceChunkCountOutputType
     */
    select?: SourceChunkCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SourceChunkCountOutputType without action
   */
  export type SourceChunkCountOutputTypeCountCitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CitationWhereInput
  }


  /**
   * Count Type GeoZipCountOutputType
   */

  export type GeoZipCountOutputType = {
    censusMetrics: number
    aiOutputScopes: number
    electionResults: number
  }

  export type GeoZipCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    censusMetrics?: boolean | GeoZipCountOutputTypeCountCensusMetricsArgs
    aiOutputScopes?: boolean | GeoZipCountOutputTypeCountAiOutputScopesArgs
    electionResults?: boolean | GeoZipCountOutputTypeCountElectionResultsArgs
  }

  // Custom InputTypes
  /**
   * GeoZipCountOutputType without action
   */
  export type GeoZipCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoZipCountOutputType
     */
    select?: GeoZipCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GeoZipCountOutputType without action
   */
  export type GeoZipCountOutputTypeCountCensusMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CensusMetricWhereInput
  }

  /**
   * GeoZipCountOutputType without action
   */
  export type GeoZipCountOutputTypeCountAiOutputScopesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIOutputScopeWhereInput
  }

  /**
   * GeoZipCountOutputType without action
   */
  export type GeoZipCountOutputTypeCountElectionResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ElectionResultWhereInput
  }


  /**
   * Count Type GeoPrecinctCountOutputType
   */

  export type GeoPrecinctCountOutputType = {
    electionResults: number
  }

  export type GeoPrecinctCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    electionResults?: boolean | GeoPrecinctCountOutputTypeCountElectionResultsArgs
  }

  // Custom InputTypes
  /**
   * GeoPrecinctCountOutputType without action
   */
  export type GeoPrecinctCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoPrecinctCountOutputType
     */
    select?: GeoPrecinctCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GeoPrecinctCountOutputType without action
   */
  export type GeoPrecinctCountOutputTypeCountElectionResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ElectionResultWhereInput
  }


  /**
   * Count Type GeoDistrictCountOutputType
   */

  export type GeoDistrictCountOutputType = {
    civicsOfficials: number
    aiOutputScopes: number
  }

  export type GeoDistrictCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    civicsOfficials?: boolean | GeoDistrictCountOutputTypeCountCivicsOfficialsArgs
    aiOutputScopes?: boolean | GeoDistrictCountOutputTypeCountAiOutputScopesArgs
  }

  // Custom InputTypes
  /**
   * GeoDistrictCountOutputType without action
   */
  export type GeoDistrictCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoDistrictCountOutputType
     */
    select?: GeoDistrictCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GeoDistrictCountOutputType without action
   */
  export type GeoDistrictCountOutputTypeCountCivicsOfficialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CivicsOfficialWhereInput
  }

  /**
   * GeoDistrictCountOutputType without action
   */
  export type GeoDistrictCountOutputTypeCountAiOutputScopesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIOutputScopeWhereInput
  }


  /**
   * Count Type ElectionCountOutputType
   */

  export type ElectionCountOutputType = {
    results: number
  }

  export type ElectionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    results?: boolean | ElectionCountOutputTypeCountResultsArgs
  }

  // Custom InputTypes
  /**
   * ElectionCountOutputType without action
   */
  export type ElectionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElectionCountOutputType
     */
    select?: ElectionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ElectionCountOutputType without action
   */
  export type ElectionCountOutputTypeCountResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ElectionResultWhereInput
  }


  /**
   * Count Type AIPromptCountOutputType
   */

  export type AIPromptCountOutputType = {
    runs: number
  }

  export type AIPromptCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    runs?: boolean | AIPromptCountOutputTypeCountRunsArgs
  }

  // Custom InputTypes
  /**
   * AIPromptCountOutputType without action
   */
  export type AIPromptCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIPromptCountOutputType
     */
    select?: AIPromptCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AIPromptCountOutputType without action
   */
  export type AIPromptCountOutputTypeCountRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIRunWhereInput
  }


  /**
   * Count Type AIRunCountOutputType
   */

  export type AIRunCountOutputType = {
    outputs: number
    inputSources: number
    analyses: number
  }

  export type AIRunCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    outputs?: boolean | AIRunCountOutputTypeCountOutputsArgs
    inputSources?: boolean | AIRunCountOutputTypeCountInputSourcesArgs
    analyses?: boolean | AIRunCountOutputTypeCountAnalysesArgs
  }

  // Custom InputTypes
  /**
   * AIRunCountOutputType without action
   */
  export type AIRunCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRunCountOutputType
     */
    select?: AIRunCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AIRunCountOutputType without action
   */
  export type AIRunCountOutputTypeCountOutputsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIOutputWhereInput
  }

  /**
   * AIRunCountOutputType without action
   */
  export type AIRunCountOutputTypeCountInputSourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIRunInputSourceWhereInput
  }

  /**
   * AIRunCountOutputType without action
   */
  export type AIRunCountOutputTypeCountAnalysesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIAnalysisWhereInput
  }


  /**
   * Count Type AIOutputCountOutputType
   */

  export type AIOutputCountOutputType = {
    sections: number
    scopes: number
  }

  export type AIOutputCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sections?: boolean | AIOutputCountOutputTypeCountSectionsArgs
    scopes?: boolean | AIOutputCountOutputTypeCountScopesArgs
  }

  // Custom InputTypes
  /**
   * AIOutputCountOutputType without action
   */
  export type AIOutputCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIOutputCountOutputType
     */
    select?: AIOutputCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AIOutputCountOutputType without action
   */
  export type AIOutputCountOutputTypeCountSectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIOutputSectionWhereInput
  }

  /**
   * AIOutputCountOutputType without action
   */
  export type AIOutputCountOutputTypeCountScopesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIOutputScopeWhereInput
  }


  /**
   * Count Type AIOutputSectionCountOutputType
   */

  export type AIOutputSectionCountOutputType = {
    citations: number
  }

  export type AIOutputSectionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    citations?: boolean | AIOutputSectionCountOutputTypeCountCitationsArgs
  }

  // Custom InputTypes
  /**
   * AIOutputSectionCountOutputType without action
   */
  export type AIOutputSectionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIOutputSectionCountOutputType
     */
    select?: AIOutputSectionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AIOutputSectionCountOutputType without action
   */
  export type AIOutputSectionCountOutputTypeCountCitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CitationWhereInput
  }


  /**
   * Count Type SurveyFormCountOutputType
   */

  export type SurveyFormCountOutputType = {
    questions: number
    responses: number
    sourceLinks: number
  }

  export type SurveyFormCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | SurveyFormCountOutputTypeCountQuestionsArgs
    responses?: boolean | SurveyFormCountOutputTypeCountResponsesArgs
    sourceLinks?: boolean | SurveyFormCountOutputTypeCountSourceLinksArgs
  }

  // Custom InputTypes
  /**
   * SurveyFormCountOutputType without action
   */
  export type SurveyFormCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyFormCountOutputType
     */
    select?: SurveyFormCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SurveyFormCountOutputType without action
   */
  export type SurveyFormCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyQuestionWhereInput
  }

  /**
   * SurveyFormCountOutputType without action
   */
  export type SurveyFormCountOutputTypeCountResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyResponseWhereInput
  }

  /**
   * SurveyFormCountOutputType without action
   */
  export type SurveyFormCountOutputTypeCountSourceLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SourceDocumentLinkWhereInput
  }


  /**
   * Count Type SurveyQuestionCountOutputType
   */

  export type SurveyQuestionCountOutputType = {
    options: number
    responseItems: number
  }

  export type SurveyQuestionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    options?: boolean | SurveyQuestionCountOutputTypeCountOptionsArgs
    responseItems?: boolean | SurveyQuestionCountOutputTypeCountResponseItemsArgs
  }

  // Custom InputTypes
  /**
   * SurveyQuestionCountOutputType without action
   */
  export type SurveyQuestionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyQuestionCountOutputType
     */
    select?: SurveyQuestionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SurveyQuestionCountOutputType without action
   */
  export type SurveyQuestionCountOutputTypeCountOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyQuestionOptionWhereInput
  }

  /**
   * SurveyQuestionCountOutputType without action
   */
  export type SurveyQuestionCountOutputTypeCountResponseItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyResponseItemWhereInput
  }


  /**
   * Count Type SurveyQuestionOptionCountOutputType
   */

  export type SurveyQuestionOptionCountOutputType = {
    responseItemOptions: number
    selectedByResponseItems: number
  }

  export type SurveyQuestionOptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responseItemOptions?: boolean | SurveyQuestionOptionCountOutputTypeCountResponseItemOptionsArgs
    selectedByResponseItems?: boolean | SurveyQuestionOptionCountOutputTypeCountSelectedByResponseItemsArgs
  }

  // Custom InputTypes
  /**
   * SurveyQuestionOptionCountOutputType without action
   */
  export type SurveyQuestionOptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyQuestionOptionCountOutputType
     */
    select?: SurveyQuestionOptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SurveyQuestionOptionCountOutputType without action
   */
  export type SurveyQuestionOptionCountOutputTypeCountResponseItemOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyResponseItemOptionWhereInput
  }

  /**
   * SurveyQuestionOptionCountOutputType without action
   */
  export type SurveyQuestionOptionCountOutputTypeCountSelectedByResponseItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyResponseItemWhereInput
  }


  /**
   * Count Type SurveyResponseCountOutputType
   */

  export type SurveyResponseCountOutputType = {
    items: number
  }

  export type SurveyResponseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | SurveyResponseCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * SurveyResponseCountOutputType without action
   */
  export type SurveyResponseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponseCountOutputType
     */
    select?: SurveyResponseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SurveyResponseCountOutputType without action
   */
  export type SurveyResponseCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyResponseItemWhereInput
  }


  /**
   * Count Type SurveyResponseItemCountOutputType
   */

  export type SurveyResponseItemCountOutputType = {
    multiSelectedOptions: number
  }

  export type SurveyResponseItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    multiSelectedOptions?: boolean | SurveyResponseItemCountOutputTypeCountMultiSelectedOptionsArgs
  }

  // Custom InputTypes
  /**
   * SurveyResponseItemCountOutputType without action
   */
  export type SurveyResponseItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponseItemCountOutputType
     */
    select?: SurveyResponseItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SurveyResponseItemCountOutputType without action
   */
  export type SurveyResponseItemCountOutputTypeCountMultiSelectedOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyResponseItemOptionWhereInput
  }


  /**
   * Count Type MediaAssetCountOutputType
   */

  export type MediaAssetCountOutputType = {
    surveyResponseItems: number
    transcripts: number
    analyses: number
  }

  export type MediaAssetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    surveyResponseItems?: boolean | MediaAssetCountOutputTypeCountSurveyResponseItemsArgs
    transcripts?: boolean | MediaAssetCountOutputTypeCountTranscriptsArgs
    analyses?: boolean | MediaAssetCountOutputTypeCountAnalysesArgs
  }

  // Custom InputTypes
  /**
   * MediaAssetCountOutputType without action
   */
  export type MediaAssetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAssetCountOutputType
     */
    select?: MediaAssetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MediaAssetCountOutputType without action
   */
  export type MediaAssetCountOutputTypeCountSurveyResponseItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyResponseItemWhereInput
  }

  /**
   * MediaAssetCountOutputType without action
   */
  export type MediaAssetCountOutputTypeCountTranscriptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TranscriptWhereInput
  }

  /**
   * MediaAssetCountOutputType without action
   */
  export type MediaAssetCountOutputTypeCountAnalysesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIAnalysisWhereInput
  }


  /**
   * Count Type TranscriptCountOutputType
   */

  export type TranscriptCountOutputType = {
    analyses: number
  }

  export type TranscriptCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    analyses?: boolean | TranscriptCountOutputTypeCountAnalysesArgs
  }

  // Custom InputTypes
  /**
   * TranscriptCountOutputType without action
   */
  export type TranscriptCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptCountOutputType
     */
    select?: TranscriptCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TranscriptCountOutputType without action
   */
  export type TranscriptCountOutputTypeCountAnalysesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIAnalysisWhereInput
  }


  /**
   * Count Type VoterRegistrationCountOutputType
   */

  export type VoterRegistrationCountOutputType = {
    voteHistory: number
    segmentMemberships: number
  }

  export type VoterRegistrationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    voteHistory?: boolean | VoterRegistrationCountOutputTypeCountVoteHistoryArgs
    segmentMemberships?: boolean | VoterRegistrationCountOutputTypeCountSegmentMembershipsArgs
  }

  // Custom InputTypes
  /**
   * VoterRegistrationCountOutputType without action
   */
  export type VoterRegistrationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoterRegistrationCountOutputType
     */
    select?: VoterRegistrationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VoterRegistrationCountOutputType without action
   */
  export type VoterRegistrationCountOutputTypeCountVoteHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoteHistoryWhereInput
  }

  /**
   * VoterRegistrationCountOutputType without action
   */
  export type VoterRegistrationCountOutputTypeCountSegmentMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SegmentMemberWhereInput
  }


  /**
   * Count Type SegmentCountOutputType
   */

  export type SegmentCountOutputType = {
    members: number
  }

  export type SegmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | SegmentCountOutputTypeCountMembersArgs
  }

  // Custom InputTypes
  /**
   * SegmentCountOutputType without action
   */
  export type SegmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SegmentCountOutputType
     */
    select?: SegmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SegmentCountOutputType without action
   */
  export type SegmentCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SegmentMemberWhereInput
  }


  /**
   * Count Type ImportJobCountOutputType
   */

  export type ImportJobCountOutputType = {
    auditLogs: number
  }

  export type ImportJobCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditLogs?: boolean | ImportJobCountOutputTypeCountAuditLogsArgs
  }

  // Custom InputTypes
  /**
   * ImportJobCountOutputType without action
   */
  export type ImportJobCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportJobCountOutputType
     */
    select?: ImportJobCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ImportJobCountOutputType without action
   */
  export type ImportJobCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }


  /**
   * Models
   */

  /**
   * Model County
   */

  export type AggregateCounty = {
    _count: CountyCountAggregateOutputType | null
    _min: CountyMinAggregateOutputType | null
    _max: CountyMaxAggregateOutputType | null
  }

  export type CountyMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    fipsCode: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CountyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    fipsCode: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CountyCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    fipsCode: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CountyMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    fipsCode?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CountyMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    fipsCode?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CountyCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    fipsCode?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CountyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which County to aggregate.
     */
    where?: CountyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Counties to fetch.
     */
    orderBy?: CountyOrderByWithRelationInput | CountyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CountyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Counties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Counties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Counties
    **/
    _count?: true | CountyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CountyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CountyMaxAggregateInputType
  }

  export type GetCountyAggregateType<T extends CountyAggregateArgs> = {
        [P in keyof T & keyof AggregateCounty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCounty[P]>
      : GetScalarType<T[P], AggregateCounty[P]>
  }




  export type CountyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CountyWhereInput
    orderBy?: CountyOrderByWithAggregationInput | CountyOrderByWithAggregationInput[]
    by: CountyScalarFieldEnum[] | CountyScalarFieldEnum
    having?: CountyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CountyCountAggregateInputType | true
    _min?: CountyMinAggregateInputType
    _max?: CountyMaxAggregateInputType
  }

  export type CountyGroupByOutputType = {
    id: string
    name: string
    slug: string
    fipsCode: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: CountyCountAggregateOutputType | null
    _min: CountyMinAggregateOutputType | null
    _max: CountyMaxAggregateOutputType | null
  }

  type GetCountyGroupByPayload<T extends CountyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CountyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CountyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CountyGroupByOutputType[P]>
            : GetScalarType<T[P], CountyGroupByOutputType[P]>
        }
      >
    >


  export type CountySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    fipsCode?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    blueprintSections?: boolean | County$blueprintSectionsArgs<ExtArgs>
    quotes?: boolean | County$quotesArgs<ExtArgs>
    assets?: boolean | County$assetsArgs<ExtArgs>
    countyIssues?: boolean | County$countyIssuesArgs<ExtArgs>
    censusMetrics?: boolean | County$censusMetricsArgs<ExtArgs>
    blsMetrics?: boolean | County$blsMetricsArgs<ExtArgs>
    civicsOfficials?: boolean | County$civicsOfficialsArgs<ExtArgs>
    electionResults?: boolean | County$electionResultsArgs<ExtArgs>
    surveyForms?: boolean | County$surveyFormsArgs<ExtArgs>
    surveyResponses?: boolean | County$surveyResponsesArgs<ExtArgs>
    aiOutputScopes?: boolean | County$aiOutputScopesArgs<ExtArgs>
    sourceLinks?: boolean | County$sourceLinksArgs<ExtArgs>
    _count?: boolean | CountyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["county"]>

  export type CountySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    fipsCode?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["county"]>

  export type CountySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    fipsCode?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["county"]>

  export type CountySelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    fipsCode?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CountyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "fipsCode" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["county"]>
  export type CountyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blueprintSections?: boolean | County$blueprintSectionsArgs<ExtArgs>
    quotes?: boolean | County$quotesArgs<ExtArgs>
    assets?: boolean | County$assetsArgs<ExtArgs>
    countyIssues?: boolean | County$countyIssuesArgs<ExtArgs>
    censusMetrics?: boolean | County$censusMetricsArgs<ExtArgs>
    blsMetrics?: boolean | County$blsMetricsArgs<ExtArgs>
    civicsOfficials?: boolean | County$civicsOfficialsArgs<ExtArgs>
    electionResults?: boolean | County$electionResultsArgs<ExtArgs>
    surveyForms?: boolean | County$surveyFormsArgs<ExtArgs>
    surveyResponses?: boolean | County$surveyResponsesArgs<ExtArgs>
    aiOutputScopes?: boolean | County$aiOutputScopesArgs<ExtArgs>
    sourceLinks?: boolean | County$sourceLinksArgs<ExtArgs>
    _count?: boolean | CountyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CountyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CountyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CountyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "County"
    objects: {
      blueprintSections: Prisma.$BlueprintSectionPayload<ExtArgs>[]
      quotes: Prisma.$QuotePayload<ExtArgs>[]
      assets: Prisma.$AssetPayload<ExtArgs>[]
      countyIssues: Prisma.$CountyIssuePayload<ExtArgs>[]
      censusMetrics: Prisma.$CensusMetricPayload<ExtArgs>[]
      blsMetrics: Prisma.$BLSMetricPayload<ExtArgs>[]
      civicsOfficials: Prisma.$CivicsOfficialPayload<ExtArgs>[]
      electionResults: Prisma.$ElectionResultPayload<ExtArgs>[]
      surveyForms: Prisma.$SurveyFormPayload<ExtArgs>[]
      surveyResponses: Prisma.$SurveyResponsePayload<ExtArgs>[]
      aiOutputScopes: Prisma.$AIOutputScopePayload<ExtArgs>[]
      sourceLinks: Prisma.$SourceDocumentLinkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      fipsCode: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["county"]>
    composites: {}
  }

  type CountyGetPayload<S extends boolean | null | undefined | CountyDefaultArgs> = $Result.GetResult<Prisma.$CountyPayload, S>

  type CountyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CountyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CountyCountAggregateInputType | true
    }

  export interface CountyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['County'], meta: { name: 'County' } }
    /**
     * Find zero or one County that matches the filter.
     * @param {CountyFindUniqueArgs} args - Arguments to find a County
     * @example
     * // Get one County
     * const county = await prisma.county.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CountyFindUniqueArgs>(args: SelectSubset<T, CountyFindUniqueArgs<ExtArgs>>): Prisma__CountyClient<$Result.GetResult<Prisma.$CountyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one County that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CountyFindUniqueOrThrowArgs} args - Arguments to find a County
     * @example
     * // Get one County
     * const county = await prisma.county.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CountyFindUniqueOrThrowArgs>(args: SelectSubset<T, CountyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CountyClient<$Result.GetResult<Prisma.$CountyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first County that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountyFindFirstArgs} args - Arguments to find a County
     * @example
     * // Get one County
     * const county = await prisma.county.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CountyFindFirstArgs>(args?: SelectSubset<T, CountyFindFirstArgs<ExtArgs>>): Prisma__CountyClient<$Result.GetResult<Prisma.$CountyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first County that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountyFindFirstOrThrowArgs} args - Arguments to find a County
     * @example
     * // Get one County
     * const county = await prisma.county.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CountyFindFirstOrThrowArgs>(args?: SelectSubset<T, CountyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CountyClient<$Result.GetResult<Prisma.$CountyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Counties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Counties
     * const counties = await prisma.county.findMany()
     * 
     * // Get first 10 Counties
     * const counties = await prisma.county.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const countyWithIdOnly = await prisma.county.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CountyFindManyArgs>(args?: SelectSubset<T, CountyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a County.
     * @param {CountyCreateArgs} args - Arguments to create a County.
     * @example
     * // Create one County
     * const County = await prisma.county.create({
     *   data: {
     *     // ... data to create a County
     *   }
     * })
     * 
     */
    create<T extends CountyCreateArgs>(args: SelectSubset<T, CountyCreateArgs<ExtArgs>>): Prisma__CountyClient<$Result.GetResult<Prisma.$CountyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Counties.
     * @param {CountyCreateManyArgs} args - Arguments to create many Counties.
     * @example
     * // Create many Counties
     * const county = await prisma.county.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CountyCreateManyArgs>(args?: SelectSubset<T, CountyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Counties and returns the data saved in the database.
     * @param {CountyCreateManyAndReturnArgs} args - Arguments to create many Counties.
     * @example
     * // Create many Counties
     * const county = await prisma.county.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Counties and only return the `id`
     * const countyWithIdOnly = await prisma.county.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CountyCreateManyAndReturnArgs>(args?: SelectSubset<T, CountyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a County.
     * @param {CountyDeleteArgs} args - Arguments to delete one County.
     * @example
     * // Delete one County
     * const County = await prisma.county.delete({
     *   where: {
     *     // ... filter to delete one County
     *   }
     * })
     * 
     */
    delete<T extends CountyDeleteArgs>(args: SelectSubset<T, CountyDeleteArgs<ExtArgs>>): Prisma__CountyClient<$Result.GetResult<Prisma.$CountyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one County.
     * @param {CountyUpdateArgs} args - Arguments to update one County.
     * @example
     * // Update one County
     * const county = await prisma.county.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CountyUpdateArgs>(args: SelectSubset<T, CountyUpdateArgs<ExtArgs>>): Prisma__CountyClient<$Result.GetResult<Prisma.$CountyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Counties.
     * @param {CountyDeleteManyArgs} args - Arguments to filter Counties to delete.
     * @example
     * // Delete a few Counties
     * const { count } = await prisma.county.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CountyDeleteManyArgs>(args?: SelectSubset<T, CountyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Counties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Counties
     * const county = await prisma.county.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CountyUpdateManyArgs>(args: SelectSubset<T, CountyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Counties and returns the data updated in the database.
     * @param {CountyUpdateManyAndReturnArgs} args - Arguments to update many Counties.
     * @example
     * // Update many Counties
     * const county = await prisma.county.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Counties and only return the `id`
     * const countyWithIdOnly = await prisma.county.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CountyUpdateManyAndReturnArgs>(args: SelectSubset<T, CountyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one County.
     * @param {CountyUpsertArgs} args - Arguments to update or create a County.
     * @example
     * // Update or create a County
     * const county = await prisma.county.upsert({
     *   create: {
     *     // ... data to create a County
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the County we want to update
     *   }
     * })
     */
    upsert<T extends CountyUpsertArgs>(args: SelectSubset<T, CountyUpsertArgs<ExtArgs>>): Prisma__CountyClient<$Result.GetResult<Prisma.$CountyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Counties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountyCountArgs} args - Arguments to filter Counties to count.
     * @example
     * // Count the number of Counties
     * const count = await prisma.county.count({
     *   where: {
     *     // ... the filter for the Counties we want to count
     *   }
     * })
    **/
    count<T extends CountyCountArgs>(
      args?: Subset<T, CountyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CountyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a County.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CountyAggregateArgs>(args: Subset<T, CountyAggregateArgs>): Prisma.PrismaPromise<GetCountyAggregateType<T>>

    /**
     * Group by County.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CountyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CountyGroupByArgs['orderBy'] }
        : { orderBy?: CountyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CountyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCountyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the County model
   */
  readonly fields: CountyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for County.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CountyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    blueprintSections<T extends County$blueprintSectionsArgs<ExtArgs> = {}>(args?: Subset<T, County$blueprintSectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlueprintSectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quotes<T extends County$quotesArgs<ExtArgs> = {}>(args?: Subset<T, County$quotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assets<T extends County$assetsArgs<ExtArgs> = {}>(args?: Subset<T, County$assetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    countyIssues<T extends County$countyIssuesArgs<ExtArgs> = {}>(args?: Subset<T, County$countyIssuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountyIssuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    censusMetrics<T extends County$censusMetricsArgs<ExtArgs> = {}>(args?: Subset<T, County$censusMetricsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CensusMetricPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    blsMetrics<T extends County$blsMetricsArgs<ExtArgs> = {}>(args?: Subset<T, County$blsMetricsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BLSMetricPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    civicsOfficials<T extends County$civicsOfficialsArgs<ExtArgs> = {}>(args?: Subset<T, County$civicsOfficialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CivicsOfficialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    electionResults<T extends County$electionResultsArgs<ExtArgs> = {}>(args?: Subset<T, County$electionResultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ElectionResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    surveyForms<T extends County$surveyFormsArgs<ExtArgs> = {}>(args?: Subset<T, County$surveyFormsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyFormPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    surveyResponses<T extends County$surveyResponsesArgs<ExtArgs> = {}>(args?: Subset<T, County$surveyResponsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    aiOutputScopes<T extends County$aiOutputScopesArgs<ExtArgs> = {}>(args?: Subset<T, County$aiOutputScopesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIOutputScopePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sourceLinks<T extends County$sourceLinksArgs<ExtArgs> = {}>(args?: Subset<T, County$sourceLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourceDocumentLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the County model
   */
  interface CountyFieldRefs {
    readonly id: FieldRef<"County", 'String'>
    readonly name: FieldRef<"County", 'String'>
    readonly slug: FieldRef<"County", 'String'>
    readonly fipsCode: FieldRef<"County", 'String'>
    readonly isActive: FieldRef<"County", 'Boolean'>
    readonly createdAt: FieldRef<"County", 'DateTime'>
    readonly updatedAt: FieldRef<"County", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * County findUnique
   */
  export type CountyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the County
     */
    select?: CountySelect<ExtArgs> | null
    /**
     * Omit specific fields from the County
     */
    omit?: CountyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountyInclude<ExtArgs> | null
    /**
     * Filter, which County to fetch.
     */
    where: CountyWhereUniqueInput
  }

  /**
   * County findUniqueOrThrow
   */
  export type CountyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the County
     */
    select?: CountySelect<ExtArgs> | null
    /**
     * Omit specific fields from the County
     */
    omit?: CountyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountyInclude<ExtArgs> | null
    /**
     * Filter, which County to fetch.
     */
    where: CountyWhereUniqueInput
  }

  /**
   * County findFirst
   */
  export type CountyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the County
     */
    select?: CountySelect<ExtArgs> | null
    /**
     * Omit specific fields from the County
     */
    omit?: CountyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountyInclude<ExtArgs> | null
    /**
     * Filter, which County to fetch.
     */
    where?: CountyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Counties to fetch.
     */
    orderBy?: CountyOrderByWithRelationInput | CountyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Counties.
     */
    cursor?: CountyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Counties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Counties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Counties.
     */
    distinct?: CountyScalarFieldEnum | CountyScalarFieldEnum[]
  }

  /**
   * County findFirstOrThrow
   */
  export type CountyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the County
     */
    select?: CountySelect<ExtArgs> | null
    /**
     * Omit specific fields from the County
     */
    omit?: CountyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountyInclude<ExtArgs> | null
    /**
     * Filter, which County to fetch.
     */
    where?: CountyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Counties to fetch.
     */
    orderBy?: CountyOrderByWithRelationInput | CountyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Counties.
     */
    cursor?: CountyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Counties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Counties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Counties.
     */
    distinct?: CountyScalarFieldEnum | CountyScalarFieldEnum[]
  }

  /**
   * County findMany
   */
  export type CountyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the County
     */
    select?: CountySelect<ExtArgs> | null
    /**
     * Omit specific fields from the County
     */
    omit?: CountyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountyInclude<ExtArgs> | null
    /**
     * Filter, which Counties to fetch.
     */
    where?: CountyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Counties to fetch.
     */
    orderBy?: CountyOrderByWithRelationInput | CountyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Counties.
     */
    cursor?: CountyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Counties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Counties.
     */
    skip?: number
    distinct?: CountyScalarFieldEnum | CountyScalarFieldEnum[]
  }

  /**
   * County create
   */
  export type CountyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the County
     */
    select?: CountySelect<ExtArgs> | null
    /**
     * Omit specific fields from the County
     */
    omit?: CountyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountyInclude<ExtArgs> | null
    /**
     * The data needed to create a County.
     */
    data: XOR<CountyCreateInput, CountyUncheckedCreateInput>
  }

  /**
   * County createMany
   */
  export type CountyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Counties.
     */
    data: CountyCreateManyInput | CountyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * County createManyAndReturn
   */
  export type CountyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the County
     */
    select?: CountySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the County
     */
    omit?: CountyOmit<ExtArgs> | null
    /**
     * The data used to create many Counties.
     */
    data: CountyCreateManyInput | CountyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * County update
   */
  export type CountyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the County
     */
    select?: CountySelect<ExtArgs> | null
    /**
     * Omit specific fields from the County
     */
    omit?: CountyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountyInclude<ExtArgs> | null
    /**
     * The data needed to update a County.
     */
    data: XOR<CountyUpdateInput, CountyUncheckedUpdateInput>
    /**
     * Choose, which County to update.
     */
    where: CountyWhereUniqueInput
  }

  /**
   * County updateMany
   */
  export type CountyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Counties.
     */
    data: XOR<CountyUpdateManyMutationInput, CountyUncheckedUpdateManyInput>
    /**
     * Filter which Counties to update
     */
    where?: CountyWhereInput
    /**
     * Limit how many Counties to update.
     */
    limit?: number
  }

  /**
   * County updateManyAndReturn
   */
  export type CountyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the County
     */
    select?: CountySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the County
     */
    omit?: CountyOmit<ExtArgs> | null
    /**
     * The data used to update Counties.
     */
    data: XOR<CountyUpdateManyMutationInput, CountyUncheckedUpdateManyInput>
    /**
     * Filter which Counties to update
     */
    where?: CountyWhereInput
    /**
     * Limit how many Counties to update.
     */
    limit?: number
  }

  /**
   * County upsert
   */
  export type CountyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the County
     */
    select?: CountySelect<ExtArgs> | null
    /**
     * Omit specific fields from the County
     */
    omit?: CountyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountyInclude<ExtArgs> | null
    /**
     * The filter to search for the County to update in case it exists.
     */
    where: CountyWhereUniqueInput
    /**
     * In case the County found by the `where` argument doesn't exist, create a new County with this data.
     */
    create: XOR<CountyCreateInput, CountyUncheckedCreateInput>
    /**
     * In case the County was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CountyUpdateInput, CountyUncheckedUpdateInput>
  }

  /**
   * County delete
   */
  export type CountyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the County
     */
    select?: CountySelect<ExtArgs> | null
    /**
     * Omit specific fields from the County
     */
    omit?: CountyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountyInclude<ExtArgs> | null
    /**
     * Filter which County to delete.
     */
    where: CountyWhereUniqueInput
  }

  /**
   * County deleteMany
   */
  export type CountyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Counties to delete
     */
    where?: CountyWhereInput
    /**
     * Limit how many Counties to delete.
     */
    limit?: number
  }

  /**
   * County.blueprintSections
   */
  export type County$blueprintSectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlueprintSection
     */
    select?: BlueprintSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlueprintSection
     */
    omit?: BlueprintSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlueprintSectionInclude<ExtArgs> | null
    where?: BlueprintSectionWhereInput
    orderBy?: BlueprintSectionOrderByWithRelationInput | BlueprintSectionOrderByWithRelationInput[]
    cursor?: BlueprintSectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlueprintSectionScalarFieldEnum | BlueprintSectionScalarFieldEnum[]
  }

  /**
   * County.quotes
   */
  export type County$quotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    where?: QuoteWhereInput
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    cursor?: QuoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuoteScalarFieldEnum | QuoteScalarFieldEnum[]
  }

  /**
   * County.assets
   */
  export type County$assetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    where?: AssetWhereInput
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    cursor?: AssetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * County.countyIssues
   */
  export type County$countyIssuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountyIssue
     */
    select?: CountyIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountyIssue
     */
    omit?: CountyIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountyIssueInclude<ExtArgs> | null
    where?: CountyIssueWhereInput
    orderBy?: CountyIssueOrderByWithRelationInput | CountyIssueOrderByWithRelationInput[]
    cursor?: CountyIssueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CountyIssueScalarFieldEnum | CountyIssueScalarFieldEnum[]
  }

  /**
   * County.censusMetrics
   */
  export type County$censusMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusMetric
     */
    select?: CensusMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusMetric
     */
    omit?: CensusMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusMetricInclude<ExtArgs> | null
    where?: CensusMetricWhereInput
    orderBy?: CensusMetricOrderByWithRelationInput | CensusMetricOrderByWithRelationInput[]
    cursor?: CensusMetricWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CensusMetricScalarFieldEnum | CensusMetricScalarFieldEnum[]
  }

  /**
   * County.blsMetrics
   */
  export type County$blsMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BLSMetric
     */
    select?: BLSMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BLSMetric
     */
    omit?: BLSMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BLSMetricInclude<ExtArgs> | null
    where?: BLSMetricWhereInput
    orderBy?: BLSMetricOrderByWithRelationInput | BLSMetricOrderByWithRelationInput[]
    cursor?: BLSMetricWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BLSMetricScalarFieldEnum | BLSMetricScalarFieldEnum[]
  }

  /**
   * County.civicsOfficials
   */
  export type County$civicsOfficialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CivicsOfficial
     */
    select?: CivicsOfficialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CivicsOfficial
     */
    omit?: CivicsOfficialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CivicsOfficialInclude<ExtArgs> | null
    where?: CivicsOfficialWhereInput
    orderBy?: CivicsOfficialOrderByWithRelationInput | CivicsOfficialOrderByWithRelationInput[]
    cursor?: CivicsOfficialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CivicsOfficialScalarFieldEnum | CivicsOfficialScalarFieldEnum[]
  }

  /**
   * County.electionResults
   */
  export type County$electionResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElectionResult
     */
    select?: ElectionResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElectionResult
     */
    omit?: ElectionResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElectionResultInclude<ExtArgs> | null
    where?: ElectionResultWhereInput
    orderBy?: ElectionResultOrderByWithRelationInput | ElectionResultOrderByWithRelationInput[]
    cursor?: ElectionResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ElectionResultScalarFieldEnum | ElectionResultScalarFieldEnum[]
  }

  /**
   * County.surveyForms
   */
  export type County$surveyFormsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyForm
     */
    select?: SurveyFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyForm
     */
    omit?: SurveyFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyFormInclude<ExtArgs> | null
    where?: SurveyFormWhereInput
    orderBy?: SurveyFormOrderByWithRelationInput | SurveyFormOrderByWithRelationInput[]
    cursor?: SurveyFormWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SurveyFormScalarFieldEnum | SurveyFormScalarFieldEnum[]
  }

  /**
   * County.surveyResponses
   */
  export type County$surveyResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponse
     */
    select?: SurveyResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyResponse
     */
    omit?: SurveyResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseInclude<ExtArgs> | null
    where?: SurveyResponseWhereInput
    orderBy?: SurveyResponseOrderByWithRelationInput | SurveyResponseOrderByWithRelationInput[]
    cursor?: SurveyResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SurveyResponseScalarFieldEnum | SurveyResponseScalarFieldEnum[]
  }

  /**
   * County.aiOutputScopes
   */
  export type County$aiOutputScopesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIOutputScope
     */
    select?: AIOutputScopeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIOutputScope
     */
    omit?: AIOutputScopeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIOutputScopeInclude<ExtArgs> | null
    where?: AIOutputScopeWhereInput
    orderBy?: AIOutputScopeOrderByWithRelationInput | AIOutputScopeOrderByWithRelationInput[]
    cursor?: AIOutputScopeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIOutputScopeScalarFieldEnum | AIOutputScopeScalarFieldEnum[]
  }

  /**
   * County.sourceLinks
   */
  export type County$sourceLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceDocumentLink
     */
    select?: SourceDocumentLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceDocumentLink
     */
    omit?: SourceDocumentLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceDocumentLinkInclude<ExtArgs> | null
    where?: SourceDocumentLinkWhereInput
    orderBy?: SourceDocumentLinkOrderByWithRelationInput | SourceDocumentLinkOrderByWithRelationInput[]
    cursor?: SourceDocumentLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SourceDocumentLinkScalarFieldEnum | SourceDocumentLinkScalarFieldEnum[]
  }

  /**
   * County without action
   */
  export type CountyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the County
     */
    select?: CountySelect<ExtArgs> | null
    /**
     * Omit specific fields from the County
     */
    omit?: CountyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountyInclude<ExtArgs> | null
  }


  /**
   * Model Issue
   */

  export type AggregateIssue = {
    _count: IssueCountAggregateOutputType | null
    _min: IssueMinAggregateOutputType | null
    _max: IssueMaxAggregateOutputType | null
  }

  export type IssueMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    summary: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IssueMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    summary: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IssueCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    summary: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IssueMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    summary?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IssueMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    summary?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IssueCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    summary?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IssueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Issue to aggregate.
     */
    where?: IssueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Issues to fetch.
     */
    orderBy?: IssueOrderByWithRelationInput | IssueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IssueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Issues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Issues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Issues
    **/
    _count?: true | IssueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IssueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IssueMaxAggregateInputType
  }

  export type GetIssueAggregateType<T extends IssueAggregateArgs> = {
        [P in keyof T & keyof AggregateIssue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIssue[P]>
      : GetScalarType<T[P], AggregateIssue[P]>
  }




  export type IssueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IssueWhereInput
    orderBy?: IssueOrderByWithAggregationInput | IssueOrderByWithAggregationInput[]
    by: IssueScalarFieldEnum[] | IssueScalarFieldEnum
    having?: IssueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IssueCountAggregateInputType | true
    _min?: IssueMinAggregateInputType
    _max?: IssueMaxAggregateInputType
  }

  export type IssueGroupByOutputType = {
    id: string
    name: string
    slug: string
    summary: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: IssueCountAggregateOutputType | null
    _min: IssueMinAggregateOutputType | null
    _max: IssueMaxAggregateOutputType | null
  }

  type GetIssueGroupByPayload<T extends IssueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IssueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IssueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IssueGroupByOutputType[P]>
            : GetScalarType<T[P], IssueGroupByOutputType[P]>
        }
      >
    >


  export type IssueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    summary?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    countyIssues?: boolean | Issue$countyIssuesArgs<ExtArgs>
    blueprintSections?: boolean | Issue$blueprintSectionsArgs<ExtArgs>
    quotes?: boolean | Issue$quotesArgs<ExtArgs>
    assets?: boolean | Issue$assetsArgs<ExtArgs>
    aiOutputScopes?: boolean | Issue$aiOutputScopesArgs<ExtArgs>
    sourceLinks?: boolean | Issue$sourceLinksArgs<ExtArgs>
    _count?: boolean | IssueCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["issue"]>

  export type IssueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    summary?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["issue"]>

  export type IssueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    summary?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["issue"]>

  export type IssueSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    summary?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IssueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "summary" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["issue"]>
  export type IssueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    countyIssues?: boolean | Issue$countyIssuesArgs<ExtArgs>
    blueprintSections?: boolean | Issue$blueprintSectionsArgs<ExtArgs>
    quotes?: boolean | Issue$quotesArgs<ExtArgs>
    assets?: boolean | Issue$assetsArgs<ExtArgs>
    aiOutputScopes?: boolean | Issue$aiOutputScopesArgs<ExtArgs>
    sourceLinks?: boolean | Issue$sourceLinksArgs<ExtArgs>
    _count?: boolean | IssueCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type IssueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type IssueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $IssuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Issue"
    objects: {
      countyIssues: Prisma.$CountyIssuePayload<ExtArgs>[]
      blueprintSections: Prisma.$BlueprintSectionPayload<ExtArgs>[]
      quotes: Prisma.$QuotePayload<ExtArgs>[]
      assets: Prisma.$AssetPayload<ExtArgs>[]
      aiOutputScopes: Prisma.$AIOutputScopePayload<ExtArgs>[]
      sourceLinks: Prisma.$SourceDocumentLinkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      summary: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["issue"]>
    composites: {}
  }

  type IssueGetPayload<S extends boolean | null | undefined | IssueDefaultArgs> = $Result.GetResult<Prisma.$IssuePayload, S>

  type IssueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IssueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IssueCountAggregateInputType | true
    }

  export interface IssueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Issue'], meta: { name: 'Issue' } }
    /**
     * Find zero or one Issue that matches the filter.
     * @param {IssueFindUniqueArgs} args - Arguments to find a Issue
     * @example
     * // Get one Issue
     * const issue = await prisma.issue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IssueFindUniqueArgs>(args: SelectSubset<T, IssueFindUniqueArgs<ExtArgs>>): Prisma__IssueClient<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Issue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IssueFindUniqueOrThrowArgs} args - Arguments to find a Issue
     * @example
     * // Get one Issue
     * const issue = await prisma.issue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IssueFindUniqueOrThrowArgs>(args: SelectSubset<T, IssueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IssueClient<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Issue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IssueFindFirstArgs} args - Arguments to find a Issue
     * @example
     * // Get one Issue
     * const issue = await prisma.issue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IssueFindFirstArgs>(args?: SelectSubset<T, IssueFindFirstArgs<ExtArgs>>): Prisma__IssueClient<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Issue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IssueFindFirstOrThrowArgs} args - Arguments to find a Issue
     * @example
     * // Get one Issue
     * const issue = await prisma.issue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IssueFindFirstOrThrowArgs>(args?: SelectSubset<T, IssueFindFirstOrThrowArgs<ExtArgs>>): Prisma__IssueClient<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Issues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IssueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Issues
     * const issues = await prisma.issue.findMany()
     * 
     * // Get first 10 Issues
     * const issues = await prisma.issue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const issueWithIdOnly = await prisma.issue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IssueFindManyArgs>(args?: SelectSubset<T, IssueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Issue.
     * @param {IssueCreateArgs} args - Arguments to create a Issue.
     * @example
     * // Create one Issue
     * const Issue = await prisma.issue.create({
     *   data: {
     *     // ... data to create a Issue
     *   }
     * })
     * 
     */
    create<T extends IssueCreateArgs>(args: SelectSubset<T, IssueCreateArgs<ExtArgs>>): Prisma__IssueClient<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Issues.
     * @param {IssueCreateManyArgs} args - Arguments to create many Issues.
     * @example
     * // Create many Issues
     * const issue = await prisma.issue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IssueCreateManyArgs>(args?: SelectSubset<T, IssueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Issues and returns the data saved in the database.
     * @param {IssueCreateManyAndReturnArgs} args - Arguments to create many Issues.
     * @example
     * // Create many Issues
     * const issue = await prisma.issue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Issues and only return the `id`
     * const issueWithIdOnly = await prisma.issue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IssueCreateManyAndReturnArgs>(args?: SelectSubset<T, IssueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Issue.
     * @param {IssueDeleteArgs} args - Arguments to delete one Issue.
     * @example
     * // Delete one Issue
     * const Issue = await prisma.issue.delete({
     *   where: {
     *     // ... filter to delete one Issue
     *   }
     * })
     * 
     */
    delete<T extends IssueDeleteArgs>(args: SelectSubset<T, IssueDeleteArgs<ExtArgs>>): Prisma__IssueClient<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Issue.
     * @param {IssueUpdateArgs} args - Arguments to update one Issue.
     * @example
     * // Update one Issue
     * const issue = await prisma.issue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IssueUpdateArgs>(args: SelectSubset<T, IssueUpdateArgs<ExtArgs>>): Prisma__IssueClient<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Issues.
     * @param {IssueDeleteManyArgs} args - Arguments to filter Issues to delete.
     * @example
     * // Delete a few Issues
     * const { count } = await prisma.issue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IssueDeleteManyArgs>(args?: SelectSubset<T, IssueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Issues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IssueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Issues
     * const issue = await prisma.issue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IssueUpdateManyArgs>(args: SelectSubset<T, IssueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Issues and returns the data updated in the database.
     * @param {IssueUpdateManyAndReturnArgs} args - Arguments to update many Issues.
     * @example
     * // Update many Issues
     * const issue = await prisma.issue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Issues and only return the `id`
     * const issueWithIdOnly = await prisma.issue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IssueUpdateManyAndReturnArgs>(args: SelectSubset<T, IssueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Issue.
     * @param {IssueUpsertArgs} args - Arguments to update or create a Issue.
     * @example
     * // Update or create a Issue
     * const issue = await prisma.issue.upsert({
     *   create: {
     *     // ... data to create a Issue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Issue we want to update
     *   }
     * })
     */
    upsert<T extends IssueUpsertArgs>(args: SelectSubset<T, IssueUpsertArgs<ExtArgs>>): Prisma__IssueClient<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Issues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IssueCountArgs} args - Arguments to filter Issues to count.
     * @example
     * // Count the number of Issues
     * const count = await prisma.issue.count({
     *   where: {
     *     // ... the filter for the Issues we want to count
     *   }
     * })
    **/
    count<T extends IssueCountArgs>(
      args?: Subset<T, IssueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IssueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Issue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IssueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IssueAggregateArgs>(args: Subset<T, IssueAggregateArgs>): Prisma.PrismaPromise<GetIssueAggregateType<T>>

    /**
     * Group by Issue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IssueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IssueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IssueGroupByArgs['orderBy'] }
        : { orderBy?: IssueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IssueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIssueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Issue model
   */
  readonly fields: IssueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Issue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IssueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    countyIssues<T extends Issue$countyIssuesArgs<ExtArgs> = {}>(args?: Subset<T, Issue$countyIssuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountyIssuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    blueprintSections<T extends Issue$blueprintSectionsArgs<ExtArgs> = {}>(args?: Subset<T, Issue$blueprintSectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlueprintSectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quotes<T extends Issue$quotesArgs<ExtArgs> = {}>(args?: Subset<T, Issue$quotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assets<T extends Issue$assetsArgs<ExtArgs> = {}>(args?: Subset<T, Issue$assetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    aiOutputScopes<T extends Issue$aiOutputScopesArgs<ExtArgs> = {}>(args?: Subset<T, Issue$aiOutputScopesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIOutputScopePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sourceLinks<T extends Issue$sourceLinksArgs<ExtArgs> = {}>(args?: Subset<T, Issue$sourceLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourceDocumentLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Issue model
   */
  interface IssueFieldRefs {
    readonly id: FieldRef<"Issue", 'String'>
    readonly name: FieldRef<"Issue", 'String'>
    readonly slug: FieldRef<"Issue", 'String'>
    readonly summary: FieldRef<"Issue", 'String'>
    readonly isActive: FieldRef<"Issue", 'Boolean'>
    readonly createdAt: FieldRef<"Issue", 'DateTime'>
    readonly updatedAt: FieldRef<"Issue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Issue findUnique
   */
  export type IssueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Issue
     */
    omit?: IssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueInclude<ExtArgs> | null
    /**
     * Filter, which Issue to fetch.
     */
    where: IssueWhereUniqueInput
  }

  /**
   * Issue findUniqueOrThrow
   */
  export type IssueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Issue
     */
    omit?: IssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueInclude<ExtArgs> | null
    /**
     * Filter, which Issue to fetch.
     */
    where: IssueWhereUniqueInput
  }

  /**
   * Issue findFirst
   */
  export type IssueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Issue
     */
    omit?: IssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueInclude<ExtArgs> | null
    /**
     * Filter, which Issue to fetch.
     */
    where?: IssueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Issues to fetch.
     */
    orderBy?: IssueOrderByWithRelationInput | IssueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Issues.
     */
    cursor?: IssueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Issues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Issues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Issues.
     */
    distinct?: IssueScalarFieldEnum | IssueScalarFieldEnum[]
  }

  /**
   * Issue findFirstOrThrow
   */
  export type IssueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Issue
     */
    omit?: IssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueInclude<ExtArgs> | null
    /**
     * Filter, which Issue to fetch.
     */
    where?: IssueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Issues to fetch.
     */
    orderBy?: IssueOrderByWithRelationInput | IssueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Issues.
     */
    cursor?: IssueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Issues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Issues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Issues.
     */
    distinct?: IssueScalarFieldEnum | IssueScalarFieldEnum[]
  }

  /**
   * Issue findMany
   */
  export type IssueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Issue
     */
    omit?: IssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueInclude<ExtArgs> | null
    /**
     * Filter, which Issues to fetch.
     */
    where?: IssueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Issues to fetch.
     */
    orderBy?: IssueOrderByWithRelationInput | IssueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Issues.
     */
    cursor?: IssueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Issues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Issues.
     */
    skip?: number
    distinct?: IssueScalarFieldEnum | IssueScalarFieldEnum[]
  }

  /**
   * Issue create
   */
  export type IssueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Issue
     */
    omit?: IssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueInclude<ExtArgs> | null
    /**
     * The data needed to create a Issue.
     */
    data: XOR<IssueCreateInput, IssueUncheckedCreateInput>
  }

  /**
   * Issue createMany
   */
  export type IssueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Issues.
     */
    data: IssueCreateManyInput | IssueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Issue createManyAndReturn
   */
  export type IssueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Issue
     */
    omit?: IssueOmit<ExtArgs> | null
    /**
     * The data used to create many Issues.
     */
    data: IssueCreateManyInput | IssueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Issue update
   */
  export type IssueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Issue
     */
    omit?: IssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueInclude<ExtArgs> | null
    /**
     * The data needed to update a Issue.
     */
    data: XOR<IssueUpdateInput, IssueUncheckedUpdateInput>
    /**
     * Choose, which Issue to update.
     */
    where: IssueWhereUniqueInput
  }

  /**
   * Issue updateMany
   */
  export type IssueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Issues.
     */
    data: XOR<IssueUpdateManyMutationInput, IssueUncheckedUpdateManyInput>
    /**
     * Filter which Issues to update
     */
    where?: IssueWhereInput
    /**
     * Limit how many Issues to update.
     */
    limit?: number
  }

  /**
   * Issue updateManyAndReturn
   */
  export type IssueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Issue
     */
    omit?: IssueOmit<ExtArgs> | null
    /**
     * The data used to update Issues.
     */
    data: XOR<IssueUpdateManyMutationInput, IssueUncheckedUpdateManyInput>
    /**
     * Filter which Issues to update
     */
    where?: IssueWhereInput
    /**
     * Limit how many Issues to update.
     */
    limit?: number
  }

  /**
   * Issue upsert
   */
  export type IssueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Issue
     */
    omit?: IssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueInclude<ExtArgs> | null
    /**
     * The filter to search for the Issue to update in case it exists.
     */
    where: IssueWhereUniqueInput
    /**
     * In case the Issue found by the `where` argument doesn't exist, create a new Issue with this data.
     */
    create: XOR<IssueCreateInput, IssueUncheckedCreateInput>
    /**
     * In case the Issue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IssueUpdateInput, IssueUncheckedUpdateInput>
  }

  /**
   * Issue delete
   */
  export type IssueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Issue
     */
    omit?: IssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueInclude<ExtArgs> | null
    /**
     * Filter which Issue to delete.
     */
    where: IssueWhereUniqueInput
  }

  /**
   * Issue deleteMany
   */
  export type IssueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Issues to delete
     */
    where?: IssueWhereInput
    /**
     * Limit how many Issues to delete.
     */
    limit?: number
  }

  /**
   * Issue.countyIssues
   */
  export type Issue$countyIssuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountyIssue
     */
    select?: CountyIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountyIssue
     */
    omit?: CountyIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountyIssueInclude<ExtArgs> | null
    where?: CountyIssueWhereInput
    orderBy?: CountyIssueOrderByWithRelationInput | CountyIssueOrderByWithRelationInput[]
    cursor?: CountyIssueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CountyIssueScalarFieldEnum | CountyIssueScalarFieldEnum[]
  }

  /**
   * Issue.blueprintSections
   */
  export type Issue$blueprintSectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlueprintSection
     */
    select?: BlueprintSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlueprintSection
     */
    omit?: BlueprintSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlueprintSectionInclude<ExtArgs> | null
    where?: BlueprintSectionWhereInput
    orderBy?: BlueprintSectionOrderByWithRelationInput | BlueprintSectionOrderByWithRelationInput[]
    cursor?: BlueprintSectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlueprintSectionScalarFieldEnum | BlueprintSectionScalarFieldEnum[]
  }

  /**
   * Issue.quotes
   */
  export type Issue$quotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    where?: QuoteWhereInput
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    cursor?: QuoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuoteScalarFieldEnum | QuoteScalarFieldEnum[]
  }

  /**
   * Issue.assets
   */
  export type Issue$assetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    where?: AssetWhereInput
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    cursor?: AssetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Issue.aiOutputScopes
   */
  export type Issue$aiOutputScopesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIOutputScope
     */
    select?: AIOutputScopeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIOutputScope
     */
    omit?: AIOutputScopeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIOutputScopeInclude<ExtArgs> | null
    where?: AIOutputScopeWhereInput
    orderBy?: AIOutputScopeOrderByWithRelationInput | AIOutputScopeOrderByWithRelationInput[]
    cursor?: AIOutputScopeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIOutputScopeScalarFieldEnum | AIOutputScopeScalarFieldEnum[]
  }

  /**
   * Issue.sourceLinks
   */
  export type Issue$sourceLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceDocumentLink
     */
    select?: SourceDocumentLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceDocumentLink
     */
    omit?: SourceDocumentLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceDocumentLinkInclude<ExtArgs> | null
    where?: SourceDocumentLinkWhereInput
    orderBy?: SourceDocumentLinkOrderByWithRelationInput | SourceDocumentLinkOrderByWithRelationInput[]
    cursor?: SourceDocumentLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SourceDocumentLinkScalarFieldEnum | SourceDocumentLinkScalarFieldEnum[]
  }

  /**
   * Issue without action
   */
  export type IssueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Issue
     */
    omit?: IssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueInclude<ExtArgs> | null
  }


  /**
   * Model CountyIssue
   */

  export type AggregateCountyIssue = {
    _count: CountyIssueCountAggregateOutputType | null
    _avg: CountyIssueAvgAggregateOutputType | null
    _sum: CountyIssueSumAggregateOutputType | null
    _min: CountyIssueMinAggregateOutputType | null
    _max: CountyIssueMaxAggregateOutputType | null
  }

  export type CountyIssueAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type CountyIssueSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type CountyIssueMinAggregateOutputType = {
    id: string | null
    countyId: string | null
    issueId: string | null
    featured: boolean | null
    sortOrder: number | null
    createdAt: Date | null
  }

  export type CountyIssueMaxAggregateOutputType = {
    id: string | null
    countyId: string | null
    issueId: string | null
    featured: boolean | null
    sortOrder: number | null
    createdAt: Date | null
  }

  export type CountyIssueCountAggregateOutputType = {
    id: number
    countyId: number
    issueId: number
    featured: number
    sortOrder: number
    createdAt: number
    _all: number
  }


  export type CountyIssueAvgAggregateInputType = {
    sortOrder?: true
  }

  export type CountyIssueSumAggregateInputType = {
    sortOrder?: true
  }

  export type CountyIssueMinAggregateInputType = {
    id?: true
    countyId?: true
    issueId?: true
    featured?: true
    sortOrder?: true
    createdAt?: true
  }

  export type CountyIssueMaxAggregateInputType = {
    id?: true
    countyId?: true
    issueId?: true
    featured?: true
    sortOrder?: true
    createdAt?: true
  }

  export type CountyIssueCountAggregateInputType = {
    id?: true
    countyId?: true
    issueId?: true
    featured?: true
    sortOrder?: true
    createdAt?: true
    _all?: true
  }

  export type CountyIssueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CountyIssue to aggregate.
     */
    where?: CountyIssueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CountyIssues to fetch.
     */
    orderBy?: CountyIssueOrderByWithRelationInput | CountyIssueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CountyIssueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CountyIssues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CountyIssues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CountyIssues
    **/
    _count?: true | CountyIssueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CountyIssueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CountyIssueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CountyIssueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CountyIssueMaxAggregateInputType
  }

  export type GetCountyIssueAggregateType<T extends CountyIssueAggregateArgs> = {
        [P in keyof T & keyof AggregateCountyIssue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCountyIssue[P]>
      : GetScalarType<T[P], AggregateCountyIssue[P]>
  }




  export type CountyIssueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CountyIssueWhereInput
    orderBy?: CountyIssueOrderByWithAggregationInput | CountyIssueOrderByWithAggregationInput[]
    by: CountyIssueScalarFieldEnum[] | CountyIssueScalarFieldEnum
    having?: CountyIssueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CountyIssueCountAggregateInputType | true
    _avg?: CountyIssueAvgAggregateInputType
    _sum?: CountyIssueSumAggregateInputType
    _min?: CountyIssueMinAggregateInputType
    _max?: CountyIssueMaxAggregateInputType
  }

  export type CountyIssueGroupByOutputType = {
    id: string
    countyId: string
    issueId: string
    featured: boolean
    sortOrder: number | null
    createdAt: Date
    _count: CountyIssueCountAggregateOutputType | null
    _avg: CountyIssueAvgAggregateOutputType | null
    _sum: CountyIssueSumAggregateOutputType | null
    _min: CountyIssueMinAggregateOutputType | null
    _max: CountyIssueMaxAggregateOutputType | null
  }

  type GetCountyIssueGroupByPayload<T extends CountyIssueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CountyIssueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CountyIssueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CountyIssueGroupByOutputType[P]>
            : GetScalarType<T[P], CountyIssueGroupByOutputType[P]>
        }
      >
    >


  export type CountyIssueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    countyId?: boolean
    issueId?: boolean
    featured?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    county?: boolean | CountyDefaultArgs<ExtArgs>
    issue?: boolean | IssueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["countyIssue"]>

  export type CountyIssueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    countyId?: boolean
    issueId?: boolean
    featured?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    county?: boolean | CountyDefaultArgs<ExtArgs>
    issue?: boolean | IssueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["countyIssue"]>

  export type CountyIssueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    countyId?: boolean
    issueId?: boolean
    featured?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    county?: boolean | CountyDefaultArgs<ExtArgs>
    issue?: boolean | IssueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["countyIssue"]>

  export type CountyIssueSelectScalar = {
    id?: boolean
    countyId?: boolean
    issueId?: boolean
    featured?: boolean
    sortOrder?: boolean
    createdAt?: boolean
  }

  export type CountyIssueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "countyId" | "issueId" | "featured" | "sortOrder" | "createdAt", ExtArgs["result"]["countyIssue"]>
  export type CountyIssueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    county?: boolean | CountyDefaultArgs<ExtArgs>
    issue?: boolean | IssueDefaultArgs<ExtArgs>
  }
  export type CountyIssueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    county?: boolean | CountyDefaultArgs<ExtArgs>
    issue?: boolean | IssueDefaultArgs<ExtArgs>
  }
  export type CountyIssueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    county?: boolean | CountyDefaultArgs<ExtArgs>
    issue?: boolean | IssueDefaultArgs<ExtArgs>
  }

  export type $CountyIssuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CountyIssue"
    objects: {
      county: Prisma.$CountyPayload<ExtArgs>
      issue: Prisma.$IssuePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      countyId: string
      issueId: string
      featured: boolean
      sortOrder: number | null
      createdAt: Date
    }, ExtArgs["result"]["countyIssue"]>
    composites: {}
  }

  type CountyIssueGetPayload<S extends boolean | null | undefined | CountyIssueDefaultArgs> = $Result.GetResult<Prisma.$CountyIssuePayload, S>

  type CountyIssueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CountyIssueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CountyIssueCountAggregateInputType | true
    }

  export interface CountyIssueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CountyIssue'], meta: { name: 'CountyIssue' } }
    /**
     * Find zero or one CountyIssue that matches the filter.
     * @param {CountyIssueFindUniqueArgs} args - Arguments to find a CountyIssue
     * @example
     * // Get one CountyIssue
     * const countyIssue = await prisma.countyIssue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CountyIssueFindUniqueArgs>(args: SelectSubset<T, CountyIssueFindUniqueArgs<ExtArgs>>): Prisma__CountyIssueClient<$Result.GetResult<Prisma.$CountyIssuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CountyIssue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CountyIssueFindUniqueOrThrowArgs} args - Arguments to find a CountyIssue
     * @example
     * // Get one CountyIssue
     * const countyIssue = await prisma.countyIssue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CountyIssueFindUniqueOrThrowArgs>(args: SelectSubset<T, CountyIssueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CountyIssueClient<$Result.GetResult<Prisma.$CountyIssuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CountyIssue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountyIssueFindFirstArgs} args - Arguments to find a CountyIssue
     * @example
     * // Get one CountyIssue
     * const countyIssue = await prisma.countyIssue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CountyIssueFindFirstArgs>(args?: SelectSubset<T, CountyIssueFindFirstArgs<ExtArgs>>): Prisma__CountyIssueClient<$Result.GetResult<Prisma.$CountyIssuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CountyIssue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountyIssueFindFirstOrThrowArgs} args - Arguments to find a CountyIssue
     * @example
     * // Get one CountyIssue
     * const countyIssue = await prisma.countyIssue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CountyIssueFindFirstOrThrowArgs>(args?: SelectSubset<T, CountyIssueFindFirstOrThrowArgs<ExtArgs>>): Prisma__CountyIssueClient<$Result.GetResult<Prisma.$CountyIssuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CountyIssues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountyIssueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CountyIssues
     * const countyIssues = await prisma.countyIssue.findMany()
     * 
     * // Get first 10 CountyIssues
     * const countyIssues = await prisma.countyIssue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const countyIssueWithIdOnly = await prisma.countyIssue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CountyIssueFindManyArgs>(args?: SelectSubset<T, CountyIssueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountyIssuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CountyIssue.
     * @param {CountyIssueCreateArgs} args - Arguments to create a CountyIssue.
     * @example
     * // Create one CountyIssue
     * const CountyIssue = await prisma.countyIssue.create({
     *   data: {
     *     // ... data to create a CountyIssue
     *   }
     * })
     * 
     */
    create<T extends CountyIssueCreateArgs>(args: SelectSubset<T, CountyIssueCreateArgs<ExtArgs>>): Prisma__CountyIssueClient<$Result.GetResult<Prisma.$CountyIssuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CountyIssues.
     * @param {CountyIssueCreateManyArgs} args - Arguments to create many CountyIssues.
     * @example
     * // Create many CountyIssues
     * const countyIssue = await prisma.countyIssue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CountyIssueCreateManyArgs>(args?: SelectSubset<T, CountyIssueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CountyIssues and returns the data saved in the database.
     * @param {CountyIssueCreateManyAndReturnArgs} args - Arguments to create many CountyIssues.
     * @example
     * // Create many CountyIssues
     * const countyIssue = await prisma.countyIssue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CountyIssues and only return the `id`
     * const countyIssueWithIdOnly = await prisma.countyIssue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CountyIssueCreateManyAndReturnArgs>(args?: SelectSubset<T, CountyIssueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountyIssuePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CountyIssue.
     * @param {CountyIssueDeleteArgs} args - Arguments to delete one CountyIssue.
     * @example
     * // Delete one CountyIssue
     * const CountyIssue = await prisma.countyIssue.delete({
     *   where: {
     *     // ... filter to delete one CountyIssue
     *   }
     * })
     * 
     */
    delete<T extends CountyIssueDeleteArgs>(args: SelectSubset<T, CountyIssueDeleteArgs<ExtArgs>>): Prisma__CountyIssueClient<$Result.GetResult<Prisma.$CountyIssuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CountyIssue.
     * @param {CountyIssueUpdateArgs} args - Arguments to update one CountyIssue.
     * @example
     * // Update one CountyIssue
     * const countyIssue = await prisma.countyIssue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CountyIssueUpdateArgs>(args: SelectSubset<T, CountyIssueUpdateArgs<ExtArgs>>): Prisma__CountyIssueClient<$Result.GetResult<Prisma.$CountyIssuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CountyIssues.
     * @param {CountyIssueDeleteManyArgs} args - Arguments to filter CountyIssues to delete.
     * @example
     * // Delete a few CountyIssues
     * const { count } = await prisma.countyIssue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CountyIssueDeleteManyArgs>(args?: SelectSubset<T, CountyIssueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CountyIssues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountyIssueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CountyIssues
     * const countyIssue = await prisma.countyIssue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CountyIssueUpdateManyArgs>(args: SelectSubset<T, CountyIssueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CountyIssues and returns the data updated in the database.
     * @param {CountyIssueUpdateManyAndReturnArgs} args - Arguments to update many CountyIssues.
     * @example
     * // Update many CountyIssues
     * const countyIssue = await prisma.countyIssue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CountyIssues and only return the `id`
     * const countyIssueWithIdOnly = await prisma.countyIssue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CountyIssueUpdateManyAndReturnArgs>(args: SelectSubset<T, CountyIssueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountyIssuePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CountyIssue.
     * @param {CountyIssueUpsertArgs} args - Arguments to update or create a CountyIssue.
     * @example
     * // Update or create a CountyIssue
     * const countyIssue = await prisma.countyIssue.upsert({
     *   create: {
     *     // ... data to create a CountyIssue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CountyIssue we want to update
     *   }
     * })
     */
    upsert<T extends CountyIssueUpsertArgs>(args: SelectSubset<T, CountyIssueUpsertArgs<ExtArgs>>): Prisma__CountyIssueClient<$Result.GetResult<Prisma.$CountyIssuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CountyIssues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountyIssueCountArgs} args - Arguments to filter CountyIssues to count.
     * @example
     * // Count the number of CountyIssues
     * const count = await prisma.countyIssue.count({
     *   where: {
     *     // ... the filter for the CountyIssues we want to count
     *   }
     * })
    **/
    count<T extends CountyIssueCountArgs>(
      args?: Subset<T, CountyIssueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CountyIssueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CountyIssue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountyIssueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CountyIssueAggregateArgs>(args: Subset<T, CountyIssueAggregateArgs>): Prisma.PrismaPromise<GetCountyIssueAggregateType<T>>

    /**
     * Group by CountyIssue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountyIssueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CountyIssueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CountyIssueGroupByArgs['orderBy'] }
        : { orderBy?: CountyIssueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CountyIssueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCountyIssueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CountyIssue model
   */
  readonly fields: CountyIssueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CountyIssue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CountyIssueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    county<T extends CountyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CountyDefaultArgs<ExtArgs>>): Prisma__CountyClient<$Result.GetResult<Prisma.$CountyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    issue<T extends IssueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IssueDefaultArgs<ExtArgs>>): Prisma__IssueClient<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CountyIssue model
   */
  interface CountyIssueFieldRefs {
    readonly id: FieldRef<"CountyIssue", 'String'>
    readonly countyId: FieldRef<"CountyIssue", 'String'>
    readonly issueId: FieldRef<"CountyIssue", 'String'>
    readonly featured: FieldRef<"CountyIssue", 'Boolean'>
    readonly sortOrder: FieldRef<"CountyIssue", 'Int'>
    readonly createdAt: FieldRef<"CountyIssue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CountyIssue findUnique
   */
  export type CountyIssueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountyIssue
     */
    select?: CountyIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountyIssue
     */
    omit?: CountyIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountyIssueInclude<ExtArgs> | null
    /**
     * Filter, which CountyIssue to fetch.
     */
    where: CountyIssueWhereUniqueInput
  }

  /**
   * CountyIssue findUniqueOrThrow
   */
  export type CountyIssueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountyIssue
     */
    select?: CountyIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountyIssue
     */
    omit?: CountyIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountyIssueInclude<ExtArgs> | null
    /**
     * Filter, which CountyIssue to fetch.
     */
    where: CountyIssueWhereUniqueInput
  }

  /**
   * CountyIssue findFirst
   */
  export type CountyIssueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountyIssue
     */
    select?: CountyIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountyIssue
     */
    omit?: CountyIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountyIssueInclude<ExtArgs> | null
    /**
     * Filter, which CountyIssue to fetch.
     */
    where?: CountyIssueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CountyIssues to fetch.
     */
    orderBy?: CountyIssueOrderByWithRelationInput | CountyIssueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CountyIssues.
     */
    cursor?: CountyIssueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CountyIssues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CountyIssues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CountyIssues.
     */
    distinct?: CountyIssueScalarFieldEnum | CountyIssueScalarFieldEnum[]
  }

  /**
   * CountyIssue findFirstOrThrow
   */
  export type CountyIssueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountyIssue
     */
    select?: CountyIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountyIssue
     */
    omit?: CountyIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountyIssueInclude<ExtArgs> | null
    /**
     * Filter, which CountyIssue to fetch.
     */
    where?: CountyIssueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CountyIssues to fetch.
     */
    orderBy?: CountyIssueOrderByWithRelationInput | CountyIssueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CountyIssues.
     */
    cursor?: CountyIssueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CountyIssues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CountyIssues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CountyIssues.
     */
    distinct?: CountyIssueScalarFieldEnum | CountyIssueScalarFieldEnum[]
  }

  /**
   * CountyIssue findMany
   */
  export type CountyIssueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountyIssue
     */
    select?: CountyIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountyIssue
     */
    omit?: CountyIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountyIssueInclude<ExtArgs> | null
    /**
     * Filter, which CountyIssues to fetch.
     */
    where?: CountyIssueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CountyIssues to fetch.
     */
    orderBy?: CountyIssueOrderByWithRelationInput | CountyIssueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CountyIssues.
     */
    cursor?: CountyIssueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CountyIssues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CountyIssues.
     */
    skip?: number
    distinct?: CountyIssueScalarFieldEnum | CountyIssueScalarFieldEnum[]
  }

  /**
   * CountyIssue create
   */
  export type CountyIssueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountyIssue
     */
    select?: CountyIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountyIssue
     */
    omit?: CountyIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountyIssueInclude<ExtArgs> | null
    /**
     * The data needed to create a CountyIssue.
     */
    data: XOR<CountyIssueCreateInput, CountyIssueUncheckedCreateInput>
  }

  /**
   * CountyIssue createMany
   */
  export type CountyIssueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CountyIssues.
     */
    data: CountyIssueCreateManyInput | CountyIssueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CountyIssue createManyAndReturn
   */
  export type CountyIssueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountyIssue
     */
    select?: CountyIssueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CountyIssue
     */
    omit?: CountyIssueOmit<ExtArgs> | null
    /**
     * The data used to create many CountyIssues.
     */
    data: CountyIssueCreateManyInput | CountyIssueCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountyIssueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CountyIssue update
   */
  export type CountyIssueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountyIssue
     */
    select?: CountyIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountyIssue
     */
    omit?: CountyIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountyIssueInclude<ExtArgs> | null
    /**
     * The data needed to update a CountyIssue.
     */
    data: XOR<CountyIssueUpdateInput, CountyIssueUncheckedUpdateInput>
    /**
     * Choose, which CountyIssue to update.
     */
    where: CountyIssueWhereUniqueInput
  }

  /**
   * CountyIssue updateMany
   */
  export type CountyIssueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CountyIssues.
     */
    data: XOR<CountyIssueUpdateManyMutationInput, CountyIssueUncheckedUpdateManyInput>
    /**
     * Filter which CountyIssues to update
     */
    where?: CountyIssueWhereInput
    /**
     * Limit how many CountyIssues to update.
     */
    limit?: number
  }

  /**
   * CountyIssue updateManyAndReturn
   */
  export type CountyIssueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountyIssue
     */
    select?: CountyIssueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CountyIssue
     */
    omit?: CountyIssueOmit<ExtArgs> | null
    /**
     * The data used to update CountyIssues.
     */
    data: XOR<CountyIssueUpdateManyMutationInput, CountyIssueUncheckedUpdateManyInput>
    /**
     * Filter which CountyIssues to update
     */
    where?: CountyIssueWhereInput
    /**
     * Limit how many CountyIssues to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountyIssueIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CountyIssue upsert
   */
  export type CountyIssueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountyIssue
     */
    select?: CountyIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountyIssue
     */
    omit?: CountyIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountyIssueInclude<ExtArgs> | null
    /**
     * The filter to search for the CountyIssue to update in case it exists.
     */
    where: CountyIssueWhereUniqueInput
    /**
     * In case the CountyIssue found by the `where` argument doesn't exist, create a new CountyIssue with this data.
     */
    create: XOR<CountyIssueCreateInput, CountyIssueUncheckedCreateInput>
    /**
     * In case the CountyIssue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CountyIssueUpdateInput, CountyIssueUncheckedUpdateInput>
  }

  /**
   * CountyIssue delete
   */
  export type CountyIssueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountyIssue
     */
    select?: CountyIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountyIssue
     */
    omit?: CountyIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountyIssueInclude<ExtArgs> | null
    /**
     * Filter which CountyIssue to delete.
     */
    where: CountyIssueWhereUniqueInput
  }

  /**
   * CountyIssue deleteMany
   */
  export type CountyIssueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CountyIssues to delete
     */
    where?: CountyIssueWhereInput
    /**
     * Limit how many CountyIssues to delete.
     */
    limit?: number
  }

  /**
   * CountyIssue without action
   */
  export type CountyIssueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountyIssue
     */
    select?: CountyIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountyIssue
     */
    omit?: CountyIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountyIssueInclude<ExtArgs> | null
  }


  /**
   * Model BlueprintSection
   */

  export type AggregateBlueprintSection = {
    _count: BlueprintSectionCountAggregateOutputType | null
    _avg: BlueprintSectionAvgAggregateOutputType | null
    _sum: BlueprintSectionSumAggregateOutputType | null
    _min: BlueprintSectionMinAggregateOutputType | null
    _max: BlueprintSectionMaxAggregateOutputType | null
  }

  export type BlueprintSectionAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type BlueprintSectionSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type BlueprintSectionMinAggregateOutputType = {
    id: string | null
    slug: string | null
    title: string | null
    bodyMd: string | null
    countyId: string | null
    issueId: string | null
    sortOrder: number | null
    isPinned: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlueprintSectionMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    title: string | null
    bodyMd: string | null
    countyId: string | null
    issueId: string | null
    sortOrder: number | null
    isPinned: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlueprintSectionCountAggregateOutputType = {
    id: number
    slug: number
    title: number
    bodyMd: number
    countyId: number
    issueId: number
    sortOrder: number
    isPinned: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BlueprintSectionAvgAggregateInputType = {
    sortOrder?: true
  }

  export type BlueprintSectionSumAggregateInputType = {
    sortOrder?: true
  }

  export type BlueprintSectionMinAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    bodyMd?: true
    countyId?: true
    issueId?: true
    sortOrder?: true
    isPinned?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlueprintSectionMaxAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    bodyMd?: true
    countyId?: true
    issueId?: true
    sortOrder?: true
    isPinned?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlueprintSectionCountAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    bodyMd?: true
    countyId?: true
    issueId?: true
    sortOrder?: true
    isPinned?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BlueprintSectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlueprintSection to aggregate.
     */
    where?: BlueprintSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlueprintSections to fetch.
     */
    orderBy?: BlueprintSectionOrderByWithRelationInput | BlueprintSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlueprintSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlueprintSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlueprintSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlueprintSections
    **/
    _count?: true | BlueprintSectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlueprintSectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlueprintSectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlueprintSectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlueprintSectionMaxAggregateInputType
  }

  export type GetBlueprintSectionAggregateType<T extends BlueprintSectionAggregateArgs> = {
        [P in keyof T & keyof AggregateBlueprintSection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlueprintSection[P]>
      : GetScalarType<T[P], AggregateBlueprintSection[P]>
  }




  export type BlueprintSectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlueprintSectionWhereInput
    orderBy?: BlueprintSectionOrderByWithAggregationInput | BlueprintSectionOrderByWithAggregationInput[]
    by: BlueprintSectionScalarFieldEnum[] | BlueprintSectionScalarFieldEnum
    having?: BlueprintSectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlueprintSectionCountAggregateInputType | true
    _avg?: BlueprintSectionAvgAggregateInputType
    _sum?: BlueprintSectionSumAggregateInputType
    _min?: BlueprintSectionMinAggregateInputType
    _max?: BlueprintSectionMaxAggregateInputType
  }

  export type BlueprintSectionGroupByOutputType = {
    id: string
    slug: string
    title: string
    bodyMd: string
    countyId: string | null
    issueId: string | null
    sortOrder: number | null
    isPinned: boolean
    createdAt: Date
    updatedAt: Date
    _count: BlueprintSectionCountAggregateOutputType | null
    _avg: BlueprintSectionAvgAggregateOutputType | null
    _sum: BlueprintSectionSumAggregateOutputType | null
    _min: BlueprintSectionMinAggregateOutputType | null
    _max: BlueprintSectionMaxAggregateOutputType | null
  }

  type GetBlueprintSectionGroupByPayload<T extends BlueprintSectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlueprintSectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlueprintSectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlueprintSectionGroupByOutputType[P]>
            : GetScalarType<T[P], BlueprintSectionGroupByOutputType[P]>
        }
      >
    >


  export type BlueprintSectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    title?: boolean
    bodyMd?: boolean
    countyId?: boolean
    issueId?: boolean
    sortOrder?: boolean
    isPinned?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    county?: boolean | BlueprintSection$countyArgs<ExtArgs>
    issue?: boolean | BlueprintSection$issueArgs<ExtArgs>
    sourceLinks?: boolean | BlueprintSection$sourceLinksArgs<ExtArgs>
    _count?: boolean | BlueprintSectionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blueprintSection"]>

  export type BlueprintSectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    title?: boolean
    bodyMd?: boolean
    countyId?: boolean
    issueId?: boolean
    sortOrder?: boolean
    isPinned?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    county?: boolean | BlueprintSection$countyArgs<ExtArgs>
    issue?: boolean | BlueprintSection$issueArgs<ExtArgs>
  }, ExtArgs["result"]["blueprintSection"]>

  export type BlueprintSectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    title?: boolean
    bodyMd?: boolean
    countyId?: boolean
    issueId?: boolean
    sortOrder?: boolean
    isPinned?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    county?: boolean | BlueprintSection$countyArgs<ExtArgs>
    issue?: boolean | BlueprintSection$issueArgs<ExtArgs>
  }, ExtArgs["result"]["blueprintSection"]>

  export type BlueprintSectionSelectScalar = {
    id?: boolean
    slug?: boolean
    title?: boolean
    bodyMd?: boolean
    countyId?: boolean
    issueId?: boolean
    sortOrder?: boolean
    isPinned?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BlueprintSectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "slug" | "title" | "bodyMd" | "countyId" | "issueId" | "sortOrder" | "isPinned" | "createdAt" | "updatedAt", ExtArgs["result"]["blueprintSection"]>
  export type BlueprintSectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    county?: boolean | BlueprintSection$countyArgs<ExtArgs>
    issue?: boolean | BlueprintSection$issueArgs<ExtArgs>
    sourceLinks?: boolean | BlueprintSection$sourceLinksArgs<ExtArgs>
    _count?: boolean | BlueprintSectionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BlueprintSectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    county?: boolean | BlueprintSection$countyArgs<ExtArgs>
    issue?: boolean | BlueprintSection$issueArgs<ExtArgs>
  }
  export type BlueprintSectionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    county?: boolean | BlueprintSection$countyArgs<ExtArgs>
    issue?: boolean | BlueprintSection$issueArgs<ExtArgs>
  }

  export type $BlueprintSectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlueprintSection"
    objects: {
      county: Prisma.$CountyPayload<ExtArgs> | null
      issue: Prisma.$IssuePayload<ExtArgs> | null
      sourceLinks: Prisma.$SourceDocumentLinkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slug: string
      title: string
      bodyMd: string
      countyId: string | null
      issueId: string | null
      sortOrder: number | null
      isPinned: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["blueprintSection"]>
    composites: {}
  }

  type BlueprintSectionGetPayload<S extends boolean | null | undefined | BlueprintSectionDefaultArgs> = $Result.GetResult<Prisma.$BlueprintSectionPayload, S>

  type BlueprintSectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BlueprintSectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlueprintSectionCountAggregateInputType | true
    }

  export interface BlueprintSectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlueprintSection'], meta: { name: 'BlueprintSection' } }
    /**
     * Find zero or one BlueprintSection that matches the filter.
     * @param {BlueprintSectionFindUniqueArgs} args - Arguments to find a BlueprintSection
     * @example
     * // Get one BlueprintSection
     * const blueprintSection = await prisma.blueprintSection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlueprintSectionFindUniqueArgs>(args: SelectSubset<T, BlueprintSectionFindUniqueArgs<ExtArgs>>): Prisma__BlueprintSectionClient<$Result.GetResult<Prisma.$BlueprintSectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BlueprintSection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BlueprintSectionFindUniqueOrThrowArgs} args - Arguments to find a BlueprintSection
     * @example
     * // Get one BlueprintSection
     * const blueprintSection = await prisma.blueprintSection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlueprintSectionFindUniqueOrThrowArgs>(args: SelectSubset<T, BlueprintSectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlueprintSectionClient<$Result.GetResult<Prisma.$BlueprintSectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlueprintSection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlueprintSectionFindFirstArgs} args - Arguments to find a BlueprintSection
     * @example
     * // Get one BlueprintSection
     * const blueprintSection = await prisma.blueprintSection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlueprintSectionFindFirstArgs>(args?: SelectSubset<T, BlueprintSectionFindFirstArgs<ExtArgs>>): Prisma__BlueprintSectionClient<$Result.GetResult<Prisma.$BlueprintSectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlueprintSection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlueprintSectionFindFirstOrThrowArgs} args - Arguments to find a BlueprintSection
     * @example
     * // Get one BlueprintSection
     * const blueprintSection = await prisma.blueprintSection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlueprintSectionFindFirstOrThrowArgs>(args?: SelectSubset<T, BlueprintSectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlueprintSectionClient<$Result.GetResult<Prisma.$BlueprintSectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BlueprintSections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlueprintSectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlueprintSections
     * const blueprintSections = await prisma.blueprintSection.findMany()
     * 
     * // Get first 10 BlueprintSections
     * const blueprintSections = await prisma.blueprintSection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blueprintSectionWithIdOnly = await prisma.blueprintSection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlueprintSectionFindManyArgs>(args?: SelectSubset<T, BlueprintSectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlueprintSectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BlueprintSection.
     * @param {BlueprintSectionCreateArgs} args - Arguments to create a BlueprintSection.
     * @example
     * // Create one BlueprintSection
     * const BlueprintSection = await prisma.blueprintSection.create({
     *   data: {
     *     // ... data to create a BlueprintSection
     *   }
     * })
     * 
     */
    create<T extends BlueprintSectionCreateArgs>(args: SelectSubset<T, BlueprintSectionCreateArgs<ExtArgs>>): Prisma__BlueprintSectionClient<$Result.GetResult<Prisma.$BlueprintSectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BlueprintSections.
     * @param {BlueprintSectionCreateManyArgs} args - Arguments to create many BlueprintSections.
     * @example
     * // Create many BlueprintSections
     * const blueprintSection = await prisma.blueprintSection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlueprintSectionCreateManyArgs>(args?: SelectSubset<T, BlueprintSectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlueprintSections and returns the data saved in the database.
     * @param {BlueprintSectionCreateManyAndReturnArgs} args - Arguments to create many BlueprintSections.
     * @example
     * // Create many BlueprintSections
     * const blueprintSection = await prisma.blueprintSection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlueprintSections and only return the `id`
     * const blueprintSectionWithIdOnly = await prisma.blueprintSection.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlueprintSectionCreateManyAndReturnArgs>(args?: SelectSubset<T, BlueprintSectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlueprintSectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BlueprintSection.
     * @param {BlueprintSectionDeleteArgs} args - Arguments to delete one BlueprintSection.
     * @example
     * // Delete one BlueprintSection
     * const BlueprintSection = await prisma.blueprintSection.delete({
     *   where: {
     *     // ... filter to delete one BlueprintSection
     *   }
     * })
     * 
     */
    delete<T extends BlueprintSectionDeleteArgs>(args: SelectSubset<T, BlueprintSectionDeleteArgs<ExtArgs>>): Prisma__BlueprintSectionClient<$Result.GetResult<Prisma.$BlueprintSectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BlueprintSection.
     * @param {BlueprintSectionUpdateArgs} args - Arguments to update one BlueprintSection.
     * @example
     * // Update one BlueprintSection
     * const blueprintSection = await prisma.blueprintSection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlueprintSectionUpdateArgs>(args: SelectSubset<T, BlueprintSectionUpdateArgs<ExtArgs>>): Prisma__BlueprintSectionClient<$Result.GetResult<Prisma.$BlueprintSectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BlueprintSections.
     * @param {BlueprintSectionDeleteManyArgs} args - Arguments to filter BlueprintSections to delete.
     * @example
     * // Delete a few BlueprintSections
     * const { count } = await prisma.blueprintSection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlueprintSectionDeleteManyArgs>(args?: SelectSubset<T, BlueprintSectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlueprintSections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlueprintSectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlueprintSections
     * const blueprintSection = await prisma.blueprintSection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlueprintSectionUpdateManyArgs>(args: SelectSubset<T, BlueprintSectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlueprintSections and returns the data updated in the database.
     * @param {BlueprintSectionUpdateManyAndReturnArgs} args - Arguments to update many BlueprintSections.
     * @example
     * // Update many BlueprintSections
     * const blueprintSection = await prisma.blueprintSection.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BlueprintSections and only return the `id`
     * const blueprintSectionWithIdOnly = await prisma.blueprintSection.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BlueprintSectionUpdateManyAndReturnArgs>(args: SelectSubset<T, BlueprintSectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlueprintSectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BlueprintSection.
     * @param {BlueprintSectionUpsertArgs} args - Arguments to update or create a BlueprintSection.
     * @example
     * // Update or create a BlueprintSection
     * const blueprintSection = await prisma.blueprintSection.upsert({
     *   create: {
     *     // ... data to create a BlueprintSection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlueprintSection we want to update
     *   }
     * })
     */
    upsert<T extends BlueprintSectionUpsertArgs>(args: SelectSubset<T, BlueprintSectionUpsertArgs<ExtArgs>>): Prisma__BlueprintSectionClient<$Result.GetResult<Prisma.$BlueprintSectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BlueprintSections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlueprintSectionCountArgs} args - Arguments to filter BlueprintSections to count.
     * @example
     * // Count the number of BlueprintSections
     * const count = await prisma.blueprintSection.count({
     *   where: {
     *     // ... the filter for the BlueprintSections we want to count
     *   }
     * })
    **/
    count<T extends BlueprintSectionCountArgs>(
      args?: Subset<T, BlueprintSectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlueprintSectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlueprintSection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlueprintSectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlueprintSectionAggregateArgs>(args: Subset<T, BlueprintSectionAggregateArgs>): Prisma.PrismaPromise<GetBlueprintSectionAggregateType<T>>

    /**
     * Group by BlueprintSection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlueprintSectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlueprintSectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlueprintSectionGroupByArgs['orderBy'] }
        : { orderBy?: BlueprintSectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlueprintSectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlueprintSectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlueprintSection model
   */
  readonly fields: BlueprintSectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlueprintSection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlueprintSectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    county<T extends BlueprintSection$countyArgs<ExtArgs> = {}>(args?: Subset<T, BlueprintSection$countyArgs<ExtArgs>>): Prisma__CountyClient<$Result.GetResult<Prisma.$CountyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    issue<T extends BlueprintSection$issueArgs<ExtArgs> = {}>(args?: Subset<T, BlueprintSection$issueArgs<ExtArgs>>): Prisma__IssueClient<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sourceLinks<T extends BlueprintSection$sourceLinksArgs<ExtArgs> = {}>(args?: Subset<T, BlueprintSection$sourceLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourceDocumentLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlueprintSection model
   */
  interface BlueprintSectionFieldRefs {
    readonly id: FieldRef<"BlueprintSection", 'String'>
    readonly slug: FieldRef<"BlueprintSection", 'String'>
    readonly title: FieldRef<"BlueprintSection", 'String'>
    readonly bodyMd: FieldRef<"BlueprintSection", 'String'>
    readonly countyId: FieldRef<"BlueprintSection", 'String'>
    readonly issueId: FieldRef<"BlueprintSection", 'String'>
    readonly sortOrder: FieldRef<"BlueprintSection", 'Int'>
    readonly isPinned: FieldRef<"BlueprintSection", 'Boolean'>
    readonly createdAt: FieldRef<"BlueprintSection", 'DateTime'>
    readonly updatedAt: FieldRef<"BlueprintSection", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BlueprintSection findUnique
   */
  export type BlueprintSectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlueprintSection
     */
    select?: BlueprintSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlueprintSection
     */
    omit?: BlueprintSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlueprintSectionInclude<ExtArgs> | null
    /**
     * Filter, which BlueprintSection to fetch.
     */
    where: BlueprintSectionWhereUniqueInput
  }

  /**
   * BlueprintSection findUniqueOrThrow
   */
  export type BlueprintSectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlueprintSection
     */
    select?: BlueprintSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlueprintSection
     */
    omit?: BlueprintSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlueprintSectionInclude<ExtArgs> | null
    /**
     * Filter, which BlueprintSection to fetch.
     */
    where: BlueprintSectionWhereUniqueInput
  }

  /**
   * BlueprintSection findFirst
   */
  export type BlueprintSectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlueprintSection
     */
    select?: BlueprintSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlueprintSection
     */
    omit?: BlueprintSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlueprintSectionInclude<ExtArgs> | null
    /**
     * Filter, which BlueprintSection to fetch.
     */
    where?: BlueprintSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlueprintSections to fetch.
     */
    orderBy?: BlueprintSectionOrderByWithRelationInput | BlueprintSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlueprintSections.
     */
    cursor?: BlueprintSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlueprintSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlueprintSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlueprintSections.
     */
    distinct?: BlueprintSectionScalarFieldEnum | BlueprintSectionScalarFieldEnum[]
  }

  /**
   * BlueprintSection findFirstOrThrow
   */
  export type BlueprintSectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlueprintSection
     */
    select?: BlueprintSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlueprintSection
     */
    omit?: BlueprintSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlueprintSectionInclude<ExtArgs> | null
    /**
     * Filter, which BlueprintSection to fetch.
     */
    where?: BlueprintSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlueprintSections to fetch.
     */
    orderBy?: BlueprintSectionOrderByWithRelationInput | BlueprintSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlueprintSections.
     */
    cursor?: BlueprintSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlueprintSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlueprintSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlueprintSections.
     */
    distinct?: BlueprintSectionScalarFieldEnum | BlueprintSectionScalarFieldEnum[]
  }

  /**
   * BlueprintSection findMany
   */
  export type BlueprintSectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlueprintSection
     */
    select?: BlueprintSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlueprintSection
     */
    omit?: BlueprintSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlueprintSectionInclude<ExtArgs> | null
    /**
     * Filter, which BlueprintSections to fetch.
     */
    where?: BlueprintSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlueprintSections to fetch.
     */
    orderBy?: BlueprintSectionOrderByWithRelationInput | BlueprintSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlueprintSections.
     */
    cursor?: BlueprintSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlueprintSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlueprintSections.
     */
    skip?: number
    distinct?: BlueprintSectionScalarFieldEnum | BlueprintSectionScalarFieldEnum[]
  }

  /**
   * BlueprintSection create
   */
  export type BlueprintSectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlueprintSection
     */
    select?: BlueprintSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlueprintSection
     */
    omit?: BlueprintSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlueprintSectionInclude<ExtArgs> | null
    /**
     * The data needed to create a BlueprintSection.
     */
    data: XOR<BlueprintSectionCreateInput, BlueprintSectionUncheckedCreateInput>
  }

  /**
   * BlueprintSection createMany
   */
  export type BlueprintSectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlueprintSections.
     */
    data: BlueprintSectionCreateManyInput | BlueprintSectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlueprintSection createManyAndReturn
   */
  export type BlueprintSectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlueprintSection
     */
    select?: BlueprintSectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlueprintSection
     */
    omit?: BlueprintSectionOmit<ExtArgs> | null
    /**
     * The data used to create many BlueprintSections.
     */
    data: BlueprintSectionCreateManyInput | BlueprintSectionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlueprintSectionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlueprintSection update
   */
  export type BlueprintSectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlueprintSection
     */
    select?: BlueprintSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlueprintSection
     */
    omit?: BlueprintSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlueprintSectionInclude<ExtArgs> | null
    /**
     * The data needed to update a BlueprintSection.
     */
    data: XOR<BlueprintSectionUpdateInput, BlueprintSectionUncheckedUpdateInput>
    /**
     * Choose, which BlueprintSection to update.
     */
    where: BlueprintSectionWhereUniqueInput
  }

  /**
   * BlueprintSection updateMany
   */
  export type BlueprintSectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlueprintSections.
     */
    data: XOR<BlueprintSectionUpdateManyMutationInput, BlueprintSectionUncheckedUpdateManyInput>
    /**
     * Filter which BlueprintSections to update
     */
    where?: BlueprintSectionWhereInput
    /**
     * Limit how many BlueprintSections to update.
     */
    limit?: number
  }

  /**
   * BlueprintSection updateManyAndReturn
   */
  export type BlueprintSectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlueprintSection
     */
    select?: BlueprintSectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlueprintSection
     */
    omit?: BlueprintSectionOmit<ExtArgs> | null
    /**
     * The data used to update BlueprintSections.
     */
    data: XOR<BlueprintSectionUpdateManyMutationInput, BlueprintSectionUncheckedUpdateManyInput>
    /**
     * Filter which BlueprintSections to update
     */
    where?: BlueprintSectionWhereInput
    /**
     * Limit how many BlueprintSections to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlueprintSectionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlueprintSection upsert
   */
  export type BlueprintSectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlueprintSection
     */
    select?: BlueprintSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlueprintSection
     */
    omit?: BlueprintSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlueprintSectionInclude<ExtArgs> | null
    /**
     * The filter to search for the BlueprintSection to update in case it exists.
     */
    where: BlueprintSectionWhereUniqueInput
    /**
     * In case the BlueprintSection found by the `where` argument doesn't exist, create a new BlueprintSection with this data.
     */
    create: XOR<BlueprintSectionCreateInput, BlueprintSectionUncheckedCreateInput>
    /**
     * In case the BlueprintSection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlueprintSectionUpdateInput, BlueprintSectionUncheckedUpdateInput>
  }

  /**
   * BlueprintSection delete
   */
  export type BlueprintSectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlueprintSection
     */
    select?: BlueprintSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlueprintSection
     */
    omit?: BlueprintSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlueprintSectionInclude<ExtArgs> | null
    /**
     * Filter which BlueprintSection to delete.
     */
    where: BlueprintSectionWhereUniqueInput
  }

  /**
   * BlueprintSection deleteMany
   */
  export type BlueprintSectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlueprintSections to delete
     */
    where?: BlueprintSectionWhereInput
    /**
     * Limit how many BlueprintSections to delete.
     */
    limit?: number
  }

  /**
   * BlueprintSection.county
   */
  export type BlueprintSection$countyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the County
     */
    select?: CountySelect<ExtArgs> | null
    /**
     * Omit specific fields from the County
     */
    omit?: CountyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountyInclude<ExtArgs> | null
    where?: CountyWhereInput
  }

  /**
   * BlueprintSection.issue
   */
  export type BlueprintSection$issueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Issue
     */
    omit?: IssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueInclude<ExtArgs> | null
    where?: IssueWhereInput
  }

  /**
   * BlueprintSection.sourceLinks
   */
  export type BlueprintSection$sourceLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceDocumentLink
     */
    select?: SourceDocumentLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceDocumentLink
     */
    omit?: SourceDocumentLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceDocumentLinkInclude<ExtArgs> | null
    where?: SourceDocumentLinkWhereInput
    orderBy?: SourceDocumentLinkOrderByWithRelationInput | SourceDocumentLinkOrderByWithRelationInput[]
    cursor?: SourceDocumentLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SourceDocumentLinkScalarFieldEnum | SourceDocumentLinkScalarFieldEnum[]
  }

  /**
   * BlueprintSection without action
   */
  export type BlueprintSectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlueprintSection
     */
    select?: BlueprintSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlueprintSection
     */
    omit?: BlueprintSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlueprintSectionInclude<ExtArgs> | null
  }


  /**
   * Model Quote
   */

  export type AggregateQuote = {
    _count: QuoteCountAggregateOutputType | null
    _min: QuoteMinAggregateOutputType | null
    _max: QuoteMaxAggregateOutputType | null
  }

  export type QuoteMinAggregateOutputType = {
    id: string | null
    text: string | null
    attributionLabel: string | null
    countyId: string | null
    issueId: string | null
    sourceNote: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuoteMaxAggregateOutputType = {
    id: string | null
    text: string | null
    attributionLabel: string | null
    countyId: string | null
    issueId: string | null
    sourceNote: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuoteCountAggregateOutputType = {
    id: number
    text: number
    attributionLabel: number
    countyId: number
    issueId: number
    sourceNote: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuoteMinAggregateInputType = {
    id?: true
    text?: true
    attributionLabel?: true
    countyId?: true
    issueId?: true
    sourceNote?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuoteMaxAggregateInputType = {
    id?: true
    text?: true
    attributionLabel?: true
    countyId?: true
    issueId?: true
    sourceNote?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuoteCountAggregateInputType = {
    id?: true
    text?: true
    attributionLabel?: true
    countyId?: true
    issueId?: true
    sourceNote?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quote to aggregate.
     */
    where?: QuoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotes to fetch.
     */
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Quotes
    **/
    _count?: true | QuoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuoteMaxAggregateInputType
  }

  export type GetQuoteAggregateType<T extends QuoteAggregateArgs> = {
        [P in keyof T & keyof AggregateQuote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuote[P]>
      : GetScalarType<T[P], AggregateQuote[P]>
  }




  export type QuoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuoteWhereInput
    orderBy?: QuoteOrderByWithAggregationInput | QuoteOrderByWithAggregationInput[]
    by: QuoteScalarFieldEnum[] | QuoteScalarFieldEnum
    having?: QuoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuoteCountAggregateInputType | true
    _min?: QuoteMinAggregateInputType
    _max?: QuoteMaxAggregateInputType
  }

  export type QuoteGroupByOutputType = {
    id: string
    text: string
    attributionLabel: string | null
    countyId: string
    issueId: string | null
    sourceNote: string | null
    createdAt: Date
    updatedAt: Date
    _count: QuoteCountAggregateOutputType | null
    _min: QuoteMinAggregateOutputType | null
    _max: QuoteMaxAggregateOutputType | null
  }

  type GetQuoteGroupByPayload<T extends QuoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuoteGroupByOutputType[P]>
            : GetScalarType<T[P], QuoteGroupByOutputType[P]>
        }
      >
    >


  export type QuoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    attributionLabel?: boolean
    countyId?: boolean
    issueId?: boolean
    sourceNote?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    county?: boolean | CountyDefaultArgs<ExtArgs>
    issue?: boolean | Quote$issueArgs<ExtArgs>
    sourceLinks?: boolean | Quote$sourceLinksArgs<ExtArgs>
    _count?: boolean | QuoteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quote"]>

  export type QuoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    attributionLabel?: boolean
    countyId?: boolean
    issueId?: boolean
    sourceNote?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    county?: boolean | CountyDefaultArgs<ExtArgs>
    issue?: boolean | Quote$issueArgs<ExtArgs>
  }, ExtArgs["result"]["quote"]>

  export type QuoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    attributionLabel?: boolean
    countyId?: boolean
    issueId?: boolean
    sourceNote?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    county?: boolean | CountyDefaultArgs<ExtArgs>
    issue?: boolean | Quote$issueArgs<ExtArgs>
  }, ExtArgs["result"]["quote"]>

  export type QuoteSelectScalar = {
    id?: boolean
    text?: boolean
    attributionLabel?: boolean
    countyId?: boolean
    issueId?: boolean
    sourceNote?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QuoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "text" | "attributionLabel" | "countyId" | "issueId" | "sourceNote" | "createdAt" | "updatedAt", ExtArgs["result"]["quote"]>
  export type QuoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    county?: boolean | CountyDefaultArgs<ExtArgs>
    issue?: boolean | Quote$issueArgs<ExtArgs>
    sourceLinks?: boolean | Quote$sourceLinksArgs<ExtArgs>
    _count?: boolean | QuoteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    county?: boolean | CountyDefaultArgs<ExtArgs>
    issue?: boolean | Quote$issueArgs<ExtArgs>
  }
  export type QuoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    county?: boolean | CountyDefaultArgs<ExtArgs>
    issue?: boolean | Quote$issueArgs<ExtArgs>
  }

  export type $QuotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Quote"
    objects: {
      county: Prisma.$CountyPayload<ExtArgs>
      issue: Prisma.$IssuePayload<ExtArgs> | null
      sourceLinks: Prisma.$SourceDocumentLinkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      text: string
      attributionLabel: string | null
      countyId: string
      issueId: string | null
      sourceNote: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["quote"]>
    composites: {}
  }

  type QuoteGetPayload<S extends boolean | null | undefined | QuoteDefaultArgs> = $Result.GetResult<Prisma.$QuotePayload, S>

  type QuoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuoteCountAggregateInputType | true
    }

  export interface QuoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Quote'], meta: { name: 'Quote' } }
    /**
     * Find zero or one Quote that matches the filter.
     * @param {QuoteFindUniqueArgs} args - Arguments to find a Quote
     * @example
     * // Get one Quote
     * const quote = await prisma.quote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuoteFindUniqueArgs>(args: SelectSubset<T, QuoteFindUniqueArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Quote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuoteFindUniqueOrThrowArgs} args - Arguments to find a Quote
     * @example
     * // Get one Quote
     * const quote = await prisma.quote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuoteFindUniqueOrThrowArgs>(args: SelectSubset<T, QuoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteFindFirstArgs} args - Arguments to find a Quote
     * @example
     * // Get one Quote
     * const quote = await prisma.quote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuoteFindFirstArgs>(args?: SelectSubset<T, QuoteFindFirstArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteFindFirstOrThrowArgs} args - Arguments to find a Quote
     * @example
     * // Get one Quote
     * const quote = await prisma.quote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuoteFindFirstOrThrowArgs>(args?: SelectSubset<T, QuoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Quotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quotes
     * const quotes = await prisma.quote.findMany()
     * 
     * // Get first 10 Quotes
     * const quotes = await prisma.quote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quoteWithIdOnly = await prisma.quote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuoteFindManyArgs>(args?: SelectSubset<T, QuoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Quote.
     * @param {QuoteCreateArgs} args - Arguments to create a Quote.
     * @example
     * // Create one Quote
     * const Quote = await prisma.quote.create({
     *   data: {
     *     // ... data to create a Quote
     *   }
     * })
     * 
     */
    create<T extends QuoteCreateArgs>(args: SelectSubset<T, QuoteCreateArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Quotes.
     * @param {QuoteCreateManyArgs} args - Arguments to create many Quotes.
     * @example
     * // Create many Quotes
     * const quote = await prisma.quote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuoteCreateManyArgs>(args?: SelectSubset<T, QuoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Quotes and returns the data saved in the database.
     * @param {QuoteCreateManyAndReturnArgs} args - Arguments to create many Quotes.
     * @example
     * // Create many Quotes
     * const quote = await prisma.quote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Quotes and only return the `id`
     * const quoteWithIdOnly = await prisma.quote.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuoteCreateManyAndReturnArgs>(args?: SelectSubset<T, QuoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Quote.
     * @param {QuoteDeleteArgs} args - Arguments to delete one Quote.
     * @example
     * // Delete one Quote
     * const Quote = await prisma.quote.delete({
     *   where: {
     *     // ... filter to delete one Quote
     *   }
     * })
     * 
     */
    delete<T extends QuoteDeleteArgs>(args: SelectSubset<T, QuoteDeleteArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Quote.
     * @param {QuoteUpdateArgs} args - Arguments to update one Quote.
     * @example
     * // Update one Quote
     * const quote = await prisma.quote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuoteUpdateArgs>(args: SelectSubset<T, QuoteUpdateArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Quotes.
     * @param {QuoteDeleteManyArgs} args - Arguments to filter Quotes to delete.
     * @example
     * // Delete a few Quotes
     * const { count } = await prisma.quote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuoteDeleteManyArgs>(args?: SelectSubset<T, QuoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quotes
     * const quote = await prisma.quote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuoteUpdateManyArgs>(args: SelectSubset<T, QuoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quotes and returns the data updated in the database.
     * @param {QuoteUpdateManyAndReturnArgs} args - Arguments to update many Quotes.
     * @example
     * // Update many Quotes
     * const quote = await prisma.quote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Quotes and only return the `id`
     * const quoteWithIdOnly = await prisma.quote.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuoteUpdateManyAndReturnArgs>(args: SelectSubset<T, QuoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Quote.
     * @param {QuoteUpsertArgs} args - Arguments to update or create a Quote.
     * @example
     * // Update or create a Quote
     * const quote = await prisma.quote.upsert({
     *   create: {
     *     // ... data to create a Quote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quote we want to update
     *   }
     * })
     */
    upsert<T extends QuoteUpsertArgs>(args: SelectSubset<T, QuoteUpsertArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Quotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteCountArgs} args - Arguments to filter Quotes to count.
     * @example
     * // Count the number of Quotes
     * const count = await prisma.quote.count({
     *   where: {
     *     // ... the filter for the Quotes we want to count
     *   }
     * })
    **/
    count<T extends QuoteCountArgs>(
      args?: Subset<T, QuoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuoteAggregateArgs>(args: Subset<T, QuoteAggregateArgs>): Prisma.PrismaPromise<GetQuoteAggregateType<T>>

    /**
     * Group by Quote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuoteGroupByArgs['orderBy'] }
        : { orderBy?: QuoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Quote model
   */
  readonly fields: QuoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Quote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    county<T extends CountyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CountyDefaultArgs<ExtArgs>>): Prisma__CountyClient<$Result.GetResult<Prisma.$CountyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    issue<T extends Quote$issueArgs<ExtArgs> = {}>(args?: Subset<T, Quote$issueArgs<ExtArgs>>): Prisma__IssueClient<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sourceLinks<T extends Quote$sourceLinksArgs<ExtArgs> = {}>(args?: Subset<T, Quote$sourceLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourceDocumentLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Quote model
   */
  interface QuoteFieldRefs {
    readonly id: FieldRef<"Quote", 'String'>
    readonly text: FieldRef<"Quote", 'String'>
    readonly attributionLabel: FieldRef<"Quote", 'String'>
    readonly countyId: FieldRef<"Quote", 'String'>
    readonly issueId: FieldRef<"Quote", 'String'>
    readonly sourceNote: FieldRef<"Quote", 'String'>
    readonly createdAt: FieldRef<"Quote", 'DateTime'>
    readonly updatedAt: FieldRef<"Quote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Quote findUnique
   */
  export type QuoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * Filter, which Quote to fetch.
     */
    where: QuoteWhereUniqueInput
  }

  /**
   * Quote findUniqueOrThrow
   */
  export type QuoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * Filter, which Quote to fetch.
     */
    where: QuoteWhereUniqueInput
  }

  /**
   * Quote findFirst
   */
  export type QuoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * Filter, which Quote to fetch.
     */
    where?: QuoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotes to fetch.
     */
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quotes.
     */
    cursor?: QuoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quotes.
     */
    distinct?: QuoteScalarFieldEnum | QuoteScalarFieldEnum[]
  }

  /**
   * Quote findFirstOrThrow
   */
  export type QuoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * Filter, which Quote to fetch.
     */
    where?: QuoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotes to fetch.
     */
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quotes.
     */
    cursor?: QuoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quotes.
     */
    distinct?: QuoteScalarFieldEnum | QuoteScalarFieldEnum[]
  }

  /**
   * Quote findMany
   */
  export type QuoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * Filter, which Quotes to fetch.
     */
    where?: QuoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotes to fetch.
     */
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Quotes.
     */
    cursor?: QuoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotes.
     */
    skip?: number
    distinct?: QuoteScalarFieldEnum | QuoteScalarFieldEnum[]
  }

  /**
   * Quote create
   */
  export type QuoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * The data needed to create a Quote.
     */
    data: XOR<QuoteCreateInput, QuoteUncheckedCreateInput>
  }

  /**
   * Quote createMany
   */
  export type QuoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Quotes.
     */
    data: QuoteCreateManyInput | QuoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Quote createManyAndReturn
   */
  export type QuoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * The data used to create many Quotes.
     */
    data: QuoteCreateManyInput | QuoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Quote update
   */
  export type QuoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * The data needed to update a Quote.
     */
    data: XOR<QuoteUpdateInput, QuoteUncheckedUpdateInput>
    /**
     * Choose, which Quote to update.
     */
    where: QuoteWhereUniqueInput
  }

  /**
   * Quote updateMany
   */
  export type QuoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Quotes.
     */
    data: XOR<QuoteUpdateManyMutationInput, QuoteUncheckedUpdateManyInput>
    /**
     * Filter which Quotes to update
     */
    where?: QuoteWhereInput
    /**
     * Limit how many Quotes to update.
     */
    limit?: number
  }

  /**
   * Quote updateManyAndReturn
   */
  export type QuoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * The data used to update Quotes.
     */
    data: XOR<QuoteUpdateManyMutationInput, QuoteUncheckedUpdateManyInput>
    /**
     * Filter which Quotes to update
     */
    where?: QuoteWhereInput
    /**
     * Limit how many Quotes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Quote upsert
   */
  export type QuoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * The filter to search for the Quote to update in case it exists.
     */
    where: QuoteWhereUniqueInput
    /**
     * In case the Quote found by the `where` argument doesn't exist, create a new Quote with this data.
     */
    create: XOR<QuoteCreateInput, QuoteUncheckedCreateInput>
    /**
     * In case the Quote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuoteUpdateInput, QuoteUncheckedUpdateInput>
  }

  /**
   * Quote delete
   */
  export type QuoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * Filter which Quote to delete.
     */
    where: QuoteWhereUniqueInput
  }

  /**
   * Quote deleteMany
   */
  export type QuoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quotes to delete
     */
    where?: QuoteWhereInput
    /**
     * Limit how many Quotes to delete.
     */
    limit?: number
  }

  /**
   * Quote.issue
   */
  export type Quote$issueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Issue
     */
    omit?: IssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueInclude<ExtArgs> | null
    where?: IssueWhereInput
  }

  /**
   * Quote.sourceLinks
   */
  export type Quote$sourceLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceDocumentLink
     */
    select?: SourceDocumentLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceDocumentLink
     */
    omit?: SourceDocumentLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceDocumentLinkInclude<ExtArgs> | null
    where?: SourceDocumentLinkWhereInput
    orderBy?: SourceDocumentLinkOrderByWithRelationInput | SourceDocumentLinkOrderByWithRelationInput[]
    cursor?: SourceDocumentLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SourceDocumentLinkScalarFieldEnum | SourceDocumentLinkScalarFieldEnum[]
  }

  /**
   * Quote without action
   */
  export type QuoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
  }


  /**
   * Model Asset
   */

  export type AggregateAsset = {
    _count: AssetCountAggregateOutputType | null
    _min: AssetMinAggregateOutputType | null
    _max: AssetMaxAggregateOutputType | null
  }

  export type AssetMinAggregateOutputType = {
    id: string | null
    assetType: $Enums.AssetType | null
    title: string | null
    caption: string | null
    credit: string | null
    license: string | null
    url: string | null
    storageKey: string | null
    countyId: string | null
    issueId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AssetMaxAggregateOutputType = {
    id: string | null
    assetType: $Enums.AssetType | null
    title: string | null
    caption: string | null
    credit: string | null
    license: string | null
    url: string | null
    storageKey: string | null
    countyId: string | null
    issueId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AssetCountAggregateOutputType = {
    id: number
    assetType: number
    title: number
    caption: number
    credit: number
    license: number
    url: number
    storageKey: number
    countyId: number
    issueId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AssetMinAggregateInputType = {
    id?: true
    assetType?: true
    title?: true
    caption?: true
    credit?: true
    license?: true
    url?: true
    storageKey?: true
    countyId?: true
    issueId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AssetMaxAggregateInputType = {
    id?: true
    assetType?: true
    title?: true
    caption?: true
    credit?: true
    license?: true
    url?: true
    storageKey?: true
    countyId?: true
    issueId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AssetCountAggregateInputType = {
    id?: true
    assetType?: true
    title?: true
    caption?: true
    credit?: true
    license?: true
    url?: true
    storageKey?: true
    countyId?: true
    issueId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AssetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Asset to aggregate.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Assets
    **/
    _count?: true | AssetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssetMaxAggregateInputType
  }

  export type GetAssetAggregateType<T extends AssetAggregateArgs> = {
        [P in keyof T & keyof AggregateAsset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAsset[P]>
      : GetScalarType<T[P], AggregateAsset[P]>
  }




  export type AssetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetWhereInput
    orderBy?: AssetOrderByWithAggregationInput | AssetOrderByWithAggregationInput[]
    by: AssetScalarFieldEnum[] | AssetScalarFieldEnum
    having?: AssetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssetCountAggregateInputType | true
    _min?: AssetMinAggregateInputType
    _max?: AssetMaxAggregateInputType
  }

  export type AssetGroupByOutputType = {
    id: string
    assetType: $Enums.AssetType
    title: string | null
    caption: string | null
    credit: string | null
    license: string | null
    url: string | null
    storageKey: string | null
    countyId: string | null
    issueId: string | null
    createdAt: Date
    updatedAt: Date
    _count: AssetCountAggregateOutputType | null
    _min: AssetMinAggregateOutputType | null
    _max: AssetMaxAggregateOutputType | null
  }

  type GetAssetGroupByPayload<T extends AssetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssetGroupByOutputType[P]>
            : GetScalarType<T[P], AssetGroupByOutputType[P]>
        }
      >
    >


  export type AssetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assetType?: boolean
    title?: boolean
    caption?: boolean
    credit?: boolean
    license?: boolean
    url?: boolean
    storageKey?: boolean
    countyId?: boolean
    issueId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    county?: boolean | Asset$countyArgs<ExtArgs>
    issue?: boolean | Asset$issueArgs<ExtArgs>
    sourceLinks?: boolean | Asset$sourceLinksArgs<ExtArgs>
    _count?: boolean | AssetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["asset"]>

  export type AssetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assetType?: boolean
    title?: boolean
    caption?: boolean
    credit?: boolean
    license?: boolean
    url?: boolean
    storageKey?: boolean
    countyId?: boolean
    issueId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    county?: boolean | Asset$countyArgs<ExtArgs>
    issue?: boolean | Asset$issueArgs<ExtArgs>
  }, ExtArgs["result"]["asset"]>

  export type AssetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assetType?: boolean
    title?: boolean
    caption?: boolean
    credit?: boolean
    license?: boolean
    url?: boolean
    storageKey?: boolean
    countyId?: boolean
    issueId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    county?: boolean | Asset$countyArgs<ExtArgs>
    issue?: boolean | Asset$issueArgs<ExtArgs>
  }, ExtArgs["result"]["asset"]>

  export type AssetSelectScalar = {
    id?: boolean
    assetType?: boolean
    title?: boolean
    caption?: boolean
    credit?: boolean
    license?: boolean
    url?: boolean
    storageKey?: boolean
    countyId?: boolean
    issueId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AssetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "assetType" | "title" | "caption" | "credit" | "license" | "url" | "storageKey" | "countyId" | "issueId" | "createdAt" | "updatedAt", ExtArgs["result"]["asset"]>
  export type AssetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    county?: boolean | Asset$countyArgs<ExtArgs>
    issue?: boolean | Asset$issueArgs<ExtArgs>
    sourceLinks?: boolean | Asset$sourceLinksArgs<ExtArgs>
    _count?: boolean | AssetCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AssetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    county?: boolean | Asset$countyArgs<ExtArgs>
    issue?: boolean | Asset$issueArgs<ExtArgs>
  }
  export type AssetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    county?: boolean | Asset$countyArgs<ExtArgs>
    issue?: boolean | Asset$issueArgs<ExtArgs>
  }

  export type $AssetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Asset"
    objects: {
      county: Prisma.$CountyPayload<ExtArgs> | null
      issue: Prisma.$IssuePayload<ExtArgs> | null
      sourceLinks: Prisma.$SourceDocumentLinkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      assetType: $Enums.AssetType
      title: string | null
      caption: string | null
      credit: string | null
      license: string | null
      url: string | null
      storageKey: string | null
      countyId: string | null
      issueId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["asset"]>
    composites: {}
  }

  type AssetGetPayload<S extends boolean | null | undefined | AssetDefaultArgs> = $Result.GetResult<Prisma.$AssetPayload, S>

  type AssetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AssetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AssetCountAggregateInputType | true
    }

  export interface AssetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Asset'], meta: { name: 'Asset' } }
    /**
     * Find zero or one Asset that matches the filter.
     * @param {AssetFindUniqueArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssetFindUniqueArgs>(args: SelectSubset<T, AssetFindUniqueArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Asset that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AssetFindUniqueOrThrowArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssetFindUniqueOrThrowArgs>(args: SelectSubset<T, AssetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Asset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetFindFirstArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssetFindFirstArgs>(args?: SelectSubset<T, AssetFindFirstArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Asset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetFindFirstOrThrowArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssetFindFirstOrThrowArgs>(args?: SelectSubset<T, AssetFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Assets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Assets
     * const assets = await prisma.asset.findMany()
     * 
     * // Get first 10 Assets
     * const assets = await prisma.asset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assetWithIdOnly = await prisma.asset.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssetFindManyArgs>(args?: SelectSubset<T, AssetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Asset.
     * @param {AssetCreateArgs} args - Arguments to create a Asset.
     * @example
     * // Create one Asset
     * const Asset = await prisma.asset.create({
     *   data: {
     *     // ... data to create a Asset
     *   }
     * })
     * 
     */
    create<T extends AssetCreateArgs>(args: SelectSubset<T, AssetCreateArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Assets.
     * @param {AssetCreateManyArgs} args - Arguments to create many Assets.
     * @example
     * // Create many Assets
     * const asset = await prisma.asset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssetCreateManyArgs>(args?: SelectSubset<T, AssetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Assets and returns the data saved in the database.
     * @param {AssetCreateManyAndReturnArgs} args - Arguments to create many Assets.
     * @example
     * // Create many Assets
     * const asset = await prisma.asset.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Assets and only return the `id`
     * const assetWithIdOnly = await prisma.asset.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssetCreateManyAndReturnArgs>(args?: SelectSubset<T, AssetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Asset.
     * @param {AssetDeleteArgs} args - Arguments to delete one Asset.
     * @example
     * // Delete one Asset
     * const Asset = await prisma.asset.delete({
     *   where: {
     *     // ... filter to delete one Asset
     *   }
     * })
     * 
     */
    delete<T extends AssetDeleteArgs>(args: SelectSubset<T, AssetDeleteArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Asset.
     * @param {AssetUpdateArgs} args - Arguments to update one Asset.
     * @example
     * // Update one Asset
     * const asset = await prisma.asset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssetUpdateArgs>(args: SelectSubset<T, AssetUpdateArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Assets.
     * @param {AssetDeleteManyArgs} args - Arguments to filter Assets to delete.
     * @example
     * // Delete a few Assets
     * const { count } = await prisma.asset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssetDeleteManyArgs>(args?: SelectSubset<T, AssetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Assets
     * const asset = await prisma.asset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssetUpdateManyArgs>(args: SelectSubset<T, AssetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assets and returns the data updated in the database.
     * @param {AssetUpdateManyAndReturnArgs} args - Arguments to update many Assets.
     * @example
     * // Update many Assets
     * const asset = await prisma.asset.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Assets and only return the `id`
     * const assetWithIdOnly = await prisma.asset.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AssetUpdateManyAndReturnArgs>(args: SelectSubset<T, AssetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Asset.
     * @param {AssetUpsertArgs} args - Arguments to update or create a Asset.
     * @example
     * // Update or create a Asset
     * const asset = await prisma.asset.upsert({
     *   create: {
     *     // ... data to create a Asset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Asset we want to update
     *   }
     * })
     */
    upsert<T extends AssetUpsertArgs>(args: SelectSubset<T, AssetUpsertArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetCountArgs} args - Arguments to filter Assets to count.
     * @example
     * // Count the number of Assets
     * const count = await prisma.asset.count({
     *   where: {
     *     // ... the filter for the Assets we want to count
     *   }
     * })
    **/
    count<T extends AssetCountArgs>(
      args?: Subset<T, AssetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Asset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssetAggregateArgs>(args: Subset<T, AssetAggregateArgs>): Prisma.PrismaPromise<GetAssetAggregateType<T>>

    /**
     * Group by Asset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssetGroupByArgs['orderBy'] }
        : { orderBy?: AssetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Asset model
   */
  readonly fields: AssetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Asset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    county<T extends Asset$countyArgs<ExtArgs> = {}>(args?: Subset<T, Asset$countyArgs<ExtArgs>>): Prisma__CountyClient<$Result.GetResult<Prisma.$CountyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    issue<T extends Asset$issueArgs<ExtArgs> = {}>(args?: Subset<T, Asset$issueArgs<ExtArgs>>): Prisma__IssueClient<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sourceLinks<T extends Asset$sourceLinksArgs<ExtArgs> = {}>(args?: Subset<T, Asset$sourceLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourceDocumentLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Asset model
   */
  interface AssetFieldRefs {
    readonly id: FieldRef<"Asset", 'String'>
    readonly assetType: FieldRef<"Asset", 'AssetType'>
    readonly title: FieldRef<"Asset", 'String'>
    readonly caption: FieldRef<"Asset", 'String'>
    readonly credit: FieldRef<"Asset", 'String'>
    readonly license: FieldRef<"Asset", 'String'>
    readonly url: FieldRef<"Asset", 'String'>
    readonly storageKey: FieldRef<"Asset", 'String'>
    readonly countyId: FieldRef<"Asset", 'String'>
    readonly issueId: FieldRef<"Asset", 'String'>
    readonly createdAt: FieldRef<"Asset", 'DateTime'>
    readonly updatedAt: FieldRef<"Asset", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Asset findUnique
   */
  export type AssetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset findUniqueOrThrow
   */
  export type AssetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset findFirst
   */
  export type AssetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assets.
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assets.
     */
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Asset findFirstOrThrow
   */
  export type AssetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assets.
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assets.
     */
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Asset findMany
   */
  export type AssetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Assets to fetch.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Assets.
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Asset create
   */
  export type AssetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * The data needed to create a Asset.
     */
    data: XOR<AssetCreateInput, AssetUncheckedCreateInput>
  }

  /**
   * Asset createMany
   */
  export type AssetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Assets.
     */
    data: AssetCreateManyInput | AssetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Asset createManyAndReturn
   */
  export type AssetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * The data used to create many Assets.
     */
    data: AssetCreateManyInput | AssetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Asset update
   */
  export type AssetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * The data needed to update a Asset.
     */
    data: XOR<AssetUpdateInput, AssetUncheckedUpdateInput>
    /**
     * Choose, which Asset to update.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset updateMany
   */
  export type AssetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Assets.
     */
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyInput>
    /**
     * Filter which Assets to update
     */
    where?: AssetWhereInput
    /**
     * Limit how many Assets to update.
     */
    limit?: number
  }

  /**
   * Asset updateManyAndReturn
   */
  export type AssetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * The data used to update Assets.
     */
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyInput>
    /**
     * Filter which Assets to update
     */
    where?: AssetWhereInput
    /**
     * Limit how many Assets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Asset upsert
   */
  export type AssetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * The filter to search for the Asset to update in case it exists.
     */
    where: AssetWhereUniqueInput
    /**
     * In case the Asset found by the `where` argument doesn't exist, create a new Asset with this data.
     */
    create: XOR<AssetCreateInput, AssetUncheckedCreateInput>
    /**
     * In case the Asset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssetUpdateInput, AssetUncheckedUpdateInput>
  }

  /**
   * Asset delete
   */
  export type AssetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter which Asset to delete.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset deleteMany
   */
  export type AssetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assets to delete
     */
    where?: AssetWhereInput
    /**
     * Limit how many Assets to delete.
     */
    limit?: number
  }

  /**
   * Asset.county
   */
  export type Asset$countyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the County
     */
    select?: CountySelect<ExtArgs> | null
    /**
     * Omit specific fields from the County
     */
    omit?: CountyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountyInclude<ExtArgs> | null
    where?: CountyWhereInput
  }

  /**
   * Asset.issue
   */
  export type Asset$issueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Issue
     */
    omit?: IssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueInclude<ExtArgs> | null
    where?: IssueWhereInput
  }

  /**
   * Asset.sourceLinks
   */
  export type Asset$sourceLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceDocumentLink
     */
    select?: SourceDocumentLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceDocumentLink
     */
    omit?: SourceDocumentLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceDocumentLinkInclude<ExtArgs> | null
    where?: SourceDocumentLinkWhereInput
    orderBy?: SourceDocumentLinkOrderByWithRelationInput | SourceDocumentLinkOrderByWithRelationInput[]
    cursor?: SourceDocumentLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SourceDocumentLinkScalarFieldEnum | SourceDocumentLinkScalarFieldEnum[]
  }

  /**
   * Asset without action
   */
  export type AssetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
  }


  /**
   * Model GlossaryTerm
   */

  export type AggregateGlossaryTerm = {
    _count: GlossaryTermCountAggregateOutputType | null
    _min: GlossaryTermMinAggregateOutputType | null
    _max: GlossaryTermMaxAggregateOutputType | null
  }

  export type GlossaryTermMinAggregateOutputType = {
    id: string | null
    term: string | null
    slug: string | null
    definitionMd: string | null
    examplesMd: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GlossaryTermMaxAggregateOutputType = {
    id: string | null
    term: string | null
    slug: string | null
    definitionMd: string | null
    examplesMd: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GlossaryTermCountAggregateOutputType = {
    id: number
    term: number
    slug: number
    definitionMd: number
    examplesMd: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GlossaryTermMinAggregateInputType = {
    id?: true
    term?: true
    slug?: true
    definitionMd?: true
    examplesMd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GlossaryTermMaxAggregateInputType = {
    id?: true
    term?: true
    slug?: true
    definitionMd?: true
    examplesMd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GlossaryTermCountAggregateInputType = {
    id?: true
    term?: true
    slug?: true
    definitionMd?: true
    examplesMd?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GlossaryTermAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GlossaryTerm to aggregate.
     */
    where?: GlossaryTermWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GlossaryTerms to fetch.
     */
    orderBy?: GlossaryTermOrderByWithRelationInput | GlossaryTermOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GlossaryTermWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GlossaryTerms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GlossaryTerms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GlossaryTerms
    **/
    _count?: true | GlossaryTermCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GlossaryTermMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GlossaryTermMaxAggregateInputType
  }

  export type GetGlossaryTermAggregateType<T extends GlossaryTermAggregateArgs> = {
        [P in keyof T & keyof AggregateGlossaryTerm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGlossaryTerm[P]>
      : GetScalarType<T[P], AggregateGlossaryTerm[P]>
  }




  export type GlossaryTermGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GlossaryTermWhereInput
    orderBy?: GlossaryTermOrderByWithAggregationInput | GlossaryTermOrderByWithAggregationInput[]
    by: GlossaryTermScalarFieldEnum[] | GlossaryTermScalarFieldEnum
    having?: GlossaryTermScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GlossaryTermCountAggregateInputType | true
    _min?: GlossaryTermMinAggregateInputType
    _max?: GlossaryTermMaxAggregateInputType
  }

  export type GlossaryTermGroupByOutputType = {
    id: string
    term: string
    slug: string
    definitionMd: string
    examplesMd: string | null
    createdAt: Date
    updatedAt: Date
    _count: GlossaryTermCountAggregateOutputType | null
    _min: GlossaryTermMinAggregateOutputType | null
    _max: GlossaryTermMaxAggregateOutputType | null
  }

  type GetGlossaryTermGroupByPayload<T extends GlossaryTermGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GlossaryTermGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GlossaryTermGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GlossaryTermGroupByOutputType[P]>
            : GetScalarType<T[P], GlossaryTermGroupByOutputType[P]>
        }
      >
    >


  export type GlossaryTermSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    term?: boolean
    slug?: boolean
    definitionMd?: boolean
    examplesMd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["glossaryTerm"]>

  export type GlossaryTermSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    term?: boolean
    slug?: boolean
    definitionMd?: boolean
    examplesMd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["glossaryTerm"]>

  export type GlossaryTermSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    term?: boolean
    slug?: boolean
    definitionMd?: boolean
    examplesMd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["glossaryTerm"]>

  export type GlossaryTermSelectScalar = {
    id?: boolean
    term?: boolean
    slug?: boolean
    definitionMd?: boolean
    examplesMd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GlossaryTermOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "term" | "slug" | "definitionMd" | "examplesMd" | "createdAt" | "updatedAt", ExtArgs["result"]["glossaryTerm"]>

  export type $GlossaryTermPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GlossaryTerm"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      term: string
      slug: string
      definitionMd: string
      examplesMd: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["glossaryTerm"]>
    composites: {}
  }

  type GlossaryTermGetPayload<S extends boolean | null | undefined | GlossaryTermDefaultArgs> = $Result.GetResult<Prisma.$GlossaryTermPayload, S>

  type GlossaryTermCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GlossaryTermFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GlossaryTermCountAggregateInputType | true
    }

  export interface GlossaryTermDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GlossaryTerm'], meta: { name: 'GlossaryTerm' } }
    /**
     * Find zero or one GlossaryTerm that matches the filter.
     * @param {GlossaryTermFindUniqueArgs} args - Arguments to find a GlossaryTerm
     * @example
     * // Get one GlossaryTerm
     * const glossaryTerm = await prisma.glossaryTerm.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GlossaryTermFindUniqueArgs>(args: SelectSubset<T, GlossaryTermFindUniqueArgs<ExtArgs>>): Prisma__GlossaryTermClient<$Result.GetResult<Prisma.$GlossaryTermPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GlossaryTerm that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GlossaryTermFindUniqueOrThrowArgs} args - Arguments to find a GlossaryTerm
     * @example
     * // Get one GlossaryTerm
     * const glossaryTerm = await prisma.glossaryTerm.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GlossaryTermFindUniqueOrThrowArgs>(args: SelectSubset<T, GlossaryTermFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GlossaryTermClient<$Result.GetResult<Prisma.$GlossaryTermPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GlossaryTerm that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlossaryTermFindFirstArgs} args - Arguments to find a GlossaryTerm
     * @example
     * // Get one GlossaryTerm
     * const glossaryTerm = await prisma.glossaryTerm.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GlossaryTermFindFirstArgs>(args?: SelectSubset<T, GlossaryTermFindFirstArgs<ExtArgs>>): Prisma__GlossaryTermClient<$Result.GetResult<Prisma.$GlossaryTermPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GlossaryTerm that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlossaryTermFindFirstOrThrowArgs} args - Arguments to find a GlossaryTerm
     * @example
     * // Get one GlossaryTerm
     * const glossaryTerm = await prisma.glossaryTerm.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GlossaryTermFindFirstOrThrowArgs>(args?: SelectSubset<T, GlossaryTermFindFirstOrThrowArgs<ExtArgs>>): Prisma__GlossaryTermClient<$Result.GetResult<Prisma.$GlossaryTermPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GlossaryTerms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlossaryTermFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GlossaryTerms
     * const glossaryTerms = await prisma.glossaryTerm.findMany()
     * 
     * // Get first 10 GlossaryTerms
     * const glossaryTerms = await prisma.glossaryTerm.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const glossaryTermWithIdOnly = await prisma.glossaryTerm.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GlossaryTermFindManyArgs>(args?: SelectSubset<T, GlossaryTermFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GlossaryTermPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GlossaryTerm.
     * @param {GlossaryTermCreateArgs} args - Arguments to create a GlossaryTerm.
     * @example
     * // Create one GlossaryTerm
     * const GlossaryTerm = await prisma.glossaryTerm.create({
     *   data: {
     *     // ... data to create a GlossaryTerm
     *   }
     * })
     * 
     */
    create<T extends GlossaryTermCreateArgs>(args: SelectSubset<T, GlossaryTermCreateArgs<ExtArgs>>): Prisma__GlossaryTermClient<$Result.GetResult<Prisma.$GlossaryTermPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GlossaryTerms.
     * @param {GlossaryTermCreateManyArgs} args - Arguments to create many GlossaryTerms.
     * @example
     * // Create many GlossaryTerms
     * const glossaryTerm = await prisma.glossaryTerm.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GlossaryTermCreateManyArgs>(args?: SelectSubset<T, GlossaryTermCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GlossaryTerms and returns the data saved in the database.
     * @param {GlossaryTermCreateManyAndReturnArgs} args - Arguments to create many GlossaryTerms.
     * @example
     * // Create many GlossaryTerms
     * const glossaryTerm = await prisma.glossaryTerm.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GlossaryTerms and only return the `id`
     * const glossaryTermWithIdOnly = await prisma.glossaryTerm.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GlossaryTermCreateManyAndReturnArgs>(args?: SelectSubset<T, GlossaryTermCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GlossaryTermPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GlossaryTerm.
     * @param {GlossaryTermDeleteArgs} args - Arguments to delete one GlossaryTerm.
     * @example
     * // Delete one GlossaryTerm
     * const GlossaryTerm = await prisma.glossaryTerm.delete({
     *   where: {
     *     // ... filter to delete one GlossaryTerm
     *   }
     * })
     * 
     */
    delete<T extends GlossaryTermDeleteArgs>(args: SelectSubset<T, GlossaryTermDeleteArgs<ExtArgs>>): Prisma__GlossaryTermClient<$Result.GetResult<Prisma.$GlossaryTermPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GlossaryTerm.
     * @param {GlossaryTermUpdateArgs} args - Arguments to update one GlossaryTerm.
     * @example
     * // Update one GlossaryTerm
     * const glossaryTerm = await prisma.glossaryTerm.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GlossaryTermUpdateArgs>(args: SelectSubset<T, GlossaryTermUpdateArgs<ExtArgs>>): Prisma__GlossaryTermClient<$Result.GetResult<Prisma.$GlossaryTermPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GlossaryTerms.
     * @param {GlossaryTermDeleteManyArgs} args - Arguments to filter GlossaryTerms to delete.
     * @example
     * // Delete a few GlossaryTerms
     * const { count } = await prisma.glossaryTerm.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GlossaryTermDeleteManyArgs>(args?: SelectSubset<T, GlossaryTermDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GlossaryTerms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlossaryTermUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GlossaryTerms
     * const glossaryTerm = await prisma.glossaryTerm.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GlossaryTermUpdateManyArgs>(args: SelectSubset<T, GlossaryTermUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GlossaryTerms and returns the data updated in the database.
     * @param {GlossaryTermUpdateManyAndReturnArgs} args - Arguments to update many GlossaryTerms.
     * @example
     * // Update many GlossaryTerms
     * const glossaryTerm = await prisma.glossaryTerm.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GlossaryTerms and only return the `id`
     * const glossaryTermWithIdOnly = await prisma.glossaryTerm.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GlossaryTermUpdateManyAndReturnArgs>(args: SelectSubset<T, GlossaryTermUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GlossaryTermPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GlossaryTerm.
     * @param {GlossaryTermUpsertArgs} args - Arguments to update or create a GlossaryTerm.
     * @example
     * // Update or create a GlossaryTerm
     * const glossaryTerm = await prisma.glossaryTerm.upsert({
     *   create: {
     *     // ... data to create a GlossaryTerm
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GlossaryTerm we want to update
     *   }
     * })
     */
    upsert<T extends GlossaryTermUpsertArgs>(args: SelectSubset<T, GlossaryTermUpsertArgs<ExtArgs>>): Prisma__GlossaryTermClient<$Result.GetResult<Prisma.$GlossaryTermPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GlossaryTerms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlossaryTermCountArgs} args - Arguments to filter GlossaryTerms to count.
     * @example
     * // Count the number of GlossaryTerms
     * const count = await prisma.glossaryTerm.count({
     *   where: {
     *     // ... the filter for the GlossaryTerms we want to count
     *   }
     * })
    **/
    count<T extends GlossaryTermCountArgs>(
      args?: Subset<T, GlossaryTermCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GlossaryTermCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GlossaryTerm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlossaryTermAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GlossaryTermAggregateArgs>(args: Subset<T, GlossaryTermAggregateArgs>): Prisma.PrismaPromise<GetGlossaryTermAggregateType<T>>

    /**
     * Group by GlossaryTerm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlossaryTermGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GlossaryTermGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GlossaryTermGroupByArgs['orderBy'] }
        : { orderBy?: GlossaryTermGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GlossaryTermGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGlossaryTermGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GlossaryTerm model
   */
  readonly fields: GlossaryTermFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GlossaryTerm.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GlossaryTermClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GlossaryTerm model
   */
  interface GlossaryTermFieldRefs {
    readonly id: FieldRef<"GlossaryTerm", 'String'>
    readonly term: FieldRef<"GlossaryTerm", 'String'>
    readonly slug: FieldRef<"GlossaryTerm", 'String'>
    readonly definitionMd: FieldRef<"GlossaryTerm", 'String'>
    readonly examplesMd: FieldRef<"GlossaryTerm", 'String'>
    readonly createdAt: FieldRef<"GlossaryTerm", 'DateTime'>
    readonly updatedAt: FieldRef<"GlossaryTerm", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GlossaryTerm findUnique
   */
  export type GlossaryTermFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlossaryTerm
     */
    select?: GlossaryTermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlossaryTerm
     */
    omit?: GlossaryTermOmit<ExtArgs> | null
    /**
     * Filter, which GlossaryTerm to fetch.
     */
    where: GlossaryTermWhereUniqueInput
  }

  /**
   * GlossaryTerm findUniqueOrThrow
   */
  export type GlossaryTermFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlossaryTerm
     */
    select?: GlossaryTermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlossaryTerm
     */
    omit?: GlossaryTermOmit<ExtArgs> | null
    /**
     * Filter, which GlossaryTerm to fetch.
     */
    where: GlossaryTermWhereUniqueInput
  }

  /**
   * GlossaryTerm findFirst
   */
  export type GlossaryTermFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlossaryTerm
     */
    select?: GlossaryTermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlossaryTerm
     */
    omit?: GlossaryTermOmit<ExtArgs> | null
    /**
     * Filter, which GlossaryTerm to fetch.
     */
    where?: GlossaryTermWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GlossaryTerms to fetch.
     */
    orderBy?: GlossaryTermOrderByWithRelationInput | GlossaryTermOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GlossaryTerms.
     */
    cursor?: GlossaryTermWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GlossaryTerms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GlossaryTerms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GlossaryTerms.
     */
    distinct?: GlossaryTermScalarFieldEnum | GlossaryTermScalarFieldEnum[]
  }

  /**
   * GlossaryTerm findFirstOrThrow
   */
  export type GlossaryTermFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlossaryTerm
     */
    select?: GlossaryTermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlossaryTerm
     */
    omit?: GlossaryTermOmit<ExtArgs> | null
    /**
     * Filter, which GlossaryTerm to fetch.
     */
    where?: GlossaryTermWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GlossaryTerms to fetch.
     */
    orderBy?: GlossaryTermOrderByWithRelationInput | GlossaryTermOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GlossaryTerms.
     */
    cursor?: GlossaryTermWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GlossaryTerms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GlossaryTerms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GlossaryTerms.
     */
    distinct?: GlossaryTermScalarFieldEnum | GlossaryTermScalarFieldEnum[]
  }

  /**
   * GlossaryTerm findMany
   */
  export type GlossaryTermFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlossaryTerm
     */
    select?: GlossaryTermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlossaryTerm
     */
    omit?: GlossaryTermOmit<ExtArgs> | null
    /**
     * Filter, which GlossaryTerms to fetch.
     */
    where?: GlossaryTermWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GlossaryTerms to fetch.
     */
    orderBy?: GlossaryTermOrderByWithRelationInput | GlossaryTermOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GlossaryTerms.
     */
    cursor?: GlossaryTermWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GlossaryTerms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GlossaryTerms.
     */
    skip?: number
    distinct?: GlossaryTermScalarFieldEnum | GlossaryTermScalarFieldEnum[]
  }

  /**
   * GlossaryTerm create
   */
  export type GlossaryTermCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlossaryTerm
     */
    select?: GlossaryTermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlossaryTerm
     */
    omit?: GlossaryTermOmit<ExtArgs> | null
    /**
     * The data needed to create a GlossaryTerm.
     */
    data: XOR<GlossaryTermCreateInput, GlossaryTermUncheckedCreateInput>
  }

  /**
   * GlossaryTerm createMany
   */
  export type GlossaryTermCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GlossaryTerms.
     */
    data: GlossaryTermCreateManyInput | GlossaryTermCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GlossaryTerm createManyAndReturn
   */
  export type GlossaryTermCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlossaryTerm
     */
    select?: GlossaryTermSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GlossaryTerm
     */
    omit?: GlossaryTermOmit<ExtArgs> | null
    /**
     * The data used to create many GlossaryTerms.
     */
    data: GlossaryTermCreateManyInput | GlossaryTermCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GlossaryTerm update
   */
  export type GlossaryTermUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlossaryTerm
     */
    select?: GlossaryTermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlossaryTerm
     */
    omit?: GlossaryTermOmit<ExtArgs> | null
    /**
     * The data needed to update a GlossaryTerm.
     */
    data: XOR<GlossaryTermUpdateInput, GlossaryTermUncheckedUpdateInput>
    /**
     * Choose, which GlossaryTerm to update.
     */
    where: GlossaryTermWhereUniqueInput
  }

  /**
   * GlossaryTerm updateMany
   */
  export type GlossaryTermUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GlossaryTerms.
     */
    data: XOR<GlossaryTermUpdateManyMutationInput, GlossaryTermUncheckedUpdateManyInput>
    /**
     * Filter which GlossaryTerms to update
     */
    where?: GlossaryTermWhereInput
    /**
     * Limit how many GlossaryTerms to update.
     */
    limit?: number
  }

  /**
   * GlossaryTerm updateManyAndReturn
   */
  export type GlossaryTermUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlossaryTerm
     */
    select?: GlossaryTermSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GlossaryTerm
     */
    omit?: GlossaryTermOmit<ExtArgs> | null
    /**
     * The data used to update GlossaryTerms.
     */
    data: XOR<GlossaryTermUpdateManyMutationInput, GlossaryTermUncheckedUpdateManyInput>
    /**
     * Filter which GlossaryTerms to update
     */
    where?: GlossaryTermWhereInput
    /**
     * Limit how many GlossaryTerms to update.
     */
    limit?: number
  }

  /**
   * GlossaryTerm upsert
   */
  export type GlossaryTermUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlossaryTerm
     */
    select?: GlossaryTermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlossaryTerm
     */
    omit?: GlossaryTermOmit<ExtArgs> | null
    /**
     * The filter to search for the GlossaryTerm to update in case it exists.
     */
    where: GlossaryTermWhereUniqueInput
    /**
     * In case the GlossaryTerm found by the `where` argument doesn't exist, create a new GlossaryTerm with this data.
     */
    create: XOR<GlossaryTermCreateInput, GlossaryTermUncheckedCreateInput>
    /**
     * In case the GlossaryTerm was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GlossaryTermUpdateInput, GlossaryTermUncheckedUpdateInput>
  }

  /**
   * GlossaryTerm delete
   */
  export type GlossaryTermDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlossaryTerm
     */
    select?: GlossaryTermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlossaryTerm
     */
    omit?: GlossaryTermOmit<ExtArgs> | null
    /**
     * Filter which GlossaryTerm to delete.
     */
    where: GlossaryTermWhereUniqueInput
  }

  /**
   * GlossaryTerm deleteMany
   */
  export type GlossaryTermDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GlossaryTerms to delete
     */
    where?: GlossaryTermWhereInput
    /**
     * Limit how many GlossaryTerms to delete.
     */
    limit?: number
  }

  /**
   * GlossaryTerm without action
   */
  export type GlossaryTermDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlossaryTerm
     */
    select?: GlossaryTermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlossaryTerm
     */
    omit?: GlossaryTermOmit<ExtArgs> | null
  }


  /**
   * Model SourceDocument
   */

  export type AggregateSourceDocument = {
    _count: SourceDocumentCountAggregateOutputType | null
    _min: SourceDocumentMinAggregateOutputType | null
    _max: SourceDocumentMaxAggregateOutputType | null
  }

  export type SourceDocumentMinAggregateOutputType = {
    id: string | null
    title: string | null
    url: string | null
    storageKey: string | null
    publisher: string | null
    publishedAt: Date | null
    capturedAt: Date | null
    methodNote: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SourceDocumentMaxAggregateOutputType = {
    id: string | null
    title: string | null
    url: string | null
    storageKey: string | null
    publisher: string | null
    publishedAt: Date | null
    capturedAt: Date | null
    methodNote: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SourceDocumentCountAggregateOutputType = {
    id: number
    title: number
    url: number
    storageKey: number
    publisher: number
    publishedAt: number
    capturedAt: number
    methodNote: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SourceDocumentMinAggregateInputType = {
    id?: true
    title?: true
    url?: true
    storageKey?: true
    publisher?: true
    publishedAt?: true
    capturedAt?: true
    methodNote?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SourceDocumentMaxAggregateInputType = {
    id?: true
    title?: true
    url?: true
    storageKey?: true
    publisher?: true
    publishedAt?: true
    capturedAt?: true
    methodNote?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SourceDocumentCountAggregateInputType = {
    id?: true
    title?: true
    url?: true
    storageKey?: true
    publisher?: true
    publishedAt?: true
    capturedAt?: true
    methodNote?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SourceDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SourceDocument to aggregate.
     */
    where?: SourceDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SourceDocuments to fetch.
     */
    orderBy?: SourceDocumentOrderByWithRelationInput | SourceDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SourceDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SourceDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SourceDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SourceDocuments
    **/
    _count?: true | SourceDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SourceDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SourceDocumentMaxAggregateInputType
  }

  export type GetSourceDocumentAggregateType<T extends SourceDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateSourceDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSourceDocument[P]>
      : GetScalarType<T[P], AggregateSourceDocument[P]>
  }




  export type SourceDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SourceDocumentWhereInput
    orderBy?: SourceDocumentOrderByWithAggregationInput | SourceDocumentOrderByWithAggregationInput[]
    by: SourceDocumentScalarFieldEnum[] | SourceDocumentScalarFieldEnum
    having?: SourceDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SourceDocumentCountAggregateInputType | true
    _min?: SourceDocumentMinAggregateInputType
    _max?: SourceDocumentMaxAggregateInputType
  }

  export type SourceDocumentGroupByOutputType = {
    id: string
    title: string
    url: string | null
    storageKey: string | null
    publisher: string | null
    publishedAt: Date | null
    capturedAt: Date | null
    methodNote: string | null
    createdAt: Date
    updatedAt: Date
    _count: SourceDocumentCountAggregateOutputType | null
    _min: SourceDocumentMinAggregateOutputType | null
    _max: SourceDocumentMaxAggregateOutputType | null
  }

  type GetSourceDocumentGroupByPayload<T extends SourceDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SourceDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SourceDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SourceDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], SourceDocumentGroupByOutputType[P]>
        }
      >
    >


  export type SourceDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    url?: boolean
    storageKey?: boolean
    publisher?: boolean
    publishedAt?: boolean
    capturedAt?: boolean
    methodNote?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    chunks?: boolean | SourceDocument$chunksArgs<ExtArgs>
    citations?: boolean | SourceDocument$citationsArgs<ExtArgs>
    runInputs?: boolean | SourceDocument$runInputsArgs<ExtArgs>
    sourceLinks?: boolean | SourceDocument$sourceLinksArgs<ExtArgs>
    _count?: boolean | SourceDocumentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sourceDocument"]>

  export type SourceDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    url?: boolean
    storageKey?: boolean
    publisher?: boolean
    publishedAt?: boolean
    capturedAt?: boolean
    methodNote?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["sourceDocument"]>

  export type SourceDocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    url?: boolean
    storageKey?: boolean
    publisher?: boolean
    publishedAt?: boolean
    capturedAt?: boolean
    methodNote?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["sourceDocument"]>

  export type SourceDocumentSelectScalar = {
    id?: boolean
    title?: boolean
    url?: boolean
    storageKey?: boolean
    publisher?: boolean
    publishedAt?: boolean
    capturedAt?: boolean
    methodNote?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SourceDocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "url" | "storageKey" | "publisher" | "publishedAt" | "capturedAt" | "methodNote" | "createdAt" | "updatedAt", ExtArgs["result"]["sourceDocument"]>
  export type SourceDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chunks?: boolean | SourceDocument$chunksArgs<ExtArgs>
    citations?: boolean | SourceDocument$citationsArgs<ExtArgs>
    runInputs?: boolean | SourceDocument$runInputsArgs<ExtArgs>
    sourceLinks?: boolean | SourceDocument$sourceLinksArgs<ExtArgs>
    _count?: boolean | SourceDocumentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SourceDocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SourceDocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SourceDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SourceDocument"
    objects: {
      chunks: Prisma.$SourceChunkPayload<ExtArgs>[]
      citations: Prisma.$CitationPayload<ExtArgs>[]
      runInputs: Prisma.$AIRunInputSourcePayload<ExtArgs>[]
      sourceLinks: Prisma.$SourceDocumentLinkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      url: string | null
      storageKey: string | null
      publisher: string | null
      publishedAt: Date | null
      capturedAt: Date | null
      methodNote: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sourceDocument"]>
    composites: {}
  }

  type SourceDocumentGetPayload<S extends boolean | null | undefined | SourceDocumentDefaultArgs> = $Result.GetResult<Prisma.$SourceDocumentPayload, S>

  type SourceDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SourceDocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SourceDocumentCountAggregateInputType | true
    }

  export interface SourceDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SourceDocument'], meta: { name: 'SourceDocument' } }
    /**
     * Find zero or one SourceDocument that matches the filter.
     * @param {SourceDocumentFindUniqueArgs} args - Arguments to find a SourceDocument
     * @example
     * // Get one SourceDocument
     * const sourceDocument = await prisma.sourceDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SourceDocumentFindUniqueArgs>(args: SelectSubset<T, SourceDocumentFindUniqueArgs<ExtArgs>>): Prisma__SourceDocumentClient<$Result.GetResult<Prisma.$SourceDocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SourceDocument that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SourceDocumentFindUniqueOrThrowArgs} args - Arguments to find a SourceDocument
     * @example
     * // Get one SourceDocument
     * const sourceDocument = await prisma.sourceDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SourceDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, SourceDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SourceDocumentClient<$Result.GetResult<Prisma.$SourceDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SourceDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceDocumentFindFirstArgs} args - Arguments to find a SourceDocument
     * @example
     * // Get one SourceDocument
     * const sourceDocument = await prisma.sourceDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SourceDocumentFindFirstArgs>(args?: SelectSubset<T, SourceDocumentFindFirstArgs<ExtArgs>>): Prisma__SourceDocumentClient<$Result.GetResult<Prisma.$SourceDocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SourceDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceDocumentFindFirstOrThrowArgs} args - Arguments to find a SourceDocument
     * @example
     * // Get one SourceDocument
     * const sourceDocument = await prisma.sourceDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SourceDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, SourceDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__SourceDocumentClient<$Result.GetResult<Prisma.$SourceDocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SourceDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SourceDocuments
     * const sourceDocuments = await prisma.sourceDocument.findMany()
     * 
     * // Get first 10 SourceDocuments
     * const sourceDocuments = await prisma.sourceDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sourceDocumentWithIdOnly = await prisma.sourceDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SourceDocumentFindManyArgs>(args?: SelectSubset<T, SourceDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourceDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SourceDocument.
     * @param {SourceDocumentCreateArgs} args - Arguments to create a SourceDocument.
     * @example
     * // Create one SourceDocument
     * const SourceDocument = await prisma.sourceDocument.create({
     *   data: {
     *     // ... data to create a SourceDocument
     *   }
     * })
     * 
     */
    create<T extends SourceDocumentCreateArgs>(args: SelectSubset<T, SourceDocumentCreateArgs<ExtArgs>>): Prisma__SourceDocumentClient<$Result.GetResult<Prisma.$SourceDocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SourceDocuments.
     * @param {SourceDocumentCreateManyArgs} args - Arguments to create many SourceDocuments.
     * @example
     * // Create many SourceDocuments
     * const sourceDocument = await prisma.sourceDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SourceDocumentCreateManyArgs>(args?: SelectSubset<T, SourceDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SourceDocuments and returns the data saved in the database.
     * @param {SourceDocumentCreateManyAndReturnArgs} args - Arguments to create many SourceDocuments.
     * @example
     * // Create many SourceDocuments
     * const sourceDocument = await prisma.sourceDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SourceDocuments and only return the `id`
     * const sourceDocumentWithIdOnly = await prisma.sourceDocument.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SourceDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, SourceDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourceDocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SourceDocument.
     * @param {SourceDocumentDeleteArgs} args - Arguments to delete one SourceDocument.
     * @example
     * // Delete one SourceDocument
     * const SourceDocument = await prisma.sourceDocument.delete({
     *   where: {
     *     // ... filter to delete one SourceDocument
     *   }
     * })
     * 
     */
    delete<T extends SourceDocumentDeleteArgs>(args: SelectSubset<T, SourceDocumentDeleteArgs<ExtArgs>>): Prisma__SourceDocumentClient<$Result.GetResult<Prisma.$SourceDocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SourceDocument.
     * @param {SourceDocumentUpdateArgs} args - Arguments to update one SourceDocument.
     * @example
     * // Update one SourceDocument
     * const sourceDocument = await prisma.sourceDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SourceDocumentUpdateArgs>(args: SelectSubset<T, SourceDocumentUpdateArgs<ExtArgs>>): Prisma__SourceDocumentClient<$Result.GetResult<Prisma.$SourceDocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SourceDocuments.
     * @param {SourceDocumentDeleteManyArgs} args - Arguments to filter SourceDocuments to delete.
     * @example
     * // Delete a few SourceDocuments
     * const { count } = await prisma.sourceDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SourceDocumentDeleteManyArgs>(args?: SelectSubset<T, SourceDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SourceDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SourceDocuments
     * const sourceDocument = await prisma.sourceDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SourceDocumentUpdateManyArgs>(args: SelectSubset<T, SourceDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SourceDocuments and returns the data updated in the database.
     * @param {SourceDocumentUpdateManyAndReturnArgs} args - Arguments to update many SourceDocuments.
     * @example
     * // Update many SourceDocuments
     * const sourceDocument = await prisma.sourceDocument.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SourceDocuments and only return the `id`
     * const sourceDocumentWithIdOnly = await prisma.sourceDocument.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SourceDocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, SourceDocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourceDocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SourceDocument.
     * @param {SourceDocumentUpsertArgs} args - Arguments to update or create a SourceDocument.
     * @example
     * // Update or create a SourceDocument
     * const sourceDocument = await prisma.sourceDocument.upsert({
     *   create: {
     *     // ... data to create a SourceDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SourceDocument we want to update
     *   }
     * })
     */
    upsert<T extends SourceDocumentUpsertArgs>(args: SelectSubset<T, SourceDocumentUpsertArgs<ExtArgs>>): Prisma__SourceDocumentClient<$Result.GetResult<Prisma.$SourceDocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SourceDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceDocumentCountArgs} args - Arguments to filter SourceDocuments to count.
     * @example
     * // Count the number of SourceDocuments
     * const count = await prisma.sourceDocument.count({
     *   where: {
     *     // ... the filter for the SourceDocuments we want to count
     *   }
     * })
    **/
    count<T extends SourceDocumentCountArgs>(
      args?: Subset<T, SourceDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SourceDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SourceDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SourceDocumentAggregateArgs>(args: Subset<T, SourceDocumentAggregateArgs>): Prisma.PrismaPromise<GetSourceDocumentAggregateType<T>>

    /**
     * Group by SourceDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SourceDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SourceDocumentGroupByArgs['orderBy'] }
        : { orderBy?: SourceDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SourceDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSourceDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SourceDocument model
   */
  readonly fields: SourceDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SourceDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SourceDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chunks<T extends SourceDocument$chunksArgs<ExtArgs> = {}>(args?: Subset<T, SourceDocument$chunksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourceChunkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    citations<T extends SourceDocument$citationsArgs<ExtArgs> = {}>(args?: Subset<T, SourceDocument$citationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    runInputs<T extends SourceDocument$runInputsArgs<ExtArgs> = {}>(args?: Subset<T, SourceDocument$runInputsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIRunInputSourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sourceLinks<T extends SourceDocument$sourceLinksArgs<ExtArgs> = {}>(args?: Subset<T, SourceDocument$sourceLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourceDocumentLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SourceDocument model
   */
  interface SourceDocumentFieldRefs {
    readonly id: FieldRef<"SourceDocument", 'String'>
    readonly title: FieldRef<"SourceDocument", 'String'>
    readonly url: FieldRef<"SourceDocument", 'String'>
    readonly storageKey: FieldRef<"SourceDocument", 'String'>
    readonly publisher: FieldRef<"SourceDocument", 'String'>
    readonly publishedAt: FieldRef<"SourceDocument", 'DateTime'>
    readonly capturedAt: FieldRef<"SourceDocument", 'DateTime'>
    readonly methodNote: FieldRef<"SourceDocument", 'String'>
    readonly createdAt: FieldRef<"SourceDocument", 'DateTime'>
    readonly updatedAt: FieldRef<"SourceDocument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SourceDocument findUnique
   */
  export type SourceDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceDocument
     */
    select?: SourceDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceDocument
     */
    omit?: SourceDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceDocumentInclude<ExtArgs> | null
    /**
     * Filter, which SourceDocument to fetch.
     */
    where: SourceDocumentWhereUniqueInput
  }

  /**
   * SourceDocument findUniqueOrThrow
   */
  export type SourceDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceDocument
     */
    select?: SourceDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceDocument
     */
    omit?: SourceDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceDocumentInclude<ExtArgs> | null
    /**
     * Filter, which SourceDocument to fetch.
     */
    where: SourceDocumentWhereUniqueInput
  }

  /**
   * SourceDocument findFirst
   */
  export type SourceDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceDocument
     */
    select?: SourceDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceDocument
     */
    omit?: SourceDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceDocumentInclude<ExtArgs> | null
    /**
     * Filter, which SourceDocument to fetch.
     */
    where?: SourceDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SourceDocuments to fetch.
     */
    orderBy?: SourceDocumentOrderByWithRelationInput | SourceDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SourceDocuments.
     */
    cursor?: SourceDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SourceDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SourceDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SourceDocuments.
     */
    distinct?: SourceDocumentScalarFieldEnum | SourceDocumentScalarFieldEnum[]
  }

  /**
   * SourceDocument findFirstOrThrow
   */
  export type SourceDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceDocument
     */
    select?: SourceDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceDocument
     */
    omit?: SourceDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceDocumentInclude<ExtArgs> | null
    /**
     * Filter, which SourceDocument to fetch.
     */
    where?: SourceDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SourceDocuments to fetch.
     */
    orderBy?: SourceDocumentOrderByWithRelationInput | SourceDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SourceDocuments.
     */
    cursor?: SourceDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SourceDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SourceDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SourceDocuments.
     */
    distinct?: SourceDocumentScalarFieldEnum | SourceDocumentScalarFieldEnum[]
  }

  /**
   * SourceDocument findMany
   */
  export type SourceDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceDocument
     */
    select?: SourceDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceDocument
     */
    omit?: SourceDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceDocumentInclude<ExtArgs> | null
    /**
     * Filter, which SourceDocuments to fetch.
     */
    where?: SourceDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SourceDocuments to fetch.
     */
    orderBy?: SourceDocumentOrderByWithRelationInput | SourceDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SourceDocuments.
     */
    cursor?: SourceDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SourceDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SourceDocuments.
     */
    skip?: number
    distinct?: SourceDocumentScalarFieldEnum | SourceDocumentScalarFieldEnum[]
  }

  /**
   * SourceDocument create
   */
  export type SourceDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceDocument
     */
    select?: SourceDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceDocument
     */
    omit?: SourceDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a SourceDocument.
     */
    data: XOR<SourceDocumentCreateInput, SourceDocumentUncheckedCreateInput>
  }

  /**
   * SourceDocument createMany
   */
  export type SourceDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SourceDocuments.
     */
    data: SourceDocumentCreateManyInput | SourceDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SourceDocument createManyAndReturn
   */
  export type SourceDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceDocument
     */
    select?: SourceDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SourceDocument
     */
    omit?: SourceDocumentOmit<ExtArgs> | null
    /**
     * The data used to create many SourceDocuments.
     */
    data: SourceDocumentCreateManyInput | SourceDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SourceDocument update
   */
  export type SourceDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceDocument
     */
    select?: SourceDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceDocument
     */
    omit?: SourceDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a SourceDocument.
     */
    data: XOR<SourceDocumentUpdateInput, SourceDocumentUncheckedUpdateInput>
    /**
     * Choose, which SourceDocument to update.
     */
    where: SourceDocumentWhereUniqueInput
  }

  /**
   * SourceDocument updateMany
   */
  export type SourceDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SourceDocuments.
     */
    data: XOR<SourceDocumentUpdateManyMutationInput, SourceDocumentUncheckedUpdateManyInput>
    /**
     * Filter which SourceDocuments to update
     */
    where?: SourceDocumentWhereInput
    /**
     * Limit how many SourceDocuments to update.
     */
    limit?: number
  }

  /**
   * SourceDocument updateManyAndReturn
   */
  export type SourceDocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceDocument
     */
    select?: SourceDocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SourceDocument
     */
    omit?: SourceDocumentOmit<ExtArgs> | null
    /**
     * The data used to update SourceDocuments.
     */
    data: XOR<SourceDocumentUpdateManyMutationInput, SourceDocumentUncheckedUpdateManyInput>
    /**
     * Filter which SourceDocuments to update
     */
    where?: SourceDocumentWhereInput
    /**
     * Limit how many SourceDocuments to update.
     */
    limit?: number
  }

  /**
   * SourceDocument upsert
   */
  export type SourceDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceDocument
     */
    select?: SourceDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceDocument
     */
    omit?: SourceDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the SourceDocument to update in case it exists.
     */
    where: SourceDocumentWhereUniqueInput
    /**
     * In case the SourceDocument found by the `where` argument doesn't exist, create a new SourceDocument with this data.
     */
    create: XOR<SourceDocumentCreateInput, SourceDocumentUncheckedCreateInput>
    /**
     * In case the SourceDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SourceDocumentUpdateInput, SourceDocumentUncheckedUpdateInput>
  }

  /**
   * SourceDocument delete
   */
  export type SourceDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceDocument
     */
    select?: SourceDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceDocument
     */
    omit?: SourceDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceDocumentInclude<ExtArgs> | null
    /**
     * Filter which SourceDocument to delete.
     */
    where: SourceDocumentWhereUniqueInput
  }

  /**
   * SourceDocument deleteMany
   */
  export type SourceDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SourceDocuments to delete
     */
    where?: SourceDocumentWhereInput
    /**
     * Limit how many SourceDocuments to delete.
     */
    limit?: number
  }

  /**
   * SourceDocument.chunks
   */
  export type SourceDocument$chunksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceChunk
     */
    select?: SourceChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceChunk
     */
    omit?: SourceChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceChunkInclude<ExtArgs> | null
    where?: SourceChunkWhereInput
    orderBy?: SourceChunkOrderByWithRelationInput | SourceChunkOrderByWithRelationInput[]
    cursor?: SourceChunkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SourceChunkScalarFieldEnum | SourceChunkScalarFieldEnum[]
  }

  /**
   * SourceDocument.citations
   */
  export type SourceDocument$citationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Citation
     */
    select?: CitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Citation
     */
    omit?: CitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CitationInclude<ExtArgs> | null
    where?: CitationWhereInput
    orderBy?: CitationOrderByWithRelationInput | CitationOrderByWithRelationInput[]
    cursor?: CitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CitationScalarFieldEnum | CitationScalarFieldEnum[]
  }

  /**
   * SourceDocument.runInputs
   */
  export type SourceDocument$runInputsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRunInputSource
     */
    select?: AIRunInputSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRunInputSource
     */
    omit?: AIRunInputSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRunInputSourceInclude<ExtArgs> | null
    where?: AIRunInputSourceWhereInput
    orderBy?: AIRunInputSourceOrderByWithRelationInput | AIRunInputSourceOrderByWithRelationInput[]
    cursor?: AIRunInputSourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIRunInputSourceScalarFieldEnum | AIRunInputSourceScalarFieldEnum[]
  }

  /**
   * SourceDocument.sourceLinks
   */
  export type SourceDocument$sourceLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceDocumentLink
     */
    select?: SourceDocumentLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceDocumentLink
     */
    omit?: SourceDocumentLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceDocumentLinkInclude<ExtArgs> | null
    where?: SourceDocumentLinkWhereInput
    orderBy?: SourceDocumentLinkOrderByWithRelationInput | SourceDocumentLinkOrderByWithRelationInput[]
    cursor?: SourceDocumentLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SourceDocumentLinkScalarFieldEnum | SourceDocumentLinkScalarFieldEnum[]
  }

  /**
   * SourceDocument without action
   */
  export type SourceDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceDocument
     */
    select?: SourceDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceDocument
     */
    omit?: SourceDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceDocumentInclude<ExtArgs> | null
  }


  /**
   * Model SourceChunk
   */

  export type AggregateSourceChunk = {
    _count: SourceChunkCountAggregateOutputType | null
    _avg: SourceChunkAvgAggregateOutputType | null
    _sum: SourceChunkSumAggregateOutputType | null
    _min: SourceChunkMinAggregateOutputType | null
    _max: SourceChunkMaxAggregateOutputType | null
  }

  export type SourceChunkAvgAggregateOutputType = {
    chunkIndex: number | null
  }

  export type SourceChunkSumAggregateOutputType = {
    chunkIndex: number | null
  }

  export type SourceChunkMinAggregateOutputType = {
    id: string | null
    sourceDocumentId: string | null
    chunkIndex: number | null
    content: string | null
    contentHash: string | null
    createdAt: Date | null
  }

  export type SourceChunkMaxAggregateOutputType = {
    id: string | null
    sourceDocumentId: string | null
    chunkIndex: number | null
    content: string | null
    contentHash: string | null
    createdAt: Date | null
  }

  export type SourceChunkCountAggregateOutputType = {
    id: number
    sourceDocumentId: number
    chunkIndex: number
    content: number
    contentHash: number
    locatorJson: number
    createdAt: number
    _all: number
  }


  export type SourceChunkAvgAggregateInputType = {
    chunkIndex?: true
  }

  export type SourceChunkSumAggregateInputType = {
    chunkIndex?: true
  }

  export type SourceChunkMinAggregateInputType = {
    id?: true
    sourceDocumentId?: true
    chunkIndex?: true
    content?: true
    contentHash?: true
    createdAt?: true
  }

  export type SourceChunkMaxAggregateInputType = {
    id?: true
    sourceDocumentId?: true
    chunkIndex?: true
    content?: true
    contentHash?: true
    createdAt?: true
  }

  export type SourceChunkCountAggregateInputType = {
    id?: true
    sourceDocumentId?: true
    chunkIndex?: true
    content?: true
    contentHash?: true
    locatorJson?: true
    createdAt?: true
    _all?: true
  }

  export type SourceChunkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SourceChunk to aggregate.
     */
    where?: SourceChunkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SourceChunks to fetch.
     */
    orderBy?: SourceChunkOrderByWithRelationInput | SourceChunkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SourceChunkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SourceChunks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SourceChunks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SourceChunks
    **/
    _count?: true | SourceChunkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SourceChunkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SourceChunkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SourceChunkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SourceChunkMaxAggregateInputType
  }

  export type GetSourceChunkAggregateType<T extends SourceChunkAggregateArgs> = {
        [P in keyof T & keyof AggregateSourceChunk]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSourceChunk[P]>
      : GetScalarType<T[P], AggregateSourceChunk[P]>
  }




  export type SourceChunkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SourceChunkWhereInput
    orderBy?: SourceChunkOrderByWithAggregationInput | SourceChunkOrderByWithAggregationInput[]
    by: SourceChunkScalarFieldEnum[] | SourceChunkScalarFieldEnum
    having?: SourceChunkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SourceChunkCountAggregateInputType | true
    _avg?: SourceChunkAvgAggregateInputType
    _sum?: SourceChunkSumAggregateInputType
    _min?: SourceChunkMinAggregateInputType
    _max?: SourceChunkMaxAggregateInputType
  }

  export type SourceChunkGroupByOutputType = {
    id: string
    sourceDocumentId: string
    chunkIndex: number
    content: string
    contentHash: string
    locatorJson: JsonValue | null
    createdAt: Date
    _count: SourceChunkCountAggregateOutputType | null
    _avg: SourceChunkAvgAggregateOutputType | null
    _sum: SourceChunkSumAggregateOutputType | null
    _min: SourceChunkMinAggregateOutputType | null
    _max: SourceChunkMaxAggregateOutputType | null
  }

  type GetSourceChunkGroupByPayload<T extends SourceChunkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SourceChunkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SourceChunkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SourceChunkGroupByOutputType[P]>
            : GetScalarType<T[P], SourceChunkGroupByOutputType[P]>
        }
      >
    >


  export type SourceChunkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sourceDocumentId?: boolean
    chunkIndex?: boolean
    content?: boolean
    contentHash?: boolean
    locatorJson?: boolean
    createdAt?: boolean
    sourceDocument?: boolean | SourceDocumentDefaultArgs<ExtArgs>
    citations?: boolean | SourceChunk$citationsArgs<ExtArgs>
    _count?: boolean | SourceChunkCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sourceChunk"]>

  export type SourceChunkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sourceDocumentId?: boolean
    chunkIndex?: boolean
    content?: boolean
    contentHash?: boolean
    locatorJson?: boolean
    createdAt?: boolean
    sourceDocument?: boolean | SourceDocumentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sourceChunk"]>

  export type SourceChunkSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sourceDocumentId?: boolean
    chunkIndex?: boolean
    content?: boolean
    contentHash?: boolean
    locatorJson?: boolean
    createdAt?: boolean
    sourceDocument?: boolean | SourceDocumentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sourceChunk"]>

  export type SourceChunkSelectScalar = {
    id?: boolean
    sourceDocumentId?: boolean
    chunkIndex?: boolean
    content?: boolean
    contentHash?: boolean
    locatorJson?: boolean
    createdAt?: boolean
  }

  export type SourceChunkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sourceDocumentId" | "chunkIndex" | "content" | "contentHash" | "locatorJson" | "createdAt", ExtArgs["result"]["sourceChunk"]>
  export type SourceChunkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sourceDocument?: boolean | SourceDocumentDefaultArgs<ExtArgs>
    citations?: boolean | SourceChunk$citationsArgs<ExtArgs>
    _count?: boolean | SourceChunkCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SourceChunkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sourceDocument?: boolean | SourceDocumentDefaultArgs<ExtArgs>
  }
  export type SourceChunkIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sourceDocument?: boolean | SourceDocumentDefaultArgs<ExtArgs>
  }

  export type $SourceChunkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SourceChunk"
    objects: {
      sourceDocument: Prisma.$SourceDocumentPayload<ExtArgs>
      citations: Prisma.$CitationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sourceDocumentId: string
      chunkIndex: number
      content: string
      contentHash: string
      locatorJson: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["sourceChunk"]>
    composites: {}
  }

  type SourceChunkGetPayload<S extends boolean | null | undefined | SourceChunkDefaultArgs> = $Result.GetResult<Prisma.$SourceChunkPayload, S>

  type SourceChunkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SourceChunkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SourceChunkCountAggregateInputType | true
    }

  export interface SourceChunkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SourceChunk'], meta: { name: 'SourceChunk' } }
    /**
     * Find zero or one SourceChunk that matches the filter.
     * @param {SourceChunkFindUniqueArgs} args - Arguments to find a SourceChunk
     * @example
     * // Get one SourceChunk
     * const sourceChunk = await prisma.sourceChunk.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SourceChunkFindUniqueArgs>(args: SelectSubset<T, SourceChunkFindUniqueArgs<ExtArgs>>): Prisma__SourceChunkClient<$Result.GetResult<Prisma.$SourceChunkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SourceChunk that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SourceChunkFindUniqueOrThrowArgs} args - Arguments to find a SourceChunk
     * @example
     * // Get one SourceChunk
     * const sourceChunk = await prisma.sourceChunk.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SourceChunkFindUniqueOrThrowArgs>(args: SelectSubset<T, SourceChunkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SourceChunkClient<$Result.GetResult<Prisma.$SourceChunkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SourceChunk that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceChunkFindFirstArgs} args - Arguments to find a SourceChunk
     * @example
     * // Get one SourceChunk
     * const sourceChunk = await prisma.sourceChunk.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SourceChunkFindFirstArgs>(args?: SelectSubset<T, SourceChunkFindFirstArgs<ExtArgs>>): Prisma__SourceChunkClient<$Result.GetResult<Prisma.$SourceChunkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SourceChunk that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceChunkFindFirstOrThrowArgs} args - Arguments to find a SourceChunk
     * @example
     * // Get one SourceChunk
     * const sourceChunk = await prisma.sourceChunk.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SourceChunkFindFirstOrThrowArgs>(args?: SelectSubset<T, SourceChunkFindFirstOrThrowArgs<ExtArgs>>): Prisma__SourceChunkClient<$Result.GetResult<Prisma.$SourceChunkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SourceChunks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceChunkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SourceChunks
     * const sourceChunks = await prisma.sourceChunk.findMany()
     * 
     * // Get first 10 SourceChunks
     * const sourceChunks = await prisma.sourceChunk.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sourceChunkWithIdOnly = await prisma.sourceChunk.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SourceChunkFindManyArgs>(args?: SelectSubset<T, SourceChunkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourceChunkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SourceChunk.
     * @param {SourceChunkCreateArgs} args - Arguments to create a SourceChunk.
     * @example
     * // Create one SourceChunk
     * const SourceChunk = await prisma.sourceChunk.create({
     *   data: {
     *     // ... data to create a SourceChunk
     *   }
     * })
     * 
     */
    create<T extends SourceChunkCreateArgs>(args: SelectSubset<T, SourceChunkCreateArgs<ExtArgs>>): Prisma__SourceChunkClient<$Result.GetResult<Prisma.$SourceChunkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SourceChunks.
     * @param {SourceChunkCreateManyArgs} args - Arguments to create many SourceChunks.
     * @example
     * // Create many SourceChunks
     * const sourceChunk = await prisma.sourceChunk.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SourceChunkCreateManyArgs>(args?: SelectSubset<T, SourceChunkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SourceChunks and returns the data saved in the database.
     * @param {SourceChunkCreateManyAndReturnArgs} args - Arguments to create many SourceChunks.
     * @example
     * // Create many SourceChunks
     * const sourceChunk = await prisma.sourceChunk.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SourceChunks and only return the `id`
     * const sourceChunkWithIdOnly = await prisma.sourceChunk.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SourceChunkCreateManyAndReturnArgs>(args?: SelectSubset<T, SourceChunkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourceChunkPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SourceChunk.
     * @param {SourceChunkDeleteArgs} args - Arguments to delete one SourceChunk.
     * @example
     * // Delete one SourceChunk
     * const SourceChunk = await prisma.sourceChunk.delete({
     *   where: {
     *     // ... filter to delete one SourceChunk
     *   }
     * })
     * 
     */
    delete<T extends SourceChunkDeleteArgs>(args: SelectSubset<T, SourceChunkDeleteArgs<ExtArgs>>): Prisma__SourceChunkClient<$Result.GetResult<Prisma.$SourceChunkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SourceChunk.
     * @param {SourceChunkUpdateArgs} args - Arguments to update one SourceChunk.
     * @example
     * // Update one SourceChunk
     * const sourceChunk = await prisma.sourceChunk.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SourceChunkUpdateArgs>(args: SelectSubset<T, SourceChunkUpdateArgs<ExtArgs>>): Prisma__SourceChunkClient<$Result.GetResult<Prisma.$SourceChunkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SourceChunks.
     * @param {SourceChunkDeleteManyArgs} args - Arguments to filter SourceChunks to delete.
     * @example
     * // Delete a few SourceChunks
     * const { count } = await prisma.sourceChunk.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SourceChunkDeleteManyArgs>(args?: SelectSubset<T, SourceChunkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SourceChunks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceChunkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SourceChunks
     * const sourceChunk = await prisma.sourceChunk.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SourceChunkUpdateManyArgs>(args: SelectSubset<T, SourceChunkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SourceChunks and returns the data updated in the database.
     * @param {SourceChunkUpdateManyAndReturnArgs} args - Arguments to update many SourceChunks.
     * @example
     * // Update many SourceChunks
     * const sourceChunk = await prisma.sourceChunk.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SourceChunks and only return the `id`
     * const sourceChunkWithIdOnly = await prisma.sourceChunk.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SourceChunkUpdateManyAndReturnArgs>(args: SelectSubset<T, SourceChunkUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourceChunkPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SourceChunk.
     * @param {SourceChunkUpsertArgs} args - Arguments to update or create a SourceChunk.
     * @example
     * // Update or create a SourceChunk
     * const sourceChunk = await prisma.sourceChunk.upsert({
     *   create: {
     *     // ... data to create a SourceChunk
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SourceChunk we want to update
     *   }
     * })
     */
    upsert<T extends SourceChunkUpsertArgs>(args: SelectSubset<T, SourceChunkUpsertArgs<ExtArgs>>): Prisma__SourceChunkClient<$Result.GetResult<Prisma.$SourceChunkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SourceChunks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceChunkCountArgs} args - Arguments to filter SourceChunks to count.
     * @example
     * // Count the number of SourceChunks
     * const count = await prisma.sourceChunk.count({
     *   where: {
     *     // ... the filter for the SourceChunks we want to count
     *   }
     * })
    **/
    count<T extends SourceChunkCountArgs>(
      args?: Subset<T, SourceChunkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SourceChunkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SourceChunk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceChunkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SourceChunkAggregateArgs>(args: Subset<T, SourceChunkAggregateArgs>): Prisma.PrismaPromise<GetSourceChunkAggregateType<T>>

    /**
     * Group by SourceChunk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceChunkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SourceChunkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SourceChunkGroupByArgs['orderBy'] }
        : { orderBy?: SourceChunkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SourceChunkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSourceChunkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SourceChunk model
   */
  readonly fields: SourceChunkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SourceChunk.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SourceChunkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sourceDocument<T extends SourceDocumentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SourceDocumentDefaultArgs<ExtArgs>>): Prisma__SourceDocumentClient<$Result.GetResult<Prisma.$SourceDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    citations<T extends SourceChunk$citationsArgs<ExtArgs> = {}>(args?: Subset<T, SourceChunk$citationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SourceChunk model
   */
  interface SourceChunkFieldRefs {
    readonly id: FieldRef<"SourceChunk", 'String'>
    readonly sourceDocumentId: FieldRef<"SourceChunk", 'String'>
    readonly chunkIndex: FieldRef<"SourceChunk", 'Int'>
    readonly content: FieldRef<"SourceChunk", 'String'>
    readonly contentHash: FieldRef<"SourceChunk", 'String'>
    readonly locatorJson: FieldRef<"SourceChunk", 'Json'>
    readonly createdAt: FieldRef<"SourceChunk", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SourceChunk findUnique
   */
  export type SourceChunkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceChunk
     */
    select?: SourceChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceChunk
     */
    omit?: SourceChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceChunkInclude<ExtArgs> | null
    /**
     * Filter, which SourceChunk to fetch.
     */
    where: SourceChunkWhereUniqueInput
  }

  /**
   * SourceChunk findUniqueOrThrow
   */
  export type SourceChunkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceChunk
     */
    select?: SourceChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceChunk
     */
    omit?: SourceChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceChunkInclude<ExtArgs> | null
    /**
     * Filter, which SourceChunk to fetch.
     */
    where: SourceChunkWhereUniqueInput
  }

  /**
   * SourceChunk findFirst
   */
  export type SourceChunkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceChunk
     */
    select?: SourceChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceChunk
     */
    omit?: SourceChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceChunkInclude<ExtArgs> | null
    /**
     * Filter, which SourceChunk to fetch.
     */
    where?: SourceChunkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SourceChunks to fetch.
     */
    orderBy?: SourceChunkOrderByWithRelationInput | SourceChunkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SourceChunks.
     */
    cursor?: SourceChunkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SourceChunks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SourceChunks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SourceChunks.
     */
    distinct?: SourceChunkScalarFieldEnum | SourceChunkScalarFieldEnum[]
  }

  /**
   * SourceChunk findFirstOrThrow
   */
  export type SourceChunkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceChunk
     */
    select?: SourceChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceChunk
     */
    omit?: SourceChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceChunkInclude<ExtArgs> | null
    /**
     * Filter, which SourceChunk to fetch.
     */
    where?: SourceChunkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SourceChunks to fetch.
     */
    orderBy?: SourceChunkOrderByWithRelationInput | SourceChunkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SourceChunks.
     */
    cursor?: SourceChunkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SourceChunks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SourceChunks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SourceChunks.
     */
    distinct?: SourceChunkScalarFieldEnum | SourceChunkScalarFieldEnum[]
  }

  /**
   * SourceChunk findMany
   */
  export type SourceChunkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceChunk
     */
    select?: SourceChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceChunk
     */
    omit?: SourceChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceChunkInclude<ExtArgs> | null
    /**
     * Filter, which SourceChunks to fetch.
     */
    where?: SourceChunkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SourceChunks to fetch.
     */
    orderBy?: SourceChunkOrderByWithRelationInput | SourceChunkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SourceChunks.
     */
    cursor?: SourceChunkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SourceChunks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SourceChunks.
     */
    skip?: number
    distinct?: SourceChunkScalarFieldEnum | SourceChunkScalarFieldEnum[]
  }

  /**
   * SourceChunk create
   */
  export type SourceChunkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceChunk
     */
    select?: SourceChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceChunk
     */
    omit?: SourceChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceChunkInclude<ExtArgs> | null
    /**
     * The data needed to create a SourceChunk.
     */
    data: XOR<SourceChunkCreateInput, SourceChunkUncheckedCreateInput>
  }

  /**
   * SourceChunk createMany
   */
  export type SourceChunkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SourceChunks.
     */
    data: SourceChunkCreateManyInput | SourceChunkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SourceChunk createManyAndReturn
   */
  export type SourceChunkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceChunk
     */
    select?: SourceChunkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SourceChunk
     */
    omit?: SourceChunkOmit<ExtArgs> | null
    /**
     * The data used to create many SourceChunks.
     */
    data: SourceChunkCreateManyInput | SourceChunkCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceChunkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SourceChunk update
   */
  export type SourceChunkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceChunk
     */
    select?: SourceChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceChunk
     */
    omit?: SourceChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceChunkInclude<ExtArgs> | null
    /**
     * The data needed to update a SourceChunk.
     */
    data: XOR<SourceChunkUpdateInput, SourceChunkUncheckedUpdateInput>
    /**
     * Choose, which SourceChunk to update.
     */
    where: SourceChunkWhereUniqueInput
  }

  /**
   * SourceChunk updateMany
   */
  export type SourceChunkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SourceChunks.
     */
    data: XOR<SourceChunkUpdateManyMutationInput, SourceChunkUncheckedUpdateManyInput>
    /**
     * Filter which SourceChunks to update
     */
    where?: SourceChunkWhereInput
    /**
     * Limit how many SourceChunks to update.
     */
    limit?: number
  }

  /**
   * SourceChunk updateManyAndReturn
   */
  export type SourceChunkUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceChunk
     */
    select?: SourceChunkSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SourceChunk
     */
    omit?: SourceChunkOmit<ExtArgs> | null
    /**
     * The data used to update SourceChunks.
     */
    data: XOR<SourceChunkUpdateManyMutationInput, SourceChunkUncheckedUpdateManyInput>
    /**
     * Filter which SourceChunks to update
     */
    where?: SourceChunkWhereInput
    /**
     * Limit how many SourceChunks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceChunkIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SourceChunk upsert
   */
  export type SourceChunkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceChunk
     */
    select?: SourceChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceChunk
     */
    omit?: SourceChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceChunkInclude<ExtArgs> | null
    /**
     * The filter to search for the SourceChunk to update in case it exists.
     */
    where: SourceChunkWhereUniqueInput
    /**
     * In case the SourceChunk found by the `where` argument doesn't exist, create a new SourceChunk with this data.
     */
    create: XOR<SourceChunkCreateInput, SourceChunkUncheckedCreateInput>
    /**
     * In case the SourceChunk was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SourceChunkUpdateInput, SourceChunkUncheckedUpdateInput>
  }

  /**
   * SourceChunk delete
   */
  export type SourceChunkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceChunk
     */
    select?: SourceChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceChunk
     */
    omit?: SourceChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceChunkInclude<ExtArgs> | null
    /**
     * Filter which SourceChunk to delete.
     */
    where: SourceChunkWhereUniqueInput
  }

  /**
   * SourceChunk deleteMany
   */
  export type SourceChunkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SourceChunks to delete
     */
    where?: SourceChunkWhereInput
    /**
     * Limit how many SourceChunks to delete.
     */
    limit?: number
  }

  /**
   * SourceChunk.citations
   */
  export type SourceChunk$citationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Citation
     */
    select?: CitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Citation
     */
    omit?: CitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CitationInclude<ExtArgs> | null
    where?: CitationWhereInput
    orderBy?: CitationOrderByWithRelationInput | CitationOrderByWithRelationInput[]
    cursor?: CitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CitationScalarFieldEnum | CitationScalarFieldEnum[]
  }

  /**
   * SourceChunk without action
   */
  export type SourceChunkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceChunk
     */
    select?: SourceChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceChunk
     */
    omit?: SourceChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceChunkInclude<ExtArgs> | null
  }


  /**
   * Model SourceDocumentLink
   */

  export type AggregateSourceDocumentLink = {
    _count: SourceDocumentLinkCountAggregateOutputType | null
    _min: SourceDocumentLinkMinAggregateOutputType | null
    _max: SourceDocumentLinkMaxAggregateOutputType | null
  }

  export type SourceDocumentLinkMinAggregateOutputType = {
    id: string | null
    sourceDocumentId: string | null
    countyId: string | null
    issueId: string | null
    blueprintSectionId: string | null
    quoteId: string | null
    assetId: string | null
    surveyFormId: string | null
    note: string | null
    createdAt: Date | null
  }

  export type SourceDocumentLinkMaxAggregateOutputType = {
    id: string | null
    sourceDocumentId: string | null
    countyId: string | null
    issueId: string | null
    blueprintSectionId: string | null
    quoteId: string | null
    assetId: string | null
    surveyFormId: string | null
    note: string | null
    createdAt: Date | null
  }

  export type SourceDocumentLinkCountAggregateOutputType = {
    id: number
    sourceDocumentId: number
    countyId: number
    issueId: number
    blueprintSectionId: number
    quoteId: number
    assetId: number
    surveyFormId: number
    note: number
    createdAt: number
    _all: number
  }


  export type SourceDocumentLinkMinAggregateInputType = {
    id?: true
    sourceDocumentId?: true
    countyId?: true
    issueId?: true
    blueprintSectionId?: true
    quoteId?: true
    assetId?: true
    surveyFormId?: true
    note?: true
    createdAt?: true
  }

  export type SourceDocumentLinkMaxAggregateInputType = {
    id?: true
    sourceDocumentId?: true
    countyId?: true
    issueId?: true
    blueprintSectionId?: true
    quoteId?: true
    assetId?: true
    surveyFormId?: true
    note?: true
    createdAt?: true
  }

  export type SourceDocumentLinkCountAggregateInputType = {
    id?: true
    sourceDocumentId?: true
    countyId?: true
    issueId?: true
    blueprintSectionId?: true
    quoteId?: true
    assetId?: true
    surveyFormId?: true
    note?: true
    createdAt?: true
    _all?: true
  }

  export type SourceDocumentLinkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SourceDocumentLink to aggregate.
     */
    where?: SourceDocumentLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SourceDocumentLinks to fetch.
     */
    orderBy?: SourceDocumentLinkOrderByWithRelationInput | SourceDocumentLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SourceDocumentLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SourceDocumentLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SourceDocumentLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SourceDocumentLinks
    **/
    _count?: true | SourceDocumentLinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SourceDocumentLinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SourceDocumentLinkMaxAggregateInputType
  }

  export type GetSourceDocumentLinkAggregateType<T extends SourceDocumentLinkAggregateArgs> = {
        [P in keyof T & keyof AggregateSourceDocumentLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSourceDocumentLink[P]>
      : GetScalarType<T[P], AggregateSourceDocumentLink[P]>
  }




  export type SourceDocumentLinkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SourceDocumentLinkWhereInput
    orderBy?: SourceDocumentLinkOrderByWithAggregationInput | SourceDocumentLinkOrderByWithAggregationInput[]
    by: SourceDocumentLinkScalarFieldEnum[] | SourceDocumentLinkScalarFieldEnum
    having?: SourceDocumentLinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SourceDocumentLinkCountAggregateInputType | true
    _min?: SourceDocumentLinkMinAggregateInputType
    _max?: SourceDocumentLinkMaxAggregateInputType
  }

  export type SourceDocumentLinkGroupByOutputType = {
    id: string
    sourceDocumentId: string
    countyId: string | null
    issueId: string | null
    blueprintSectionId: string | null
    quoteId: string | null
    assetId: string | null
    surveyFormId: string | null
    note: string | null
    createdAt: Date
    _count: SourceDocumentLinkCountAggregateOutputType | null
    _min: SourceDocumentLinkMinAggregateOutputType | null
    _max: SourceDocumentLinkMaxAggregateOutputType | null
  }

  type GetSourceDocumentLinkGroupByPayload<T extends SourceDocumentLinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SourceDocumentLinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SourceDocumentLinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SourceDocumentLinkGroupByOutputType[P]>
            : GetScalarType<T[P], SourceDocumentLinkGroupByOutputType[P]>
        }
      >
    >


  export type SourceDocumentLinkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sourceDocumentId?: boolean
    countyId?: boolean
    issueId?: boolean
    blueprintSectionId?: boolean
    quoteId?: boolean
    assetId?: boolean
    surveyFormId?: boolean
    note?: boolean
    createdAt?: boolean
    sourceDocument?: boolean | SourceDocumentDefaultArgs<ExtArgs>
    county?: boolean | SourceDocumentLink$countyArgs<ExtArgs>
    issue?: boolean | SourceDocumentLink$issueArgs<ExtArgs>
    blueprintSection?: boolean | SourceDocumentLink$blueprintSectionArgs<ExtArgs>
    quote?: boolean | SourceDocumentLink$quoteArgs<ExtArgs>
    asset?: boolean | SourceDocumentLink$assetArgs<ExtArgs>
    surveyForm?: boolean | SourceDocumentLink$surveyFormArgs<ExtArgs>
  }, ExtArgs["result"]["sourceDocumentLink"]>

  export type SourceDocumentLinkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sourceDocumentId?: boolean
    countyId?: boolean
    issueId?: boolean
    blueprintSectionId?: boolean
    quoteId?: boolean
    assetId?: boolean
    surveyFormId?: boolean
    note?: boolean
    createdAt?: boolean
    sourceDocument?: boolean | SourceDocumentDefaultArgs<ExtArgs>
    county?: boolean | SourceDocumentLink$countyArgs<ExtArgs>
    issue?: boolean | SourceDocumentLink$issueArgs<ExtArgs>
    blueprintSection?: boolean | SourceDocumentLink$blueprintSectionArgs<ExtArgs>
    quote?: boolean | SourceDocumentLink$quoteArgs<ExtArgs>
    asset?: boolean | SourceDocumentLink$assetArgs<ExtArgs>
    surveyForm?: boolean | SourceDocumentLink$surveyFormArgs<ExtArgs>
  }, ExtArgs["result"]["sourceDocumentLink"]>

  export type SourceDocumentLinkSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sourceDocumentId?: boolean
    countyId?: boolean
    issueId?: boolean
    blueprintSectionId?: boolean
    quoteId?: boolean
    assetId?: boolean
    surveyFormId?: boolean
    note?: boolean
    createdAt?: boolean
    sourceDocument?: boolean | SourceDocumentDefaultArgs<ExtArgs>
    county?: boolean | SourceDocumentLink$countyArgs<ExtArgs>
    issue?: boolean | SourceDocumentLink$issueArgs<ExtArgs>
    blueprintSection?: boolean | SourceDocumentLink$blueprintSectionArgs<ExtArgs>
    quote?: boolean | SourceDocumentLink$quoteArgs<ExtArgs>
    asset?: boolean | SourceDocumentLink$assetArgs<ExtArgs>
    surveyForm?: boolean | SourceDocumentLink$surveyFormArgs<ExtArgs>
  }, ExtArgs["result"]["sourceDocumentLink"]>

  export type SourceDocumentLinkSelectScalar = {
    id?: boolean
    sourceDocumentId?: boolean
    countyId?: boolean
    issueId?: boolean
    blueprintSectionId?: boolean
    quoteId?: boolean
    assetId?: boolean
    surveyFormId?: boolean
    note?: boolean
    createdAt?: boolean
  }

  export type SourceDocumentLinkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sourceDocumentId" | "countyId" | "issueId" | "blueprintSectionId" | "quoteId" | "assetId" | "surveyFormId" | "note" | "createdAt", ExtArgs["result"]["sourceDocumentLink"]>
  export type SourceDocumentLinkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sourceDocument?: boolean | SourceDocumentDefaultArgs<ExtArgs>
    county?: boolean | SourceDocumentLink$countyArgs<ExtArgs>
    issue?: boolean | SourceDocumentLink$issueArgs<ExtArgs>
    blueprintSection?: boolean | SourceDocumentLink$blueprintSectionArgs<ExtArgs>
    quote?: boolean | SourceDocumentLink$quoteArgs<ExtArgs>
    asset?: boolean | SourceDocumentLink$assetArgs<ExtArgs>
    surveyForm?: boolean | SourceDocumentLink$surveyFormArgs<ExtArgs>
  }
  export type SourceDocumentLinkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sourceDocument?: boolean | SourceDocumentDefaultArgs<ExtArgs>
    county?: boolean | SourceDocumentLink$countyArgs<ExtArgs>
    issue?: boolean | SourceDocumentLink$issueArgs<ExtArgs>
    blueprintSection?: boolean | SourceDocumentLink$blueprintSectionArgs<ExtArgs>
    quote?: boolean | SourceDocumentLink$quoteArgs<ExtArgs>
    asset?: boolean | SourceDocumentLink$assetArgs<ExtArgs>
    surveyForm?: boolean | SourceDocumentLink$surveyFormArgs<ExtArgs>
  }
  export type SourceDocumentLinkIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sourceDocument?: boolean | SourceDocumentDefaultArgs<ExtArgs>
    county?: boolean | SourceDocumentLink$countyArgs<ExtArgs>
    issue?: boolean | SourceDocumentLink$issueArgs<ExtArgs>
    blueprintSection?: boolean | SourceDocumentLink$blueprintSectionArgs<ExtArgs>
    quote?: boolean | SourceDocumentLink$quoteArgs<ExtArgs>
    asset?: boolean | SourceDocumentLink$assetArgs<ExtArgs>
    surveyForm?: boolean | SourceDocumentLink$surveyFormArgs<ExtArgs>
  }

  export type $SourceDocumentLinkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SourceDocumentLink"
    objects: {
      sourceDocument: Prisma.$SourceDocumentPayload<ExtArgs>
      county: Prisma.$CountyPayload<ExtArgs> | null
      issue: Prisma.$IssuePayload<ExtArgs> | null
      blueprintSection: Prisma.$BlueprintSectionPayload<ExtArgs> | null
      quote: Prisma.$QuotePayload<ExtArgs> | null
      asset: Prisma.$AssetPayload<ExtArgs> | null
      surveyForm: Prisma.$SurveyFormPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sourceDocumentId: string
      countyId: string | null
      issueId: string | null
      blueprintSectionId: string | null
      quoteId: string | null
      assetId: string | null
      surveyFormId: string | null
      note: string | null
      createdAt: Date
    }, ExtArgs["result"]["sourceDocumentLink"]>
    composites: {}
  }

  type SourceDocumentLinkGetPayload<S extends boolean | null | undefined | SourceDocumentLinkDefaultArgs> = $Result.GetResult<Prisma.$SourceDocumentLinkPayload, S>

  type SourceDocumentLinkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SourceDocumentLinkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SourceDocumentLinkCountAggregateInputType | true
    }

  export interface SourceDocumentLinkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SourceDocumentLink'], meta: { name: 'SourceDocumentLink' } }
    /**
     * Find zero or one SourceDocumentLink that matches the filter.
     * @param {SourceDocumentLinkFindUniqueArgs} args - Arguments to find a SourceDocumentLink
     * @example
     * // Get one SourceDocumentLink
     * const sourceDocumentLink = await prisma.sourceDocumentLink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SourceDocumentLinkFindUniqueArgs>(args: SelectSubset<T, SourceDocumentLinkFindUniqueArgs<ExtArgs>>): Prisma__SourceDocumentLinkClient<$Result.GetResult<Prisma.$SourceDocumentLinkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SourceDocumentLink that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SourceDocumentLinkFindUniqueOrThrowArgs} args - Arguments to find a SourceDocumentLink
     * @example
     * // Get one SourceDocumentLink
     * const sourceDocumentLink = await prisma.sourceDocumentLink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SourceDocumentLinkFindUniqueOrThrowArgs>(args: SelectSubset<T, SourceDocumentLinkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SourceDocumentLinkClient<$Result.GetResult<Prisma.$SourceDocumentLinkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SourceDocumentLink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceDocumentLinkFindFirstArgs} args - Arguments to find a SourceDocumentLink
     * @example
     * // Get one SourceDocumentLink
     * const sourceDocumentLink = await prisma.sourceDocumentLink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SourceDocumentLinkFindFirstArgs>(args?: SelectSubset<T, SourceDocumentLinkFindFirstArgs<ExtArgs>>): Prisma__SourceDocumentLinkClient<$Result.GetResult<Prisma.$SourceDocumentLinkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SourceDocumentLink that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceDocumentLinkFindFirstOrThrowArgs} args - Arguments to find a SourceDocumentLink
     * @example
     * // Get one SourceDocumentLink
     * const sourceDocumentLink = await prisma.sourceDocumentLink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SourceDocumentLinkFindFirstOrThrowArgs>(args?: SelectSubset<T, SourceDocumentLinkFindFirstOrThrowArgs<ExtArgs>>): Prisma__SourceDocumentLinkClient<$Result.GetResult<Prisma.$SourceDocumentLinkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SourceDocumentLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceDocumentLinkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SourceDocumentLinks
     * const sourceDocumentLinks = await prisma.sourceDocumentLink.findMany()
     * 
     * // Get first 10 SourceDocumentLinks
     * const sourceDocumentLinks = await prisma.sourceDocumentLink.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sourceDocumentLinkWithIdOnly = await prisma.sourceDocumentLink.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SourceDocumentLinkFindManyArgs>(args?: SelectSubset<T, SourceDocumentLinkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourceDocumentLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SourceDocumentLink.
     * @param {SourceDocumentLinkCreateArgs} args - Arguments to create a SourceDocumentLink.
     * @example
     * // Create one SourceDocumentLink
     * const SourceDocumentLink = await prisma.sourceDocumentLink.create({
     *   data: {
     *     // ... data to create a SourceDocumentLink
     *   }
     * })
     * 
     */
    create<T extends SourceDocumentLinkCreateArgs>(args: SelectSubset<T, SourceDocumentLinkCreateArgs<ExtArgs>>): Prisma__SourceDocumentLinkClient<$Result.GetResult<Prisma.$SourceDocumentLinkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SourceDocumentLinks.
     * @param {SourceDocumentLinkCreateManyArgs} args - Arguments to create many SourceDocumentLinks.
     * @example
     * // Create many SourceDocumentLinks
     * const sourceDocumentLink = await prisma.sourceDocumentLink.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SourceDocumentLinkCreateManyArgs>(args?: SelectSubset<T, SourceDocumentLinkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SourceDocumentLinks and returns the data saved in the database.
     * @param {SourceDocumentLinkCreateManyAndReturnArgs} args - Arguments to create many SourceDocumentLinks.
     * @example
     * // Create many SourceDocumentLinks
     * const sourceDocumentLink = await prisma.sourceDocumentLink.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SourceDocumentLinks and only return the `id`
     * const sourceDocumentLinkWithIdOnly = await prisma.sourceDocumentLink.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SourceDocumentLinkCreateManyAndReturnArgs>(args?: SelectSubset<T, SourceDocumentLinkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourceDocumentLinkPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SourceDocumentLink.
     * @param {SourceDocumentLinkDeleteArgs} args - Arguments to delete one SourceDocumentLink.
     * @example
     * // Delete one SourceDocumentLink
     * const SourceDocumentLink = await prisma.sourceDocumentLink.delete({
     *   where: {
     *     // ... filter to delete one SourceDocumentLink
     *   }
     * })
     * 
     */
    delete<T extends SourceDocumentLinkDeleteArgs>(args: SelectSubset<T, SourceDocumentLinkDeleteArgs<ExtArgs>>): Prisma__SourceDocumentLinkClient<$Result.GetResult<Prisma.$SourceDocumentLinkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SourceDocumentLink.
     * @param {SourceDocumentLinkUpdateArgs} args - Arguments to update one SourceDocumentLink.
     * @example
     * // Update one SourceDocumentLink
     * const sourceDocumentLink = await prisma.sourceDocumentLink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SourceDocumentLinkUpdateArgs>(args: SelectSubset<T, SourceDocumentLinkUpdateArgs<ExtArgs>>): Prisma__SourceDocumentLinkClient<$Result.GetResult<Prisma.$SourceDocumentLinkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SourceDocumentLinks.
     * @param {SourceDocumentLinkDeleteManyArgs} args - Arguments to filter SourceDocumentLinks to delete.
     * @example
     * // Delete a few SourceDocumentLinks
     * const { count } = await prisma.sourceDocumentLink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SourceDocumentLinkDeleteManyArgs>(args?: SelectSubset<T, SourceDocumentLinkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SourceDocumentLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceDocumentLinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SourceDocumentLinks
     * const sourceDocumentLink = await prisma.sourceDocumentLink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SourceDocumentLinkUpdateManyArgs>(args: SelectSubset<T, SourceDocumentLinkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SourceDocumentLinks and returns the data updated in the database.
     * @param {SourceDocumentLinkUpdateManyAndReturnArgs} args - Arguments to update many SourceDocumentLinks.
     * @example
     * // Update many SourceDocumentLinks
     * const sourceDocumentLink = await prisma.sourceDocumentLink.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SourceDocumentLinks and only return the `id`
     * const sourceDocumentLinkWithIdOnly = await prisma.sourceDocumentLink.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SourceDocumentLinkUpdateManyAndReturnArgs>(args: SelectSubset<T, SourceDocumentLinkUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourceDocumentLinkPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SourceDocumentLink.
     * @param {SourceDocumentLinkUpsertArgs} args - Arguments to update or create a SourceDocumentLink.
     * @example
     * // Update or create a SourceDocumentLink
     * const sourceDocumentLink = await prisma.sourceDocumentLink.upsert({
     *   create: {
     *     // ... data to create a SourceDocumentLink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SourceDocumentLink we want to update
     *   }
     * })
     */
    upsert<T extends SourceDocumentLinkUpsertArgs>(args: SelectSubset<T, SourceDocumentLinkUpsertArgs<ExtArgs>>): Prisma__SourceDocumentLinkClient<$Result.GetResult<Prisma.$SourceDocumentLinkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SourceDocumentLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceDocumentLinkCountArgs} args - Arguments to filter SourceDocumentLinks to count.
     * @example
     * // Count the number of SourceDocumentLinks
     * const count = await prisma.sourceDocumentLink.count({
     *   where: {
     *     // ... the filter for the SourceDocumentLinks we want to count
     *   }
     * })
    **/
    count<T extends SourceDocumentLinkCountArgs>(
      args?: Subset<T, SourceDocumentLinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SourceDocumentLinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SourceDocumentLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceDocumentLinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SourceDocumentLinkAggregateArgs>(args: Subset<T, SourceDocumentLinkAggregateArgs>): Prisma.PrismaPromise<GetSourceDocumentLinkAggregateType<T>>

    /**
     * Group by SourceDocumentLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceDocumentLinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SourceDocumentLinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SourceDocumentLinkGroupByArgs['orderBy'] }
        : { orderBy?: SourceDocumentLinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SourceDocumentLinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSourceDocumentLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SourceDocumentLink model
   */
  readonly fields: SourceDocumentLinkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SourceDocumentLink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SourceDocumentLinkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sourceDocument<T extends SourceDocumentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SourceDocumentDefaultArgs<ExtArgs>>): Prisma__SourceDocumentClient<$Result.GetResult<Prisma.$SourceDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    county<T extends SourceDocumentLink$countyArgs<ExtArgs> = {}>(args?: Subset<T, SourceDocumentLink$countyArgs<ExtArgs>>): Prisma__CountyClient<$Result.GetResult<Prisma.$CountyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    issue<T extends SourceDocumentLink$issueArgs<ExtArgs> = {}>(args?: Subset<T, SourceDocumentLink$issueArgs<ExtArgs>>): Prisma__IssueClient<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    blueprintSection<T extends SourceDocumentLink$blueprintSectionArgs<ExtArgs> = {}>(args?: Subset<T, SourceDocumentLink$blueprintSectionArgs<ExtArgs>>): Prisma__BlueprintSectionClient<$Result.GetResult<Prisma.$BlueprintSectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    quote<T extends SourceDocumentLink$quoteArgs<ExtArgs> = {}>(args?: Subset<T, SourceDocumentLink$quoteArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    asset<T extends SourceDocumentLink$assetArgs<ExtArgs> = {}>(args?: Subset<T, SourceDocumentLink$assetArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    surveyForm<T extends SourceDocumentLink$surveyFormArgs<ExtArgs> = {}>(args?: Subset<T, SourceDocumentLink$surveyFormArgs<ExtArgs>>): Prisma__SurveyFormClient<$Result.GetResult<Prisma.$SurveyFormPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SourceDocumentLink model
   */
  interface SourceDocumentLinkFieldRefs {
    readonly id: FieldRef<"SourceDocumentLink", 'String'>
    readonly sourceDocumentId: FieldRef<"SourceDocumentLink", 'String'>
    readonly countyId: FieldRef<"SourceDocumentLink", 'String'>
    readonly issueId: FieldRef<"SourceDocumentLink", 'String'>
    readonly blueprintSectionId: FieldRef<"SourceDocumentLink", 'String'>
    readonly quoteId: FieldRef<"SourceDocumentLink", 'String'>
    readonly assetId: FieldRef<"SourceDocumentLink", 'String'>
    readonly surveyFormId: FieldRef<"SourceDocumentLink", 'String'>
    readonly note: FieldRef<"SourceDocumentLink", 'String'>
    readonly createdAt: FieldRef<"SourceDocumentLink", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SourceDocumentLink findUnique
   */
  export type SourceDocumentLinkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceDocumentLink
     */
    select?: SourceDocumentLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceDocumentLink
     */
    omit?: SourceDocumentLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceDocumentLinkInclude<ExtArgs> | null
    /**
     * Filter, which SourceDocumentLink to fetch.
     */
    where: SourceDocumentLinkWhereUniqueInput
  }

  /**
   * SourceDocumentLink findUniqueOrThrow
   */
  export type SourceDocumentLinkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceDocumentLink
     */
    select?: SourceDocumentLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceDocumentLink
     */
    omit?: SourceDocumentLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceDocumentLinkInclude<ExtArgs> | null
    /**
     * Filter, which SourceDocumentLink to fetch.
     */
    where: SourceDocumentLinkWhereUniqueInput
  }

  /**
   * SourceDocumentLink findFirst
   */
  export type SourceDocumentLinkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceDocumentLink
     */
    select?: SourceDocumentLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceDocumentLink
     */
    omit?: SourceDocumentLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceDocumentLinkInclude<ExtArgs> | null
    /**
     * Filter, which SourceDocumentLink to fetch.
     */
    where?: SourceDocumentLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SourceDocumentLinks to fetch.
     */
    orderBy?: SourceDocumentLinkOrderByWithRelationInput | SourceDocumentLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SourceDocumentLinks.
     */
    cursor?: SourceDocumentLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SourceDocumentLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SourceDocumentLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SourceDocumentLinks.
     */
    distinct?: SourceDocumentLinkScalarFieldEnum | SourceDocumentLinkScalarFieldEnum[]
  }

  /**
   * SourceDocumentLink findFirstOrThrow
   */
  export type SourceDocumentLinkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceDocumentLink
     */
    select?: SourceDocumentLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceDocumentLink
     */
    omit?: SourceDocumentLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceDocumentLinkInclude<ExtArgs> | null
    /**
     * Filter, which SourceDocumentLink to fetch.
     */
    where?: SourceDocumentLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SourceDocumentLinks to fetch.
     */
    orderBy?: SourceDocumentLinkOrderByWithRelationInput | SourceDocumentLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SourceDocumentLinks.
     */
    cursor?: SourceDocumentLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SourceDocumentLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SourceDocumentLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SourceDocumentLinks.
     */
    distinct?: SourceDocumentLinkScalarFieldEnum | SourceDocumentLinkScalarFieldEnum[]
  }

  /**
   * SourceDocumentLink findMany
   */
  export type SourceDocumentLinkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceDocumentLink
     */
    select?: SourceDocumentLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceDocumentLink
     */
    omit?: SourceDocumentLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceDocumentLinkInclude<ExtArgs> | null
    /**
     * Filter, which SourceDocumentLinks to fetch.
     */
    where?: SourceDocumentLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SourceDocumentLinks to fetch.
     */
    orderBy?: SourceDocumentLinkOrderByWithRelationInput | SourceDocumentLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SourceDocumentLinks.
     */
    cursor?: SourceDocumentLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SourceDocumentLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SourceDocumentLinks.
     */
    skip?: number
    distinct?: SourceDocumentLinkScalarFieldEnum | SourceDocumentLinkScalarFieldEnum[]
  }

  /**
   * SourceDocumentLink create
   */
  export type SourceDocumentLinkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceDocumentLink
     */
    select?: SourceDocumentLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceDocumentLink
     */
    omit?: SourceDocumentLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceDocumentLinkInclude<ExtArgs> | null
    /**
     * The data needed to create a SourceDocumentLink.
     */
    data: XOR<SourceDocumentLinkCreateInput, SourceDocumentLinkUncheckedCreateInput>
  }

  /**
   * SourceDocumentLink createMany
   */
  export type SourceDocumentLinkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SourceDocumentLinks.
     */
    data: SourceDocumentLinkCreateManyInput | SourceDocumentLinkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SourceDocumentLink createManyAndReturn
   */
  export type SourceDocumentLinkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceDocumentLink
     */
    select?: SourceDocumentLinkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SourceDocumentLink
     */
    omit?: SourceDocumentLinkOmit<ExtArgs> | null
    /**
     * The data used to create many SourceDocumentLinks.
     */
    data: SourceDocumentLinkCreateManyInput | SourceDocumentLinkCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceDocumentLinkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SourceDocumentLink update
   */
  export type SourceDocumentLinkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceDocumentLink
     */
    select?: SourceDocumentLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceDocumentLink
     */
    omit?: SourceDocumentLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceDocumentLinkInclude<ExtArgs> | null
    /**
     * The data needed to update a SourceDocumentLink.
     */
    data: XOR<SourceDocumentLinkUpdateInput, SourceDocumentLinkUncheckedUpdateInput>
    /**
     * Choose, which SourceDocumentLink to update.
     */
    where: SourceDocumentLinkWhereUniqueInput
  }

  /**
   * SourceDocumentLink updateMany
   */
  export type SourceDocumentLinkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SourceDocumentLinks.
     */
    data: XOR<SourceDocumentLinkUpdateManyMutationInput, SourceDocumentLinkUncheckedUpdateManyInput>
    /**
     * Filter which SourceDocumentLinks to update
     */
    where?: SourceDocumentLinkWhereInput
    /**
     * Limit how many SourceDocumentLinks to update.
     */
    limit?: number
  }

  /**
   * SourceDocumentLink updateManyAndReturn
   */
  export type SourceDocumentLinkUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceDocumentLink
     */
    select?: SourceDocumentLinkSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SourceDocumentLink
     */
    omit?: SourceDocumentLinkOmit<ExtArgs> | null
    /**
     * The data used to update SourceDocumentLinks.
     */
    data: XOR<SourceDocumentLinkUpdateManyMutationInput, SourceDocumentLinkUncheckedUpdateManyInput>
    /**
     * Filter which SourceDocumentLinks to update
     */
    where?: SourceDocumentLinkWhereInput
    /**
     * Limit how many SourceDocumentLinks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceDocumentLinkIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SourceDocumentLink upsert
   */
  export type SourceDocumentLinkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceDocumentLink
     */
    select?: SourceDocumentLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceDocumentLink
     */
    omit?: SourceDocumentLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceDocumentLinkInclude<ExtArgs> | null
    /**
     * The filter to search for the SourceDocumentLink to update in case it exists.
     */
    where: SourceDocumentLinkWhereUniqueInput
    /**
     * In case the SourceDocumentLink found by the `where` argument doesn't exist, create a new SourceDocumentLink with this data.
     */
    create: XOR<SourceDocumentLinkCreateInput, SourceDocumentLinkUncheckedCreateInput>
    /**
     * In case the SourceDocumentLink was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SourceDocumentLinkUpdateInput, SourceDocumentLinkUncheckedUpdateInput>
  }

  /**
   * SourceDocumentLink delete
   */
  export type SourceDocumentLinkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceDocumentLink
     */
    select?: SourceDocumentLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceDocumentLink
     */
    omit?: SourceDocumentLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceDocumentLinkInclude<ExtArgs> | null
    /**
     * Filter which SourceDocumentLink to delete.
     */
    where: SourceDocumentLinkWhereUniqueInput
  }

  /**
   * SourceDocumentLink deleteMany
   */
  export type SourceDocumentLinkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SourceDocumentLinks to delete
     */
    where?: SourceDocumentLinkWhereInput
    /**
     * Limit how many SourceDocumentLinks to delete.
     */
    limit?: number
  }

  /**
   * SourceDocumentLink.county
   */
  export type SourceDocumentLink$countyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the County
     */
    select?: CountySelect<ExtArgs> | null
    /**
     * Omit specific fields from the County
     */
    omit?: CountyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountyInclude<ExtArgs> | null
    where?: CountyWhereInput
  }

  /**
   * SourceDocumentLink.issue
   */
  export type SourceDocumentLink$issueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Issue
     */
    omit?: IssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueInclude<ExtArgs> | null
    where?: IssueWhereInput
  }

  /**
   * SourceDocumentLink.blueprintSection
   */
  export type SourceDocumentLink$blueprintSectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlueprintSection
     */
    select?: BlueprintSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlueprintSection
     */
    omit?: BlueprintSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlueprintSectionInclude<ExtArgs> | null
    where?: BlueprintSectionWhereInput
  }

  /**
   * SourceDocumentLink.quote
   */
  export type SourceDocumentLink$quoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    where?: QuoteWhereInput
  }

  /**
   * SourceDocumentLink.asset
   */
  export type SourceDocumentLink$assetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    where?: AssetWhereInput
  }

  /**
   * SourceDocumentLink.surveyForm
   */
  export type SourceDocumentLink$surveyFormArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyForm
     */
    select?: SurveyFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyForm
     */
    omit?: SurveyFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyFormInclude<ExtArgs> | null
    where?: SurveyFormWhereInput
  }

  /**
   * SourceDocumentLink without action
   */
  export type SourceDocumentLinkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceDocumentLink
     */
    select?: SourceDocumentLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceDocumentLink
     */
    omit?: SourceDocumentLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceDocumentLinkInclude<ExtArgs> | null
  }


  /**
   * Model GeoCounty
   */

  export type AggregateGeoCounty = {
    _count: GeoCountyCountAggregateOutputType | null
    _min: GeoCountyMinAggregateOutputType | null
    _max: GeoCountyMaxAggregateOutputType | null
  }

  export type GeoCountyMinAggregateOutputType = {
    id: string | null
    fipsCode: string | null
    name: string | null
    createdAt: Date | null
  }

  export type GeoCountyMaxAggregateOutputType = {
    id: string | null
    fipsCode: string | null
    name: string | null
    createdAt: Date | null
  }

  export type GeoCountyCountAggregateOutputType = {
    id: number
    fipsCode: number
    name: number
    createdAt: number
    _all: number
  }


  export type GeoCountyMinAggregateInputType = {
    id?: true
    fipsCode?: true
    name?: true
    createdAt?: true
  }

  export type GeoCountyMaxAggregateInputType = {
    id?: true
    fipsCode?: true
    name?: true
    createdAt?: true
  }

  export type GeoCountyCountAggregateInputType = {
    id?: true
    fipsCode?: true
    name?: true
    createdAt?: true
    _all?: true
  }

  export type GeoCountyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GeoCounty to aggregate.
     */
    where?: GeoCountyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeoCounties to fetch.
     */
    orderBy?: GeoCountyOrderByWithRelationInput | GeoCountyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GeoCountyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeoCounties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeoCounties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GeoCounties
    **/
    _count?: true | GeoCountyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GeoCountyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GeoCountyMaxAggregateInputType
  }

  export type GetGeoCountyAggregateType<T extends GeoCountyAggregateArgs> = {
        [P in keyof T & keyof AggregateGeoCounty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGeoCounty[P]>
      : GetScalarType<T[P], AggregateGeoCounty[P]>
  }




  export type GeoCountyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GeoCountyWhereInput
    orderBy?: GeoCountyOrderByWithAggregationInput | GeoCountyOrderByWithAggregationInput[]
    by: GeoCountyScalarFieldEnum[] | GeoCountyScalarFieldEnum
    having?: GeoCountyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GeoCountyCountAggregateInputType | true
    _min?: GeoCountyMinAggregateInputType
    _max?: GeoCountyMaxAggregateInputType
  }

  export type GeoCountyGroupByOutputType = {
    id: string
    fipsCode: string | null
    name: string
    createdAt: Date
    _count: GeoCountyCountAggregateOutputType | null
    _min: GeoCountyMinAggregateOutputType | null
    _max: GeoCountyMaxAggregateOutputType | null
  }

  type GetGeoCountyGroupByPayload<T extends GeoCountyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GeoCountyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GeoCountyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GeoCountyGroupByOutputType[P]>
            : GetScalarType<T[P], GeoCountyGroupByOutputType[P]>
        }
      >
    >


  export type GeoCountySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fipsCode?: boolean
    name?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["geoCounty"]>

  export type GeoCountySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fipsCode?: boolean
    name?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["geoCounty"]>

  export type GeoCountySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fipsCode?: boolean
    name?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["geoCounty"]>

  export type GeoCountySelectScalar = {
    id?: boolean
    fipsCode?: boolean
    name?: boolean
    createdAt?: boolean
  }

  export type GeoCountyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fipsCode" | "name" | "createdAt", ExtArgs["result"]["geoCounty"]>

  export type $GeoCountyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GeoCounty"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fipsCode: string | null
      name: string
      createdAt: Date
    }, ExtArgs["result"]["geoCounty"]>
    composites: {}
  }

  type GeoCountyGetPayload<S extends boolean | null | undefined | GeoCountyDefaultArgs> = $Result.GetResult<Prisma.$GeoCountyPayload, S>

  type GeoCountyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GeoCountyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GeoCountyCountAggregateInputType | true
    }

  export interface GeoCountyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GeoCounty'], meta: { name: 'GeoCounty' } }
    /**
     * Find zero or one GeoCounty that matches the filter.
     * @param {GeoCountyFindUniqueArgs} args - Arguments to find a GeoCounty
     * @example
     * // Get one GeoCounty
     * const geoCounty = await prisma.geoCounty.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GeoCountyFindUniqueArgs>(args: SelectSubset<T, GeoCountyFindUniqueArgs<ExtArgs>>): Prisma__GeoCountyClient<$Result.GetResult<Prisma.$GeoCountyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GeoCounty that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GeoCountyFindUniqueOrThrowArgs} args - Arguments to find a GeoCounty
     * @example
     * // Get one GeoCounty
     * const geoCounty = await prisma.geoCounty.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GeoCountyFindUniqueOrThrowArgs>(args: SelectSubset<T, GeoCountyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GeoCountyClient<$Result.GetResult<Prisma.$GeoCountyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GeoCounty that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeoCountyFindFirstArgs} args - Arguments to find a GeoCounty
     * @example
     * // Get one GeoCounty
     * const geoCounty = await prisma.geoCounty.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GeoCountyFindFirstArgs>(args?: SelectSubset<T, GeoCountyFindFirstArgs<ExtArgs>>): Prisma__GeoCountyClient<$Result.GetResult<Prisma.$GeoCountyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GeoCounty that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeoCountyFindFirstOrThrowArgs} args - Arguments to find a GeoCounty
     * @example
     * // Get one GeoCounty
     * const geoCounty = await prisma.geoCounty.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GeoCountyFindFirstOrThrowArgs>(args?: SelectSubset<T, GeoCountyFindFirstOrThrowArgs<ExtArgs>>): Prisma__GeoCountyClient<$Result.GetResult<Prisma.$GeoCountyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GeoCounties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeoCountyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GeoCounties
     * const geoCounties = await prisma.geoCounty.findMany()
     * 
     * // Get first 10 GeoCounties
     * const geoCounties = await prisma.geoCounty.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const geoCountyWithIdOnly = await prisma.geoCounty.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GeoCountyFindManyArgs>(args?: SelectSubset<T, GeoCountyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeoCountyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GeoCounty.
     * @param {GeoCountyCreateArgs} args - Arguments to create a GeoCounty.
     * @example
     * // Create one GeoCounty
     * const GeoCounty = await prisma.geoCounty.create({
     *   data: {
     *     // ... data to create a GeoCounty
     *   }
     * })
     * 
     */
    create<T extends GeoCountyCreateArgs>(args: SelectSubset<T, GeoCountyCreateArgs<ExtArgs>>): Prisma__GeoCountyClient<$Result.GetResult<Prisma.$GeoCountyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GeoCounties.
     * @param {GeoCountyCreateManyArgs} args - Arguments to create many GeoCounties.
     * @example
     * // Create many GeoCounties
     * const geoCounty = await prisma.geoCounty.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GeoCountyCreateManyArgs>(args?: SelectSubset<T, GeoCountyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GeoCounties and returns the data saved in the database.
     * @param {GeoCountyCreateManyAndReturnArgs} args - Arguments to create many GeoCounties.
     * @example
     * // Create many GeoCounties
     * const geoCounty = await prisma.geoCounty.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GeoCounties and only return the `id`
     * const geoCountyWithIdOnly = await prisma.geoCounty.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GeoCountyCreateManyAndReturnArgs>(args?: SelectSubset<T, GeoCountyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeoCountyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GeoCounty.
     * @param {GeoCountyDeleteArgs} args - Arguments to delete one GeoCounty.
     * @example
     * // Delete one GeoCounty
     * const GeoCounty = await prisma.geoCounty.delete({
     *   where: {
     *     // ... filter to delete one GeoCounty
     *   }
     * })
     * 
     */
    delete<T extends GeoCountyDeleteArgs>(args: SelectSubset<T, GeoCountyDeleteArgs<ExtArgs>>): Prisma__GeoCountyClient<$Result.GetResult<Prisma.$GeoCountyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GeoCounty.
     * @param {GeoCountyUpdateArgs} args - Arguments to update one GeoCounty.
     * @example
     * // Update one GeoCounty
     * const geoCounty = await prisma.geoCounty.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GeoCountyUpdateArgs>(args: SelectSubset<T, GeoCountyUpdateArgs<ExtArgs>>): Prisma__GeoCountyClient<$Result.GetResult<Prisma.$GeoCountyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GeoCounties.
     * @param {GeoCountyDeleteManyArgs} args - Arguments to filter GeoCounties to delete.
     * @example
     * // Delete a few GeoCounties
     * const { count } = await prisma.geoCounty.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GeoCountyDeleteManyArgs>(args?: SelectSubset<T, GeoCountyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GeoCounties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeoCountyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GeoCounties
     * const geoCounty = await prisma.geoCounty.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GeoCountyUpdateManyArgs>(args: SelectSubset<T, GeoCountyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GeoCounties and returns the data updated in the database.
     * @param {GeoCountyUpdateManyAndReturnArgs} args - Arguments to update many GeoCounties.
     * @example
     * // Update many GeoCounties
     * const geoCounty = await prisma.geoCounty.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GeoCounties and only return the `id`
     * const geoCountyWithIdOnly = await prisma.geoCounty.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GeoCountyUpdateManyAndReturnArgs>(args: SelectSubset<T, GeoCountyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeoCountyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GeoCounty.
     * @param {GeoCountyUpsertArgs} args - Arguments to update or create a GeoCounty.
     * @example
     * // Update or create a GeoCounty
     * const geoCounty = await prisma.geoCounty.upsert({
     *   create: {
     *     // ... data to create a GeoCounty
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GeoCounty we want to update
     *   }
     * })
     */
    upsert<T extends GeoCountyUpsertArgs>(args: SelectSubset<T, GeoCountyUpsertArgs<ExtArgs>>): Prisma__GeoCountyClient<$Result.GetResult<Prisma.$GeoCountyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GeoCounties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeoCountyCountArgs} args - Arguments to filter GeoCounties to count.
     * @example
     * // Count the number of GeoCounties
     * const count = await prisma.geoCounty.count({
     *   where: {
     *     // ... the filter for the GeoCounties we want to count
     *   }
     * })
    **/
    count<T extends GeoCountyCountArgs>(
      args?: Subset<T, GeoCountyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GeoCountyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GeoCounty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeoCountyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GeoCountyAggregateArgs>(args: Subset<T, GeoCountyAggregateArgs>): Prisma.PrismaPromise<GetGeoCountyAggregateType<T>>

    /**
     * Group by GeoCounty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeoCountyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GeoCountyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GeoCountyGroupByArgs['orderBy'] }
        : { orderBy?: GeoCountyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GeoCountyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGeoCountyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GeoCounty model
   */
  readonly fields: GeoCountyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GeoCounty.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GeoCountyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GeoCounty model
   */
  interface GeoCountyFieldRefs {
    readonly id: FieldRef<"GeoCounty", 'String'>
    readonly fipsCode: FieldRef<"GeoCounty", 'String'>
    readonly name: FieldRef<"GeoCounty", 'String'>
    readonly createdAt: FieldRef<"GeoCounty", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GeoCounty findUnique
   */
  export type GeoCountyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoCounty
     */
    select?: GeoCountySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeoCounty
     */
    omit?: GeoCountyOmit<ExtArgs> | null
    /**
     * Filter, which GeoCounty to fetch.
     */
    where: GeoCountyWhereUniqueInput
  }

  /**
   * GeoCounty findUniqueOrThrow
   */
  export type GeoCountyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoCounty
     */
    select?: GeoCountySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeoCounty
     */
    omit?: GeoCountyOmit<ExtArgs> | null
    /**
     * Filter, which GeoCounty to fetch.
     */
    where: GeoCountyWhereUniqueInput
  }

  /**
   * GeoCounty findFirst
   */
  export type GeoCountyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoCounty
     */
    select?: GeoCountySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeoCounty
     */
    omit?: GeoCountyOmit<ExtArgs> | null
    /**
     * Filter, which GeoCounty to fetch.
     */
    where?: GeoCountyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeoCounties to fetch.
     */
    orderBy?: GeoCountyOrderByWithRelationInput | GeoCountyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GeoCounties.
     */
    cursor?: GeoCountyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeoCounties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeoCounties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GeoCounties.
     */
    distinct?: GeoCountyScalarFieldEnum | GeoCountyScalarFieldEnum[]
  }

  /**
   * GeoCounty findFirstOrThrow
   */
  export type GeoCountyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoCounty
     */
    select?: GeoCountySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeoCounty
     */
    omit?: GeoCountyOmit<ExtArgs> | null
    /**
     * Filter, which GeoCounty to fetch.
     */
    where?: GeoCountyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeoCounties to fetch.
     */
    orderBy?: GeoCountyOrderByWithRelationInput | GeoCountyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GeoCounties.
     */
    cursor?: GeoCountyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeoCounties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeoCounties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GeoCounties.
     */
    distinct?: GeoCountyScalarFieldEnum | GeoCountyScalarFieldEnum[]
  }

  /**
   * GeoCounty findMany
   */
  export type GeoCountyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoCounty
     */
    select?: GeoCountySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeoCounty
     */
    omit?: GeoCountyOmit<ExtArgs> | null
    /**
     * Filter, which GeoCounties to fetch.
     */
    where?: GeoCountyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeoCounties to fetch.
     */
    orderBy?: GeoCountyOrderByWithRelationInput | GeoCountyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GeoCounties.
     */
    cursor?: GeoCountyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeoCounties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeoCounties.
     */
    skip?: number
    distinct?: GeoCountyScalarFieldEnum | GeoCountyScalarFieldEnum[]
  }

  /**
   * GeoCounty create
   */
  export type GeoCountyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoCounty
     */
    select?: GeoCountySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeoCounty
     */
    omit?: GeoCountyOmit<ExtArgs> | null
    /**
     * The data needed to create a GeoCounty.
     */
    data: XOR<GeoCountyCreateInput, GeoCountyUncheckedCreateInput>
  }

  /**
   * GeoCounty createMany
   */
  export type GeoCountyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GeoCounties.
     */
    data: GeoCountyCreateManyInput | GeoCountyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GeoCounty createManyAndReturn
   */
  export type GeoCountyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoCounty
     */
    select?: GeoCountySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GeoCounty
     */
    omit?: GeoCountyOmit<ExtArgs> | null
    /**
     * The data used to create many GeoCounties.
     */
    data: GeoCountyCreateManyInput | GeoCountyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GeoCounty update
   */
  export type GeoCountyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoCounty
     */
    select?: GeoCountySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeoCounty
     */
    omit?: GeoCountyOmit<ExtArgs> | null
    /**
     * The data needed to update a GeoCounty.
     */
    data: XOR<GeoCountyUpdateInput, GeoCountyUncheckedUpdateInput>
    /**
     * Choose, which GeoCounty to update.
     */
    where: GeoCountyWhereUniqueInput
  }

  /**
   * GeoCounty updateMany
   */
  export type GeoCountyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GeoCounties.
     */
    data: XOR<GeoCountyUpdateManyMutationInput, GeoCountyUncheckedUpdateManyInput>
    /**
     * Filter which GeoCounties to update
     */
    where?: GeoCountyWhereInput
    /**
     * Limit how many GeoCounties to update.
     */
    limit?: number
  }

  /**
   * GeoCounty updateManyAndReturn
   */
  export type GeoCountyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoCounty
     */
    select?: GeoCountySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GeoCounty
     */
    omit?: GeoCountyOmit<ExtArgs> | null
    /**
     * The data used to update GeoCounties.
     */
    data: XOR<GeoCountyUpdateManyMutationInput, GeoCountyUncheckedUpdateManyInput>
    /**
     * Filter which GeoCounties to update
     */
    where?: GeoCountyWhereInput
    /**
     * Limit how many GeoCounties to update.
     */
    limit?: number
  }

  /**
   * GeoCounty upsert
   */
  export type GeoCountyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoCounty
     */
    select?: GeoCountySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeoCounty
     */
    omit?: GeoCountyOmit<ExtArgs> | null
    /**
     * The filter to search for the GeoCounty to update in case it exists.
     */
    where: GeoCountyWhereUniqueInput
    /**
     * In case the GeoCounty found by the `where` argument doesn't exist, create a new GeoCounty with this data.
     */
    create: XOR<GeoCountyCreateInput, GeoCountyUncheckedCreateInput>
    /**
     * In case the GeoCounty was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GeoCountyUpdateInput, GeoCountyUncheckedUpdateInput>
  }

  /**
   * GeoCounty delete
   */
  export type GeoCountyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoCounty
     */
    select?: GeoCountySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeoCounty
     */
    omit?: GeoCountyOmit<ExtArgs> | null
    /**
     * Filter which GeoCounty to delete.
     */
    where: GeoCountyWhereUniqueInput
  }

  /**
   * GeoCounty deleteMany
   */
  export type GeoCountyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GeoCounties to delete
     */
    where?: GeoCountyWhereInput
    /**
     * Limit how many GeoCounties to delete.
     */
    limit?: number
  }

  /**
   * GeoCounty without action
   */
  export type GeoCountyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoCounty
     */
    select?: GeoCountySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeoCounty
     */
    omit?: GeoCountyOmit<ExtArgs> | null
  }


  /**
   * Model GeoZip
   */

  export type AggregateGeoZip = {
    _count: GeoZipCountAggregateOutputType | null
    _min: GeoZipMinAggregateOutputType | null
    _max: GeoZipMaxAggregateOutputType | null
  }

  export type GeoZipMinAggregateOutputType = {
    id: string | null
    zipCode: string | null
    createdAt: Date | null
  }

  export type GeoZipMaxAggregateOutputType = {
    id: string | null
    zipCode: string | null
    createdAt: Date | null
  }

  export type GeoZipCountAggregateOutputType = {
    id: number
    zipCode: number
    createdAt: number
    _all: number
  }


  export type GeoZipMinAggregateInputType = {
    id?: true
    zipCode?: true
    createdAt?: true
  }

  export type GeoZipMaxAggregateInputType = {
    id?: true
    zipCode?: true
    createdAt?: true
  }

  export type GeoZipCountAggregateInputType = {
    id?: true
    zipCode?: true
    createdAt?: true
    _all?: true
  }

  export type GeoZipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GeoZip to aggregate.
     */
    where?: GeoZipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeoZips to fetch.
     */
    orderBy?: GeoZipOrderByWithRelationInput | GeoZipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GeoZipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeoZips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeoZips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GeoZips
    **/
    _count?: true | GeoZipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GeoZipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GeoZipMaxAggregateInputType
  }

  export type GetGeoZipAggregateType<T extends GeoZipAggregateArgs> = {
        [P in keyof T & keyof AggregateGeoZip]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGeoZip[P]>
      : GetScalarType<T[P], AggregateGeoZip[P]>
  }




  export type GeoZipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GeoZipWhereInput
    orderBy?: GeoZipOrderByWithAggregationInput | GeoZipOrderByWithAggregationInput[]
    by: GeoZipScalarFieldEnum[] | GeoZipScalarFieldEnum
    having?: GeoZipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GeoZipCountAggregateInputType | true
    _min?: GeoZipMinAggregateInputType
    _max?: GeoZipMaxAggregateInputType
  }

  export type GeoZipGroupByOutputType = {
    id: string
    zipCode: string
    createdAt: Date
    _count: GeoZipCountAggregateOutputType | null
    _min: GeoZipMinAggregateOutputType | null
    _max: GeoZipMaxAggregateOutputType | null
  }

  type GetGeoZipGroupByPayload<T extends GeoZipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GeoZipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GeoZipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GeoZipGroupByOutputType[P]>
            : GetScalarType<T[P], GeoZipGroupByOutputType[P]>
        }
      >
    >


  export type GeoZipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    zipCode?: boolean
    createdAt?: boolean
    censusMetrics?: boolean | GeoZip$censusMetricsArgs<ExtArgs>
    aiOutputScopes?: boolean | GeoZip$aiOutputScopesArgs<ExtArgs>
    electionResults?: boolean | GeoZip$electionResultsArgs<ExtArgs>
    _count?: boolean | GeoZipCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["geoZip"]>

  export type GeoZipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    zipCode?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["geoZip"]>

  export type GeoZipSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    zipCode?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["geoZip"]>

  export type GeoZipSelectScalar = {
    id?: boolean
    zipCode?: boolean
    createdAt?: boolean
  }

  export type GeoZipOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "zipCode" | "createdAt", ExtArgs["result"]["geoZip"]>
  export type GeoZipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    censusMetrics?: boolean | GeoZip$censusMetricsArgs<ExtArgs>
    aiOutputScopes?: boolean | GeoZip$aiOutputScopesArgs<ExtArgs>
    electionResults?: boolean | GeoZip$electionResultsArgs<ExtArgs>
    _count?: boolean | GeoZipCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GeoZipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type GeoZipIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $GeoZipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GeoZip"
    objects: {
      censusMetrics: Prisma.$CensusMetricPayload<ExtArgs>[]
      aiOutputScopes: Prisma.$AIOutputScopePayload<ExtArgs>[]
      electionResults: Prisma.$ElectionResultPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      zipCode: string
      createdAt: Date
    }, ExtArgs["result"]["geoZip"]>
    composites: {}
  }

  type GeoZipGetPayload<S extends boolean | null | undefined | GeoZipDefaultArgs> = $Result.GetResult<Prisma.$GeoZipPayload, S>

  type GeoZipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GeoZipFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GeoZipCountAggregateInputType | true
    }

  export interface GeoZipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GeoZip'], meta: { name: 'GeoZip' } }
    /**
     * Find zero or one GeoZip that matches the filter.
     * @param {GeoZipFindUniqueArgs} args - Arguments to find a GeoZip
     * @example
     * // Get one GeoZip
     * const geoZip = await prisma.geoZip.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GeoZipFindUniqueArgs>(args: SelectSubset<T, GeoZipFindUniqueArgs<ExtArgs>>): Prisma__GeoZipClient<$Result.GetResult<Prisma.$GeoZipPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GeoZip that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GeoZipFindUniqueOrThrowArgs} args - Arguments to find a GeoZip
     * @example
     * // Get one GeoZip
     * const geoZip = await prisma.geoZip.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GeoZipFindUniqueOrThrowArgs>(args: SelectSubset<T, GeoZipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GeoZipClient<$Result.GetResult<Prisma.$GeoZipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GeoZip that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeoZipFindFirstArgs} args - Arguments to find a GeoZip
     * @example
     * // Get one GeoZip
     * const geoZip = await prisma.geoZip.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GeoZipFindFirstArgs>(args?: SelectSubset<T, GeoZipFindFirstArgs<ExtArgs>>): Prisma__GeoZipClient<$Result.GetResult<Prisma.$GeoZipPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GeoZip that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeoZipFindFirstOrThrowArgs} args - Arguments to find a GeoZip
     * @example
     * // Get one GeoZip
     * const geoZip = await prisma.geoZip.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GeoZipFindFirstOrThrowArgs>(args?: SelectSubset<T, GeoZipFindFirstOrThrowArgs<ExtArgs>>): Prisma__GeoZipClient<$Result.GetResult<Prisma.$GeoZipPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GeoZips that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeoZipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GeoZips
     * const geoZips = await prisma.geoZip.findMany()
     * 
     * // Get first 10 GeoZips
     * const geoZips = await prisma.geoZip.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const geoZipWithIdOnly = await prisma.geoZip.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GeoZipFindManyArgs>(args?: SelectSubset<T, GeoZipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeoZipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GeoZip.
     * @param {GeoZipCreateArgs} args - Arguments to create a GeoZip.
     * @example
     * // Create one GeoZip
     * const GeoZip = await prisma.geoZip.create({
     *   data: {
     *     // ... data to create a GeoZip
     *   }
     * })
     * 
     */
    create<T extends GeoZipCreateArgs>(args: SelectSubset<T, GeoZipCreateArgs<ExtArgs>>): Prisma__GeoZipClient<$Result.GetResult<Prisma.$GeoZipPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GeoZips.
     * @param {GeoZipCreateManyArgs} args - Arguments to create many GeoZips.
     * @example
     * // Create many GeoZips
     * const geoZip = await prisma.geoZip.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GeoZipCreateManyArgs>(args?: SelectSubset<T, GeoZipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GeoZips and returns the data saved in the database.
     * @param {GeoZipCreateManyAndReturnArgs} args - Arguments to create many GeoZips.
     * @example
     * // Create many GeoZips
     * const geoZip = await prisma.geoZip.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GeoZips and only return the `id`
     * const geoZipWithIdOnly = await prisma.geoZip.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GeoZipCreateManyAndReturnArgs>(args?: SelectSubset<T, GeoZipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeoZipPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GeoZip.
     * @param {GeoZipDeleteArgs} args - Arguments to delete one GeoZip.
     * @example
     * // Delete one GeoZip
     * const GeoZip = await prisma.geoZip.delete({
     *   where: {
     *     // ... filter to delete one GeoZip
     *   }
     * })
     * 
     */
    delete<T extends GeoZipDeleteArgs>(args: SelectSubset<T, GeoZipDeleteArgs<ExtArgs>>): Prisma__GeoZipClient<$Result.GetResult<Prisma.$GeoZipPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GeoZip.
     * @param {GeoZipUpdateArgs} args - Arguments to update one GeoZip.
     * @example
     * // Update one GeoZip
     * const geoZip = await prisma.geoZip.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GeoZipUpdateArgs>(args: SelectSubset<T, GeoZipUpdateArgs<ExtArgs>>): Prisma__GeoZipClient<$Result.GetResult<Prisma.$GeoZipPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GeoZips.
     * @param {GeoZipDeleteManyArgs} args - Arguments to filter GeoZips to delete.
     * @example
     * // Delete a few GeoZips
     * const { count } = await prisma.geoZip.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GeoZipDeleteManyArgs>(args?: SelectSubset<T, GeoZipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GeoZips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeoZipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GeoZips
     * const geoZip = await prisma.geoZip.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GeoZipUpdateManyArgs>(args: SelectSubset<T, GeoZipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GeoZips and returns the data updated in the database.
     * @param {GeoZipUpdateManyAndReturnArgs} args - Arguments to update many GeoZips.
     * @example
     * // Update many GeoZips
     * const geoZip = await prisma.geoZip.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GeoZips and only return the `id`
     * const geoZipWithIdOnly = await prisma.geoZip.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GeoZipUpdateManyAndReturnArgs>(args: SelectSubset<T, GeoZipUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeoZipPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GeoZip.
     * @param {GeoZipUpsertArgs} args - Arguments to update or create a GeoZip.
     * @example
     * // Update or create a GeoZip
     * const geoZip = await prisma.geoZip.upsert({
     *   create: {
     *     // ... data to create a GeoZip
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GeoZip we want to update
     *   }
     * })
     */
    upsert<T extends GeoZipUpsertArgs>(args: SelectSubset<T, GeoZipUpsertArgs<ExtArgs>>): Prisma__GeoZipClient<$Result.GetResult<Prisma.$GeoZipPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GeoZips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeoZipCountArgs} args - Arguments to filter GeoZips to count.
     * @example
     * // Count the number of GeoZips
     * const count = await prisma.geoZip.count({
     *   where: {
     *     // ... the filter for the GeoZips we want to count
     *   }
     * })
    **/
    count<T extends GeoZipCountArgs>(
      args?: Subset<T, GeoZipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GeoZipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GeoZip.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeoZipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GeoZipAggregateArgs>(args: Subset<T, GeoZipAggregateArgs>): Prisma.PrismaPromise<GetGeoZipAggregateType<T>>

    /**
     * Group by GeoZip.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeoZipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GeoZipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GeoZipGroupByArgs['orderBy'] }
        : { orderBy?: GeoZipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GeoZipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGeoZipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GeoZip model
   */
  readonly fields: GeoZipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GeoZip.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GeoZipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    censusMetrics<T extends GeoZip$censusMetricsArgs<ExtArgs> = {}>(args?: Subset<T, GeoZip$censusMetricsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CensusMetricPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    aiOutputScopes<T extends GeoZip$aiOutputScopesArgs<ExtArgs> = {}>(args?: Subset<T, GeoZip$aiOutputScopesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIOutputScopePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    electionResults<T extends GeoZip$electionResultsArgs<ExtArgs> = {}>(args?: Subset<T, GeoZip$electionResultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ElectionResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GeoZip model
   */
  interface GeoZipFieldRefs {
    readonly id: FieldRef<"GeoZip", 'String'>
    readonly zipCode: FieldRef<"GeoZip", 'String'>
    readonly createdAt: FieldRef<"GeoZip", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GeoZip findUnique
   */
  export type GeoZipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoZip
     */
    select?: GeoZipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeoZip
     */
    omit?: GeoZipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeoZipInclude<ExtArgs> | null
    /**
     * Filter, which GeoZip to fetch.
     */
    where: GeoZipWhereUniqueInput
  }

  /**
   * GeoZip findUniqueOrThrow
   */
  export type GeoZipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoZip
     */
    select?: GeoZipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeoZip
     */
    omit?: GeoZipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeoZipInclude<ExtArgs> | null
    /**
     * Filter, which GeoZip to fetch.
     */
    where: GeoZipWhereUniqueInput
  }

  /**
   * GeoZip findFirst
   */
  export type GeoZipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoZip
     */
    select?: GeoZipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeoZip
     */
    omit?: GeoZipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeoZipInclude<ExtArgs> | null
    /**
     * Filter, which GeoZip to fetch.
     */
    where?: GeoZipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeoZips to fetch.
     */
    orderBy?: GeoZipOrderByWithRelationInput | GeoZipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GeoZips.
     */
    cursor?: GeoZipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeoZips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeoZips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GeoZips.
     */
    distinct?: GeoZipScalarFieldEnum | GeoZipScalarFieldEnum[]
  }

  /**
   * GeoZip findFirstOrThrow
   */
  export type GeoZipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoZip
     */
    select?: GeoZipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeoZip
     */
    omit?: GeoZipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeoZipInclude<ExtArgs> | null
    /**
     * Filter, which GeoZip to fetch.
     */
    where?: GeoZipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeoZips to fetch.
     */
    orderBy?: GeoZipOrderByWithRelationInput | GeoZipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GeoZips.
     */
    cursor?: GeoZipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeoZips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeoZips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GeoZips.
     */
    distinct?: GeoZipScalarFieldEnum | GeoZipScalarFieldEnum[]
  }

  /**
   * GeoZip findMany
   */
  export type GeoZipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoZip
     */
    select?: GeoZipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeoZip
     */
    omit?: GeoZipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeoZipInclude<ExtArgs> | null
    /**
     * Filter, which GeoZips to fetch.
     */
    where?: GeoZipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeoZips to fetch.
     */
    orderBy?: GeoZipOrderByWithRelationInput | GeoZipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GeoZips.
     */
    cursor?: GeoZipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeoZips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeoZips.
     */
    skip?: number
    distinct?: GeoZipScalarFieldEnum | GeoZipScalarFieldEnum[]
  }

  /**
   * GeoZip create
   */
  export type GeoZipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoZip
     */
    select?: GeoZipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeoZip
     */
    omit?: GeoZipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeoZipInclude<ExtArgs> | null
    /**
     * The data needed to create a GeoZip.
     */
    data: XOR<GeoZipCreateInput, GeoZipUncheckedCreateInput>
  }

  /**
   * GeoZip createMany
   */
  export type GeoZipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GeoZips.
     */
    data: GeoZipCreateManyInput | GeoZipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GeoZip createManyAndReturn
   */
  export type GeoZipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoZip
     */
    select?: GeoZipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GeoZip
     */
    omit?: GeoZipOmit<ExtArgs> | null
    /**
     * The data used to create many GeoZips.
     */
    data: GeoZipCreateManyInput | GeoZipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GeoZip update
   */
  export type GeoZipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoZip
     */
    select?: GeoZipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeoZip
     */
    omit?: GeoZipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeoZipInclude<ExtArgs> | null
    /**
     * The data needed to update a GeoZip.
     */
    data: XOR<GeoZipUpdateInput, GeoZipUncheckedUpdateInput>
    /**
     * Choose, which GeoZip to update.
     */
    where: GeoZipWhereUniqueInput
  }

  /**
   * GeoZip updateMany
   */
  export type GeoZipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GeoZips.
     */
    data: XOR<GeoZipUpdateManyMutationInput, GeoZipUncheckedUpdateManyInput>
    /**
     * Filter which GeoZips to update
     */
    where?: GeoZipWhereInput
    /**
     * Limit how many GeoZips to update.
     */
    limit?: number
  }

  /**
   * GeoZip updateManyAndReturn
   */
  export type GeoZipUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoZip
     */
    select?: GeoZipSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GeoZip
     */
    omit?: GeoZipOmit<ExtArgs> | null
    /**
     * The data used to update GeoZips.
     */
    data: XOR<GeoZipUpdateManyMutationInput, GeoZipUncheckedUpdateManyInput>
    /**
     * Filter which GeoZips to update
     */
    where?: GeoZipWhereInput
    /**
     * Limit how many GeoZips to update.
     */
    limit?: number
  }

  /**
   * GeoZip upsert
   */
  export type GeoZipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoZip
     */
    select?: GeoZipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeoZip
     */
    omit?: GeoZipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeoZipInclude<ExtArgs> | null
    /**
     * The filter to search for the GeoZip to update in case it exists.
     */
    where: GeoZipWhereUniqueInput
    /**
     * In case the GeoZip found by the `where` argument doesn't exist, create a new GeoZip with this data.
     */
    create: XOR<GeoZipCreateInput, GeoZipUncheckedCreateInput>
    /**
     * In case the GeoZip was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GeoZipUpdateInput, GeoZipUncheckedUpdateInput>
  }

  /**
   * GeoZip delete
   */
  export type GeoZipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoZip
     */
    select?: GeoZipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeoZip
     */
    omit?: GeoZipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeoZipInclude<ExtArgs> | null
    /**
     * Filter which GeoZip to delete.
     */
    where: GeoZipWhereUniqueInput
  }

  /**
   * GeoZip deleteMany
   */
  export type GeoZipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GeoZips to delete
     */
    where?: GeoZipWhereInput
    /**
     * Limit how many GeoZips to delete.
     */
    limit?: number
  }

  /**
   * GeoZip.censusMetrics
   */
  export type GeoZip$censusMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusMetric
     */
    select?: CensusMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusMetric
     */
    omit?: CensusMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusMetricInclude<ExtArgs> | null
    where?: CensusMetricWhereInput
    orderBy?: CensusMetricOrderByWithRelationInput | CensusMetricOrderByWithRelationInput[]
    cursor?: CensusMetricWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CensusMetricScalarFieldEnum | CensusMetricScalarFieldEnum[]
  }

  /**
   * GeoZip.aiOutputScopes
   */
  export type GeoZip$aiOutputScopesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIOutputScope
     */
    select?: AIOutputScopeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIOutputScope
     */
    omit?: AIOutputScopeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIOutputScopeInclude<ExtArgs> | null
    where?: AIOutputScopeWhereInput
    orderBy?: AIOutputScopeOrderByWithRelationInput | AIOutputScopeOrderByWithRelationInput[]
    cursor?: AIOutputScopeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIOutputScopeScalarFieldEnum | AIOutputScopeScalarFieldEnum[]
  }

  /**
   * GeoZip.electionResults
   */
  export type GeoZip$electionResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElectionResult
     */
    select?: ElectionResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElectionResult
     */
    omit?: ElectionResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElectionResultInclude<ExtArgs> | null
    where?: ElectionResultWhereInput
    orderBy?: ElectionResultOrderByWithRelationInput | ElectionResultOrderByWithRelationInput[]
    cursor?: ElectionResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ElectionResultScalarFieldEnum | ElectionResultScalarFieldEnum[]
  }

  /**
   * GeoZip without action
   */
  export type GeoZipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoZip
     */
    select?: GeoZipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeoZip
     */
    omit?: GeoZipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeoZipInclude<ExtArgs> | null
  }


  /**
   * Model GeoPrecinct
   */

  export type AggregateGeoPrecinct = {
    _count: GeoPrecinctCountAggregateOutputType | null
    _min: GeoPrecinctMinAggregateOutputType | null
    _max: GeoPrecinctMaxAggregateOutputType | null
  }

  export type GeoPrecinctMinAggregateOutputType = {
    id: string | null
    name: string | null
    precinctCode: string | null
    createdAt: Date | null
  }

  export type GeoPrecinctMaxAggregateOutputType = {
    id: string | null
    name: string | null
    precinctCode: string | null
    createdAt: Date | null
  }

  export type GeoPrecinctCountAggregateOutputType = {
    id: number
    name: number
    precinctCode: number
    createdAt: number
    _all: number
  }


  export type GeoPrecinctMinAggregateInputType = {
    id?: true
    name?: true
    precinctCode?: true
    createdAt?: true
  }

  export type GeoPrecinctMaxAggregateInputType = {
    id?: true
    name?: true
    precinctCode?: true
    createdAt?: true
  }

  export type GeoPrecinctCountAggregateInputType = {
    id?: true
    name?: true
    precinctCode?: true
    createdAt?: true
    _all?: true
  }

  export type GeoPrecinctAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GeoPrecinct to aggregate.
     */
    where?: GeoPrecinctWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeoPrecincts to fetch.
     */
    orderBy?: GeoPrecinctOrderByWithRelationInput | GeoPrecinctOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GeoPrecinctWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeoPrecincts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeoPrecincts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GeoPrecincts
    **/
    _count?: true | GeoPrecinctCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GeoPrecinctMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GeoPrecinctMaxAggregateInputType
  }

  export type GetGeoPrecinctAggregateType<T extends GeoPrecinctAggregateArgs> = {
        [P in keyof T & keyof AggregateGeoPrecinct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGeoPrecinct[P]>
      : GetScalarType<T[P], AggregateGeoPrecinct[P]>
  }




  export type GeoPrecinctGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GeoPrecinctWhereInput
    orderBy?: GeoPrecinctOrderByWithAggregationInput | GeoPrecinctOrderByWithAggregationInput[]
    by: GeoPrecinctScalarFieldEnum[] | GeoPrecinctScalarFieldEnum
    having?: GeoPrecinctScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GeoPrecinctCountAggregateInputType | true
    _min?: GeoPrecinctMinAggregateInputType
    _max?: GeoPrecinctMaxAggregateInputType
  }

  export type GeoPrecinctGroupByOutputType = {
    id: string
    name: string | null
    precinctCode: string | null
    createdAt: Date
    _count: GeoPrecinctCountAggregateOutputType | null
    _min: GeoPrecinctMinAggregateOutputType | null
    _max: GeoPrecinctMaxAggregateOutputType | null
  }

  type GetGeoPrecinctGroupByPayload<T extends GeoPrecinctGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GeoPrecinctGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GeoPrecinctGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GeoPrecinctGroupByOutputType[P]>
            : GetScalarType<T[P], GeoPrecinctGroupByOutputType[P]>
        }
      >
    >


  export type GeoPrecinctSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    precinctCode?: boolean
    createdAt?: boolean
    electionResults?: boolean | GeoPrecinct$electionResultsArgs<ExtArgs>
    _count?: boolean | GeoPrecinctCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["geoPrecinct"]>

  export type GeoPrecinctSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    precinctCode?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["geoPrecinct"]>

  export type GeoPrecinctSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    precinctCode?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["geoPrecinct"]>

  export type GeoPrecinctSelectScalar = {
    id?: boolean
    name?: boolean
    precinctCode?: boolean
    createdAt?: boolean
  }

  export type GeoPrecinctOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "precinctCode" | "createdAt", ExtArgs["result"]["geoPrecinct"]>
  export type GeoPrecinctInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    electionResults?: boolean | GeoPrecinct$electionResultsArgs<ExtArgs>
    _count?: boolean | GeoPrecinctCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GeoPrecinctIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type GeoPrecinctIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $GeoPrecinctPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GeoPrecinct"
    objects: {
      electionResults: Prisma.$ElectionResultPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      precinctCode: string | null
      createdAt: Date
    }, ExtArgs["result"]["geoPrecinct"]>
    composites: {}
  }

  type GeoPrecinctGetPayload<S extends boolean | null | undefined | GeoPrecinctDefaultArgs> = $Result.GetResult<Prisma.$GeoPrecinctPayload, S>

  type GeoPrecinctCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GeoPrecinctFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GeoPrecinctCountAggregateInputType | true
    }

  export interface GeoPrecinctDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GeoPrecinct'], meta: { name: 'GeoPrecinct' } }
    /**
     * Find zero or one GeoPrecinct that matches the filter.
     * @param {GeoPrecinctFindUniqueArgs} args - Arguments to find a GeoPrecinct
     * @example
     * // Get one GeoPrecinct
     * const geoPrecinct = await prisma.geoPrecinct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GeoPrecinctFindUniqueArgs>(args: SelectSubset<T, GeoPrecinctFindUniqueArgs<ExtArgs>>): Prisma__GeoPrecinctClient<$Result.GetResult<Prisma.$GeoPrecinctPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GeoPrecinct that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GeoPrecinctFindUniqueOrThrowArgs} args - Arguments to find a GeoPrecinct
     * @example
     * // Get one GeoPrecinct
     * const geoPrecinct = await prisma.geoPrecinct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GeoPrecinctFindUniqueOrThrowArgs>(args: SelectSubset<T, GeoPrecinctFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GeoPrecinctClient<$Result.GetResult<Prisma.$GeoPrecinctPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GeoPrecinct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeoPrecinctFindFirstArgs} args - Arguments to find a GeoPrecinct
     * @example
     * // Get one GeoPrecinct
     * const geoPrecinct = await prisma.geoPrecinct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GeoPrecinctFindFirstArgs>(args?: SelectSubset<T, GeoPrecinctFindFirstArgs<ExtArgs>>): Prisma__GeoPrecinctClient<$Result.GetResult<Prisma.$GeoPrecinctPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GeoPrecinct that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeoPrecinctFindFirstOrThrowArgs} args - Arguments to find a GeoPrecinct
     * @example
     * // Get one GeoPrecinct
     * const geoPrecinct = await prisma.geoPrecinct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GeoPrecinctFindFirstOrThrowArgs>(args?: SelectSubset<T, GeoPrecinctFindFirstOrThrowArgs<ExtArgs>>): Prisma__GeoPrecinctClient<$Result.GetResult<Prisma.$GeoPrecinctPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GeoPrecincts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeoPrecinctFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GeoPrecincts
     * const geoPrecincts = await prisma.geoPrecinct.findMany()
     * 
     * // Get first 10 GeoPrecincts
     * const geoPrecincts = await prisma.geoPrecinct.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const geoPrecinctWithIdOnly = await prisma.geoPrecinct.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GeoPrecinctFindManyArgs>(args?: SelectSubset<T, GeoPrecinctFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeoPrecinctPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GeoPrecinct.
     * @param {GeoPrecinctCreateArgs} args - Arguments to create a GeoPrecinct.
     * @example
     * // Create one GeoPrecinct
     * const GeoPrecinct = await prisma.geoPrecinct.create({
     *   data: {
     *     // ... data to create a GeoPrecinct
     *   }
     * })
     * 
     */
    create<T extends GeoPrecinctCreateArgs>(args: SelectSubset<T, GeoPrecinctCreateArgs<ExtArgs>>): Prisma__GeoPrecinctClient<$Result.GetResult<Prisma.$GeoPrecinctPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GeoPrecincts.
     * @param {GeoPrecinctCreateManyArgs} args - Arguments to create many GeoPrecincts.
     * @example
     * // Create many GeoPrecincts
     * const geoPrecinct = await prisma.geoPrecinct.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GeoPrecinctCreateManyArgs>(args?: SelectSubset<T, GeoPrecinctCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GeoPrecincts and returns the data saved in the database.
     * @param {GeoPrecinctCreateManyAndReturnArgs} args - Arguments to create many GeoPrecincts.
     * @example
     * // Create many GeoPrecincts
     * const geoPrecinct = await prisma.geoPrecinct.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GeoPrecincts and only return the `id`
     * const geoPrecinctWithIdOnly = await prisma.geoPrecinct.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GeoPrecinctCreateManyAndReturnArgs>(args?: SelectSubset<T, GeoPrecinctCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeoPrecinctPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GeoPrecinct.
     * @param {GeoPrecinctDeleteArgs} args - Arguments to delete one GeoPrecinct.
     * @example
     * // Delete one GeoPrecinct
     * const GeoPrecinct = await prisma.geoPrecinct.delete({
     *   where: {
     *     // ... filter to delete one GeoPrecinct
     *   }
     * })
     * 
     */
    delete<T extends GeoPrecinctDeleteArgs>(args: SelectSubset<T, GeoPrecinctDeleteArgs<ExtArgs>>): Prisma__GeoPrecinctClient<$Result.GetResult<Prisma.$GeoPrecinctPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GeoPrecinct.
     * @param {GeoPrecinctUpdateArgs} args - Arguments to update one GeoPrecinct.
     * @example
     * // Update one GeoPrecinct
     * const geoPrecinct = await prisma.geoPrecinct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GeoPrecinctUpdateArgs>(args: SelectSubset<T, GeoPrecinctUpdateArgs<ExtArgs>>): Prisma__GeoPrecinctClient<$Result.GetResult<Prisma.$GeoPrecinctPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GeoPrecincts.
     * @param {GeoPrecinctDeleteManyArgs} args - Arguments to filter GeoPrecincts to delete.
     * @example
     * // Delete a few GeoPrecincts
     * const { count } = await prisma.geoPrecinct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GeoPrecinctDeleteManyArgs>(args?: SelectSubset<T, GeoPrecinctDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GeoPrecincts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeoPrecinctUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GeoPrecincts
     * const geoPrecinct = await prisma.geoPrecinct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GeoPrecinctUpdateManyArgs>(args: SelectSubset<T, GeoPrecinctUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GeoPrecincts and returns the data updated in the database.
     * @param {GeoPrecinctUpdateManyAndReturnArgs} args - Arguments to update many GeoPrecincts.
     * @example
     * // Update many GeoPrecincts
     * const geoPrecinct = await prisma.geoPrecinct.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GeoPrecincts and only return the `id`
     * const geoPrecinctWithIdOnly = await prisma.geoPrecinct.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GeoPrecinctUpdateManyAndReturnArgs>(args: SelectSubset<T, GeoPrecinctUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeoPrecinctPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GeoPrecinct.
     * @param {GeoPrecinctUpsertArgs} args - Arguments to update or create a GeoPrecinct.
     * @example
     * // Update or create a GeoPrecinct
     * const geoPrecinct = await prisma.geoPrecinct.upsert({
     *   create: {
     *     // ... data to create a GeoPrecinct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GeoPrecinct we want to update
     *   }
     * })
     */
    upsert<T extends GeoPrecinctUpsertArgs>(args: SelectSubset<T, GeoPrecinctUpsertArgs<ExtArgs>>): Prisma__GeoPrecinctClient<$Result.GetResult<Prisma.$GeoPrecinctPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GeoPrecincts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeoPrecinctCountArgs} args - Arguments to filter GeoPrecincts to count.
     * @example
     * // Count the number of GeoPrecincts
     * const count = await prisma.geoPrecinct.count({
     *   where: {
     *     // ... the filter for the GeoPrecincts we want to count
     *   }
     * })
    **/
    count<T extends GeoPrecinctCountArgs>(
      args?: Subset<T, GeoPrecinctCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GeoPrecinctCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GeoPrecinct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeoPrecinctAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GeoPrecinctAggregateArgs>(args: Subset<T, GeoPrecinctAggregateArgs>): Prisma.PrismaPromise<GetGeoPrecinctAggregateType<T>>

    /**
     * Group by GeoPrecinct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeoPrecinctGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GeoPrecinctGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GeoPrecinctGroupByArgs['orderBy'] }
        : { orderBy?: GeoPrecinctGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GeoPrecinctGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGeoPrecinctGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GeoPrecinct model
   */
  readonly fields: GeoPrecinctFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GeoPrecinct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GeoPrecinctClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    electionResults<T extends GeoPrecinct$electionResultsArgs<ExtArgs> = {}>(args?: Subset<T, GeoPrecinct$electionResultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ElectionResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GeoPrecinct model
   */
  interface GeoPrecinctFieldRefs {
    readonly id: FieldRef<"GeoPrecinct", 'String'>
    readonly name: FieldRef<"GeoPrecinct", 'String'>
    readonly precinctCode: FieldRef<"GeoPrecinct", 'String'>
    readonly createdAt: FieldRef<"GeoPrecinct", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GeoPrecinct findUnique
   */
  export type GeoPrecinctFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoPrecinct
     */
    select?: GeoPrecinctSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeoPrecinct
     */
    omit?: GeoPrecinctOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeoPrecinctInclude<ExtArgs> | null
    /**
     * Filter, which GeoPrecinct to fetch.
     */
    where: GeoPrecinctWhereUniqueInput
  }

  /**
   * GeoPrecinct findUniqueOrThrow
   */
  export type GeoPrecinctFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoPrecinct
     */
    select?: GeoPrecinctSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeoPrecinct
     */
    omit?: GeoPrecinctOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeoPrecinctInclude<ExtArgs> | null
    /**
     * Filter, which GeoPrecinct to fetch.
     */
    where: GeoPrecinctWhereUniqueInput
  }

  /**
   * GeoPrecinct findFirst
   */
  export type GeoPrecinctFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoPrecinct
     */
    select?: GeoPrecinctSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeoPrecinct
     */
    omit?: GeoPrecinctOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeoPrecinctInclude<ExtArgs> | null
    /**
     * Filter, which GeoPrecinct to fetch.
     */
    where?: GeoPrecinctWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeoPrecincts to fetch.
     */
    orderBy?: GeoPrecinctOrderByWithRelationInput | GeoPrecinctOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GeoPrecincts.
     */
    cursor?: GeoPrecinctWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeoPrecincts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeoPrecincts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GeoPrecincts.
     */
    distinct?: GeoPrecinctScalarFieldEnum | GeoPrecinctScalarFieldEnum[]
  }

  /**
   * GeoPrecinct findFirstOrThrow
   */
  export type GeoPrecinctFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoPrecinct
     */
    select?: GeoPrecinctSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeoPrecinct
     */
    omit?: GeoPrecinctOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeoPrecinctInclude<ExtArgs> | null
    /**
     * Filter, which GeoPrecinct to fetch.
     */
    where?: GeoPrecinctWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeoPrecincts to fetch.
     */
    orderBy?: GeoPrecinctOrderByWithRelationInput | GeoPrecinctOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GeoPrecincts.
     */
    cursor?: GeoPrecinctWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeoPrecincts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeoPrecincts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GeoPrecincts.
     */
    distinct?: GeoPrecinctScalarFieldEnum | GeoPrecinctScalarFieldEnum[]
  }

  /**
   * GeoPrecinct findMany
   */
  export type GeoPrecinctFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoPrecinct
     */
    select?: GeoPrecinctSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeoPrecinct
     */
    omit?: GeoPrecinctOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeoPrecinctInclude<ExtArgs> | null
    /**
     * Filter, which GeoPrecincts to fetch.
     */
    where?: GeoPrecinctWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeoPrecincts to fetch.
     */
    orderBy?: GeoPrecinctOrderByWithRelationInput | GeoPrecinctOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GeoPrecincts.
     */
    cursor?: GeoPrecinctWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeoPrecincts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeoPrecincts.
     */
    skip?: number
    distinct?: GeoPrecinctScalarFieldEnum | GeoPrecinctScalarFieldEnum[]
  }

  /**
   * GeoPrecinct create
   */
  export type GeoPrecinctCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoPrecinct
     */
    select?: GeoPrecinctSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeoPrecinct
     */
    omit?: GeoPrecinctOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeoPrecinctInclude<ExtArgs> | null
    /**
     * The data needed to create a GeoPrecinct.
     */
    data?: XOR<GeoPrecinctCreateInput, GeoPrecinctUncheckedCreateInput>
  }

  /**
   * GeoPrecinct createMany
   */
  export type GeoPrecinctCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GeoPrecincts.
     */
    data: GeoPrecinctCreateManyInput | GeoPrecinctCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GeoPrecinct createManyAndReturn
   */
  export type GeoPrecinctCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoPrecinct
     */
    select?: GeoPrecinctSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GeoPrecinct
     */
    omit?: GeoPrecinctOmit<ExtArgs> | null
    /**
     * The data used to create many GeoPrecincts.
     */
    data: GeoPrecinctCreateManyInput | GeoPrecinctCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GeoPrecinct update
   */
  export type GeoPrecinctUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoPrecinct
     */
    select?: GeoPrecinctSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeoPrecinct
     */
    omit?: GeoPrecinctOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeoPrecinctInclude<ExtArgs> | null
    /**
     * The data needed to update a GeoPrecinct.
     */
    data: XOR<GeoPrecinctUpdateInput, GeoPrecinctUncheckedUpdateInput>
    /**
     * Choose, which GeoPrecinct to update.
     */
    where: GeoPrecinctWhereUniqueInput
  }

  /**
   * GeoPrecinct updateMany
   */
  export type GeoPrecinctUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GeoPrecincts.
     */
    data: XOR<GeoPrecinctUpdateManyMutationInput, GeoPrecinctUncheckedUpdateManyInput>
    /**
     * Filter which GeoPrecincts to update
     */
    where?: GeoPrecinctWhereInput
    /**
     * Limit how many GeoPrecincts to update.
     */
    limit?: number
  }

  /**
   * GeoPrecinct updateManyAndReturn
   */
  export type GeoPrecinctUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoPrecinct
     */
    select?: GeoPrecinctSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GeoPrecinct
     */
    omit?: GeoPrecinctOmit<ExtArgs> | null
    /**
     * The data used to update GeoPrecincts.
     */
    data: XOR<GeoPrecinctUpdateManyMutationInput, GeoPrecinctUncheckedUpdateManyInput>
    /**
     * Filter which GeoPrecincts to update
     */
    where?: GeoPrecinctWhereInput
    /**
     * Limit how many GeoPrecincts to update.
     */
    limit?: number
  }

  /**
   * GeoPrecinct upsert
   */
  export type GeoPrecinctUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoPrecinct
     */
    select?: GeoPrecinctSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeoPrecinct
     */
    omit?: GeoPrecinctOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeoPrecinctInclude<ExtArgs> | null
    /**
     * The filter to search for the GeoPrecinct to update in case it exists.
     */
    where: GeoPrecinctWhereUniqueInput
    /**
     * In case the GeoPrecinct found by the `where` argument doesn't exist, create a new GeoPrecinct with this data.
     */
    create: XOR<GeoPrecinctCreateInput, GeoPrecinctUncheckedCreateInput>
    /**
     * In case the GeoPrecinct was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GeoPrecinctUpdateInput, GeoPrecinctUncheckedUpdateInput>
  }

  /**
   * GeoPrecinct delete
   */
  export type GeoPrecinctDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoPrecinct
     */
    select?: GeoPrecinctSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeoPrecinct
     */
    omit?: GeoPrecinctOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeoPrecinctInclude<ExtArgs> | null
    /**
     * Filter which GeoPrecinct to delete.
     */
    where: GeoPrecinctWhereUniqueInput
  }

  /**
   * GeoPrecinct deleteMany
   */
  export type GeoPrecinctDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GeoPrecincts to delete
     */
    where?: GeoPrecinctWhereInput
    /**
     * Limit how many GeoPrecincts to delete.
     */
    limit?: number
  }

  /**
   * GeoPrecinct.electionResults
   */
  export type GeoPrecinct$electionResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElectionResult
     */
    select?: ElectionResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElectionResult
     */
    omit?: ElectionResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElectionResultInclude<ExtArgs> | null
    where?: ElectionResultWhereInput
    orderBy?: ElectionResultOrderByWithRelationInput | ElectionResultOrderByWithRelationInput[]
    cursor?: ElectionResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ElectionResultScalarFieldEnum | ElectionResultScalarFieldEnum[]
  }

  /**
   * GeoPrecinct without action
   */
  export type GeoPrecinctDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoPrecinct
     */
    select?: GeoPrecinctSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeoPrecinct
     */
    omit?: GeoPrecinctOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeoPrecinctInclude<ExtArgs> | null
  }


  /**
   * Model GeoDistrict
   */

  export type AggregateGeoDistrict = {
    _count: GeoDistrictCountAggregateOutputType | null
    _min: GeoDistrictMinAggregateOutputType | null
    _max: GeoDistrictMaxAggregateOutputType | null
  }

  export type GeoDistrictMinAggregateOutputType = {
    id: string | null
    districtCode: string | null
    districtType: string | null
    createdAt: Date | null
  }

  export type GeoDistrictMaxAggregateOutputType = {
    id: string | null
    districtCode: string | null
    districtType: string | null
    createdAt: Date | null
  }

  export type GeoDistrictCountAggregateOutputType = {
    id: number
    districtCode: number
    districtType: number
    createdAt: number
    _all: number
  }


  export type GeoDistrictMinAggregateInputType = {
    id?: true
    districtCode?: true
    districtType?: true
    createdAt?: true
  }

  export type GeoDistrictMaxAggregateInputType = {
    id?: true
    districtCode?: true
    districtType?: true
    createdAt?: true
  }

  export type GeoDistrictCountAggregateInputType = {
    id?: true
    districtCode?: true
    districtType?: true
    createdAt?: true
    _all?: true
  }

  export type GeoDistrictAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GeoDistrict to aggregate.
     */
    where?: GeoDistrictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeoDistricts to fetch.
     */
    orderBy?: GeoDistrictOrderByWithRelationInput | GeoDistrictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GeoDistrictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeoDistricts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeoDistricts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GeoDistricts
    **/
    _count?: true | GeoDistrictCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GeoDistrictMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GeoDistrictMaxAggregateInputType
  }

  export type GetGeoDistrictAggregateType<T extends GeoDistrictAggregateArgs> = {
        [P in keyof T & keyof AggregateGeoDistrict]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGeoDistrict[P]>
      : GetScalarType<T[P], AggregateGeoDistrict[P]>
  }




  export type GeoDistrictGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GeoDistrictWhereInput
    orderBy?: GeoDistrictOrderByWithAggregationInput | GeoDistrictOrderByWithAggregationInput[]
    by: GeoDistrictScalarFieldEnum[] | GeoDistrictScalarFieldEnum
    having?: GeoDistrictScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GeoDistrictCountAggregateInputType | true
    _min?: GeoDistrictMinAggregateInputType
    _max?: GeoDistrictMaxAggregateInputType
  }

  export type GeoDistrictGroupByOutputType = {
    id: string
    districtCode: string
    districtType: string | null
    createdAt: Date
    _count: GeoDistrictCountAggregateOutputType | null
    _min: GeoDistrictMinAggregateOutputType | null
    _max: GeoDistrictMaxAggregateOutputType | null
  }

  type GetGeoDistrictGroupByPayload<T extends GeoDistrictGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GeoDistrictGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GeoDistrictGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GeoDistrictGroupByOutputType[P]>
            : GetScalarType<T[P], GeoDistrictGroupByOutputType[P]>
        }
      >
    >


  export type GeoDistrictSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    districtCode?: boolean
    districtType?: boolean
    createdAt?: boolean
    civicsOfficials?: boolean | GeoDistrict$civicsOfficialsArgs<ExtArgs>
    aiOutputScopes?: boolean | GeoDistrict$aiOutputScopesArgs<ExtArgs>
    _count?: boolean | GeoDistrictCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["geoDistrict"]>

  export type GeoDistrictSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    districtCode?: boolean
    districtType?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["geoDistrict"]>

  export type GeoDistrictSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    districtCode?: boolean
    districtType?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["geoDistrict"]>

  export type GeoDistrictSelectScalar = {
    id?: boolean
    districtCode?: boolean
    districtType?: boolean
    createdAt?: boolean
  }

  export type GeoDistrictOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "districtCode" | "districtType" | "createdAt", ExtArgs["result"]["geoDistrict"]>
  export type GeoDistrictInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    civicsOfficials?: boolean | GeoDistrict$civicsOfficialsArgs<ExtArgs>
    aiOutputScopes?: boolean | GeoDistrict$aiOutputScopesArgs<ExtArgs>
    _count?: boolean | GeoDistrictCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GeoDistrictIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type GeoDistrictIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $GeoDistrictPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GeoDistrict"
    objects: {
      civicsOfficials: Prisma.$CivicsOfficialPayload<ExtArgs>[]
      aiOutputScopes: Prisma.$AIOutputScopePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      districtCode: string
      districtType: string | null
      createdAt: Date
    }, ExtArgs["result"]["geoDistrict"]>
    composites: {}
  }

  type GeoDistrictGetPayload<S extends boolean | null | undefined | GeoDistrictDefaultArgs> = $Result.GetResult<Prisma.$GeoDistrictPayload, S>

  type GeoDistrictCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GeoDistrictFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GeoDistrictCountAggregateInputType | true
    }

  export interface GeoDistrictDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GeoDistrict'], meta: { name: 'GeoDistrict' } }
    /**
     * Find zero or one GeoDistrict that matches the filter.
     * @param {GeoDistrictFindUniqueArgs} args - Arguments to find a GeoDistrict
     * @example
     * // Get one GeoDistrict
     * const geoDistrict = await prisma.geoDistrict.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GeoDistrictFindUniqueArgs>(args: SelectSubset<T, GeoDistrictFindUniqueArgs<ExtArgs>>): Prisma__GeoDistrictClient<$Result.GetResult<Prisma.$GeoDistrictPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GeoDistrict that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GeoDistrictFindUniqueOrThrowArgs} args - Arguments to find a GeoDistrict
     * @example
     * // Get one GeoDistrict
     * const geoDistrict = await prisma.geoDistrict.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GeoDistrictFindUniqueOrThrowArgs>(args: SelectSubset<T, GeoDistrictFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GeoDistrictClient<$Result.GetResult<Prisma.$GeoDistrictPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GeoDistrict that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeoDistrictFindFirstArgs} args - Arguments to find a GeoDistrict
     * @example
     * // Get one GeoDistrict
     * const geoDistrict = await prisma.geoDistrict.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GeoDistrictFindFirstArgs>(args?: SelectSubset<T, GeoDistrictFindFirstArgs<ExtArgs>>): Prisma__GeoDistrictClient<$Result.GetResult<Prisma.$GeoDistrictPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GeoDistrict that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeoDistrictFindFirstOrThrowArgs} args - Arguments to find a GeoDistrict
     * @example
     * // Get one GeoDistrict
     * const geoDistrict = await prisma.geoDistrict.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GeoDistrictFindFirstOrThrowArgs>(args?: SelectSubset<T, GeoDistrictFindFirstOrThrowArgs<ExtArgs>>): Prisma__GeoDistrictClient<$Result.GetResult<Prisma.$GeoDistrictPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GeoDistricts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeoDistrictFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GeoDistricts
     * const geoDistricts = await prisma.geoDistrict.findMany()
     * 
     * // Get first 10 GeoDistricts
     * const geoDistricts = await prisma.geoDistrict.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const geoDistrictWithIdOnly = await prisma.geoDistrict.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GeoDistrictFindManyArgs>(args?: SelectSubset<T, GeoDistrictFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeoDistrictPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GeoDistrict.
     * @param {GeoDistrictCreateArgs} args - Arguments to create a GeoDistrict.
     * @example
     * // Create one GeoDistrict
     * const GeoDistrict = await prisma.geoDistrict.create({
     *   data: {
     *     // ... data to create a GeoDistrict
     *   }
     * })
     * 
     */
    create<T extends GeoDistrictCreateArgs>(args: SelectSubset<T, GeoDistrictCreateArgs<ExtArgs>>): Prisma__GeoDistrictClient<$Result.GetResult<Prisma.$GeoDistrictPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GeoDistricts.
     * @param {GeoDistrictCreateManyArgs} args - Arguments to create many GeoDistricts.
     * @example
     * // Create many GeoDistricts
     * const geoDistrict = await prisma.geoDistrict.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GeoDistrictCreateManyArgs>(args?: SelectSubset<T, GeoDistrictCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GeoDistricts and returns the data saved in the database.
     * @param {GeoDistrictCreateManyAndReturnArgs} args - Arguments to create many GeoDistricts.
     * @example
     * // Create many GeoDistricts
     * const geoDistrict = await prisma.geoDistrict.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GeoDistricts and only return the `id`
     * const geoDistrictWithIdOnly = await prisma.geoDistrict.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GeoDistrictCreateManyAndReturnArgs>(args?: SelectSubset<T, GeoDistrictCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeoDistrictPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GeoDistrict.
     * @param {GeoDistrictDeleteArgs} args - Arguments to delete one GeoDistrict.
     * @example
     * // Delete one GeoDistrict
     * const GeoDistrict = await prisma.geoDistrict.delete({
     *   where: {
     *     // ... filter to delete one GeoDistrict
     *   }
     * })
     * 
     */
    delete<T extends GeoDistrictDeleteArgs>(args: SelectSubset<T, GeoDistrictDeleteArgs<ExtArgs>>): Prisma__GeoDistrictClient<$Result.GetResult<Prisma.$GeoDistrictPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GeoDistrict.
     * @param {GeoDistrictUpdateArgs} args - Arguments to update one GeoDistrict.
     * @example
     * // Update one GeoDistrict
     * const geoDistrict = await prisma.geoDistrict.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GeoDistrictUpdateArgs>(args: SelectSubset<T, GeoDistrictUpdateArgs<ExtArgs>>): Prisma__GeoDistrictClient<$Result.GetResult<Prisma.$GeoDistrictPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GeoDistricts.
     * @param {GeoDistrictDeleteManyArgs} args - Arguments to filter GeoDistricts to delete.
     * @example
     * // Delete a few GeoDistricts
     * const { count } = await prisma.geoDistrict.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GeoDistrictDeleteManyArgs>(args?: SelectSubset<T, GeoDistrictDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GeoDistricts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeoDistrictUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GeoDistricts
     * const geoDistrict = await prisma.geoDistrict.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GeoDistrictUpdateManyArgs>(args: SelectSubset<T, GeoDistrictUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GeoDistricts and returns the data updated in the database.
     * @param {GeoDistrictUpdateManyAndReturnArgs} args - Arguments to update many GeoDistricts.
     * @example
     * // Update many GeoDistricts
     * const geoDistrict = await prisma.geoDistrict.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GeoDistricts and only return the `id`
     * const geoDistrictWithIdOnly = await prisma.geoDistrict.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GeoDistrictUpdateManyAndReturnArgs>(args: SelectSubset<T, GeoDistrictUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeoDistrictPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GeoDistrict.
     * @param {GeoDistrictUpsertArgs} args - Arguments to update or create a GeoDistrict.
     * @example
     * // Update or create a GeoDistrict
     * const geoDistrict = await prisma.geoDistrict.upsert({
     *   create: {
     *     // ... data to create a GeoDistrict
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GeoDistrict we want to update
     *   }
     * })
     */
    upsert<T extends GeoDistrictUpsertArgs>(args: SelectSubset<T, GeoDistrictUpsertArgs<ExtArgs>>): Prisma__GeoDistrictClient<$Result.GetResult<Prisma.$GeoDistrictPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GeoDistricts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeoDistrictCountArgs} args - Arguments to filter GeoDistricts to count.
     * @example
     * // Count the number of GeoDistricts
     * const count = await prisma.geoDistrict.count({
     *   where: {
     *     // ... the filter for the GeoDistricts we want to count
     *   }
     * })
    **/
    count<T extends GeoDistrictCountArgs>(
      args?: Subset<T, GeoDistrictCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GeoDistrictCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GeoDistrict.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeoDistrictAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GeoDistrictAggregateArgs>(args: Subset<T, GeoDistrictAggregateArgs>): Prisma.PrismaPromise<GetGeoDistrictAggregateType<T>>

    /**
     * Group by GeoDistrict.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeoDistrictGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GeoDistrictGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GeoDistrictGroupByArgs['orderBy'] }
        : { orderBy?: GeoDistrictGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GeoDistrictGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGeoDistrictGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GeoDistrict model
   */
  readonly fields: GeoDistrictFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GeoDistrict.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GeoDistrictClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    civicsOfficials<T extends GeoDistrict$civicsOfficialsArgs<ExtArgs> = {}>(args?: Subset<T, GeoDistrict$civicsOfficialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CivicsOfficialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    aiOutputScopes<T extends GeoDistrict$aiOutputScopesArgs<ExtArgs> = {}>(args?: Subset<T, GeoDistrict$aiOutputScopesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIOutputScopePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GeoDistrict model
   */
  interface GeoDistrictFieldRefs {
    readonly id: FieldRef<"GeoDistrict", 'String'>
    readonly districtCode: FieldRef<"GeoDistrict", 'String'>
    readonly districtType: FieldRef<"GeoDistrict", 'String'>
    readonly createdAt: FieldRef<"GeoDistrict", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GeoDistrict findUnique
   */
  export type GeoDistrictFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoDistrict
     */
    select?: GeoDistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeoDistrict
     */
    omit?: GeoDistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeoDistrictInclude<ExtArgs> | null
    /**
     * Filter, which GeoDistrict to fetch.
     */
    where: GeoDistrictWhereUniqueInput
  }

  /**
   * GeoDistrict findUniqueOrThrow
   */
  export type GeoDistrictFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoDistrict
     */
    select?: GeoDistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeoDistrict
     */
    omit?: GeoDistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeoDistrictInclude<ExtArgs> | null
    /**
     * Filter, which GeoDistrict to fetch.
     */
    where: GeoDistrictWhereUniqueInput
  }

  /**
   * GeoDistrict findFirst
   */
  export type GeoDistrictFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoDistrict
     */
    select?: GeoDistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeoDistrict
     */
    omit?: GeoDistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeoDistrictInclude<ExtArgs> | null
    /**
     * Filter, which GeoDistrict to fetch.
     */
    where?: GeoDistrictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeoDistricts to fetch.
     */
    orderBy?: GeoDistrictOrderByWithRelationInput | GeoDistrictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GeoDistricts.
     */
    cursor?: GeoDistrictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeoDistricts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeoDistricts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GeoDistricts.
     */
    distinct?: GeoDistrictScalarFieldEnum | GeoDistrictScalarFieldEnum[]
  }

  /**
   * GeoDistrict findFirstOrThrow
   */
  export type GeoDistrictFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoDistrict
     */
    select?: GeoDistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeoDistrict
     */
    omit?: GeoDistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeoDistrictInclude<ExtArgs> | null
    /**
     * Filter, which GeoDistrict to fetch.
     */
    where?: GeoDistrictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeoDistricts to fetch.
     */
    orderBy?: GeoDistrictOrderByWithRelationInput | GeoDistrictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GeoDistricts.
     */
    cursor?: GeoDistrictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeoDistricts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeoDistricts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GeoDistricts.
     */
    distinct?: GeoDistrictScalarFieldEnum | GeoDistrictScalarFieldEnum[]
  }

  /**
   * GeoDistrict findMany
   */
  export type GeoDistrictFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoDistrict
     */
    select?: GeoDistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeoDistrict
     */
    omit?: GeoDistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeoDistrictInclude<ExtArgs> | null
    /**
     * Filter, which GeoDistricts to fetch.
     */
    where?: GeoDistrictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeoDistricts to fetch.
     */
    orderBy?: GeoDistrictOrderByWithRelationInput | GeoDistrictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GeoDistricts.
     */
    cursor?: GeoDistrictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeoDistricts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeoDistricts.
     */
    skip?: number
    distinct?: GeoDistrictScalarFieldEnum | GeoDistrictScalarFieldEnum[]
  }

  /**
   * GeoDistrict create
   */
  export type GeoDistrictCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoDistrict
     */
    select?: GeoDistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeoDistrict
     */
    omit?: GeoDistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeoDistrictInclude<ExtArgs> | null
    /**
     * The data needed to create a GeoDistrict.
     */
    data: XOR<GeoDistrictCreateInput, GeoDistrictUncheckedCreateInput>
  }

  /**
   * GeoDistrict createMany
   */
  export type GeoDistrictCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GeoDistricts.
     */
    data: GeoDistrictCreateManyInput | GeoDistrictCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GeoDistrict createManyAndReturn
   */
  export type GeoDistrictCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoDistrict
     */
    select?: GeoDistrictSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GeoDistrict
     */
    omit?: GeoDistrictOmit<ExtArgs> | null
    /**
     * The data used to create many GeoDistricts.
     */
    data: GeoDistrictCreateManyInput | GeoDistrictCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GeoDistrict update
   */
  export type GeoDistrictUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoDistrict
     */
    select?: GeoDistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeoDistrict
     */
    omit?: GeoDistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeoDistrictInclude<ExtArgs> | null
    /**
     * The data needed to update a GeoDistrict.
     */
    data: XOR<GeoDistrictUpdateInput, GeoDistrictUncheckedUpdateInput>
    /**
     * Choose, which GeoDistrict to update.
     */
    where: GeoDistrictWhereUniqueInput
  }

  /**
   * GeoDistrict updateMany
   */
  export type GeoDistrictUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GeoDistricts.
     */
    data: XOR<GeoDistrictUpdateManyMutationInput, GeoDistrictUncheckedUpdateManyInput>
    /**
     * Filter which GeoDistricts to update
     */
    where?: GeoDistrictWhereInput
    /**
     * Limit how many GeoDistricts to update.
     */
    limit?: number
  }

  /**
   * GeoDistrict updateManyAndReturn
   */
  export type GeoDistrictUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoDistrict
     */
    select?: GeoDistrictSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GeoDistrict
     */
    omit?: GeoDistrictOmit<ExtArgs> | null
    /**
     * The data used to update GeoDistricts.
     */
    data: XOR<GeoDistrictUpdateManyMutationInput, GeoDistrictUncheckedUpdateManyInput>
    /**
     * Filter which GeoDistricts to update
     */
    where?: GeoDistrictWhereInput
    /**
     * Limit how many GeoDistricts to update.
     */
    limit?: number
  }

  /**
   * GeoDistrict upsert
   */
  export type GeoDistrictUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoDistrict
     */
    select?: GeoDistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeoDistrict
     */
    omit?: GeoDistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeoDistrictInclude<ExtArgs> | null
    /**
     * The filter to search for the GeoDistrict to update in case it exists.
     */
    where: GeoDistrictWhereUniqueInput
    /**
     * In case the GeoDistrict found by the `where` argument doesn't exist, create a new GeoDistrict with this data.
     */
    create: XOR<GeoDistrictCreateInput, GeoDistrictUncheckedCreateInput>
    /**
     * In case the GeoDistrict was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GeoDistrictUpdateInput, GeoDistrictUncheckedUpdateInput>
  }

  /**
   * GeoDistrict delete
   */
  export type GeoDistrictDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoDistrict
     */
    select?: GeoDistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeoDistrict
     */
    omit?: GeoDistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeoDistrictInclude<ExtArgs> | null
    /**
     * Filter which GeoDistrict to delete.
     */
    where: GeoDistrictWhereUniqueInput
  }

  /**
   * GeoDistrict deleteMany
   */
  export type GeoDistrictDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GeoDistricts to delete
     */
    where?: GeoDistrictWhereInput
    /**
     * Limit how many GeoDistricts to delete.
     */
    limit?: number
  }

  /**
   * GeoDistrict.civicsOfficials
   */
  export type GeoDistrict$civicsOfficialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CivicsOfficial
     */
    select?: CivicsOfficialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CivicsOfficial
     */
    omit?: CivicsOfficialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CivicsOfficialInclude<ExtArgs> | null
    where?: CivicsOfficialWhereInput
    orderBy?: CivicsOfficialOrderByWithRelationInput | CivicsOfficialOrderByWithRelationInput[]
    cursor?: CivicsOfficialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CivicsOfficialScalarFieldEnum | CivicsOfficialScalarFieldEnum[]
  }

  /**
   * GeoDistrict.aiOutputScopes
   */
  export type GeoDistrict$aiOutputScopesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIOutputScope
     */
    select?: AIOutputScopeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIOutputScope
     */
    omit?: AIOutputScopeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIOutputScopeInclude<ExtArgs> | null
    where?: AIOutputScopeWhereInput
    orderBy?: AIOutputScopeOrderByWithRelationInput | AIOutputScopeOrderByWithRelationInput[]
    cursor?: AIOutputScopeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIOutputScopeScalarFieldEnum | AIOutputScopeScalarFieldEnum[]
  }

  /**
   * GeoDistrict without action
   */
  export type GeoDistrictDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoDistrict
     */
    select?: GeoDistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeoDistrict
     */
    omit?: GeoDistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeoDistrictInclude<ExtArgs> | null
  }


  /**
   * Model GeoCrosswalk
   */

  export type AggregateGeoCrosswalk = {
    _count: GeoCrosswalkCountAggregateOutputType | null
    _avg: GeoCrosswalkAvgAggregateOutputType | null
    _sum: GeoCrosswalkSumAggregateOutputType | null
    _min: GeoCrosswalkMinAggregateOutputType | null
    _max: GeoCrosswalkMaxAggregateOutputType | null
  }

  export type GeoCrosswalkAvgAggregateOutputType = {
    weight: number | null
  }

  export type GeoCrosswalkSumAggregateOutputType = {
    weight: number | null
  }

  export type GeoCrosswalkMinAggregateOutputType = {
    id: string | null
    crosswalkType: $Enums.CrosswalkType | null
    fromGeoZipId: string | null
    fromGeoPrecinctId: string | null
    fromGeoDistrictId: string | null
    fromGeoCountyFips: string | null
    toGeoZipId: string | null
    toGeoPrecinctId: string | null
    toGeoDistrictId: string | null
    toGeoCountyFips: string | null
    weight: number | null
    createdAt: Date | null
  }

  export type GeoCrosswalkMaxAggregateOutputType = {
    id: string | null
    crosswalkType: $Enums.CrosswalkType | null
    fromGeoZipId: string | null
    fromGeoPrecinctId: string | null
    fromGeoDistrictId: string | null
    fromGeoCountyFips: string | null
    toGeoZipId: string | null
    toGeoPrecinctId: string | null
    toGeoDistrictId: string | null
    toGeoCountyFips: string | null
    weight: number | null
    createdAt: Date | null
  }

  export type GeoCrosswalkCountAggregateOutputType = {
    id: number
    crosswalkType: number
    fromGeoZipId: number
    fromGeoPrecinctId: number
    fromGeoDistrictId: number
    fromGeoCountyFips: number
    toGeoZipId: number
    toGeoPrecinctId: number
    toGeoDistrictId: number
    toGeoCountyFips: number
    weight: number
    createdAt: number
    _all: number
  }


  export type GeoCrosswalkAvgAggregateInputType = {
    weight?: true
  }

  export type GeoCrosswalkSumAggregateInputType = {
    weight?: true
  }

  export type GeoCrosswalkMinAggregateInputType = {
    id?: true
    crosswalkType?: true
    fromGeoZipId?: true
    fromGeoPrecinctId?: true
    fromGeoDistrictId?: true
    fromGeoCountyFips?: true
    toGeoZipId?: true
    toGeoPrecinctId?: true
    toGeoDistrictId?: true
    toGeoCountyFips?: true
    weight?: true
    createdAt?: true
  }

  export type GeoCrosswalkMaxAggregateInputType = {
    id?: true
    crosswalkType?: true
    fromGeoZipId?: true
    fromGeoPrecinctId?: true
    fromGeoDistrictId?: true
    fromGeoCountyFips?: true
    toGeoZipId?: true
    toGeoPrecinctId?: true
    toGeoDistrictId?: true
    toGeoCountyFips?: true
    weight?: true
    createdAt?: true
  }

  export type GeoCrosswalkCountAggregateInputType = {
    id?: true
    crosswalkType?: true
    fromGeoZipId?: true
    fromGeoPrecinctId?: true
    fromGeoDistrictId?: true
    fromGeoCountyFips?: true
    toGeoZipId?: true
    toGeoPrecinctId?: true
    toGeoDistrictId?: true
    toGeoCountyFips?: true
    weight?: true
    createdAt?: true
    _all?: true
  }

  export type GeoCrosswalkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GeoCrosswalk to aggregate.
     */
    where?: GeoCrosswalkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeoCrosswalks to fetch.
     */
    orderBy?: GeoCrosswalkOrderByWithRelationInput | GeoCrosswalkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GeoCrosswalkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeoCrosswalks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeoCrosswalks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GeoCrosswalks
    **/
    _count?: true | GeoCrosswalkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GeoCrosswalkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GeoCrosswalkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GeoCrosswalkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GeoCrosswalkMaxAggregateInputType
  }

  export type GetGeoCrosswalkAggregateType<T extends GeoCrosswalkAggregateArgs> = {
        [P in keyof T & keyof AggregateGeoCrosswalk]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGeoCrosswalk[P]>
      : GetScalarType<T[P], AggregateGeoCrosswalk[P]>
  }




  export type GeoCrosswalkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GeoCrosswalkWhereInput
    orderBy?: GeoCrosswalkOrderByWithAggregationInput | GeoCrosswalkOrderByWithAggregationInput[]
    by: GeoCrosswalkScalarFieldEnum[] | GeoCrosswalkScalarFieldEnum
    having?: GeoCrosswalkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GeoCrosswalkCountAggregateInputType | true
    _avg?: GeoCrosswalkAvgAggregateInputType
    _sum?: GeoCrosswalkSumAggregateInputType
    _min?: GeoCrosswalkMinAggregateInputType
    _max?: GeoCrosswalkMaxAggregateInputType
  }

  export type GeoCrosswalkGroupByOutputType = {
    id: string
    crosswalkType: $Enums.CrosswalkType
    fromGeoZipId: string | null
    fromGeoPrecinctId: string | null
    fromGeoDistrictId: string | null
    fromGeoCountyFips: string | null
    toGeoZipId: string | null
    toGeoPrecinctId: string | null
    toGeoDistrictId: string | null
    toGeoCountyFips: string | null
    weight: number | null
    createdAt: Date
    _count: GeoCrosswalkCountAggregateOutputType | null
    _avg: GeoCrosswalkAvgAggregateOutputType | null
    _sum: GeoCrosswalkSumAggregateOutputType | null
    _min: GeoCrosswalkMinAggregateOutputType | null
    _max: GeoCrosswalkMaxAggregateOutputType | null
  }

  type GetGeoCrosswalkGroupByPayload<T extends GeoCrosswalkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GeoCrosswalkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GeoCrosswalkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GeoCrosswalkGroupByOutputType[P]>
            : GetScalarType<T[P], GeoCrosswalkGroupByOutputType[P]>
        }
      >
    >


  export type GeoCrosswalkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    crosswalkType?: boolean
    fromGeoZipId?: boolean
    fromGeoPrecinctId?: boolean
    fromGeoDistrictId?: boolean
    fromGeoCountyFips?: boolean
    toGeoZipId?: boolean
    toGeoPrecinctId?: boolean
    toGeoDistrictId?: boolean
    toGeoCountyFips?: boolean
    weight?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["geoCrosswalk"]>

  export type GeoCrosswalkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    crosswalkType?: boolean
    fromGeoZipId?: boolean
    fromGeoPrecinctId?: boolean
    fromGeoDistrictId?: boolean
    fromGeoCountyFips?: boolean
    toGeoZipId?: boolean
    toGeoPrecinctId?: boolean
    toGeoDistrictId?: boolean
    toGeoCountyFips?: boolean
    weight?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["geoCrosswalk"]>

  export type GeoCrosswalkSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    crosswalkType?: boolean
    fromGeoZipId?: boolean
    fromGeoPrecinctId?: boolean
    fromGeoDistrictId?: boolean
    fromGeoCountyFips?: boolean
    toGeoZipId?: boolean
    toGeoPrecinctId?: boolean
    toGeoDistrictId?: boolean
    toGeoCountyFips?: boolean
    weight?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["geoCrosswalk"]>

  export type GeoCrosswalkSelectScalar = {
    id?: boolean
    crosswalkType?: boolean
    fromGeoZipId?: boolean
    fromGeoPrecinctId?: boolean
    fromGeoDistrictId?: boolean
    fromGeoCountyFips?: boolean
    toGeoZipId?: boolean
    toGeoPrecinctId?: boolean
    toGeoDistrictId?: boolean
    toGeoCountyFips?: boolean
    weight?: boolean
    createdAt?: boolean
  }

  export type GeoCrosswalkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "crosswalkType" | "fromGeoZipId" | "fromGeoPrecinctId" | "fromGeoDistrictId" | "fromGeoCountyFips" | "toGeoZipId" | "toGeoPrecinctId" | "toGeoDistrictId" | "toGeoCountyFips" | "weight" | "createdAt", ExtArgs["result"]["geoCrosswalk"]>

  export type $GeoCrosswalkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GeoCrosswalk"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      crosswalkType: $Enums.CrosswalkType
      fromGeoZipId: string | null
      fromGeoPrecinctId: string | null
      fromGeoDistrictId: string | null
      fromGeoCountyFips: string | null
      toGeoZipId: string | null
      toGeoPrecinctId: string | null
      toGeoDistrictId: string | null
      toGeoCountyFips: string | null
      weight: number | null
      createdAt: Date
    }, ExtArgs["result"]["geoCrosswalk"]>
    composites: {}
  }

  type GeoCrosswalkGetPayload<S extends boolean | null | undefined | GeoCrosswalkDefaultArgs> = $Result.GetResult<Prisma.$GeoCrosswalkPayload, S>

  type GeoCrosswalkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GeoCrosswalkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GeoCrosswalkCountAggregateInputType | true
    }

  export interface GeoCrosswalkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GeoCrosswalk'], meta: { name: 'GeoCrosswalk' } }
    /**
     * Find zero or one GeoCrosswalk that matches the filter.
     * @param {GeoCrosswalkFindUniqueArgs} args - Arguments to find a GeoCrosswalk
     * @example
     * // Get one GeoCrosswalk
     * const geoCrosswalk = await prisma.geoCrosswalk.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GeoCrosswalkFindUniqueArgs>(args: SelectSubset<T, GeoCrosswalkFindUniqueArgs<ExtArgs>>): Prisma__GeoCrosswalkClient<$Result.GetResult<Prisma.$GeoCrosswalkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GeoCrosswalk that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GeoCrosswalkFindUniqueOrThrowArgs} args - Arguments to find a GeoCrosswalk
     * @example
     * // Get one GeoCrosswalk
     * const geoCrosswalk = await prisma.geoCrosswalk.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GeoCrosswalkFindUniqueOrThrowArgs>(args: SelectSubset<T, GeoCrosswalkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GeoCrosswalkClient<$Result.GetResult<Prisma.$GeoCrosswalkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GeoCrosswalk that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeoCrosswalkFindFirstArgs} args - Arguments to find a GeoCrosswalk
     * @example
     * // Get one GeoCrosswalk
     * const geoCrosswalk = await prisma.geoCrosswalk.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GeoCrosswalkFindFirstArgs>(args?: SelectSubset<T, GeoCrosswalkFindFirstArgs<ExtArgs>>): Prisma__GeoCrosswalkClient<$Result.GetResult<Prisma.$GeoCrosswalkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GeoCrosswalk that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeoCrosswalkFindFirstOrThrowArgs} args - Arguments to find a GeoCrosswalk
     * @example
     * // Get one GeoCrosswalk
     * const geoCrosswalk = await prisma.geoCrosswalk.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GeoCrosswalkFindFirstOrThrowArgs>(args?: SelectSubset<T, GeoCrosswalkFindFirstOrThrowArgs<ExtArgs>>): Prisma__GeoCrosswalkClient<$Result.GetResult<Prisma.$GeoCrosswalkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GeoCrosswalks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeoCrosswalkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GeoCrosswalks
     * const geoCrosswalks = await prisma.geoCrosswalk.findMany()
     * 
     * // Get first 10 GeoCrosswalks
     * const geoCrosswalks = await prisma.geoCrosswalk.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const geoCrosswalkWithIdOnly = await prisma.geoCrosswalk.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GeoCrosswalkFindManyArgs>(args?: SelectSubset<T, GeoCrosswalkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeoCrosswalkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GeoCrosswalk.
     * @param {GeoCrosswalkCreateArgs} args - Arguments to create a GeoCrosswalk.
     * @example
     * // Create one GeoCrosswalk
     * const GeoCrosswalk = await prisma.geoCrosswalk.create({
     *   data: {
     *     // ... data to create a GeoCrosswalk
     *   }
     * })
     * 
     */
    create<T extends GeoCrosswalkCreateArgs>(args: SelectSubset<T, GeoCrosswalkCreateArgs<ExtArgs>>): Prisma__GeoCrosswalkClient<$Result.GetResult<Prisma.$GeoCrosswalkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GeoCrosswalks.
     * @param {GeoCrosswalkCreateManyArgs} args - Arguments to create many GeoCrosswalks.
     * @example
     * // Create many GeoCrosswalks
     * const geoCrosswalk = await prisma.geoCrosswalk.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GeoCrosswalkCreateManyArgs>(args?: SelectSubset<T, GeoCrosswalkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GeoCrosswalks and returns the data saved in the database.
     * @param {GeoCrosswalkCreateManyAndReturnArgs} args - Arguments to create many GeoCrosswalks.
     * @example
     * // Create many GeoCrosswalks
     * const geoCrosswalk = await prisma.geoCrosswalk.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GeoCrosswalks and only return the `id`
     * const geoCrosswalkWithIdOnly = await prisma.geoCrosswalk.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GeoCrosswalkCreateManyAndReturnArgs>(args?: SelectSubset<T, GeoCrosswalkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeoCrosswalkPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GeoCrosswalk.
     * @param {GeoCrosswalkDeleteArgs} args - Arguments to delete one GeoCrosswalk.
     * @example
     * // Delete one GeoCrosswalk
     * const GeoCrosswalk = await prisma.geoCrosswalk.delete({
     *   where: {
     *     // ... filter to delete one GeoCrosswalk
     *   }
     * })
     * 
     */
    delete<T extends GeoCrosswalkDeleteArgs>(args: SelectSubset<T, GeoCrosswalkDeleteArgs<ExtArgs>>): Prisma__GeoCrosswalkClient<$Result.GetResult<Prisma.$GeoCrosswalkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GeoCrosswalk.
     * @param {GeoCrosswalkUpdateArgs} args - Arguments to update one GeoCrosswalk.
     * @example
     * // Update one GeoCrosswalk
     * const geoCrosswalk = await prisma.geoCrosswalk.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GeoCrosswalkUpdateArgs>(args: SelectSubset<T, GeoCrosswalkUpdateArgs<ExtArgs>>): Prisma__GeoCrosswalkClient<$Result.GetResult<Prisma.$GeoCrosswalkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GeoCrosswalks.
     * @param {GeoCrosswalkDeleteManyArgs} args - Arguments to filter GeoCrosswalks to delete.
     * @example
     * // Delete a few GeoCrosswalks
     * const { count } = await prisma.geoCrosswalk.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GeoCrosswalkDeleteManyArgs>(args?: SelectSubset<T, GeoCrosswalkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GeoCrosswalks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeoCrosswalkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GeoCrosswalks
     * const geoCrosswalk = await prisma.geoCrosswalk.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GeoCrosswalkUpdateManyArgs>(args: SelectSubset<T, GeoCrosswalkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GeoCrosswalks and returns the data updated in the database.
     * @param {GeoCrosswalkUpdateManyAndReturnArgs} args - Arguments to update many GeoCrosswalks.
     * @example
     * // Update many GeoCrosswalks
     * const geoCrosswalk = await prisma.geoCrosswalk.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GeoCrosswalks and only return the `id`
     * const geoCrosswalkWithIdOnly = await prisma.geoCrosswalk.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GeoCrosswalkUpdateManyAndReturnArgs>(args: SelectSubset<T, GeoCrosswalkUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeoCrosswalkPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GeoCrosswalk.
     * @param {GeoCrosswalkUpsertArgs} args - Arguments to update or create a GeoCrosswalk.
     * @example
     * // Update or create a GeoCrosswalk
     * const geoCrosswalk = await prisma.geoCrosswalk.upsert({
     *   create: {
     *     // ... data to create a GeoCrosswalk
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GeoCrosswalk we want to update
     *   }
     * })
     */
    upsert<T extends GeoCrosswalkUpsertArgs>(args: SelectSubset<T, GeoCrosswalkUpsertArgs<ExtArgs>>): Prisma__GeoCrosswalkClient<$Result.GetResult<Prisma.$GeoCrosswalkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GeoCrosswalks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeoCrosswalkCountArgs} args - Arguments to filter GeoCrosswalks to count.
     * @example
     * // Count the number of GeoCrosswalks
     * const count = await prisma.geoCrosswalk.count({
     *   where: {
     *     // ... the filter for the GeoCrosswalks we want to count
     *   }
     * })
    **/
    count<T extends GeoCrosswalkCountArgs>(
      args?: Subset<T, GeoCrosswalkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GeoCrosswalkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GeoCrosswalk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeoCrosswalkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GeoCrosswalkAggregateArgs>(args: Subset<T, GeoCrosswalkAggregateArgs>): Prisma.PrismaPromise<GetGeoCrosswalkAggregateType<T>>

    /**
     * Group by GeoCrosswalk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeoCrosswalkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GeoCrosswalkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GeoCrosswalkGroupByArgs['orderBy'] }
        : { orderBy?: GeoCrosswalkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GeoCrosswalkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGeoCrosswalkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GeoCrosswalk model
   */
  readonly fields: GeoCrosswalkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GeoCrosswalk.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GeoCrosswalkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GeoCrosswalk model
   */
  interface GeoCrosswalkFieldRefs {
    readonly id: FieldRef<"GeoCrosswalk", 'String'>
    readonly crosswalkType: FieldRef<"GeoCrosswalk", 'CrosswalkType'>
    readonly fromGeoZipId: FieldRef<"GeoCrosswalk", 'String'>
    readonly fromGeoPrecinctId: FieldRef<"GeoCrosswalk", 'String'>
    readonly fromGeoDistrictId: FieldRef<"GeoCrosswalk", 'String'>
    readonly fromGeoCountyFips: FieldRef<"GeoCrosswalk", 'String'>
    readonly toGeoZipId: FieldRef<"GeoCrosswalk", 'String'>
    readonly toGeoPrecinctId: FieldRef<"GeoCrosswalk", 'String'>
    readonly toGeoDistrictId: FieldRef<"GeoCrosswalk", 'String'>
    readonly toGeoCountyFips: FieldRef<"GeoCrosswalk", 'String'>
    readonly weight: FieldRef<"GeoCrosswalk", 'Float'>
    readonly createdAt: FieldRef<"GeoCrosswalk", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GeoCrosswalk findUnique
   */
  export type GeoCrosswalkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoCrosswalk
     */
    select?: GeoCrosswalkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeoCrosswalk
     */
    omit?: GeoCrosswalkOmit<ExtArgs> | null
    /**
     * Filter, which GeoCrosswalk to fetch.
     */
    where: GeoCrosswalkWhereUniqueInput
  }

  /**
   * GeoCrosswalk findUniqueOrThrow
   */
  export type GeoCrosswalkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoCrosswalk
     */
    select?: GeoCrosswalkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeoCrosswalk
     */
    omit?: GeoCrosswalkOmit<ExtArgs> | null
    /**
     * Filter, which GeoCrosswalk to fetch.
     */
    where: GeoCrosswalkWhereUniqueInput
  }

  /**
   * GeoCrosswalk findFirst
   */
  export type GeoCrosswalkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoCrosswalk
     */
    select?: GeoCrosswalkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeoCrosswalk
     */
    omit?: GeoCrosswalkOmit<ExtArgs> | null
    /**
     * Filter, which GeoCrosswalk to fetch.
     */
    where?: GeoCrosswalkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeoCrosswalks to fetch.
     */
    orderBy?: GeoCrosswalkOrderByWithRelationInput | GeoCrosswalkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GeoCrosswalks.
     */
    cursor?: GeoCrosswalkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeoCrosswalks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeoCrosswalks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GeoCrosswalks.
     */
    distinct?: GeoCrosswalkScalarFieldEnum | GeoCrosswalkScalarFieldEnum[]
  }

  /**
   * GeoCrosswalk findFirstOrThrow
   */
  export type GeoCrosswalkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoCrosswalk
     */
    select?: GeoCrosswalkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeoCrosswalk
     */
    omit?: GeoCrosswalkOmit<ExtArgs> | null
    /**
     * Filter, which GeoCrosswalk to fetch.
     */
    where?: GeoCrosswalkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeoCrosswalks to fetch.
     */
    orderBy?: GeoCrosswalkOrderByWithRelationInput | GeoCrosswalkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GeoCrosswalks.
     */
    cursor?: GeoCrosswalkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeoCrosswalks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeoCrosswalks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GeoCrosswalks.
     */
    distinct?: GeoCrosswalkScalarFieldEnum | GeoCrosswalkScalarFieldEnum[]
  }

  /**
   * GeoCrosswalk findMany
   */
  export type GeoCrosswalkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoCrosswalk
     */
    select?: GeoCrosswalkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeoCrosswalk
     */
    omit?: GeoCrosswalkOmit<ExtArgs> | null
    /**
     * Filter, which GeoCrosswalks to fetch.
     */
    where?: GeoCrosswalkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeoCrosswalks to fetch.
     */
    orderBy?: GeoCrosswalkOrderByWithRelationInput | GeoCrosswalkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GeoCrosswalks.
     */
    cursor?: GeoCrosswalkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeoCrosswalks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeoCrosswalks.
     */
    skip?: number
    distinct?: GeoCrosswalkScalarFieldEnum | GeoCrosswalkScalarFieldEnum[]
  }

  /**
   * GeoCrosswalk create
   */
  export type GeoCrosswalkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoCrosswalk
     */
    select?: GeoCrosswalkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeoCrosswalk
     */
    omit?: GeoCrosswalkOmit<ExtArgs> | null
    /**
     * The data needed to create a GeoCrosswalk.
     */
    data: XOR<GeoCrosswalkCreateInput, GeoCrosswalkUncheckedCreateInput>
  }

  /**
   * GeoCrosswalk createMany
   */
  export type GeoCrosswalkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GeoCrosswalks.
     */
    data: GeoCrosswalkCreateManyInput | GeoCrosswalkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GeoCrosswalk createManyAndReturn
   */
  export type GeoCrosswalkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoCrosswalk
     */
    select?: GeoCrosswalkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GeoCrosswalk
     */
    omit?: GeoCrosswalkOmit<ExtArgs> | null
    /**
     * The data used to create many GeoCrosswalks.
     */
    data: GeoCrosswalkCreateManyInput | GeoCrosswalkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GeoCrosswalk update
   */
  export type GeoCrosswalkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoCrosswalk
     */
    select?: GeoCrosswalkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeoCrosswalk
     */
    omit?: GeoCrosswalkOmit<ExtArgs> | null
    /**
     * The data needed to update a GeoCrosswalk.
     */
    data: XOR<GeoCrosswalkUpdateInput, GeoCrosswalkUncheckedUpdateInput>
    /**
     * Choose, which GeoCrosswalk to update.
     */
    where: GeoCrosswalkWhereUniqueInput
  }

  /**
   * GeoCrosswalk updateMany
   */
  export type GeoCrosswalkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GeoCrosswalks.
     */
    data: XOR<GeoCrosswalkUpdateManyMutationInput, GeoCrosswalkUncheckedUpdateManyInput>
    /**
     * Filter which GeoCrosswalks to update
     */
    where?: GeoCrosswalkWhereInput
    /**
     * Limit how many GeoCrosswalks to update.
     */
    limit?: number
  }

  /**
   * GeoCrosswalk updateManyAndReturn
   */
  export type GeoCrosswalkUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoCrosswalk
     */
    select?: GeoCrosswalkSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GeoCrosswalk
     */
    omit?: GeoCrosswalkOmit<ExtArgs> | null
    /**
     * The data used to update GeoCrosswalks.
     */
    data: XOR<GeoCrosswalkUpdateManyMutationInput, GeoCrosswalkUncheckedUpdateManyInput>
    /**
     * Filter which GeoCrosswalks to update
     */
    where?: GeoCrosswalkWhereInput
    /**
     * Limit how many GeoCrosswalks to update.
     */
    limit?: number
  }

  /**
   * GeoCrosswalk upsert
   */
  export type GeoCrosswalkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoCrosswalk
     */
    select?: GeoCrosswalkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeoCrosswalk
     */
    omit?: GeoCrosswalkOmit<ExtArgs> | null
    /**
     * The filter to search for the GeoCrosswalk to update in case it exists.
     */
    where: GeoCrosswalkWhereUniqueInput
    /**
     * In case the GeoCrosswalk found by the `where` argument doesn't exist, create a new GeoCrosswalk with this data.
     */
    create: XOR<GeoCrosswalkCreateInput, GeoCrosswalkUncheckedCreateInput>
    /**
     * In case the GeoCrosswalk was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GeoCrosswalkUpdateInput, GeoCrosswalkUncheckedUpdateInput>
  }

  /**
   * GeoCrosswalk delete
   */
  export type GeoCrosswalkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoCrosswalk
     */
    select?: GeoCrosswalkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeoCrosswalk
     */
    omit?: GeoCrosswalkOmit<ExtArgs> | null
    /**
     * Filter which GeoCrosswalk to delete.
     */
    where: GeoCrosswalkWhereUniqueInput
  }

  /**
   * GeoCrosswalk deleteMany
   */
  export type GeoCrosswalkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GeoCrosswalks to delete
     */
    where?: GeoCrosswalkWhereInput
    /**
     * Limit how many GeoCrosswalks to delete.
     */
    limit?: number
  }

  /**
   * GeoCrosswalk without action
   */
  export type GeoCrosswalkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoCrosswalk
     */
    select?: GeoCrosswalkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeoCrosswalk
     */
    omit?: GeoCrosswalkOmit<ExtArgs> | null
  }


  /**
   * Model CensusMetric
   */

  export type AggregateCensusMetric = {
    _count: CensusMetricCountAggregateOutputType | null
    _avg: CensusMetricAvgAggregateOutputType | null
    _sum: CensusMetricSumAggregateOutputType | null
    _min: CensusMetricMinAggregateOutputType | null
    _max: CensusMetricMaxAggregateOutputType | null
  }

  export type CensusMetricAvgAggregateOutputType = {
    value: number | null
  }

  export type CensusMetricSumAggregateOutputType = {
    value: number | null
  }

  export type CensusMetricMinAggregateOutputType = {
    id: string | null
    countyId: string | null
    geoZipId: string | null
    metricKey: string | null
    metricLabel: string | null
    value: number | null
    valueText: string | null
    asOfDate: Date | null
    sourceNote: string | null
    createdAt: Date | null
  }

  export type CensusMetricMaxAggregateOutputType = {
    id: string | null
    countyId: string | null
    geoZipId: string | null
    metricKey: string | null
    metricLabel: string | null
    value: number | null
    valueText: string | null
    asOfDate: Date | null
    sourceNote: string | null
    createdAt: Date | null
  }

  export type CensusMetricCountAggregateOutputType = {
    id: number
    countyId: number
    geoZipId: number
    metricKey: number
    metricLabel: number
    value: number
    valueText: number
    asOfDate: number
    sourceNote: number
    createdAt: number
    _all: number
  }


  export type CensusMetricAvgAggregateInputType = {
    value?: true
  }

  export type CensusMetricSumAggregateInputType = {
    value?: true
  }

  export type CensusMetricMinAggregateInputType = {
    id?: true
    countyId?: true
    geoZipId?: true
    metricKey?: true
    metricLabel?: true
    value?: true
    valueText?: true
    asOfDate?: true
    sourceNote?: true
    createdAt?: true
  }

  export type CensusMetricMaxAggregateInputType = {
    id?: true
    countyId?: true
    geoZipId?: true
    metricKey?: true
    metricLabel?: true
    value?: true
    valueText?: true
    asOfDate?: true
    sourceNote?: true
    createdAt?: true
  }

  export type CensusMetricCountAggregateInputType = {
    id?: true
    countyId?: true
    geoZipId?: true
    metricKey?: true
    metricLabel?: true
    value?: true
    valueText?: true
    asOfDate?: true
    sourceNote?: true
    createdAt?: true
    _all?: true
  }

  export type CensusMetricAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CensusMetric to aggregate.
     */
    where?: CensusMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CensusMetrics to fetch.
     */
    orderBy?: CensusMetricOrderByWithRelationInput | CensusMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CensusMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CensusMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CensusMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CensusMetrics
    **/
    _count?: true | CensusMetricCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CensusMetricAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CensusMetricSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CensusMetricMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CensusMetricMaxAggregateInputType
  }

  export type GetCensusMetricAggregateType<T extends CensusMetricAggregateArgs> = {
        [P in keyof T & keyof AggregateCensusMetric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCensusMetric[P]>
      : GetScalarType<T[P], AggregateCensusMetric[P]>
  }




  export type CensusMetricGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CensusMetricWhereInput
    orderBy?: CensusMetricOrderByWithAggregationInput | CensusMetricOrderByWithAggregationInput[]
    by: CensusMetricScalarFieldEnum[] | CensusMetricScalarFieldEnum
    having?: CensusMetricScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CensusMetricCountAggregateInputType | true
    _avg?: CensusMetricAvgAggregateInputType
    _sum?: CensusMetricSumAggregateInputType
    _min?: CensusMetricMinAggregateInputType
    _max?: CensusMetricMaxAggregateInputType
  }

  export type CensusMetricGroupByOutputType = {
    id: string
    countyId: string | null
    geoZipId: string | null
    metricKey: string
    metricLabel: string | null
    value: number | null
    valueText: string | null
    asOfDate: Date | null
    sourceNote: string | null
    createdAt: Date
    _count: CensusMetricCountAggregateOutputType | null
    _avg: CensusMetricAvgAggregateOutputType | null
    _sum: CensusMetricSumAggregateOutputType | null
    _min: CensusMetricMinAggregateOutputType | null
    _max: CensusMetricMaxAggregateOutputType | null
  }

  type GetCensusMetricGroupByPayload<T extends CensusMetricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CensusMetricGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CensusMetricGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CensusMetricGroupByOutputType[P]>
            : GetScalarType<T[P], CensusMetricGroupByOutputType[P]>
        }
      >
    >


  export type CensusMetricSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    countyId?: boolean
    geoZipId?: boolean
    metricKey?: boolean
    metricLabel?: boolean
    value?: boolean
    valueText?: boolean
    asOfDate?: boolean
    sourceNote?: boolean
    createdAt?: boolean
    county?: boolean | CensusMetric$countyArgs<ExtArgs>
    geoZip?: boolean | CensusMetric$geoZipArgs<ExtArgs>
  }, ExtArgs["result"]["censusMetric"]>

  export type CensusMetricSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    countyId?: boolean
    geoZipId?: boolean
    metricKey?: boolean
    metricLabel?: boolean
    value?: boolean
    valueText?: boolean
    asOfDate?: boolean
    sourceNote?: boolean
    createdAt?: boolean
    county?: boolean | CensusMetric$countyArgs<ExtArgs>
    geoZip?: boolean | CensusMetric$geoZipArgs<ExtArgs>
  }, ExtArgs["result"]["censusMetric"]>

  export type CensusMetricSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    countyId?: boolean
    geoZipId?: boolean
    metricKey?: boolean
    metricLabel?: boolean
    value?: boolean
    valueText?: boolean
    asOfDate?: boolean
    sourceNote?: boolean
    createdAt?: boolean
    county?: boolean | CensusMetric$countyArgs<ExtArgs>
    geoZip?: boolean | CensusMetric$geoZipArgs<ExtArgs>
  }, ExtArgs["result"]["censusMetric"]>

  export type CensusMetricSelectScalar = {
    id?: boolean
    countyId?: boolean
    geoZipId?: boolean
    metricKey?: boolean
    metricLabel?: boolean
    value?: boolean
    valueText?: boolean
    asOfDate?: boolean
    sourceNote?: boolean
    createdAt?: boolean
  }

  export type CensusMetricOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "countyId" | "geoZipId" | "metricKey" | "metricLabel" | "value" | "valueText" | "asOfDate" | "sourceNote" | "createdAt", ExtArgs["result"]["censusMetric"]>
  export type CensusMetricInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    county?: boolean | CensusMetric$countyArgs<ExtArgs>
    geoZip?: boolean | CensusMetric$geoZipArgs<ExtArgs>
  }
  export type CensusMetricIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    county?: boolean | CensusMetric$countyArgs<ExtArgs>
    geoZip?: boolean | CensusMetric$geoZipArgs<ExtArgs>
  }
  export type CensusMetricIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    county?: boolean | CensusMetric$countyArgs<ExtArgs>
    geoZip?: boolean | CensusMetric$geoZipArgs<ExtArgs>
  }

  export type $CensusMetricPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CensusMetric"
    objects: {
      county: Prisma.$CountyPayload<ExtArgs> | null
      geoZip: Prisma.$GeoZipPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      countyId: string | null
      geoZipId: string | null
      metricKey: string
      metricLabel: string | null
      value: number | null
      valueText: string | null
      asOfDate: Date | null
      sourceNote: string | null
      createdAt: Date
    }, ExtArgs["result"]["censusMetric"]>
    composites: {}
  }

  type CensusMetricGetPayload<S extends boolean | null | undefined | CensusMetricDefaultArgs> = $Result.GetResult<Prisma.$CensusMetricPayload, S>

  type CensusMetricCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CensusMetricFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CensusMetricCountAggregateInputType | true
    }

  export interface CensusMetricDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CensusMetric'], meta: { name: 'CensusMetric' } }
    /**
     * Find zero or one CensusMetric that matches the filter.
     * @param {CensusMetricFindUniqueArgs} args - Arguments to find a CensusMetric
     * @example
     * // Get one CensusMetric
     * const censusMetric = await prisma.censusMetric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CensusMetricFindUniqueArgs>(args: SelectSubset<T, CensusMetricFindUniqueArgs<ExtArgs>>): Prisma__CensusMetricClient<$Result.GetResult<Prisma.$CensusMetricPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CensusMetric that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CensusMetricFindUniqueOrThrowArgs} args - Arguments to find a CensusMetric
     * @example
     * // Get one CensusMetric
     * const censusMetric = await prisma.censusMetric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CensusMetricFindUniqueOrThrowArgs>(args: SelectSubset<T, CensusMetricFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CensusMetricClient<$Result.GetResult<Prisma.$CensusMetricPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CensusMetric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CensusMetricFindFirstArgs} args - Arguments to find a CensusMetric
     * @example
     * // Get one CensusMetric
     * const censusMetric = await prisma.censusMetric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CensusMetricFindFirstArgs>(args?: SelectSubset<T, CensusMetricFindFirstArgs<ExtArgs>>): Prisma__CensusMetricClient<$Result.GetResult<Prisma.$CensusMetricPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CensusMetric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CensusMetricFindFirstOrThrowArgs} args - Arguments to find a CensusMetric
     * @example
     * // Get one CensusMetric
     * const censusMetric = await prisma.censusMetric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CensusMetricFindFirstOrThrowArgs>(args?: SelectSubset<T, CensusMetricFindFirstOrThrowArgs<ExtArgs>>): Prisma__CensusMetricClient<$Result.GetResult<Prisma.$CensusMetricPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CensusMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CensusMetricFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CensusMetrics
     * const censusMetrics = await prisma.censusMetric.findMany()
     * 
     * // Get first 10 CensusMetrics
     * const censusMetrics = await prisma.censusMetric.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const censusMetricWithIdOnly = await prisma.censusMetric.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CensusMetricFindManyArgs>(args?: SelectSubset<T, CensusMetricFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CensusMetricPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CensusMetric.
     * @param {CensusMetricCreateArgs} args - Arguments to create a CensusMetric.
     * @example
     * // Create one CensusMetric
     * const CensusMetric = await prisma.censusMetric.create({
     *   data: {
     *     // ... data to create a CensusMetric
     *   }
     * })
     * 
     */
    create<T extends CensusMetricCreateArgs>(args: SelectSubset<T, CensusMetricCreateArgs<ExtArgs>>): Prisma__CensusMetricClient<$Result.GetResult<Prisma.$CensusMetricPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CensusMetrics.
     * @param {CensusMetricCreateManyArgs} args - Arguments to create many CensusMetrics.
     * @example
     * // Create many CensusMetrics
     * const censusMetric = await prisma.censusMetric.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CensusMetricCreateManyArgs>(args?: SelectSubset<T, CensusMetricCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CensusMetrics and returns the data saved in the database.
     * @param {CensusMetricCreateManyAndReturnArgs} args - Arguments to create many CensusMetrics.
     * @example
     * // Create many CensusMetrics
     * const censusMetric = await prisma.censusMetric.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CensusMetrics and only return the `id`
     * const censusMetricWithIdOnly = await prisma.censusMetric.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CensusMetricCreateManyAndReturnArgs>(args?: SelectSubset<T, CensusMetricCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CensusMetricPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CensusMetric.
     * @param {CensusMetricDeleteArgs} args - Arguments to delete one CensusMetric.
     * @example
     * // Delete one CensusMetric
     * const CensusMetric = await prisma.censusMetric.delete({
     *   where: {
     *     // ... filter to delete one CensusMetric
     *   }
     * })
     * 
     */
    delete<T extends CensusMetricDeleteArgs>(args: SelectSubset<T, CensusMetricDeleteArgs<ExtArgs>>): Prisma__CensusMetricClient<$Result.GetResult<Prisma.$CensusMetricPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CensusMetric.
     * @param {CensusMetricUpdateArgs} args - Arguments to update one CensusMetric.
     * @example
     * // Update one CensusMetric
     * const censusMetric = await prisma.censusMetric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CensusMetricUpdateArgs>(args: SelectSubset<T, CensusMetricUpdateArgs<ExtArgs>>): Prisma__CensusMetricClient<$Result.GetResult<Prisma.$CensusMetricPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CensusMetrics.
     * @param {CensusMetricDeleteManyArgs} args - Arguments to filter CensusMetrics to delete.
     * @example
     * // Delete a few CensusMetrics
     * const { count } = await prisma.censusMetric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CensusMetricDeleteManyArgs>(args?: SelectSubset<T, CensusMetricDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CensusMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CensusMetricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CensusMetrics
     * const censusMetric = await prisma.censusMetric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CensusMetricUpdateManyArgs>(args: SelectSubset<T, CensusMetricUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CensusMetrics and returns the data updated in the database.
     * @param {CensusMetricUpdateManyAndReturnArgs} args - Arguments to update many CensusMetrics.
     * @example
     * // Update many CensusMetrics
     * const censusMetric = await prisma.censusMetric.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CensusMetrics and only return the `id`
     * const censusMetricWithIdOnly = await prisma.censusMetric.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CensusMetricUpdateManyAndReturnArgs>(args: SelectSubset<T, CensusMetricUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CensusMetricPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CensusMetric.
     * @param {CensusMetricUpsertArgs} args - Arguments to update or create a CensusMetric.
     * @example
     * // Update or create a CensusMetric
     * const censusMetric = await prisma.censusMetric.upsert({
     *   create: {
     *     // ... data to create a CensusMetric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CensusMetric we want to update
     *   }
     * })
     */
    upsert<T extends CensusMetricUpsertArgs>(args: SelectSubset<T, CensusMetricUpsertArgs<ExtArgs>>): Prisma__CensusMetricClient<$Result.GetResult<Prisma.$CensusMetricPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CensusMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CensusMetricCountArgs} args - Arguments to filter CensusMetrics to count.
     * @example
     * // Count the number of CensusMetrics
     * const count = await prisma.censusMetric.count({
     *   where: {
     *     // ... the filter for the CensusMetrics we want to count
     *   }
     * })
    **/
    count<T extends CensusMetricCountArgs>(
      args?: Subset<T, CensusMetricCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CensusMetricCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CensusMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CensusMetricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CensusMetricAggregateArgs>(args: Subset<T, CensusMetricAggregateArgs>): Prisma.PrismaPromise<GetCensusMetricAggregateType<T>>

    /**
     * Group by CensusMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CensusMetricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CensusMetricGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CensusMetricGroupByArgs['orderBy'] }
        : { orderBy?: CensusMetricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CensusMetricGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCensusMetricGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CensusMetric model
   */
  readonly fields: CensusMetricFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CensusMetric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CensusMetricClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    county<T extends CensusMetric$countyArgs<ExtArgs> = {}>(args?: Subset<T, CensusMetric$countyArgs<ExtArgs>>): Prisma__CountyClient<$Result.GetResult<Prisma.$CountyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    geoZip<T extends CensusMetric$geoZipArgs<ExtArgs> = {}>(args?: Subset<T, CensusMetric$geoZipArgs<ExtArgs>>): Prisma__GeoZipClient<$Result.GetResult<Prisma.$GeoZipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CensusMetric model
   */
  interface CensusMetricFieldRefs {
    readonly id: FieldRef<"CensusMetric", 'String'>
    readonly countyId: FieldRef<"CensusMetric", 'String'>
    readonly geoZipId: FieldRef<"CensusMetric", 'String'>
    readonly metricKey: FieldRef<"CensusMetric", 'String'>
    readonly metricLabel: FieldRef<"CensusMetric", 'String'>
    readonly value: FieldRef<"CensusMetric", 'Float'>
    readonly valueText: FieldRef<"CensusMetric", 'String'>
    readonly asOfDate: FieldRef<"CensusMetric", 'DateTime'>
    readonly sourceNote: FieldRef<"CensusMetric", 'String'>
    readonly createdAt: FieldRef<"CensusMetric", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CensusMetric findUnique
   */
  export type CensusMetricFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusMetric
     */
    select?: CensusMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusMetric
     */
    omit?: CensusMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusMetricInclude<ExtArgs> | null
    /**
     * Filter, which CensusMetric to fetch.
     */
    where: CensusMetricWhereUniqueInput
  }

  /**
   * CensusMetric findUniqueOrThrow
   */
  export type CensusMetricFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusMetric
     */
    select?: CensusMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusMetric
     */
    omit?: CensusMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusMetricInclude<ExtArgs> | null
    /**
     * Filter, which CensusMetric to fetch.
     */
    where: CensusMetricWhereUniqueInput
  }

  /**
   * CensusMetric findFirst
   */
  export type CensusMetricFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusMetric
     */
    select?: CensusMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusMetric
     */
    omit?: CensusMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusMetricInclude<ExtArgs> | null
    /**
     * Filter, which CensusMetric to fetch.
     */
    where?: CensusMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CensusMetrics to fetch.
     */
    orderBy?: CensusMetricOrderByWithRelationInput | CensusMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CensusMetrics.
     */
    cursor?: CensusMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CensusMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CensusMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CensusMetrics.
     */
    distinct?: CensusMetricScalarFieldEnum | CensusMetricScalarFieldEnum[]
  }

  /**
   * CensusMetric findFirstOrThrow
   */
  export type CensusMetricFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusMetric
     */
    select?: CensusMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusMetric
     */
    omit?: CensusMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusMetricInclude<ExtArgs> | null
    /**
     * Filter, which CensusMetric to fetch.
     */
    where?: CensusMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CensusMetrics to fetch.
     */
    orderBy?: CensusMetricOrderByWithRelationInput | CensusMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CensusMetrics.
     */
    cursor?: CensusMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CensusMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CensusMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CensusMetrics.
     */
    distinct?: CensusMetricScalarFieldEnum | CensusMetricScalarFieldEnum[]
  }

  /**
   * CensusMetric findMany
   */
  export type CensusMetricFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusMetric
     */
    select?: CensusMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusMetric
     */
    omit?: CensusMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusMetricInclude<ExtArgs> | null
    /**
     * Filter, which CensusMetrics to fetch.
     */
    where?: CensusMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CensusMetrics to fetch.
     */
    orderBy?: CensusMetricOrderByWithRelationInput | CensusMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CensusMetrics.
     */
    cursor?: CensusMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CensusMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CensusMetrics.
     */
    skip?: number
    distinct?: CensusMetricScalarFieldEnum | CensusMetricScalarFieldEnum[]
  }

  /**
   * CensusMetric create
   */
  export type CensusMetricCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusMetric
     */
    select?: CensusMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusMetric
     */
    omit?: CensusMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusMetricInclude<ExtArgs> | null
    /**
     * The data needed to create a CensusMetric.
     */
    data: XOR<CensusMetricCreateInput, CensusMetricUncheckedCreateInput>
  }

  /**
   * CensusMetric createMany
   */
  export type CensusMetricCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CensusMetrics.
     */
    data: CensusMetricCreateManyInput | CensusMetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CensusMetric createManyAndReturn
   */
  export type CensusMetricCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusMetric
     */
    select?: CensusMetricSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CensusMetric
     */
    omit?: CensusMetricOmit<ExtArgs> | null
    /**
     * The data used to create many CensusMetrics.
     */
    data: CensusMetricCreateManyInput | CensusMetricCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusMetricIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CensusMetric update
   */
  export type CensusMetricUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusMetric
     */
    select?: CensusMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusMetric
     */
    omit?: CensusMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusMetricInclude<ExtArgs> | null
    /**
     * The data needed to update a CensusMetric.
     */
    data: XOR<CensusMetricUpdateInput, CensusMetricUncheckedUpdateInput>
    /**
     * Choose, which CensusMetric to update.
     */
    where: CensusMetricWhereUniqueInput
  }

  /**
   * CensusMetric updateMany
   */
  export type CensusMetricUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CensusMetrics.
     */
    data: XOR<CensusMetricUpdateManyMutationInput, CensusMetricUncheckedUpdateManyInput>
    /**
     * Filter which CensusMetrics to update
     */
    where?: CensusMetricWhereInput
    /**
     * Limit how many CensusMetrics to update.
     */
    limit?: number
  }

  /**
   * CensusMetric updateManyAndReturn
   */
  export type CensusMetricUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusMetric
     */
    select?: CensusMetricSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CensusMetric
     */
    omit?: CensusMetricOmit<ExtArgs> | null
    /**
     * The data used to update CensusMetrics.
     */
    data: XOR<CensusMetricUpdateManyMutationInput, CensusMetricUncheckedUpdateManyInput>
    /**
     * Filter which CensusMetrics to update
     */
    where?: CensusMetricWhereInput
    /**
     * Limit how many CensusMetrics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusMetricIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CensusMetric upsert
   */
  export type CensusMetricUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusMetric
     */
    select?: CensusMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusMetric
     */
    omit?: CensusMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusMetricInclude<ExtArgs> | null
    /**
     * The filter to search for the CensusMetric to update in case it exists.
     */
    where: CensusMetricWhereUniqueInput
    /**
     * In case the CensusMetric found by the `where` argument doesn't exist, create a new CensusMetric with this data.
     */
    create: XOR<CensusMetricCreateInput, CensusMetricUncheckedCreateInput>
    /**
     * In case the CensusMetric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CensusMetricUpdateInput, CensusMetricUncheckedUpdateInput>
  }

  /**
   * CensusMetric delete
   */
  export type CensusMetricDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusMetric
     */
    select?: CensusMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusMetric
     */
    omit?: CensusMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusMetricInclude<ExtArgs> | null
    /**
     * Filter which CensusMetric to delete.
     */
    where: CensusMetricWhereUniqueInput
  }

  /**
   * CensusMetric deleteMany
   */
  export type CensusMetricDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CensusMetrics to delete
     */
    where?: CensusMetricWhereInput
    /**
     * Limit how many CensusMetrics to delete.
     */
    limit?: number
  }

  /**
   * CensusMetric.county
   */
  export type CensusMetric$countyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the County
     */
    select?: CountySelect<ExtArgs> | null
    /**
     * Omit specific fields from the County
     */
    omit?: CountyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountyInclude<ExtArgs> | null
    where?: CountyWhereInput
  }

  /**
   * CensusMetric.geoZip
   */
  export type CensusMetric$geoZipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoZip
     */
    select?: GeoZipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeoZip
     */
    omit?: GeoZipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeoZipInclude<ExtArgs> | null
    where?: GeoZipWhereInput
  }

  /**
   * CensusMetric without action
   */
  export type CensusMetricDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CensusMetric
     */
    select?: CensusMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CensusMetric
     */
    omit?: CensusMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CensusMetricInclude<ExtArgs> | null
  }


  /**
   * Model BLSMetric
   */

  export type AggregateBLSMetric = {
    _count: BLSMetricCountAggregateOutputType | null
    _avg: BLSMetricAvgAggregateOutputType | null
    _sum: BLSMetricSumAggregateOutputType | null
    _min: BLSMetricMinAggregateOutputType | null
    _max: BLSMetricMaxAggregateOutputType | null
  }

  export type BLSMetricAvgAggregateOutputType = {
    value: number | null
  }

  export type BLSMetricSumAggregateOutputType = {
    value: number | null
  }

  export type BLSMetricMinAggregateOutputType = {
    id: string | null
    countyId: string | null
    seriesKey: string | null
    seriesLabel: string | null
    value: number | null
    asOfDate: Date | null
    sourceNote: string | null
    createdAt: Date | null
  }

  export type BLSMetricMaxAggregateOutputType = {
    id: string | null
    countyId: string | null
    seriesKey: string | null
    seriesLabel: string | null
    value: number | null
    asOfDate: Date | null
    sourceNote: string | null
    createdAt: Date | null
  }

  export type BLSMetricCountAggregateOutputType = {
    id: number
    countyId: number
    seriesKey: number
    seriesLabel: number
    value: number
    asOfDate: number
    sourceNote: number
    createdAt: number
    _all: number
  }


  export type BLSMetricAvgAggregateInputType = {
    value?: true
  }

  export type BLSMetricSumAggregateInputType = {
    value?: true
  }

  export type BLSMetricMinAggregateInputType = {
    id?: true
    countyId?: true
    seriesKey?: true
    seriesLabel?: true
    value?: true
    asOfDate?: true
    sourceNote?: true
    createdAt?: true
  }

  export type BLSMetricMaxAggregateInputType = {
    id?: true
    countyId?: true
    seriesKey?: true
    seriesLabel?: true
    value?: true
    asOfDate?: true
    sourceNote?: true
    createdAt?: true
  }

  export type BLSMetricCountAggregateInputType = {
    id?: true
    countyId?: true
    seriesKey?: true
    seriesLabel?: true
    value?: true
    asOfDate?: true
    sourceNote?: true
    createdAt?: true
    _all?: true
  }

  export type BLSMetricAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BLSMetric to aggregate.
     */
    where?: BLSMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BLSMetrics to fetch.
     */
    orderBy?: BLSMetricOrderByWithRelationInput | BLSMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BLSMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BLSMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BLSMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BLSMetrics
    **/
    _count?: true | BLSMetricCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BLSMetricAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BLSMetricSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BLSMetricMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BLSMetricMaxAggregateInputType
  }

  export type GetBLSMetricAggregateType<T extends BLSMetricAggregateArgs> = {
        [P in keyof T & keyof AggregateBLSMetric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBLSMetric[P]>
      : GetScalarType<T[P], AggregateBLSMetric[P]>
  }




  export type BLSMetricGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BLSMetricWhereInput
    orderBy?: BLSMetricOrderByWithAggregationInput | BLSMetricOrderByWithAggregationInput[]
    by: BLSMetricScalarFieldEnum[] | BLSMetricScalarFieldEnum
    having?: BLSMetricScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BLSMetricCountAggregateInputType | true
    _avg?: BLSMetricAvgAggregateInputType
    _sum?: BLSMetricSumAggregateInputType
    _min?: BLSMetricMinAggregateInputType
    _max?: BLSMetricMaxAggregateInputType
  }

  export type BLSMetricGroupByOutputType = {
    id: string
    countyId: string
    seriesKey: string
    seriesLabel: string | null
    value: number | null
    asOfDate: Date | null
    sourceNote: string | null
    createdAt: Date
    _count: BLSMetricCountAggregateOutputType | null
    _avg: BLSMetricAvgAggregateOutputType | null
    _sum: BLSMetricSumAggregateOutputType | null
    _min: BLSMetricMinAggregateOutputType | null
    _max: BLSMetricMaxAggregateOutputType | null
  }

  type GetBLSMetricGroupByPayload<T extends BLSMetricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BLSMetricGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BLSMetricGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BLSMetricGroupByOutputType[P]>
            : GetScalarType<T[P], BLSMetricGroupByOutputType[P]>
        }
      >
    >


  export type BLSMetricSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    countyId?: boolean
    seriesKey?: boolean
    seriesLabel?: boolean
    value?: boolean
    asOfDate?: boolean
    sourceNote?: boolean
    createdAt?: boolean
    county?: boolean | CountyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bLSMetric"]>

  export type BLSMetricSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    countyId?: boolean
    seriesKey?: boolean
    seriesLabel?: boolean
    value?: boolean
    asOfDate?: boolean
    sourceNote?: boolean
    createdAt?: boolean
    county?: boolean | CountyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bLSMetric"]>

  export type BLSMetricSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    countyId?: boolean
    seriesKey?: boolean
    seriesLabel?: boolean
    value?: boolean
    asOfDate?: boolean
    sourceNote?: boolean
    createdAt?: boolean
    county?: boolean | CountyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bLSMetric"]>

  export type BLSMetricSelectScalar = {
    id?: boolean
    countyId?: boolean
    seriesKey?: boolean
    seriesLabel?: boolean
    value?: boolean
    asOfDate?: boolean
    sourceNote?: boolean
    createdAt?: boolean
  }

  export type BLSMetricOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "countyId" | "seriesKey" | "seriesLabel" | "value" | "asOfDate" | "sourceNote" | "createdAt", ExtArgs["result"]["bLSMetric"]>
  export type BLSMetricInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    county?: boolean | CountyDefaultArgs<ExtArgs>
  }
  export type BLSMetricIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    county?: boolean | CountyDefaultArgs<ExtArgs>
  }
  export type BLSMetricIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    county?: boolean | CountyDefaultArgs<ExtArgs>
  }

  export type $BLSMetricPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BLSMetric"
    objects: {
      county: Prisma.$CountyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      countyId: string
      seriesKey: string
      seriesLabel: string | null
      value: number | null
      asOfDate: Date | null
      sourceNote: string | null
      createdAt: Date
    }, ExtArgs["result"]["bLSMetric"]>
    composites: {}
  }

  type BLSMetricGetPayload<S extends boolean | null | undefined | BLSMetricDefaultArgs> = $Result.GetResult<Prisma.$BLSMetricPayload, S>

  type BLSMetricCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BLSMetricFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BLSMetricCountAggregateInputType | true
    }

  export interface BLSMetricDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BLSMetric'], meta: { name: 'BLSMetric' } }
    /**
     * Find zero or one BLSMetric that matches the filter.
     * @param {BLSMetricFindUniqueArgs} args - Arguments to find a BLSMetric
     * @example
     * // Get one BLSMetric
     * const bLSMetric = await prisma.bLSMetric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BLSMetricFindUniqueArgs>(args: SelectSubset<T, BLSMetricFindUniqueArgs<ExtArgs>>): Prisma__BLSMetricClient<$Result.GetResult<Prisma.$BLSMetricPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BLSMetric that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BLSMetricFindUniqueOrThrowArgs} args - Arguments to find a BLSMetric
     * @example
     * // Get one BLSMetric
     * const bLSMetric = await prisma.bLSMetric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BLSMetricFindUniqueOrThrowArgs>(args: SelectSubset<T, BLSMetricFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BLSMetricClient<$Result.GetResult<Prisma.$BLSMetricPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BLSMetric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BLSMetricFindFirstArgs} args - Arguments to find a BLSMetric
     * @example
     * // Get one BLSMetric
     * const bLSMetric = await prisma.bLSMetric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BLSMetricFindFirstArgs>(args?: SelectSubset<T, BLSMetricFindFirstArgs<ExtArgs>>): Prisma__BLSMetricClient<$Result.GetResult<Prisma.$BLSMetricPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BLSMetric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BLSMetricFindFirstOrThrowArgs} args - Arguments to find a BLSMetric
     * @example
     * // Get one BLSMetric
     * const bLSMetric = await prisma.bLSMetric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BLSMetricFindFirstOrThrowArgs>(args?: SelectSubset<T, BLSMetricFindFirstOrThrowArgs<ExtArgs>>): Prisma__BLSMetricClient<$Result.GetResult<Prisma.$BLSMetricPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BLSMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BLSMetricFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BLSMetrics
     * const bLSMetrics = await prisma.bLSMetric.findMany()
     * 
     * // Get first 10 BLSMetrics
     * const bLSMetrics = await prisma.bLSMetric.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bLSMetricWithIdOnly = await prisma.bLSMetric.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BLSMetricFindManyArgs>(args?: SelectSubset<T, BLSMetricFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BLSMetricPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BLSMetric.
     * @param {BLSMetricCreateArgs} args - Arguments to create a BLSMetric.
     * @example
     * // Create one BLSMetric
     * const BLSMetric = await prisma.bLSMetric.create({
     *   data: {
     *     // ... data to create a BLSMetric
     *   }
     * })
     * 
     */
    create<T extends BLSMetricCreateArgs>(args: SelectSubset<T, BLSMetricCreateArgs<ExtArgs>>): Prisma__BLSMetricClient<$Result.GetResult<Prisma.$BLSMetricPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BLSMetrics.
     * @param {BLSMetricCreateManyArgs} args - Arguments to create many BLSMetrics.
     * @example
     * // Create many BLSMetrics
     * const bLSMetric = await prisma.bLSMetric.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BLSMetricCreateManyArgs>(args?: SelectSubset<T, BLSMetricCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BLSMetrics and returns the data saved in the database.
     * @param {BLSMetricCreateManyAndReturnArgs} args - Arguments to create many BLSMetrics.
     * @example
     * // Create many BLSMetrics
     * const bLSMetric = await prisma.bLSMetric.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BLSMetrics and only return the `id`
     * const bLSMetricWithIdOnly = await prisma.bLSMetric.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BLSMetricCreateManyAndReturnArgs>(args?: SelectSubset<T, BLSMetricCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BLSMetricPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BLSMetric.
     * @param {BLSMetricDeleteArgs} args - Arguments to delete one BLSMetric.
     * @example
     * // Delete one BLSMetric
     * const BLSMetric = await prisma.bLSMetric.delete({
     *   where: {
     *     // ... filter to delete one BLSMetric
     *   }
     * })
     * 
     */
    delete<T extends BLSMetricDeleteArgs>(args: SelectSubset<T, BLSMetricDeleteArgs<ExtArgs>>): Prisma__BLSMetricClient<$Result.GetResult<Prisma.$BLSMetricPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BLSMetric.
     * @param {BLSMetricUpdateArgs} args - Arguments to update one BLSMetric.
     * @example
     * // Update one BLSMetric
     * const bLSMetric = await prisma.bLSMetric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BLSMetricUpdateArgs>(args: SelectSubset<T, BLSMetricUpdateArgs<ExtArgs>>): Prisma__BLSMetricClient<$Result.GetResult<Prisma.$BLSMetricPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BLSMetrics.
     * @param {BLSMetricDeleteManyArgs} args - Arguments to filter BLSMetrics to delete.
     * @example
     * // Delete a few BLSMetrics
     * const { count } = await prisma.bLSMetric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BLSMetricDeleteManyArgs>(args?: SelectSubset<T, BLSMetricDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BLSMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BLSMetricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BLSMetrics
     * const bLSMetric = await prisma.bLSMetric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BLSMetricUpdateManyArgs>(args: SelectSubset<T, BLSMetricUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BLSMetrics and returns the data updated in the database.
     * @param {BLSMetricUpdateManyAndReturnArgs} args - Arguments to update many BLSMetrics.
     * @example
     * // Update many BLSMetrics
     * const bLSMetric = await prisma.bLSMetric.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BLSMetrics and only return the `id`
     * const bLSMetricWithIdOnly = await prisma.bLSMetric.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BLSMetricUpdateManyAndReturnArgs>(args: SelectSubset<T, BLSMetricUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BLSMetricPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BLSMetric.
     * @param {BLSMetricUpsertArgs} args - Arguments to update or create a BLSMetric.
     * @example
     * // Update or create a BLSMetric
     * const bLSMetric = await prisma.bLSMetric.upsert({
     *   create: {
     *     // ... data to create a BLSMetric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BLSMetric we want to update
     *   }
     * })
     */
    upsert<T extends BLSMetricUpsertArgs>(args: SelectSubset<T, BLSMetricUpsertArgs<ExtArgs>>): Prisma__BLSMetricClient<$Result.GetResult<Prisma.$BLSMetricPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BLSMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BLSMetricCountArgs} args - Arguments to filter BLSMetrics to count.
     * @example
     * // Count the number of BLSMetrics
     * const count = await prisma.bLSMetric.count({
     *   where: {
     *     // ... the filter for the BLSMetrics we want to count
     *   }
     * })
    **/
    count<T extends BLSMetricCountArgs>(
      args?: Subset<T, BLSMetricCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BLSMetricCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BLSMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BLSMetricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BLSMetricAggregateArgs>(args: Subset<T, BLSMetricAggregateArgs>): Prisma.PrismaPromise<GetBLSMetricAggregateType<T>>

    /**
     * Group by BLSMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BLSMetricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BLSMetricGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BLSMetricGroupByArgs['orderBy'] }
        : { orderBy?: BLSMetricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BLSMetricGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBLSMetricGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BLSMetric model
   */
  readonly fields: BLSMetricFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BLSMetric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BLSMetricClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    county<T extends CountyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CountyDefaultArgs<ExtArgs>>): Prisma__CountyClient<$Result.GetResult<Prisma.$CountyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BLSMetric model
   */
  interface BLSMetricFieldRefs {
    readonly id: FieldRef<"BLSMetric", 'String'>
    readonly countyId: FieldRef<"BLSMetric", 'String'>
    readonly seriesKey: FieldRef<"BLSMetric", 'String'>
    readonly seriesLabel: FieldRef<"BLSMetric", 'String'>
    readonly value: FieldRef<"BLSMetric", 'Float'>
    readonly asOfDate: FieldRef<"BLSMetric", 'DateTime'>
    readonly sourceNote: FieldRef<"BLSMetric", 'String'>
    readonly createdAt: FieldRef<"BLSMetric", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BLSMetric findUnique
   */
  export type BLSMetricFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BLSMetric
     */
    select?: BLSMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BLSMetric
     */
    omit?: BLSMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BLSMetricInclude<ExtArgs> | null
    /**
     * Filter, which BLSMetric to fetch.
     */
    where: BLSMetricWhereUniqueInput
  }

  /**
   * BLSMetric findUniqueOrThrow
   */
  export type BLSMetricFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BLSMetric
     */
    select?: BLSMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BLSMetric
     */
    omit?: BLSMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BLSMetricInclude<ExtArgs> | null
    /**
     * Filter, which BLSMetric to fetch.
     */
    where: BLSMetricWhereUniqueInput
  }

  /**
   * BLSMetric findFirst
   */
  export type BLSMetricFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BLSMetric
     */
    select?: BLSMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BLSMetric
     */
    omit?: BLSMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BLSMetricInclude<ExtArgs> | null
    /**
     * Filter, which BLSMetric to fetch.
     */
    where?: BLSMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BLSMetrics to fetch.
     */
    orderBy?: BLSMetricOrderByWithRelationInput | BLSMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BLSMetrics.
     */
    cursor?: BLSMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BLSMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BLSMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BLSMetrics.
     */
    distinct?: BLSMetricScalarFieldEnum | BLSMetricScalarFieldEnum[]
  }

  /**
   * BLSMetric findFirstOrThrow
   */
  export type BLSMetricFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BLSMetric
     */
    select?: BLSMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BLSMetric
     */
    omit?: BLSMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BLSMetricInclude<ExtArgs> | null
    /**
     * Filter, which BLSMetric to fetch.
     */
    where?: BLSMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BLSMetrics to fetch.
     */
    orderBy?: BLSMetricOrderByWithRelationInput | BLSMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BLSMetrics.
     */
    cursor?: BLSMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BLSMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BLSMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BLSMetrics.
     */
    distinct?: BLSMetricScalarFieldEnum | BLSMetricScalarFieldEnum[]
  }

  /**
   * BLSMetric findMany
   */
  export type BLSMetricFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BLSMetric
     */
    select?: BLSMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BLSMetric
     */
    omit?: BLSMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BLSMetricInclude<ExtArgs> | null
    /**
     * Filter, which BLSMetrics to fetch.
     */
    where?: BLSMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BLSMetrics to fetch.
     */
    orderBy?: BLSMetricOrderByWithRelationInput | BLSMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BLSMetrics.
     */
    cursor?: BLSMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BLSMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BLSMetrics.
     */
    skip?: number
    distinct?: BLSMetricScalarFieldEnum | BLSMetricScalarFieldEnum[]
  }

  /**
   * BLSMetric create
   */
  export type BLSMetricCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BLSMetric
     */
    select?: BLSMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BLSMetric
     */
    omit?: BLSMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BLSMetricInclude<ExtArgs> | null
    /**
     * The data needed to create a BLSMetric.
     */
    data: XOR<BLSMetricCreateInput, BLSMetricUncheckedCreateInput>
  }

  /**
   * BLSMetric createMany
   */
  export type BLSMetricCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BLSMetrics.
     */
    data: BLSMetricCreateManyInput | BLSMetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BLSMetric createManyAndReturn
   */
  export type BLSMetricCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BLSMetric
     */
    select?: BLSMetricSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BLSMetric
     */
    omit?: BLSMetricOmit<ExtArgs> | null
    /**
     * The data used to create many BLSMetrics.
     */
    data: BLSMetricCreateManyInput | BLSMetricCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BLSMetricIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BLSMetric update
   */
  export type BLSMetricUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BLSMetric
     */
    select?: BLSMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BLSMetric
     */
    omit?: BLSMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BLSMetricInclude<ExtArgs> | null
    /**
     * The data needed to update a BLSMetric.
     */
    data: XOR<BLSMetricUpdateInput, BLSMetricUncheckedUpdateInput>
    /**
     * Choose, which BLSMetric to update.
     */
    where: BLSMetricWhereUniqueInput
  }

  /**
   * BLSMetric updateMany
   */
  export type BLSMetricUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BLSMetrics.
     */
    data: XOR<BLSMetricUpdateManyMutationInput, BLSMetricUncheckedUpdateManyInput>
    /**
     * Filter which BLSMetrics to update
     */
    where?: BLSMetricWhereInput
    /**
     * Limit how many BLSMetrics to update.
     */
    limit?: number
  }

  /**
   * BLSMetric updateManyAndReturn
   */
  export type BLSMetricUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BLSMetric
     */
    select?: BLSMetricSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BLSMetric
     */
    omit?: BLSMetricOmit<ExtArgs> | null
    /**
     * The data used to update BLSMetrics.
     */
    data: XOR<BLSMetricUpdateManyMutationInput, BLSMetricUncheckedUpdateManyInput>
    /**
     * Filter which BLSMetrics to update
     */
    where?: BLSMetricWhereInput
    /**
     * Limit how many BLSMetrics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BLSMetricIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BLSMetric upsert
   */
  export type BLSMetricUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BLSMetric
     */
    select?: BLSMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BLSMetric
     */
    omit?: BLSMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BLSMetricInclude<ExtArgs> | null
    /**
     * The filter to search for the BLSMetric to update in case it exists.
     */
    where: BLSMetricWhereUniqueInput
    /**
     * In case the BLSMetric found by the `where` argument doesn't exist, create a new BLSMetric with this data.
     */
    create: XOR<BLSMetricCreateInput, BLSMetricUncheckedCreateInput>
    /**
     * In case the BLSMetric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BLSMetricUpdateInput, BLSMetricUncheckedUpdateInput>
  }

  /**
   * BLSMetric delete
   */
  export type BLSMetricDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BLSMetric
     */
    select?: BLSMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BLSMetric
     */
    omit?: BLSMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BLSMetricInclude<ExtArgs> | null
    /**
     * Filter which BLSMetric to delete.
     */
    where: BLSMetricWhereUniqueInput
  }

  /**
   * BLSMetric deleteMany
   */
  export type BLSMetricDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BLSMetrics to delete
     */
    where?: BLSMetricWhereInput
    /**
     * Limit how many BLSMetrics to delete.
     */
    limit?: number
  }

  /**
   * BLSMetric without action
   */
  export type BLSMetricDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BLSMetric
     */
    select?: BLSMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BLSMetric
     */
    omit?: BLSMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BLSMetricInclude<ExtArgs> | null
  }


  /**
   * Model CivicsOfficial
   */

  export type AggregateCivicsOfficial = {
    _count: CivicsOfficialCountAggregateOutputType | null
    _min: CivicsOfficialMinAggregateOutputType | null
    _max: CivicsOfficialMaxAggregateOutputType | null
  }

  export type CivicsOfficialMinAggregateOutputType = {
    id: string | null
    name: string | null
    officeName: string | null
    party: string | null
    phone: string | null
    website: string | null
    photoUrl: string | null
    countyId: string | null
    districtId: string | null
    sourceNote: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CivicsOfficialMaxAggregateOutputType = {
    id: string | null
    name: string | null
    officeName: string | null
    party: string | null
    phone: string | null
    website: string | null
    photoUrl: string | null
    countyId: string | null
    districtId: string | null
    sourceNote: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CivicsOfficialCountAggregateOutputType = {
    id: number
    name: number
    officeName: number
    party: number
    phone: number
    website: number
    photoUrl: number
    countyId: number
    districtId: number
    sourceNote: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CivicsOfficialMinAggregateInputType = {
    id?: true
    name?: true
    officeName?: true
    party?: true
    phone?: true
    website?: true
    photoUrl?: true
    countyId?: true
    districtId?: true
    sourceNote?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CivicsOfficialMaxAggregateInputType = {
    id?: true
    name?: true
    officeName?: true
    party?: true
    phone?: true
    website?: true
    photoUrl?: true
    countyId?: true
    districtId?: true
    sourceNote?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CivicsOfficialCountAggregateInputType = {
    id?: true
    name?: true
    officeName?: true
    party?: true
    phone?: true
    website?: true
    photoUrl?: true
    countyId?: true
    districtId?: true
    sourceNote?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CivicsOfficialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CivicsOfficial to aggregate.
     */
    where?: CivicsOfficialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CivicsOfficials to fetch.
     */
    orderBy?: CivicsOfficialOrderByWithRelationInput | CivicsOfficialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CivicsOfficialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CivicsOfficials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CivicsOfficials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CivicsOfficials
    **/
    _count?: true | CivicsOfficialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CivicsOfficialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CivicsOfficialMaxAggregateInputType
  }

  export type GetCivicsOfficialAggregateType<T extends CivicsOfficialAggregateArgs> = {
        [P in keyof T & keyof AggregateCivicsOfficial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCivicsOfficial[P]>
      : GetScalarType<T[P], AggregateCivicsOfficial[P]>
  }




  export type CivicsOfficialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CivicsOfficialWhereInput
    orderBy?: CivicsOfficialOrderByWithAggregationInput | CivicsOfficialOrderByWithAggregationInput[]
    by: CivicsOfficialScalarFieldEnum[] | CivicsOfficialScalarFieldEnum
    having?: CivicsOfficialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CivicsOfficialCountAggregateInputType | true
    _min?: CivicsOfficialMinAggregateInputType
    _max?: CivicsOfficialMaxAggregateInputType
  }

  export type CivicsOfficialGroupByOutputType = {
    id: string
    name: string
    officeName: string
    party: string | null
    phone: string | null
    website: string | null
    photoUrl: string | null
    countyId: string | null
    districtId: string | null
    sourceNote: string | null
    createdAt: Date
    updatedAt: Date
    _count: CivicsOfficialCountAggregateOutputType | null
    _min: CivicsOfficialMinAggregateOutputType | null
    _max: CivicsOfficialMaxAggregateOutputType | null
  }

  type GetCivicsOfficialGroupByPayload<T extends CivicsOfficialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CivicsOfficialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CivicsOfficialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CivicsOfficialGroupByOutputType[P]>
            : GetScalarType<T[P], CivicsOfficialGroupByOutputType[P]>
        }
      >
    >


  export type CivicsOfficialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    officeName?: boolean
    party?: boolean
    phone?: boolean
    website?: boolean
    photoUrl?: boolean
    countyId?: boolean
    districtId?: boolean
    sourceNote?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    county?: boolean | CivicsOfficial$countyArgs<ExtArgs>
    district?: boolean | CivicsOfficial$districtArgs<ExtArgs>
  }, ExtArgs["result"]["civicsOfficial"]>

  export type CivicsOfficialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    officeName?: boolean
    party?: boolean
    phone?: boolean
    website?: boolean
    photoUrl?: boolean
    countyId?: boolean
    districtId?: boolean
    sourceNote?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    county?: boolean | CivicsOfficial$countyArgs<ExtArgs>
    district?: boolean | CivicsOfficial$districtArgs<ExtArgs>
  }, ExtArgs["result"]["civicsOfficial"]>

  export type CivicsOfficialSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    officeName?: boolean
    party?: boolean
    phone?: boolean
    website?: boolean
    photoUrl?: boolean
    countyId?: boolean
    districtId?: boolean
    sourceNote?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    county?: boolean | CivicsOfficial$countyArgs<ExtArgs>
    district?: boolean | CivicsOfficial$districtArgs<ExtArgs>
  }, ExtArgs["result"]["civicsOfficial"]>

  export type CivicsOfficialSelectScalar = {
    id?: boolean
    name?: boolean
    officeName?: boolean
    party?: boolean
    phone?: boolean
    website?: boolean
    photoUrl?: boolean
    countyId?: boolean
    districtId?: boolean
    sourceNote?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CivicsOfficialOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "officeName" | "party" | "phone" | "website" | "photoUrl" | "countyId" | "districtId" | "sourceNote" | "createdAt" | "updatedAt", ExtArgs["result"]["civicsOfficial"]>
  export type CivicsOfficialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    county?: boolean | CivicsOfficial$countyArgs<ExtArgs>
    district?: boolean | CivicsOfficial$districtArgs<ExtArgs>
  }
  export type CivicsOfficialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    county?: boolean | CivicsOfficial$countyArgs<ExtArgs>
    district?: boolean | CivicsOfficial$districtArgs<ExtArgs>
  }
  export type CivicsOfficialIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    county?: boolean | CivicsOfficial$countyArgs<ExtArgs>
    district?: boolean | CivicsOfficial$districtArgs<ExtArgs>
  }

  export type $CivicsOfficialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CivicsOfficial"
    objects: {
      county: Prisma.$CountyPayload<ExtArgs> | null
      district: Prisma.$GeoDistrictPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      officeName: string
      party: string | null
      phone: string | null
      website: string | null
      photoUrl: string | null
      countyId: string | null
      districtId: string | null
      sourceNote: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["civicsOfficial"]>
    composites: {}
  }

  type CivicsOfficialGetPayload<S extends boolean | null | undefined | CivicsOfficialDefaultArgs> = $Result.GetResult<Prisma.$CivicsOfficialPayload, S>

  type CivicsOfficialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CivicsOfficialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CivicsOfficialCountAggregateInputType | true
    }

  export interface CivicsOfficialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CivicsOfficial'], meta: { name: 'CivicsOfficial' } }
    /**
     * Find zero or one CivicsOfficial that matches the filter.
     * @param {CivicsOfficialFindUniqueArgs} args - Arguments to find a CivicsOfficial
     * @example
     * // Get one CivicsOfficial
     * const civicsOfficial = await prisma.civicsOfficial.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CivicsOfficialFindUniqueArgs>(args: SelectSubset<T, CivicsOfficialFindUniqueArgs<ExtArgs>>): Prisma__CivicsOfficialClient<$Result.GetResult<Prisma.$CivicsOfficialPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CivicsOfficial that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CivicsOfficialFindUniqueOrThrowArgs} args - Arguments to find a CivicsOfficial
     * @example
     * // Get one CivicsOfficial
     * const civicsOfficial = await prisma.civicsOfficial.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CivicsOfficialFindUniqueOrThrowArgs>(args: SelectSubset<T, CivicsOfficialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CivicsOfficialClient<$Result.GetResult<Prisma.$CivicsOfficialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CivicsOfficial that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CivicsOfficialFindFirstArgs} args - Arguments to find a CivicsOfficial
     * @example
     * // Get one CivicsOfficial
     * const civicsOfficial = await prisma.civicsOfficial.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CivicsOfficialFindFirstArgs>(args?: SelectSubset<T, CivicsOfficialFindFirstArgs<ExtArgs>>): Prisma__CivicsOfficialClient<$Result.GetResult<Prisma.$CivicsOfficialPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CivicsOfficial that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CivicsOfficialFindFirstOrThrowArgs} args - Arguments to find a CivicsOfficial
     * @example
     * // Get one CivicsOfficial
     * const civicsOfficial = await prisma.civicsOfficial.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CivicsOfficialFindFirstOrThrowArgs>(args?: SelectSubset<T, CivicsOfficialFindFirstOrThrowArgs<ExtArgs>>): Prisma__CivicsOfficialClient<$Result.GetResult<Prisma.$CivicsOfficialPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CivicsOfficials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CivicsOfficialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CivicsOfficials
     * const civicsOfficials = await prisma.civicsOfficial.findMany()
     * 
     * // Get first 10 CivicsOfficials
     * const civicsOfficials = await prisma.civicsOfficial.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const civicsOfficialWithIdOnly = await prisma.civicsOfficial.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CivicsOfficialFindManyArgs>(args?: SelectSubset<T, CivicsOfficialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CivicsOfficialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CivicsOfficial.
     * @param {CivicsOfficialCreateArgs} args - Arguments to create a CivicsOfficial.
     * @example
     * // Create one CivicsOfficial
     * const CivicsOfficial = await prisma.civicsOfficial.create({
     *   data: {
     *     // ... data to create a CivicsOfficial
     *   }
     * })
     * 
     */
    create<T extends CivicsOfficialCreateArgs>(args: SelectSubset<T, CivicsOfficialCreateArgs<ExtArgs>>): Prisma__CivicsOfficialClient<$Result.GetResult<Prisma.$CivicsOfficialPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CivicsOfficials.
     * @param {CivicsOfficialCreateManyArgs} args - Arguments to create many CivicsOfficials.
     * @example
     * // Create many CivicsOfficials
     * const civicsOfficial = await prisma.civicsOfficial.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CivicsOfficialCreateManyArgs>(args?: SelectSubset<T, CivicsOfficialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CivicsOfficials and returns the data saved in the database.
     * @param {CivicsOfficialCreateManyAndReturnArgs} args - Arguments to create many CivicsOfficials.
     * @example
     * // Create many CivicsOfficials
     * const civicsOfficial = await prisma.civicsOfficial.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CivicsOfficials and only return the `id`
     * const civicsOfficialWithIdOnly = await prisma.civicsOfficial.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CivicsOfficialCreateManyAndReturnArgs>(args?: SelectSubset<T, CivicsOfficialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CivicsOfficialPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CivicsOfficial.
     * @param {CivicsOfficialDeleteArgs} args - Arguments to delete one CivicsOfficial.
     * @example
     * // Delete one CivicsOfficial
     * const CivicsOfficial = await prisma.civicsOfficial.delete({
     *   where: {
     *     // ... filter to delete one CivicsOfficial
     *   }
     * })
     * 
     */
    delete<T extends CivicsOfficialDeleteArgs>(args: SelectSubset<T, CivicsOfficialDeleteArgs<ExtArgs>>): Prisma__CivicsOfficialClient<$Result.GetResult<Prisma.$CivicsOfficialPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CivicsOfficial.
     * @param {CivicsOfficialUpdateArgs} args - Arguments to update one CivicsOfficial.
     * @example
     * // Update one CivicsOfficial
     * const civicsOfficial = await prisma.civicsOfficial.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CivicsOfficialUpdateArgs>(args: SelectSubset<T, CivicsOfficialUpdateArgs<ExtArgs>>): Prisma__CivicsOfficialClient<$Result.GetResult<Prisma.$CivicsOfficialPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CivicsOfficials.
     * @param {CivicsOfficialDeleteManyArgs} args - Arguments to filter CivicsOfficials to delete.
     * @example
     * // Delete a few CivicsOfficials
     * const { count } = await prisma.civicsOfficial.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CivicsOfficialDeleteManyArgs>(args?: SelectSubset<T, CivicsOfficialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CivicsOfficials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CivicsOfficialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CivicsOfficials
     * const civicsOfficial = await prisma.civicsOfficial.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CivicsOfficialUpdateManyArgs>(args: SelectSubset<T, CivicsOfficialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CivicsOfficials and returns the data updated in the database.
     * @param {CivicsOfficialUpdateManyAndReturnArgs} args - Arguments to update many CivicsOfficials.
     * @example
     * // Update many CivicsOfficials
     * const civicsOfficial = await prisma.civicsOfficial.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CivicsOfficials and only return the `id`
     * const civicsOfficialWithIdOnly = await prisma.civicsOfficial.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CivicsOfficialUpdateManyAndReturnArgs>(args: SelectSubset<T, CivicsOfficialUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CivicsOfficialPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CivicsOfficial.
     * @param {CivicsOfficialUpsertArgs} args - Arguments to update or create a CivicsOfficial.
     * @example
     * // Update or create a CivicsOfficial
     * const civicsOfficial = await prisma.civicsOfficial.upsert({
     *   create: {
     *     // ... data to create a CivicsOfficial
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CivicsOfficial we want to update
     *   }
     * })
     */
    upsert<T extends CivicsOfficialUpsertArgs>(args: SelectSubset<T, CivicsOfficialUpsertArgs<ExtArgs>>): Prisma__CivicsOfficialClient<$Result.GetResult<Prisma.$CivicsOfficialPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CivicsOfficials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CivicsOfficialCountArgs} args - Arguments to filter CivicsOfficials to count.
     * @example
     * // Count the number of CivicsOfficials
     * const count = await prisma.civicsOfficial.count({
     *   where: {
     *     // ... the filter for the CivicsOfficials we want to count
     *   }
     * })
    **/
    count<T extends CivicsOfficialCountArgs>(
      args?: Subset<T, CivicsOfficialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CivicsOfficialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CivicsOfficial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CivicsOfficialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CivicsOfficialAggregateArgs>(args: Subset<T, CivicsOfficialAggregateArgs>): Prisma.PrismaPromise<GetCivicsOfficialAggregateType<T>>

    /**
     * Group by CivicsOfficial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CivicsOfficialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CivicsOfficialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CivicsOfficialGroupByArgs['orderBy'] }
        : { orderBy?: CivicsOfficialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CivicsOfficialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCivicsOfficialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CivicsOfficial model
   */
  readonly fields: CivicsOfficialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CivicsOfficial.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CivicsOfficialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    county<T extends CivicsOfficial$countyArgs<ExtArgs> = {}>(args?: Subset<T, CivicsOfficial$countyArgs<ExtArgs>>): Prisma__CountyClient<$Result.GetResult<Prisma.$CountyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    district<T extends CivicsOfficial$districtArgs<ExtArgs> = {}>(args?: Subset<T, CivicsOfficial$districtArgs<ExtArgs>>): Prisma__GeoDistrictClient<$Result.GetResult<Prisma.$GeoDistrictPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CivicsOfficial model
   */
  interface CivicsOfficialFieldRefs {
    readonly id: FieldRef<"CivicsOfficial", 'String'>
    readonly name: FieldRef<"CivicsOfficial", 'String'>
    readonly officeName: FieldRef<"CivicsOfficial", 'String'>
    readonly party: FieldRef<"CivicsOfficial", 'String'>
    readonly phone: FieldRef<"CivicsOfficial", 'String'>
    readonly website: FieldRef<"CivicsOfficial", 'String'>
    readonly photoUrl: FieldRef<"CivicsOfficial", 'String'>
    readonly countyId: FieldRef<"CivicsOfficial", 'String'>
    readonly districtId: FieldRef<"CivicsOfficial", 'String'>
    readonly sourceNote: FieldRef<"CivicsOfficial", 'String'>
    readonly createdAt: FieldRef<"CivicsOfficial", 'DateTime'>
    readonly updatedAt: FieldRef<"CivicsOfficial", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CivicsOfficial findUnique
   */
  export type CivicsOfficialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CivicsOfficial
     */
    select?: CivicsOfficialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CivicsOfficial
     */
    omit?: CivicsOfficialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CivicsOfficialInclude<ExtArgs> | null
    /**
     * Filter, which CivicsOfficial to fetch.
     */
    where: CivicsOfficialWhereUniqueInput
  }

  /**
   * CivicsOfficial findUniqueOrThrow
   */
  export type CivicsOfficialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CivicsOfficial
     */
    select?: CivicsOfficialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CivicsOfficial
     */
    omit?: CivicsOfficialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CivicsOfficialInclude<ExtArgs> | null
    /**
     * Filter, which CivicsOfficial to fetch.
     */
    where: CivicsOfficialWhereUniqueInput
  }

  /**
   * CivicsOfficial findFirst
   */
  export type CivicsOfficialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CivicsOfficial
     */
    select?: CivicsOfficialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CivicsOfficial
     */
    omit?: CivicsOfficialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CivicsOfficialInclude<ExtArgs> | null
    /**
     * Filter, which CivicsOfficial to fetch.
     */
    where?: CivicsOfficialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CivicsOfficials to fetch.
     */
    orderBy?: CivicsOfficialOrderByWithRelationInput | CivicsOfficialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CivicsOfficials.
     */
    cursor?: CivicsOfficialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CivicsOfficials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CivicsOfficials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CivicsOfficials.
     */
    distinct?: CivicsOfficialScalarFieldEnum | CivicsOfficialScalarFieldEnum[]
  }

  /**
   * CivicsOfficial findFirstOrThrow
   */
  export type CivicsOfficialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CivicsOfficial
     */
    select?: CivicsOfficialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CivicsOfficial
     */
    omit?: CivicsOfficialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CivicsOfficialInclude<ExtArgs> | null
    /**
     * Filter, which CivicsOfficial to fetch.
     */
    where?: CivicsOfficialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CivicsOfficials to fetch.
     */
    orderBy?: CivicsOfficialOrderByWithRelationInput | CivicsOfficialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CivicsOfficials.
     */
    cursor?: CivicsOfficialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CivicsOfficials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CivicsOfficials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CivicsOfficials.
     */
    distinct?: CivicsOfficialScalarFieldEnum | CivicsOfficialScalarFieldEnum[]
  }

  /**
   * CivicsOfficial findMany
   */
  export type CivicsOfficialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CivicsOfficial
     */
    select?: CivicsOfficialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CivicsOfficial
     */
    omit?: CivicsOfficialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CivicsOfficialInclude<ExtArgs> | null
    /**
     * Filter, which CivicsOfficials to fetch.
     */
    where?: CivicsOfficialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CivicsOfficials to fetch.
     */
    orderBy?: CivicsOfficialOrderByWithRelationInput | CivicsOfficialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CivicsOfficials.
     */
    cursor?: CivicsOfficialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CivicsOfficials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CivicsOfficials.
     */
    skip?: number
    distinct?: CivicsOfficialScalarFieldEnum | CivicsOfficialScalarFieldEnum[]
  }

  /**
   * CivicsOfficial create
   */
  export type CivicsOfficialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CivicsOfficial
     */
    select?: CivicsOfficialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CivicsOfficial
     */
    omit?: CivicsOfficialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CivicsOfficialInclude<ExtArgs> | null
    /**
     * The data needed to create a CivicsOfficial.
     */
    data: XOR<CivicsOfficialCreateInput, CivicsOfficialUncheckedCreateInput>
  }

  /**
   * CivicsOfficial createMany
   */
  export type CivicsOfficialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CivicsOfficials.
     */
    data: CivicsOfficialCreateManyInput | CivicsOfficialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CivicsOfficial createManyAndReturn
   */
  export type CivicsOfficialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CivicsOfficial
     */
    select?: CivicsOfficialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CivicsOfficial
     */
    omit?: CivicsOfficialOmit<ExtArgs> | null
    /**
     * The data used to create many CivicsOfficials.
     */
    data: CivicsOfficialCreateManyInput | CivicsOfficialCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CivicsOfficialIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CivicsOfficial update
   */
  export type CivicsOfficialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CivicsOfficial
     */
    select?: CivicsOfficialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CivicsOfficial
     */
    omit?: CivicsOfficialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CivicsOfficialInclude<ExtArgs> | null
    /**
     * The data needed to update a CivicsOfficial.
     */
    data: XOR<CivicsOfficialUpdateInput, CivicsOfficialUncheckedUpdateInput>
    /**
     * Choose, which CivicsOfficial to update.
     */
    where: CivicsOfficialWhereUniqueInput
  }

  /**
   * CivicsOfficial updateMany
   */
  export type CivicsOfficialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CivicsOfficials.
     */
    data: XOR<CivicsOfficialUpdateManyMutationInput, CivicsOfficialUncheckedUpdateManyInput>
    /**
     * Filter which CivicsOfficials to update
     */
    where?: CivicsOfficialWhereInput
    /**
     * Limit how many CivicsOfficials to update.
     */
    limit?: number
  }

  /**
   * CivicsOfficial updateManyAndReturn
   */
  export type CivicsOfficialUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CivicsOfficial
     */
    select?: CivicsOfficialSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CivicsOfficial
     */
    omit?: CivicsOfficialOmit<ExtArgs> | null
    /**
     * The data used to update CivicsOfficials.
     */
    data: XOR<CivicsOfficialUpdateManyMutationInput, CivicsOfficialUncheckedUpdateManyInput>
    /**
     * Filter which CivicsOfficials to update
     */
    where?: CivicsOfficialWhereInput
    /**
     * Limit how many CivicsOfficials to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CivicsOfficialIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CivicsOfficial upsert
   */
  export type CivicsOfficialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CivicsOfficial
     */
    select?: CivicsOfficialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CivicsOfficial
     */
    omit?: CivicsOfficialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CivicsOfficialInclude<ExtArgs> | null
    /**
     * The filter to search for the CivicsOfficial to update in case it exists.
     */
    where: CivicsOfficialWhereUniqueInput
    /**
     * In case the CivicsOfficial found by the `where` argument doesn't exist, create a new CivicsOfficial with this data.
     */
    create: XOR<CivicsOfficialCreateInput, CivicsOfficialUncheckedCreateInput>
    /**
     * In case the CivicsOfficial was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CivicsOfficialUpdateInput, CivicsOfficialUncheckedUpdateInput>
  }

  /**
   * CivicsOfficial delete
   */
  export type CivicsOfficialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CivicsOfficial
     */
    select?: CivicsOfficialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CivicsOfficial
     */
    omit?: CivicsOfficialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CivicsOfficialInclude<ExtArgs> | null
    /**
     * Filter which CivicsOfficial to delete.
     */
    where: CivicsOfficialWhereUniqueInput
  }

  /**
   * CivicsOfficial deleteMany
   */
  export type CivicsOfficialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CivicsOfficials to delete
     */
    where?: CivicsOfficialWhereInput
    /**
     * Limit how many CivicsOfficials to delete.
     */
    limit?: number
  }

  /**
   * CivicsOfficial.county
   */
  export type CivicsOfficial$countyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the County
     */
    select?: CountySelect<ExtArgs> | null
    /**
     * Omit specific fields from the County
     */
    omit?: CountyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountyInclude<ExtArgs> | null
    where?: CountyWhereInput
  }

  /**
   * CivicsOfficial.district
   */
  export type CivicsOfficial$districtArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoDistrict
     */
    select?: GeoDistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeoDistrict
     */
    omit?: GeoDistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeoDistrictInclude<ExtArgs> | null
    where?: GeoDistrictWhereInput
  }

  /**
   * CivicsOfficial without action
   */
  export type CivicsOfficialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CivicsOfficial
     */
    select?: CivicsOfficialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CivicsOfficial
     */
    omit?: CivicsOfficialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CivicsOfficialInclude<ExtArgs> | null
  }


  /**
   * Model Election
   */

  export type AggregateElection = {
    _count: ElectionCountAggregateOutputType | null
    _min: ElectionMinAggregateOutputType | null
    _max: ElectionMaxAggregateOutputType | null
  }

  export type ElectionMinAggregateOutputType = {
    id: string | null
    name: string | null
    electionDate: Date | null
    electionType: string | null
    notes: string | null
    createdAt: Date | null
  }

  export type ElectionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    electionDate: Date | null
    electionType: string | null
    notes: string | null
    createdAt: Date | null
  }

  export type ElectionCountAggregateOutputType = {
    id: number
    name: number
    electionDate: number
    electionType: number
    notes: number
    createdAt: number
    _all: number
  }


  export type ElectionMinAggregateInputType = {
    id?: true
    name?: true
    electionDate?: true
    electionType?: true
    notes?: true
    createdAt?: true
  }

  export type ElectionMaxAggregateInputType = {
    id?: true
    name?: true
    electionDate?: true
    electionType?: true
    notes?: true
    createdAt?: true
  }

  export type ElectionCountAggregateInputType = {
    id?: true
    name?: true
    electionDate?: true
    electionType?: true
    notes?: true
    createdAt?: true
    _all?: true
  }

  export type ElectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Election to aggregate.
     */
    where?: ElectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Elections to fetch.
     */
    orderBy?: ElectionOrderByWithRelationInput | ElectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ElectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Elections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Elections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Elections
    **/
    _count?: true | ElectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ElectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ElectionMaxAggregateInputType
  }

  export type GetElectionAggregateType<T extends ElectionAggregateArgs> = {
        [P in keyof T & keyof AggregateElection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateElection[P]>
      : GetScalarType<T[P], AggregateElection[P]>
  }




  export type ElectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ElectionWhereInput
    orderBy?: ElectionOrderByWithAggregationInput | ElectionOrderByWithAggregationInput[]
    by: ElectionScalarFieldEnum[] | ElectionScalarFieldEnum
    having?: ElectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ElectionCountAggregateInputType | true
    _min?: ElectionMinAggregateInputType
    _max?: ElectionMaxAggregateInputType
  }

  export type ElectionGroupByOutputType = {
    id: string
    name: string
    electionDate: Date
    electionType: string | null
    notes: string | null
    createdAt: Date
    _count: ElectionCountAggregateOutputType | null
    _min: ElectionMinAggregateOutputType | null
    _max: ElectionMaxAggregateOutputType | null
  }

  type GetElectionGroupByPayload<T extends ElectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ElectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ElectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ElectionGroupByOutputType[P]>
            : GetScalarType<T[P], ElectionGroupByOutputType[P]>
        }
      >
    >


  export type ElectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    electionDate?: boolean
    electionType?: boolean
    notes?: boolean
    createdAt?: boolean
    results?: boolean | Election$resultsArgs<ExtArgs>
    _count?: boolean | ElectionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["election"]>

  export type ElectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    electionDate?: boolean
    electionType?: boolean
    notes?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["election"]>

  export type ElectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    electionDate?: boolean
    electionType?: boolean
    notes?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["election"]>

  export type ElectionSelectScalar = {
    id?: boolean
    name?: boolean
    electionDate?: boolean
    electionType?: boolean
    notes?: boolean
    createdAt?: boolean
  }

  export type ElectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "electionDate" | "electionType" | "notes" | "createdAt", ExtArgs["result"]["election"]>
  export type ElectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    results?: boolean | Election$resultsArgs<ExtArgs>
    _count?: boolean | ElectionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ElectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ElectionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ElectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Election"
    objects: {
      results: Prisma.$ElectionResultPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      electionDate: Date
      electionType: string | null
      notes: string | null
      createdAt: Date
    }, ExtArgs["result"]["election"]>
    composites: {}
  }

  type ElectionGetPayload<S extends boolean | null | undefined | ElectionDefaultArgs> = $Result.GetResult<Prisma.$ElectionPayload, S>

  type ElectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ElectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ElectionCountAggregateInputType | true
    }

  export interface ElectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Election'], meta: { name: 'Election' } }
    /**
     * Find zero or one Election that matches the filter.
     * @param {ElectionFindUniqueArgs} args - Arguments to find a Election
     * @example
     * // Get one Election
     * const election = await prisma.election.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ElectionFindUniqueArgs>(args: SelectSubset<T, ElectionFindUniqueArgs<ExtArgs>>): Prisma__ElectionClient<$Result.GetResult<Prisma.$ElectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Election that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ElectionFindUniqueOrThrowArgs} args - Arguments to find a Election
     * @example
     * // Get one Election
     * const election = await prisma.election.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ElectionFindUniqueOrThrowArgs>(args: SelectSubset<T, ElectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ElectionClient<$Result.GetResult<Prisma.$ElectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Election that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElectionFindFirstArgs} args - Arguments to find a Election
     * @example
     * // Get one Election
     * const election = await prisma.election.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ElectionFindFirstArgs>(args?: SelectSubset<T, ElectionFindFirstArgs<ExtArgs>>): Prisma__ElectionClient<$Result.GetResult<Prisma.$ElectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Election that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElectionFindFirstOrThrowArgs} args - Arguments to find a Election
     * @example
     * // Get one Election
     * const election = await prisma.election.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ElectionFindFirstOrThrowArgs>(args?: SelectSubset<T, ElectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ElectionClient<$Result.GetResult<Prisma.$ElectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Elections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Elections
     * const elections = await prisma.election.findMany()
     * 
     * // Get first 10 Elections
     * const elections = await prisma.election.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const electionWithIdOnly = await prisma.election.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ElectionFindManyArgs>(args?: SelectSubset<T, ElectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ElectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Election.
     * @param {ElectionCreateArgs} args - Arguments to create a Election.
     * @example
     * // Create one Election
     * const Election = await prisma.election.create({
     *   data: {
     *     // ... data to create a Election
     *   }
     * })
     * 
     */
    create<T extends ElectionCreateArgs>(args: SelectSubset<T, ElectionCreateArgs<ExtArgs>>): Prisma__ElectionClient<$Result.GetResult<Prisma.$ElectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Elections.
     * @param {ElectionCreateManyArgs} args - Arguments to create many Elections.
     * @example
     * // Create many Elections
     * const election = await prisma.election.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ElectionCreateManyArgs>(args?: SelectSubset<T, ElectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Elections and returns the data saved in the database.
     * @param {ElectionCreateManyAndReturnArgs} args - Arguments to create many Elections.
     * @example
     * // Create many Elections
     * const election = await prisma.election.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Elections and only return the `id`
     * const electionWithIdOnly = await prisma.election.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ElectionCreateManyAndReturnArgs>(args?: SelectSubset<T, ElectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ElectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Election.
     * @param {ElectionDeleteArgs} args - Arguments to delete one Election.
     * @example
     * // Delete one Election
     * const Election = await prisma.election.delete({
     *   where: {
     *     // ... filter to delete one Election
     *   }
     * })
     * 
     */
    delete<T extends ElectionDeleteArgs>(args: SelectSubset<T, ElectionDeleteArgs<ExtArgs>>): Prisma__ElectionClient<$Result.GetResult<Prisma.$ElectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Election.
     * @param {ElectionUpdateArgs} args - Arguments to update one Election.
     * @example
     * // Update one Election
     * const election = await prisma.election.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ElectionUpdateArgs>(args: SelectSubset<T, ElectionUpdateArgs<ExtArgs>>): Prisma__ElectionClient<$Result.GetResult<Prisma.$ElectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Elections.
     * @param {ElectionDeleteManyArgs} args - Arguments to filter Elections to delete.
     * @example
     * // Delete a few Elections
     * const { count } = await prisma.election.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ElectionDeleteManyArgs>(args?: SelectSubset<T, ElectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Elections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Elections
     * const election = await prisma.election.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ElectionUpdateManyArgs>(args: SelectSubset<T, ElectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Elections and returns the data updated in the database.
     * @param {ElectionUpdateManyAndReturnArgs} args - Arguments to update many Elections.
     * @example
     * // Update many Elections
     * const election = await prisma.election.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Elections and only return the `id`
     * const electionWithIdOnly = await prisma.election.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ElectionUpdateManyAndReturnArgs>(args: SelectSubset<T, ElectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ElectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Election.
     * @param {ElectionUpsertArgs} args - Arguments to update or create a Election.
     * @example
     * // Update or create a Election
     * const election = await prisma.election.upsert({
     *   create: {
     *     // ... data to create a Election
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Election we want to update
     *   }
     * })
     */
    upsert<T extends ElectionUpsertArgs>(args: SelectSubset<T, ElectionUpsertArgs<ExtArgs>>): Prisma__ElectionClient<$Result.GetResult<Prisma.$ElectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Elections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElectionCountArgs} args - Arguments to filter Elections to count.
     * @example
     * // Count the number of Elections
     * const count = await prisma.election.count({
     *   where: {
     *     // ... the filter for the Elections we want to count
     *   }
     * })
    **/
    count<T extends ElectionCountArgs>(
      args?: Subset<T, ElectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ElectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Election.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ElectionAggregateArgs>(args: Subset<T, ElectionAggregateArgs>): Prisma.PrismaPromise<GetElectionAggregateType<T>>

    /**
     * Group by Election.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ElectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ElectionGroupByArgs['orderBy'] }
        : { orderBy?: ElectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ElectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetElectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Election model
   */
  readonly fields: ElectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Election.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ElectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    results<T extends Election$resultsArgs<ExtArgs> = {}>(args?: Subset<T, Election$resultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ElectionResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Election model
   */
  interface ElectionFieldRefs {
    readonly id: FieldRef<"Election", 'String'>
    readonly name: FieldRef<"Election", 'String'>
    readonly electionDate: FieldRef<"Election", 'DateTime'>
    readonly electionType: FieldRef<"Election", 'String'>
    readonly notes: FieldRef<"Election", 'String'>
    readonly createdAt: FieldRef<"Election", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Election findUnique
   */
  export type ElectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Election
     */
    select?: ElectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Election
     */
    omit?: ElectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElectionInclude<ExtArgs> | null
    /**
     * Filter, which Election to fetch.
     */
    where: ElectionWhereUniqueInput
  }

  /**
   * Election findUniqueOrThrow
   */
  export type ElectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Election
     */
    select?: ElectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Election
     */
    omit?: ElectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElectionInclude<ExtArgs> | null
    /**
     * Filter, which Election to fetch.
     */
    where: ElectionWhereUniqueInput
  }

  /**
   * Election findFirst
   */
  export type ElectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Election
     */
    select?: ElectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Election
     */
    omit?: ElectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElectionInclude<ExtArgs> | null
    /**
     * Filter, which Election to fetch.
     */
    where?: ElectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Elections to fetch.
     */
    orderBy?: ElectionOrderByWithRelationInput | ElectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Elections.
     */
    cursor?: ElectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Elections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Elections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Elections.
     */
    distinct?: ElectionScalarFieldEnum | ElectionScalarFieldEnum[]
  }

  /**
   * Election findFirstOrThrow
   */
  export type ElectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Election
     */
    select?: ElectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Election
     */
    omit?: ElectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElectionInclude<ExtArgs> | null
    /**
     * Filter, which Election to fetch.
     */
    where?: ElectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Elections to fetch.
     */
    orderBy?: ElectionOrderByWithRelationInput | ElectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Elections.
     */
    cursor?: ElectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Elections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Elections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Elections.
     */
    distinct?: ElectionScalarFieldEnum | ElectionScalarFieldEnum[]
  }

  /**
   * Election findMany
   */
  export type ElectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Election
     */
    select?: ElectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Election
     */
    omit?: ElectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElectionInclude<ExtArgs> | null
    /**
     * Filter, which Elections to fetch.
     */
    where?: ElectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Elections to fetch.
     */
    orderBy?: ElectionOrderByWithRelationInput | ElectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Elections.
     */
    cursor?: ElectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Elections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Elections.
     */
    skip?: number
    distinct?: ElectionScalarFieldEnum | ElectionScalarFieldEnum[]
  }

  /**
   * Election create
   */
  export type ElectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Election
     */
    select?: ElectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Election
     */
    omit?: ElectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElectionInclude<ExtArgs> | null
    /**
     * The data needed to create a Election.
     */
    data: XOR<ElectionCreateInput, ElectionUncheckedCreateInput>
  }

  /**
   * Election createMany
   */
  export type ElectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Elections.
     */
    data: ElectionCreateManyInput | ElectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Election createManyAndReturn
   */
  export type ElectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Election
     */
    select?: ElectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Election
     */
    omit?: ElectionOmit<ExtArgs> | null
    /**
     * The data used to create many Elections.
     */
    data: ElectionCreateManyInput | ElectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Election update
   */
  export type ElectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Election
     */
    select?: ElectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Election
     */
    omit?: ElectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElectionInclude<ExtArgs> | null
    /**
     * The data needed to update a Election.
     */
    data: XOR<ElectionUpdateInput, ElectionUncheckedUpdateInput>
    /**
     * Choose, which Election to update.
     */
    where: ElectionWhereUniqueInput
  }

  /**
   * Election updateMany
   */
  export type ElectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Elections.
     */
    data: XOR<ElectionUpdateManyMutationInput, ElectionUncheckedUpdateManyInput>
    /**
     * Filter which Elections to update
     */
    where?: ElectionWhereInput
    /**
     * Limit how many Elections to update.
     */
    limit?: number
  }

  /**
   * Election updateManyAndReturn
   */
  export type ElectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Election
     */
    select?: ElectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Election
     */
    omit?: ElectionOmit<ExtArgs> | null
    /**
     * The data used to update Elections.
     */
    data: XOR<ElectionUpdateManyMutationInput, ElectionUncheckedUpdateManyInput>
    /**
     * Filter which Elections to update
     */
    where?: ElectionWhereInput
    /**
     * Limit how many Elections to update.
     */
    limit?: number
  }

  /**
   * Election upsert
   */
  export type ElectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Election
     */
    select?: ElectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Election
     */
    omit?: ElectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElectionInclude<ExtArgs> | null
    /**
     * The filter to search for the Election to update in case it exists.
     */
    where: ElectionWhereUniqueInput
    /**
     * In case the Election found by the `where` argument doesn't exist, create a new Election with this data.
     */
    create: XOR<ElectionCreateInput, ElectionUncheckedCreateInput>
    /**
     * In case the Election was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ElectionUpdateInput, ElectionUncheckedUpdateInput>
  }

  /**
   * Election delete
   */
  export type ElectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Election
     */
    select?: ElectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Election
     */
    omit?: ElectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElectionInclude<ExtArgs> | null
    /**
     * Filter which Election to delete.
     */
    where: ElectionWhereUniqueInput
  }

  /**
   * Election deleteMany
   */
  export type ElectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Elections to delete
     */
    where?: ElectionWhereInput
    /**
     * Limit how many Elections to delete.
     */
    limit?: number
  }

  /**
   * Election.results
   */
  export type Election$resultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElectionResult
     */
    select?: ElectionResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElectionResult
     */
    omit?: ElectionResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElectionResultInclude<ExtArgs> | null
    where?: ElectionResultWhereInput
    orderBy?: ElectionResultOrderByWithRelationInput | ElectionResultOrderByWithRelationInput[]
    cursor?: ElectionResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ElectionResultScalarFieldEnum | ElectionResultScalarFieldEnum[]
  }

  /**
   * Election without action
   */
  export type ElectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Election
     */
    select?: ElectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Election
     */
    omit?: ElectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElectionInclude<ExtArgs> | null
  }


  /**
   * Model ElectionResult
   */

  export type AggregateElectionResult = {
    _count: ElectionResultCountAggregateOutputType | null
    _avg: ElectionResultAvgAggregateOutputType | null
    _sum: ElectionResultSumAggregateOutputType | null
    _min: ElectionResultMinAggregateOutputType | null
    _max: ElectionResultMaxAggregateOutputType | null
  }

  export type ElectionResultAvgAggregateOutputType = {
    votes: number | null
    voteShare: number | null
  }

  export type ElectionResultSumAggregateOutputType = {
    votes: number | null
    voteShare: number | null
  }

  export type ElectionResultMinAggregateOutputType = {
    id: string | null
    electionId: string | null
    countyId: string | null
    geoZipId: string | null
    precinctId: string | null
    choiceLabel: string | null
    votes: number | null
    voteShare: number | null
    createdAt: Date | null
  }

  export type ElectionResultMaxAggregateOutputType = {
    id: string | null
    electionId: string | null
    countyId: string | null
    geoZipId: string | null
    precinctId: string | null
    choiceLabel: string | null
    votes: number | null
    voteShare: number | null
    createdAt: Date | null
  }

  export type ElectionResultCountAggregateOutputType = {
    id: number
    electionId: number
    countyId: number
    geoZipId: number
    precinctId: number
    choiceLabel: number
    votes: number
    voteShare: number
    createdAt: number
    _all: number
  }


  export type ElectionResultAvgAggregateInputType = {
    votes?: true
    voteShare?: true
  }

  export type ElectionResultSumAggregateInputType = {
    votes?: true
    voteShare?: true
  }

  export type ElectionResultMinAggregateInputType = {
    id?: true
    electionId?: true
    countyId?: true
    geoZipId?: true
    precinctId?: true
    choiceLabel?: true
    votes?: true
    voteShare?: true
    createdAt?: true
  }

  export type ElectionResultMaxAggregateInputType = {
    id?: true
    electionId?: true
    countyId?: true
    geoZipId?: true
    precinctId?: true
    choiceLabel?: true
    votes?: true
    voteShare?: true
    createdAt?: true
  }

  export type ElectionResultCountAggregateInputType = {
    id?: true
    electionId?: true
    countyId?: true
    geoZipId?: true
    precinctId?: true
    choiceLabel?: true
    votes?: true
    voteShare?: true
    createdAt?: true
    _all?: true
  }

  export type ElectionResultAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ElectionResult to aggregate.
     */
    where?: ElectionResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ElectionResults to fetch.
     */
    orderBy?: ElectionResultOrderByWithRelationInput | ElectionResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ElectionResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ElectionResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ElectionResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ElectionResults
    **/
    _count?: true | ElectionResultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ElectionResultAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ElectionResultSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ElectionResultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ElectionResultMaxAggregateInputType
  }

  export type GetElectionResultAggregateType<T extends ElectionResultAggregateArgs> = {
        [P in keyof T & keyof AggregateElectionResult]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateElectionResult[P]>
      : GetScalarType<T[P], AggregateElectionResult[P]>
  }




  export type ElectionResultGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ElectionResultWhereInput
    orderBy?: ElectionResultOrderByWithAggregationInput | ElectionResultOrderByWithAggregationInput[]
    by: ElectionResultScalarFieldEnum[] | ElectionResultScalarFieldEnum
    having?: ElectionResultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ElectionResultCountAggregateInputType | true
    _avg?: ElectionResultAvgAggregateInputType
    _sum?: ElectionResultSumAggregateInputType
    _min?: ElectionResultMinAggregateInputType
    _max?: ElectionResultMaxAggregateInputType
  }

  export type ElectionResultGroupByOutputType = {
    id: string
    electionId: string
    countyId: string | null
    geoZipId: string | null
    precinctId: string | null
    choiceLabel: string
    votes: number | null
    voteShare: number | null
    createdAt: Date
    _count: ElectionResultCountAggregateOutputType | null
    _avg: ElectionResultAvgAggregateOutputType | null
    _sum: ElectionResultSumAggregateOutputType | null
    _min: ElectionResultMinAggregateOutputType | null
    _max: ElectionResultMaxAggregateOutputType | null
  }

  type GetElectionResultGroupByPayload<T extends ElectionResultGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ElectionResultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ElectionResultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ElectionResultGroupByOutputType[P]>
            : GetScalarType<T[P], ElectionResultGroupByOutputType[P]>
        }
      >
    >


  export type ElectionResultSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    electionId?: boolean
    countyId?: boolean
    geoZipId?: boolean
    precinctId?: boolean
    choiceLabel?: boolean
    votes?: boolean
    voteShare?: boolean
    createdAt?: boolean
    election?: boolean | ElectionDefaultArgs<ExtArgs>
    county?: boolean | ElectionResult$countyArgs<ExtArgs>
    geoZip?: boolean | ElectionResult$geoZipArgs<ExtArgs>
    precinct?: boolean | ElectionResult$precinctArgs<ExtArgs>
  }, ExtArgs["result"]["electionResult"]>

  export type ElectionResultSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    electionId?: boolean
    countyId?: boolean
    geoZipId?: boolean
    precinctId?: boolean
    choiceLabel?: boolean
    votes?: boolean
    voteShare?: boolean
    createdAt?: boolean
    election?: boolean | ElectionDefaultArgs<ExtArgs>
    county?: boolean | ElectionResult$countyArgs<ExtArgs>
    geoZip?: boolean | ElectionResult$geoZipArgs<ExtArgs>
    precinct?: boolean | ElectionResult$precinctArgs<ExtArgs>
  }, ExtArgs["result"]["electionResult"]>

  export type ElectionResultSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    electionId?: boolean
    countyId?: boolean
    geoZipId?: boolean
    precinctId?: boolean
    choiceLabel?: boolean
    votes?: boolean
    voteShare?: boolean
    createdAt?: boolean
    election?: boolean | ElectionDefaultArgs<ExtArgs>
    county?: boolean | ElectionResult$countyArgs<ExtArgs>
    geoZip?: boolean | ElectionResult$geoZipArgs<ExtArgs>
    precinct?: boolean | ElectionResult$precinctArgs<ExtArgs>
  }, ExtArgs["result"]["electionResult"]>

  export type ElectionResultSelectScalar = {
    id?: boolean
    electionId?: boolean
    countyId?: boolean
    geoZipId?: boolean
    precinctId?: boolean
    choiceLabel?: boolean
    votes?: boolean
    voteShare?: boolean
    createdAt?: boolean
  }

  export type ElectionResultOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "electionId" | "countyId" | "geoZipId" | "precinctId" | "choiceLabel" | "votes" | "voteShare" | "createdAt", ExtArgs["result"]["electionResult"]>
  export type ElectionResultInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    election?: boolean | ElectionDefaultArgs<ExtArgs>
    county?: boolean | ElectionResult$countyArgs<ExtArgs>
    geoZip?: boolean | ElectionResult$geoZipArgs<ExtArgs>
    precinct?: boolean | ElectionResult$precinctArgs<ExtArgs>
  }
  export type ElectionResultIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    election?: boolean | ElectionDefaultArgs<ExtArgs>
    county?: boolean | ElectionResult$countyArgs<ExtArgs>
    geoZip?: boolean | ElectionResult$geoZipArgs<ExtArgs>
    precinct?: boolean | ElectionResult$precinctArgs<ExtArgs>
  }
  export type ElectionResultIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    election?: boolean | ElectionDefaultArgs<ExtArgs>
    county?: boolean | ElectionResult$countyArgs<ExtArgs>
    geoZip?: boolean | ElectionResult$geoZipArgs<ExtArgs>
    precinct?: boolean | ElectionResult$precinctArgs<ExtArgs>
  }

  export type $ElectionResultPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ElectionResult"
    objects: {
      election: Prisma.$ElectionPayload<ExtArgs>
      county: Prisma.$CountyPayload<ExtArgs> | null
      geoZip: Prisma.$GeoZipPayload<ExtArgs> | null
      precinct: Prisma.$GeoPrecinctPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      electionId: string
      countyId: string | null
      geoZipId: string | null
      precinctId: string | null
      choiceLabel: string
      votes: number | null
      voteShare: number | null
      createdAt: Date
    }, ExtArgs["result"]["electionResult"]>
    composites: {}
  }

  type ElectionResultGetPayload<S extends boolean | null | undefined | ElectionResultDefaultArgs> = $Result.GetResult<Prisma.$ElectionResultPayload, S>

  type ElectionResultCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ElectionResultFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ElectionResultCountAggregateInputType | true
    }

  export interface ElectionResultDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ElectionResult'], meta: { name: 'ElectionResult' } }
    /**
     * Find zero or one ElectionResult that matches the filter.
     * @param {ElectionResultFindUniqueArgs} args - Arguments to find a ElectionResult
     * @example
     * // Get one ElectionResult
     * const electionResult = await prisma.electionResult.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ElectionResultFindUniqueArgs>(args: SelectSubset<T, ElectionResultFindUniqueArgs<ExtArgs>>): Prisma__ElectionResultClient<$Result.GetResult<Prisma.$ElectionResultPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ElectionResult that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ElectionResultFindUniqueOrThrowArgs} args - Arguments to find a ElectionResult
     * @example
     * // Get one ElectionResult
     * const electionResult = await prisma.electionResult.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ElectionResultFindUniqueOrThrowArgs>(args: SelectSubset<T, ElectionResultFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ElectionResultClient<$Result.GetResult<Prisma.$ElectionResultPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ElectionResult that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElectionResultFindFirstArgs} args - Arguments to find a ElectionResult
     * @example
     * // Get one ElectionResult
     * const electionResult = await prisma.electionResult.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ElectionResultFindFirstArgs>(args?: SelectSubset<T, ElectionResultFindFirstArgs<ExtArgs>>): Prisma__ElectionResultClient<$Result.GetResult<Prisma.$ElectionResultPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ElectionResult that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElectionResultFindFirstOrThrowArgs} args - Arguments to find a ElectionResult
     * @example
     * // Get one ElectionResult
     * const electionResult = await prisma.electionResult.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ElectionResultFindFirstOrThrowArgs>(args?: SelectSubset<T, ElectionResultFindFirstOrThrowArgs<ExtArgs>>): Prisma__ElectionResultClient<$Result.GetResult<Prisma.$ElectionResultPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ElectionResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElectionResultFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ElectionResults
     * const electionResults = await prisma.electionResult.findMany()
     * 
     * // Get first 10 ElectionResults
     * const electionResults = await prisma.electionResult.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const electionResultWithIdOnly = await prisma.electionResult.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ElectionResultFindManyArgs>(args?: SelectSubset<T, ElectionResultFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ElectionResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ElectionResult.
     * @param {ElectionResultCreateArgs} args - Arguments to create a ElectionResult.
     * @example
     * // Create one ElectionResult
     * const ElectionResult = await prisma.electionResult.create({
     *   data: {
     *     // ... data to create a ElectionResult
     *   }
     * })
     * 
     */
    create<T extends ElectionResultCreateArgs>(args: SelectSubset<T, ElectionResultCreateArgs<ExtArgs>>): Prisma__ElectionResultClient<$Result.GetResult<Prisma.$ElectionResultPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ElectionResults.
     * @param {ElectionResultCreateManyArgs} args - Arguments to create many ElectionResults.
     * @example
     * // Create many ElectionResults
     * const electionResult = await prisma.electionResult.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ElectionResultCreateManyArgs>(args?: SelectSubset<T, ElectionResultCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ElectionResults and returns the data saved in the database.
     * @param {ElectionResultCreateManyAndReturnArgs} args - Arguments to create many ElectionResults.
     * @example
     * // Create many ElectionResults
     * const electionResult = await prisma.electionResult.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ElectionResults and only return the `id`
     * const electionResultWithIdOnly = await prisma.electionResult.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ElectionResultCreateManyAndReturnArgs>(args?: SelectSubset<T, ElectionResultCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ElectionResultPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ElectionResult.
     * @param {ElectionResultDeleteArgs} args - Arguments to delete one ElectionResult.
     * @example
     * // Delete one ElectionResult
     * const ElectionResult = await prisma.electionResult.delete({
     *   where: {
     *     // ... filter to delete one ElectionResult
     *   }
     * })
     * 
     */
    delete<T extends ElectionResultDeleteArgs>(args: SelectSubset<T, ElectionResultDeleteArgs<ExtArgs>>): Prisma__ElectionResultClient<$Result.GetResult<Prisma.$ElectionResultPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ElectionResult.
     * @param {ElectionResultUpdateArgs} args - Arguments to update one ElectionResult.
     * @example
     * // Update one ElectionResult
     * const electionResult = await prisma.electionResult.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ElectionResultUpdateArgs>(args: SelectSubset<T, ElectionResultUpdateArgs<ExtArgs>>): Prisma__ElectionResultClient<$Result.GetResult<Prisma.$ElectionResultPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ElectionResults.
     * @param {ElectionResultDeleteManyArgs} args - Arguments to filter ElectionResults to delete.
     * @example
     * // Delete a few ElectionResults
     * const { count } = await prisma.electionResult.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ElectionResultDeleteManyArgs>(args?: SelectSubset<T, ElectionResultDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ElectionResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElectionResultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ElectionResults
     * const electionResult = await prisma.electionResult.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ElectionResultUpdateManyArgs>(args: SelectSubset<T, ElectionResultUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ElectionResults and returns the data updated in the database.
     * @param {ElectionResultUpdateManyAndReturnArgs} args - Arguments to update many ElectionResults.
     * @example
     * // Update many ElectionResults
     * const electionResult = await prisma.electionResult.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ElectionResults and only return the `id`
     * const electionResultWithIdOnly = await prisma.electionResult.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ElectionResultUpdateManyAndReturnArgs>(args: SelectSubset<T, ElectionResultUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ElectionResultPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ElectionResult.
     * @param {ElectionResultUpsertArgs} args - Arguments to update or create a ElectionResult.
     * @example
     * // Update or create a ElectionResult
     * const electionResult = await prisma.electionResult.upsert({
     *   create: {
     *     // ... data to create a ElectionResult
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ElectionResult we want to update
     *   }
     * })
     */
    upsert<T extends ElectionResultUpsertArgs>(args: SelectSubset<T, ElectionResultUpsertArgs<ExtArgs>>): Prisma__ElectionResultClient<$Result.GetResult<Prisma.$ElectionResultPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ElectionResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElectionResultCountArgs} args - Arguments to filter ElectionResults to count.
     * @example
     * // Count the number of ElectionResults
     * const count = await prisma.electionResult.count({
     *   where: {
     *     // ... the filter for the ElectionResults we want to count
     *   }
     * })
    **/
    count<T extends ElectionResultCountArgs>(
      args?: Subset<T, ElectionResultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ElectionResultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ElectionResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElectionResultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ElectionResultAggregateArgs>(args: Subset<T, ElectionResultAggregateArgs>): Prisma.PrismaPromise<GetElectionResultAggregateType<T>>

    /**
     * Group by ElectionResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElectionResultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ElectionResultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ElectionResultGroupByArgs['orderBy'] }
        : { orderBy?: ElectionResultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ElectionResultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetElectionResultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ElectionResult model
   */
  readonly fields: ElectionResultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ElectionResult.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ElectionResultClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    election<T extends ElectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ElectionDefaultArgs<ExtArgs>>): Prisma__ElectionClient<$Result.GetResult<Prisma.$ElectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    county<T extends ElectionResult$countyArgs<ExtArgs> = {}>(args?: Subset<T, ElectionResult$countyArgs<ExtArgs>>): Prisma__CountyClient<$Result.GetResult<Prisma.$CountyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    geoZip<T extends ElectionResult$geoZipArgs<ExtArgs> = {}>(args?: Subset<T, ElectionResult$geoZipArgs<ExtArgs>>): Prisma__GeoZipClient<$Result.GetResult<Prisma.$GeoZipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    precinct<T extends ElectionResult$precinctArgs<ExtArgs> = {}>(args?: Subset<T, ElectionResult$precinctArgs<ExtArgs>>): Prisma__GeoPrecinctClient<$Result.GetResult<Prisma.$GeoPrecinctPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ElectionResult model
   */
  interface ElectionResultFieldRefs {
    readonly id: FieldRef<"ElectionResult", 'String'>
    readonly electionId: FieldRef<"ElectionResult", 'String'>
    readonly countyId: FieldRef<"ElectionResult", 'String'>
    readonly geoZipId: FieldRef<"ElectionResult", 'String'>
    readonly precinctId: FieldRef<"ElectionResult", 'String'>
    readonly choiceLabel: FieldRef<"ElectionResult", 'String'>
    readonly votes: FieldRef<"ElectionResult", 'Int'>
    readonly voteShare: FieldRef<"ElectionResult", 'Float'>
    readonly createdAt: FieldRef<"ElectionResult", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ElectionResult findUnique
   */
  export type ElectionResultFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElectionResult
     */
    select?: ElectionResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElectionResult
     */
    omit?: ElectionResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElectionResultInclude<ExtArgs> | null
    /**
     * Filter, which ElectionResult to fetch.
     */
    where: ElectionResultWhereUniqueInput
  }

  /**
   * ElectionResult findUniqueOrThrow
   */
  export type ElectionResultFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElectionResult
     */
    select?: ElectionResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElectionResult
     */
    omit?: ElectionResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElectionResultInclude<ExtArgs> | null
    /**
     * Filter, which ElectionResult to fetch.
     */
    where: ElectionResultWhereUniqueInput
  }

  /**
   * ElectionResult findFirst
   */
  export type ElectionResultFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElectionResult
     */
    select?: ElectionResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElectionResult
     */
    omit?: ElectionResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElectionResultInclude<ExtArgs> | null
    /**
     * Filter, which ElectionResult to fetch.
     */
    where?: ElectionResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ElectionResults to fetch.
     */
    orderBy?: ElectionResultOrderByWithRelationInput | ElectionResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ElectionResults.
     */
    cursor?: ElectionResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ElectionResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ElectionResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ElectionResults.
     */
    distinct?: ElectionResultScalarFieldEnum | ElectionResultScalarFieldEnum[]
  }

  /**
   * ElectionResult findFirstOrThrow
   */
  export type ElectionResultFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElectionResult
     */
    select?: ElectionResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElectionResult
     */
    omit?: ElectionResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElectionResultInclude<ExtArgs> | null
    /**
     * Filter, which ElectionResult to fetch.
     */
    where?: ElectionResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ElectionResults to fetch.
     */
    orderBy?: ElectionResultOrderByWithRelationInput | ElectionResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ElectionResults.
     */
    cursor?: ElectionResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ElectionResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ElectionResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ElectionResults.
     */
    distinct?: ElectionResultScalarFieldEnum | ElectionResultScalarFieldEnum[]
  }

  /**
   * ElectionResult findMany
   */
  export type ElectionResultFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElectionResult
     */
    select?: ElectionResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElectionResult
     */
    omit?: ElectionResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElectionResultInclude<ExtArgs> | null
    /**
     * Filter, which ElectionResults to fetch.
     */
    where?: ElectionResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ElectionResults to fetch.
     */
    orderBy?: ElectionResultOrderByWithRelationInput | ElectionResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ElectionResults.
     */
    cursor?: ElectionResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ElectionResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ElectionResults.
     */
    skip?: number
    distinct?: ElectionResultScalarFieldEnum | ElectionResultScalarFieldEnum[]
  }

  /**
   * ElectionResult create
   */
  export type ElectionResultCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElectionResult
     */
    select?: ElectionResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElectionResult
     */
    omit?: ElectionResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElectionResultInclude<ExtArgs> | null
    /**
     * The data needed to create a ElectionResult.
     */
    data: XOR<ElectionResultCreateInput, ElectionResultUncheckedCreateInput>
  }

  /**
   * ElectionResult createMany
   */
  export type ElectionResultCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ElectionResults.
     */
    data: ElectionResultCreateManyInput | ElectionResultCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ElectionResult createManyAndReturn
   */
  export type ElectionResultCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElectionResult
     */
    select?: ElectionResultSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ElectionResult
     */
    omit?: ElectionResultOmit<ExtArgs> | null
    /**
     * The data used to create many ElectionResults.
     */
    data: ElectionResultCreateManyInput | ElectionResultCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElectionResultIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ElectionResult update
   */
  export type ElectionResultUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElectionResult
     */
    select?: ElectionResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElectionResult
     */
    omit?: ElectionResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElectionResultInclude<ExtArgs> | null
    /**
     * The data needed to update a ElectionResult.
     */
    data: XOR<ElectionResultUpdateInput, ElectionResultUncheckedUpdateInput>
    /**
     * Choose, which ElectionResult to update.
     */
    where: ElectionResultWhereUniqueInput
  }

  /**
   * ElectionResult updateMany
   */
  export type ElectionResultUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ElectionResults.
     */
    data: XOR<ElectionResultUpdateManyMutationInput, ElectionResultUncheckedUpdateManyInput>
    /**
     * Filter which ElectionResults to update
     */
    where?: ElectionResultWhereInput
    /**
     * Limit how many ElectionResults to update.
     */
    limit?: number
  }

  /**
   * ElectionResult updateManyAndReturn
   */
  export type ElectionResultUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElectionResult
     */
    select?: ElectionResultSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ElectionResult
     */
    omit?: ElectionResultOmit<ExtArgs> | null
    /**
     * The data used to update ElectionResults.
     */
    data: XOR<ElectionResultUpdateManyMutationInput, ElectionResultUncheckedUpdateManyInput>
    /**
     * Filter which ElectionResults to update
     */
    where?: ElectionResultWhereInput
    /**
     * Limit how many ElectionResults to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElectionResultIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ElectionResult upsert
   */
  export type ElectionResultUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElectionResult
     */
    select?: ElectionResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElectionResult
     */
    omit?: ElectionResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElectionResultInclude<ExtArgs> | null
    /**
     * The filter to search for the ElectionResult to update in case it exists.
     */
    where: ElectionResultWhereUniqueInput
    /**
     * In case the ElectionResult found by the `where` argument doesn't exist, create a new ElectionResult with this data.
     */
    create: XOR<ElectionResultCreateInput, ElectionResultUncheckedCreateInput>
    /**
     * In case the ElectionResult was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ElectionResultUpdateInput, ElectionResultUncheckedUpdateInput>
  }

  /**
   * ElectionResult delete
   */
  export type ElectionResultDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElectionResult
     */
    select?: ElectionResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElectionResult
     */
    omit?: ElectionResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElectionResultInclude<ExtArgs> | null
    /**
     * Filter which ElectionResult to delete.
     */
    where: ElectionResultWhereUniqueInput
  }

  /**
   * ElectionResult deleteMany
   */
  export type ElectionResultDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ElectionResults to delete
     */
    where?: ElectionResultWhereInput
    /**
     * Limit how many ElectionResults to delete.
     */
    limit?: number
  }

  /**
   * ElectionResult.county
   */
  export type ElectionResult$countyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the County
     */
    select?: CountySelect<ExtArgs> | null
    /**
     * Omit specific fields from the County
     */
    omit?: CountyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountyInclude<ExtArgs> | null
    where?: CountyWhereInput
  }

  /**
   * ElectionResult.geoZip
   */
  export type ElectionResult$geoZipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoZip
     */
    select?: GeoZipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeoZip
     */
    omit?: GeoZipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeoZipInclude<ExtArgs> | null
    where?: GeoZipWhereInput
  }

  /**
   * ElectionResult.precinct
   */
  export type ElectionResult$precinctArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoPrecinct
     */
    select?: GeoPrecinctSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeoPrecinct
     */
    omit?: GeoPrecinctOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeoPrecinctInclude<ExtArgs> | null
    where?: GeoPrecinctWhereInput
  }

  /**
   * ElectionResult without action
   */
  export type ElectionResultDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElectionResult
     */
    select?: ElectionResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElectionResult
     */
    omit?: ElectionResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElectionResultInclude<ExtArgs> | null
  }


  /**
   * Model AIPrompt
   */

  export type AggregateAIPrompt = {
    _count: AIPromptCountAggregateOutputType | null
    _avg: AIPromptAvgAggregateOutputType | null
    _sum: AIPromptSumAggregateOutputType | null
    _min: AIPromptMinAggregateOutputType | null
    _max: AIPromptMaxAggregateOutputType | null
  }

  export type AIPromptAvgAggregateOutputType = {
    version: number | null
  }

  export type AIPromptSumAggregateOutputType = {
    version: number | null
  }

  export type AIPromptMinAggregateOutputType = {
    id: string | null
    promptKey: string | null
    version: number | null
    name: string | null
    description: string | null
    template: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AIPromptMaxAggregateOutputType = {
    id: string | null
    promptKey: string | null
    version: number | null
    name: string | null
    description: string | null
    template: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AIPromptCountAggregateOutputType = {
    id: number
    promptKey: number
    version: number
    name: number
    description: number
    template: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AIPromptAvgAggregateInputType = {
    version?: true
  }

  export type AIPromptSumAggregateInputType = {
    version?: true
  }

  export type AIPromptMinAggregateInputType = {
    id?: true
    promptKey?: true
    version?: true
    name?: true
    description?: true
    template?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AIPromptMaxAggregateInputType = {
    id?: true
    promptKey?: true
    version?: true
    name?: true
    description?: true
    template?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AIPromptCountAggregateInputType = {
    id?: true
    promptKey?: true
    version?: true
    name?: true
    description?: true
    template?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AIPromptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIPrompt to aggregate.
     */
    where?: AIPromptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIPrompts to fetch.
     */
    orderBy?: AIPromptOrderByWithRelationInput | AIPromptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIPromptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIPrompts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIPrompts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIPrompts
    **/
    _count?: true | AIPromptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AIPromptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AIPromptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIPromptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIPromptMaxAggregateInputType
  }

  export type GetAIPromptAggregateType<T extends AIPromptAggregateArgs> = {
        [P in keyof T & keyof AggregateAIPrompt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIPrompt[P]>
      : GetScalarType<T[P], AggregateAIPrompt[P]>
  }




  export type AIPromptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIPromptWhereInput
    orderBy?: AIPromptOrderByWithAggregationInput | AIPromptOrderByWithAggregationInput[]
    by: AIPromptScalarFieldEnum[] | AIPromptScalarFieldEnum
    having?: AIPromptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIPromptCountAggregateInputType | true
    _avg?: AIPromptAvgAggregateInputType
    _sum?: AIPromptSumAggregateInputType
    _min?: AIPromptMinAggregateInputType
    _max?: AIPromptMaxAggregateInputType
  }

  export type AIPromptGroupByOutputType = {
    id: string
    promptKey: string
    version: number
    name: string
    description: string | null
    template: string
    createdAt: Date
    updatedAt: Date
    _count: AIPromptCountAggregateOutputType | null
    _avg: AIPromptAvgAggregateOutputType | null
    _sum: AIPromptSumAggregateOutputType | null
    _min: AIPromptMinAggregateOutputType | null
    _max: AIPromptMaxAggregateOutputType | null
  }

  type GetAIPromptGroupByPayload<T extends AIPromptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIPromptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIPromptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIPromptGroupByOutputType[P]>
            : GetScalarType<T[P], AIPromptGroupByOutputType[P]>
        }
      >
    >


  export type AIPromptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    promptKey?: boolean
    version?: boolean
    name?: boolean
    description?: boolean
    template?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    runs?: boolean | AIPrompt$runsArgs<ExtArgs>
    _count?: boolean | AIPromptCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIPrompt"]>

  export type AIPromptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    promptKey?: boolean
    version?: boolean
    name?: boolean
    description?: boolean
    template?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aIPrompt"]>

  export type AIPromptSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    promptKey?: boolean
    version?: boolean
    name?: boolean
    description?: boolean
    template?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aIPrompt"]>

  export type AIPromptSelectScalar = {
    id?: boolean
    promptKey?: boolean
    version?: boolean
    name?: boolean
    description?: boolean
    template?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AIPromptOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "promptKey" | "version" | "name" | "description" | "template" | "createdAt" | "updatedAt", ExtArgs["result"]["aIPrompt"]>
  export type AIPromptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    runs?: boolean | AIPrompt$runsArgs<ExtArgs>
    _count?: boolean | AIPromptCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AIPromptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AIPromptIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AIPromptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIPrompt"
    objects: {
      runs: Prisma.$AIRunPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      promptKey: string
      version: number
      name: string
      description: string | null
      template: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["aIPrompt"]>
    composites: {}
  }

  type AIPromptGetPayload<S extends boolean | null | undefined | AIPromptDefaultArgs> = $Result.GetResult<Prisma.$AIPromptPayload, S>

  type AIPromptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AIPromptFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AIPromptCountAggregateInputType | true
    }

  export interface AIPromptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIPrompt'], meta: { name: 'AIPrompt' } }
    /**
     * Find zero or one AIPrompt that matches the filter.
     * @param {AIPromptFindUniqueArgs} args - Arguments to find a AIPrompt
     * @example
     * // Get one AIPrompt
     * const aIPrompt = await prisma.aIPrompt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIPromptFindUniqueArgs>(args: SelectSubset<T, AIPromptFindUniqueArgs<ExtArgs>>): Prisma__AIPromptClient<$Result.GetResult<Prisma.$AIPromptPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AIPrompt that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AIPromptFindUniqueOrThrowArgs} args - Arguments to find a AIPrompt
     * @example
     * // Get one AIPrompt
     * const aIPrompt = await prisma.aIPrompt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIPromptFindUniqueOrThrowArgs>(args: SelectSubset<T, AIPromptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIPromptClient<$Result.GetResult<Prisma.$AIPromptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIPrompt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIPromptFindFirstArgs} args - Arguments to find a AIPrompt
     * @example
     * // Get one AIPrompt
     * const aIPrompt = await prisma.aIPrompt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIPromptFindFirstArgs>(args?: SelectSubset<T, AIPromptFindFirstArgs<ExtArgs>>): Prisma__AIPromptClient<$Result.GetResult<Prisma.$AIPromptPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIPrompt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIPromptFindFirstOrThrowArgs} args - Arguments to find a AIPrompt
     * @example
     * // Get one AIPrompt
     * const aIPrompt = await prisma.aIPrompt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIPromptFindFirstOrThrowArgs>(args?: SelectSubset<T, AIPromptFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIPromptClient<$Result.GetResult<Prisma.$AIPromptPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AIPrompts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIPromptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIPrompts
     * const aIPrompts = await prisma.aIPrompt.findMany()
     * 
     * // Get first 10 AIPrompts
     * const aIPrompts = await prisma.aIPrompt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIPromptWithIdOnly = await prisma.aIPrompt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIPromptFindManyArgs>(args?: SelectSubset<T, AIPromptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIPromptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AIPrompt.
     * @param {AIPromptCreateArgs} args - Arguments to create a AIPrompt.
     * @example
     * // Create one AIPrompt
     * const AIPrompt = await prisma.aIPrompt.create({
     *   data: {
     *     // ... data to create a AIPrompt
     *   }
     * })
     * 
     */
    create<T extends AIPromptCreateArgs>(args: SelectSubset<T, AIPromptCreateArgs<ExtArgs>>): Prisma__AIPromptClient<$Result.GetResult<Prisma.$AIPromptPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AIPrompts.
     * @param {AIPromptCreateManyArgs} args - Arguments to create many AIPrompts.
     * @example
     * // Create many AIPrompts
     * const aIPrompt = await prisma.aIPrompt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIPromptCreateManyArgs>(args?: SelectSubset<T, AIPromptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIPrompts and returns the data saved in the database.
     * @param {AIPromptCreateManyAndReturnArgs} args - Arguments to create many AIPrompts.
     * @example
     * // Create many AIPrompts
     * const aIPrompt = await prisma.aIPrompt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIPrompts and only return the `id`
     * const aIPromptWithIdOnly = await prisma.aIPrompt.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIPromptCreateManyAndReturnArgs>(args?: SelectSubset<T, AIPromptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIPromptPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AIPrompt.
     * @param {AIPromptDeleteArgs} args - Arguments to delete one AIPrompt.
     * @example
     * // Delete one AIPrompt
     * const AIPrompt = await prisma.aIPrompt.delete({
     *   where: {
     *     // ... filter to delete one AIPrompt
     *   }
     * })
     * 
     */
    delete<T extends AIPromptDeleteArgs>(args: SelectSubset<T, AIPromptDeleteArgs<ExtArgs>>): Prisma__AIPromptClient<$Result.GetResult<Prisma.$AIPromptPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AIPrompt.
     * @param {AIPromptUpdateArgs} args - Arguments to update one AIPrompt.
     * @example
     * // Update one AIPrompt
     * const aIPrompt = await prisma.aIPrompt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIPromptUpdateArgs>(args: SelectSubset<T, AIPromptUpdateArgs<ExtArgs>>): Prisma__AIPromptClient<$Result.GetResult<Prisma.$AIPromptPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AIPrompts.
     * @param {AIPromptDeleteManyArgs} args - Arguments to filter AIPrompts to delete.
     * @example
     * // Delete a few AIPrompts
     * const { count } = await prisma.aIPrompt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIPromptDeleteManyArgs>(args?: SelectSubset<T, AIPromptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIPrompts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIPromptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIPrompts
     * const aIPrompt = await prisma.aIPrompt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIPromptUpdateManyArgs>(args: SelectSubset<T, AIPromptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIPrompts and returns the data updated in the database.
     * @param {AIPromptUpdateManyAndReturnArgs} args - Arguments to update many AIPrompts.
     * @example
     * // Update many AIPrompts
     * const aIPrompt = await prisma.aIPrompt.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AIPrompts and only return the `id`
     * const aIPromptWithIdOnly = await prisma.aIPrompt.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AIPromptUpdateManyAndReturnArgs>(args: SelectSubset<T, AIPromptUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIPromptPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AIPrompt.
     * @param {AIPromptUpsertArgs} args - Arguments to update or create a AIPrompt.
     * @example
     * // Update or create a AIPrompt
     * const aIPrompt = await prisma.aIPrompt.upsert({
     *   create: {
     *     // ... data to create a AIPrompt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIPrompt we want to update
     *   }
     * })
     */
    upsert<T extends AIPromptUpsertArgs>(args: SelectSubset<T, AIPromptUpsertArgs<ExtArgs>>): Prisma__AIPromptClient<$Result.GetResult<Prisma.$AIPromptPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AIPrompts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIPromptCountArgs} args - Arguments to filter AIPrompts to count.
     * @example
     * // Count the number of AIPrompts
     * const count = await prisma.aIPrompt.count({
     *   where: {
     *     // ... the filter for the AIPrompts we want to count
     *   }
     * })
    **/
    count<T extends AIPromptCountArgs>(
      args?: Subset<T, AIPromptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIPromptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIPrompt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIPromptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIPromptAggregateArgs>(args: Subset<T, AIPromptAggregateArgs>): Prisma.PrismaPromise<GetAIPromptAggregateType<T>>

    /**
     * Group by AIPrompt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIPromptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIPromptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIPromptGroupByArgs['orderBy'] }
        : { orderBy?: AIPromptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIPromptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIPromptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIPrompt model
   */
  readonly fields: AIPromptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIPrompt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIPromptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    runs<T extends AIPrompt$runsArgs<ExtArgs> = {}>(args?: Subset<T, AIPrompt$runsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIRunPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIPrompt model
   */
  interface AIPromptFieldRefs {
    readonly id: FieldRef<"AIPrompt", 'String'>
    readonly promptKey: FieldRef<"AIPrompt", 'String'>
    readonly version: FieldRef<"AIPrompt", 'Int'>
    readonly name: FieldRef<"AIPrompt", 'String'>
    readonly description: FieldRef<"AIPrompt", 'String'>
    readonly template: FieldRef<"AIPrompt", 'String'>
    readonly createdAt: FieldRef<"AIPrompt", 'DateTime'>
    readonly updatedAt: FieldRef<"AIPrompt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AIPrompt findUnique
   */
  export type AIPromptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIPrompt
     */
    select?: AIPromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIPrompt
     */
    omit?: AIPromptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIPromptInclude<ExtArgs> | null
    /**
     * Filter, which AIPrompt to fetch.
     */
    where: AIPromptWhereUniqueInput
  }

  /**
   * AIPrompt findUniqueOrThrow
   */
  export type AIPromptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIPrompt
     */
    select?: AIPromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIPrompt
     */
    omit?: AIPromptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIPromptInclude<ExtArgs> | null
    /**
     * Filter, which AIPrompt to fetch.
     */
    where: AIPromptWhereUniqueInput
  }

  /**
   * AIPrompt findFirst
   */
  export type AIPromptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIPrompt
     */
    select?: AIPromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIPrompt
     */
    omit?: AIPromptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIPromptInclude<ExtArgs> | null
    /**
     * Filter, which AIPrompt to fetch.
     */
    where?: AIPromptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIPrompts to fetch.
     */
    orderBy?: AIPromptOrderByWithRelationInput | AIPromptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIPrompts.
     */
    cursor?: AIPromptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIPrompts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIPrompts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIPrompts.
     */
    distinct?: AIPromptScalarFieldEnum | AIPromptScalarFieldEnum[]
  }

  /**
   * AIPrompt findFirstOrThrow
   */
  export type AIPromptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIPrompt
     */
    select?: AIPromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIPrompt
     */
    omit?: AIPromptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIPromptInclude<ExtArgs> | null
    /**
     * Filter, which AIPrompt to fetch.
     */
    where?: AIPromptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIPrompts to fetch.
     */
    orderBy?: AIPromptOrderByWithRelationInput | AIPromptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIPrompts.
     */
    cursor?: AIPromptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIPrompts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIPrompts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIPrompts.
     */
    distinct?: AIPromptScalarFieldEnum | AIPromptScalarFieldEnum[]
  }

  /**
   * AIPrompt findMany
   */
  export type AIPromptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIPrompt
     */
    select?: AIPromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIPrompt
     */
    omit?: AIPromptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIPromptInclude<ExtArgs> | null
    /**
     * Filter, which AIPrompts to fetch.
     */
    where?: AIPromptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIPrompts to fetch.
     */
    orderBy?: AIPromptOrderByWithRelationInput | AIPromptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIPrompts.
     */
    cursor?: AIPromptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIPrompts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIPrompts.
     */
    skip?: number
    distinct?: AIPromptScalarFieldEnum | AIPromptScalarFieldEnum[]
  }

  /**
   * AIPrompt create
   */
  export type AIPromptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIPrompt
     */
    select?: AIPromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIPrompt
     */
    omit?: AIPromptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIPromptInclude<ExtArgs> | null
    /**
     * The data needed to create a AIPrompt.
     */
    data: XOR<AIPromptCreateInput, AIPromptUncheckedCreateInput>
  }

  /**
   * AIPrompt createMany
   */
  export type AIPromptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIPrompts.
     */
    data: AIPromptCreateManyInput | AIPromptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIPrompt createManyAndReturn
   */
  export type AIPromptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIPrompt
     */
    select?: AIPromptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIPrompt
     */
    omit?: AIPromptOmit<ExtArgs> | null
    /**
     * The data used to create many AIPrompts.
     */
    data: AIPromptCreateManyInput | AIPromptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIPrompt update
   */
  export type AIPromptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIPrompt
     */
    select?: AIPromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIPrompt
     */
    omit?: AIPromptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIPromptInclude<ExtArgs> | null
    /**
     * The data needed to update a AIPrompt.
     */
    data: XOR<AIPromptUpdateInput, AIPromptUncheckedUpdateInput>
    /**
     * Choose, which AIPrompt to update.
     */
    where: AIPromptWhereUniqueInput
  }

  /**
   * AIPrompt updateMany
   */
  export type AIPromptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIPrompts.
     */
    data: XOR<AIPromptUpdateManyMutationInput, AIPromptUncheckedUpdateManyInput>
    /**
     * Filter which AIPrompts to update
     */
    where?: AIPromptWhereInput
    /**
     * Limit how many AIPrompts to update.
     */
    limit?: number
  }

  /**
   * AIPrompt updateManyAndReturn
   */
  export type AIPromptUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIPrompt
     */
    select?: AIPromptSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIPrompt
     */
    omit?: AIPromptOmit<ExtArgs> | null
    /**
     * The data used to update AIPrompts.
     */
    data: XOR<AIPromptUpdateManyMutationInput, AIPromptUncheckedUpdateManyInput>
    /**
     * Filter which AIPrompts to update
     */
    where?: AIPromptWhereInput
    /**
     * Limit how many AIPrompts to update.
     */
    limit?: number
  }

  /**
   * AIPrompt upsert
   */
  export type AIPromptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIPrompt
     */
    select?: AIPromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIPrompt
     */
    omit?: AIPromptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIPromptInclude<ExtArgs> | null
    /**
     * The filter to search for the AIPrompt to update in case it exists.
     */
    where: AIPromptWhereUniqueInput
    /**
     * In case the AIPrompt found by the `where` argument doesn't exist, create a new AIPrompt with this data.
     */
    create: XOR<AIPromptCreateInput, AIPromptUncheckedCreateInput>
    /**
     * In case the AIPrompt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIPromptUpdateInput, AIPromptUncheckedUpdateInput>
  }

  /**
   * AIPrompt delete
   */
  export type AIPromptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIPrompt
     */
    select?: AIPromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIPrompt
     */
    omit?: AIPromptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIPromptInclude<ExtArgs> | null
    /**
     * Filter which AIPrompt to delete.
     */
    where: AIPromptWhereUniqueInput
  }

  /**
   * AIPrompt deleteMany
   */
  export type AIPromptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIPrompts to delete
     */
    where?: AIPromptWhereInput
    /**
     * Limit how many AIPrompts to delete.
     */
    limit?: number
  }

  /**
   * AIPrompt.runs
   */
  export type AIPrompt$runsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRun
     */
    select?: AIRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRun
     */
    omit?: AIRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRunInclude<ExtArgs> | null
    where?: AIRunWhereInput
    orderBy?: AIRunOrderByWithRelationInput | AIRunOrderByWithRelationInput[]
    cursor?: AIRunWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIRunScalarFieldEnum | AIRunScalarFieldEnum[]
  }

  /**
   * AIPrompt without action
   */
  export type AIPromptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIPrompt
     */
    select?: AIPromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIPrompt
     */
    omit?: AIPromptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIPromptInclude<ExtArgs> | null
  }


  /**
   * Model AIRun
   */

  export type AggregateAIRun = {
    _count: AIRunCountAggregateOutputType | null
    _min: AIRunMinAggregateOutputType | null
    _max: AIRunMaxAggregateOutputType | null
  }

  export type AIRunMinAggregateOutputType = {
    id: string | null
    promptId: string | null
    model: string | null
    status: $Enums.AIRunStatus | null
    startedAt: Date | null
    completedAt: Date | null
    errorText: string | null
    inputSummary: string | null
    createdAt: Date | null
  }

  export type AIRunMaxAggregateOutputType = {
    id: string | null
    promptId: string | null
    model: string | null
    status: $Enums.AIRunStatus | null
    startedAt: Date | null
    completedAt: Date | null
    errorText: string | null
    inputSummary: string | null
    createdAt: Date | null
  }

  export type AIRunCountAggregateOutputType = {
    id: number
    promptId: number
    model: number
    paramsJson: number
    status: number
    startedAt: number
    completedAt: number
    errorText: number
    inputSummary: number
    createdAt: number
    _all: number
  }


  export type AIRunMinAggregateInputType = {
    id?: true
    promptId?: true
    model?: true
    status?: true
    startedAt?: true
    completedAt?: true
    errorText?: true
    inputSummary?: true
    createdAt?: true
  }

  export type AIRunMaxAggregateInputType = {
    id?: true
    promptId?: true
    model?: true
    status?: true
    startedAt?: true
    completedAt?: true
    errorText?: true
    inputSummary?: true
    createdAt?: true
  }

  export type AIRunCountAggregateInputType = {
    id?: true
    promptId?: true
    model?: true
    paramsJson?: true
    status?: true
    startedAt?: true
    completedAt?: true
    errorText?: true
    inputSummary?: true
    createdAt?: true
    _all?: true
  }

  export type AIRunAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIRun to aggregate.
     */
    where?: AIRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIRuns to fetch.
     */
    orderBy?: AIRunOrderByWithRelationInput | AIRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIRuns
    **/
    _count?: true | AIRunCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIRunMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIRunMaxAggregateInputType
  }

  export type GetAIRunAggregateType<T extends AIRunAggregateArgs> = {
        [P in keyof T & keyof AggregateAIRun]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIRun[P]>
      : GetScalarType<T[P], AggregateAIRun[P]>
  }




  export type AIRunGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIRunWhereInput
    orderBy?: AIRunOrderByWithAggregationInput | AIRunOrderByWithAggregationInput[]
    by: AIRunScalarFieldEnum[] | AIRunScalarFieldEnum
    having?: AIRunScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIRunCountAggregateInputType | true
    _min?: AIRunMinAggregateInputType
    _max?: AIRunMaxAggregateInputType
  }

  export type AIRunGroupByOutputType = {
    id: string
    promptId: string
    model: string
    paramsJson: JsonValue | null
    status: $Enums.AIRunStatus
    startedAt: Date | null
    completedAt: Date | null
    errorText: string | null
    inputSummary: string | null
    createdAt: Date
    _count: AIRunCountAggregateOutputType | null
    _min: AIRunMinAggregateOutputType | null
    _max: AIRunMaxAggregateOutputType | null
  }

  type GetAIRunGroupByPayload<T extends AIRunGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIRunGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIRunGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIRunGroupByOutputType[P]>
            : GetScalarType<T[P], AIRunGroupByOutputType[P]>
        }
      >
    >


  export type AIRunSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    promptId?: boolean
    model?: boolean
    paramsJson?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    errorText?: boolean
    inputSummary?: boolean
    createdAt?: boolean
    prompt?: boolean | AIPromptDefaultArgs<ExtArgs>
    outputs?: boolean | AIRun$outputsArgs<ExtArgs>
    inputSources?: boolean | AIRun$inputSourcesArgs<ExtArgs>
    analyses?: boolean | AIRun$analysesArgs<ExtArgs>
    _count?: boolean | AIRunCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIRun"]>

  export type AIRunSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    promptId?: boolean
    model?: boolean
    paramsJson?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    errorText?: boolean
    inputSummary?: boolean
    createdAt?: boolean
    prompt?: boolean | AIPromptDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIRun"]>

  export type AIRunSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    promptId?: boolean
    model?: boolean
    paramsJson?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    errorText?: boolean
    inputSummary?: boolean
    createdAt?: boolean
    prompt?: boolean | AIPromptDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIRun"]>

  export type AIRunSelectScalar = {
    id?: boolean
    promptId?: boolean
    model?: boolean
    paramsJson?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    errorText?: boolean
    inputSummary?: boolean
    createdAt?: boolean
  }

  export type AIRunOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "promptId" | "model" | "paramsJson" | "status" | "startedAt" | "completedAt" | "errorText" | "inputSummary" | "createdAt", ExtArgs["result"]["aIRun"]>
  export type AIRunInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prompt?: boolean | AIPromptDefaultArgs<ExtArgs>
    outputs?: boolean | AIRun$outputsArgs<ExtArgs>
    inputSources?: boolean | AIRun$inputSourcesArgs<ExtArgs>
    analyses?: boolean | AIRun$analysesArgs<ExtArgs>
    _count?: boolean | AIRunCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AIRunIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prompt?: boolean | AIPromptDefaultArgs<ExtArgs>
  }
  export type AIRunIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prompt?: boolean | AIPromptDefaultArgs<ExtArgs>
  }

  export type $AIRunPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIRun"
    objects: {
      prompt: Prisma.$AIPromptPayload<ExtArgs>
      outputs: Prisma.$AIOutputPayload<ExtArgs>[]
      inputSources: Prisma.$AIRunInputSourcePayload<ExtArgs>[]
      analyses: Prisma.$AIAnalysisPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      promptId: string
      model: string
      paramsJson: Prisma.JsonValue | null
      status: $Enums.AIRunStatus
      startedAt: Date | null
      completedAt: Date | null
      errorText: string | null
      inputSummary: string | null
      createdAt: Date
    }, ExtArgs["result"]["aIRun"]>
    composites: {}
  }

  type AIRunGetPayload<S extends boolean | null | undefined | AIRunDefaultArgs> = $Result.GetResult<Prisma.$AIRunPayload, S>

  type AIRunCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AIRunFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AIRunCountAggregateInputType | true
    }

  export interface AIRunDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIRun'], meta: { name: 'AIRun' } }
    /**
     * Find zero or one AIRun that matches the filter.
     * @param {AIRunFindUniqueArgs} args - Arguments to find a AIRun
     * @example
     * // Get one AIRun
     * const aIRun = await prisma.aIRun.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIRunFindUniqueArgs>(args: SelectSubset<T, AIRunFindUniqueArgs<ExtArgs>>): Prisma__AIRunClient<$Result.GetResult<Prisma.$AIRunPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AIRun that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AIRunFindUniqueOrThrowArgs} args - Arguments to find a AIRun
     * @example
     * // Get one AIRun
     * const aIRun = await prisma.aIRun.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIRunFindUniqueOrThrowArgs>(args: SelectSubset<T, AIRunFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIRunClient<$Result.GetResult<Prisma.$AIRunPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIRun that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIRunFindFirstArgs} args - Arguments to find a AIRun
     * @example
     * // Get one AIRun
     * const aIRun = await prisma.aIRun.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIRunFindFirstArgs>(args?: SelectSubset<T, AIRunFindFirstArgs<ExtArgs>>): Prisma__AIRunClient<$Result.GetResult<Prisma.$AIRunPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIRun that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIRunFindFirstOrThrowArgs} args - Arguments to find a AIRun
     * @example
     * // Get one AIRun
     * const aIRun = await prisma.aIRun.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIRunFindFirstOrThrowArgs>(args?: SelectSubset<T, AIRunFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIRunClient<$Result.GetResult<Prisma.$AIRunPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AIRuns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIRunFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIRuns
     * const aIRuns = await prisma.aIRun.findMany()
     * 
     * // Get first 10 AIRuns
     * const aIRuns = await prisma.aIRun.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIRunWithIdOnly = await prisma.aIRun.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIRunFindManyArgs>(args?: SelectSubset<T, AIRunFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIRunPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AIRun.
     * @param {AIRunCreateArgs} args - Arguments to create a AIRun.
     * @example
     * // Create one AIRun
     * const AIRun = await prisma.aIRun.create({
     *   data: {
     *     // ... data to create a AIRun
     *   }
     * })
     * 
     */
    create<T extends AIRunCreateArgs>(args: SelectSubset<T, AIRunCreateArgs<ExtArgs>>): Prisma__AIRunClient<$Result.GetResult<Prisma.$AIRunPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AIRuns.
     * @param {AIRunCreateManyArgs} args - Arguments to create many AIRuns.
     * @example
     * // Create many AIRuns
     * const aIRun = await prisma.aIRun.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIRunCreateManyArgs>(args?: SelectSubset<T, AIRunCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIRuns and returns the data saved in the database.
     * @param {AIRunCreateManyAndReturnArgs} args - Arguments to create many AIRuns.
     * @example
     * // Create many AIRuns
     * const aIRun = await prisma.aIRun.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIRuns and only return the `id`
     * const aIRunWithIdOnly = await prisma.aIRun.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIRunCreateManyAndReturnArgs>(args?: SelectSubset<T, AIRunCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIRunPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AIRun.
     * @param {AIRunDeleteArgs} args - Arguments to delete one AIRun.
     * @example
     * // Delete one AIRun
     * const AIRun = await prisma.aIRun.delete({
     *   where: {
     *     // ... filter to delete one AIRun
     *   }
     * })
     * 
     */
    delete<T extends AIRunDeleteArgs>(args: SelectSubset<T, AIRunDeleteArgs<ExtArgs>>): Prisma__AIRunClient<$Result.GetResult<Prisma.$AIRunPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AIRun.
     * @param {AIRunUpdateArgs} args - Arguments to update one AIRun.
     * @example
     * // Update one AIRun
     * const aIRun = await prisma.aIRun.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIRunUpdateArgs>(args: SelectSubset<T, AIRunUpdateArgs<ExtArgs>>): Prisma__AIRunClient<$Result.GetResult<Prisma.$AIRunPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AIRuns.
     * @param {AIRunDeleteManyArgs} args - Arguments to filter AIRuns to delete.
     * @example
     * // Delete a few AIRuns
     * const { count } = await prisma.aIRun.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIRunDeleteManyArgs>(args?: SelectSubset<T, AIRunDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIRunUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIRuns
     * const aIRun = await prisma.aIRun.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIRunUpdateManyArgs>(args: SelectSubset<T, AIRunUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIRuns and returns the data updated in the database.
     * @param {AIRunUpdateManyAndReturnArgs} args - Arguments to update many AIRuns.
     * @example
     * // Update many AIRuns
     * const aIRun = await prisma.aIRun.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AIRuns and only return the `id`
     * const aIRunWithIdOnly = await prisma.aIRun.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AIRunUpdateManyAndReturnArgs>(args: SelectSubset<T, AIRunUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIRunPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AIRun.
     * @param {AIRunUpsertArgs} args - Arguments to update or create a AIRun.
     * @example
     * // Update or create a AIRun
     * const aIRun = await prisma.aIRun.upsert({
     *   create: {
     *     // ... data to create a AIRun
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIRun we want to update
     *   }
     * })
     */
    upsert<T extends AIRunUpsertArgs>(args: SelectSubset<T, AIRunUpsertArgs<ExtArgs>>): Prisma__AIRunClient<$Result.GetResult<Prisma.$AIRunPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AIRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIRunCountArgs} args - Arguments to filter AIRuns to count.
     * @example
     * // Count the number of AIRuns
     * const count = await prisma.aIRun.count({
     *   where: {
     *     // ... the filter for the AIRuns we want to count
     *   }
     * })
    **/
    count<T extends AIRunCountArgs>(
      args?: Subset<T, AIRunCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIRunCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIRun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIRunAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIRunAggregateArgs>(args: Subset<T, AIRunAggregateArgs>): Prisma.PrismaPromise<GetAIRunAggregateType<T>>

    /**
     * Group by AIRun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIRunGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIRunGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIRunGroupByArgs['orderBy'] }
        : { orderBy?: AIRunGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIRunGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIRunGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIRun model
   */
  readonly fields: AIRunFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIRun.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIRunClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    prompt<T extends AIPromptDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AIPromptDefaultArgs<ExtArgs>>): Prisma__AIPromptClient<$Result.GetResult<Prisma.$AIPromptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    outputs<T extends AIRun$outputsArgs<ExtArgs> = {}>(args?: Subset<T, AIRun$outputsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIOutputPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inputSources<T extends AIRun$inputSourcesArgs<ExtArgs> = {}>(args?: Subset<T, AIRun$inputSourcesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIRunInputSourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    analyses<T extends AIRun$analysesArgs<ExtArgs> = {}>(args?: Subset<T, AIRun$analysesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIAnalysisPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIRun model
   */
  interface AIRunFieldRefs {
    readonly id: FieldRef<"AIRun", 'String'>
    readonly promptId: FieldRef<"AIRun", 'String'>
    readonly model: FieldRef<"AIRun", 'String'>
    readonly paramsJson: FieldRef<"AIRun", 'Json'>
    readonly status: FieldRef<"AIRun", 'AIRunStatus'>
    readonly startedAt: FieldRef<"AIRun", 'DateTime'>
    readonly completedAt: FieldRef<"AIRun", 'DateTime'>
    readonly errorText: FieldRef<"AIRun", 'String'>
    readonly inputSummary: FieldRef<"AIRun", 'String'>
    readonly createdAt: FieldRef<"AIRun", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AIRun findUnique
   */
  export type AIRunFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRun
     */
    select?: AIRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRun
     */
    omit?: AIRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRunInclude<ExtArgs> | null
    /**
     * Filter, which AIRun to fetch.
     */
    where: AIRunWhereUniqueInput
  }

  /**
   * AIRun findUniqueOrThrow
   */
  export type AIRunFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRun
     */
    select?: AIRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRun
     */
    omit?: AIRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRunInclude<ExtArgs> | null
    /**
     * Filter, which AIRun to fetch.
     */
    where: AIRunWhereUniqueInput
  }

  /**
   * AIRun findFirst
   */
  export type AIRunFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRun
     */
    select?: AIRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRun
     */
    omit?: AIRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRunInclude<ExtArgs> | null
    /**
     * Filter, which AIRun to fetch.
     */
    where?: AIRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIRuns to fetch.
     */
    orderBy?: AIRunOrderByWithRelationInput | AIRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIRuns.
     */
    cursor?: AIRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIRuns.
     */
    distinct?: AIRunScalarFieldEnum | AIRunScalarFieldEnum[]
  }

  /**
   * AIRun findFirstOrThrow
   */
  export type AIRunFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRun
     */
    select?: AIRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRun
     */
    omit?: AIRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRunInclude<ExtArgs> | null
    /**
     * Filter, which AIRun to fetch.
     */
    where?: AIRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIRuns to fetch.
     */
    orderBy?: AIRunOrderByWithRelationInput | AIRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIRuns.
     */
    cursor?: AIRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIRuns.
     */
    distinct?: AIRunScalarFieldEnum | AIRunScalarFieldEnum[]
  }

  /**
   * AIRun findMany
   */
  export type AIRunFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRun
     */
    select?: AIRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRun
     */
    omit?: AIRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRunInclude<ExtArgs> | null
    /**
     * Filter, which AIRuns to fetch.
     */
    where?: AIRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIRuns to fetch.
     */
    orderBy?: AIRunOrderByWithRelationInput | AIRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIRuns.
     */
    cursor?: AIRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIRuns.
     */
    skip?: number
    distinct?: AIRunScalarFieldEnum | AIRunScalarFieldEnum[]
  }

  /**
   * AIRun create
   */
  export type AIRunCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRun
     */
    select?: AIRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRun
     */
    omit?: AIRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRunInclude<ExtArgs> | null
    /**
     * The data needed to create a AIRun.
     */
    data: XOR<AIRunCreateInput, AIRunUncheckedCreateInput>
  }

  /**
   * AIRun createMany
   */
  export type AIRunCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIRuns.
     */
    data: AIRunCreateManyInput | AIRunCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIRun createManyAndReturn
   */
  export type AIRunCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRun
     */
    select?: AIRunSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIRun
     */
    omit?: AIRunOmit<ExtArgs> | null
    /**
     * The data used to create many AIRuns.
     */
    data: AIRunCreateManyInput | AIRunCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRunIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIRun update
   */
  export type AIRunUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRun
     */
    select?: AIRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRun
     */
    omit?: AIRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRunInclude<ExtArgs> | null
    /**
     * The data needed to update a AIRun.
     */
    data: XOR<AIRunUpdateInput, AIRunUncheckedUpdateInput>
    /**
     * Choose, which AIRun to update.
     */
    where: AIRunWhereUniqueInput
  }

  /**
   * AIRun updateMany
   */
  export type AIRunUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIRuns.
     */
    data: XOR<AIRunUpdateManyMutationInput, AIRunUncheckedUpdateManyInput>
    /**
     * Filter which AIRuns to update
     */
    where?: AIRunWhereInput
    /**
     * Limit how many AIRuns to update.
     */
    limit?: number
  }

  /**
   * AIRun updateManyAndReturn
   */
  export type AIRunUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRun
     */
    select?: AIRunSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIRun
     */
    omit?: AIRunOmit<ExtArgs> | null
    /**
     * The data used to update AIRuns.
     */
    data: XOR<AIRunUpdateManyMutationInput, AIRunUncheckedUpdateManyInput>
    /**
     * Filter which AIRuns to update
     */
    where?: AIRunWhereInput
    /**
     * Limit how many AIRuns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRunIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIRun upsert
   */
  export type AIRunUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRun
     */
    select?: AIRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRun
     */
    omit?: AIRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRunInclude<ExtArgs> | null
    /**
     * The filter to search for the AIRun to update in case it exists.
     */
    where: AIRunWhereUniqueInput
    /**
     * In case the AIRun found by the `where` argument doesn't exist, create a new AIRun with this data.
     */
    create: XOR<AIRunCreateInput, AIRunUncheckedCreateInput>
    /**
     * In case the AIRun was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIRunUpdateInput, AIRunUncheckedUpdateInput>
  }

  /**
   * AIRun delete
   */
  export type AIRunDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRun
     */
    select?: AIRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRun
     */
    omit?: AIRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRunInclude<ExtArgs> | null
    /**
     * Filter which AIRun to delete.
     */
    where: AIRunWhereUniqueInput
  }

  /**
   * AIRun deleteMany
   */
  export type AIRunDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIRuns to delete
     */
    where?: AIRunWhereInput
    /**
     * Limit how many AIRuns to delete.
     */
    limit?: number
  }

  /**
   * AIRun.outputs
   */
  export type AIRun$outputsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIOutput
     */
    select?: AIOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIOutput
     */
    omit?: AIOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIOutputInclude<ExtArgs> | null
    where?: AIOutputWhereInput
    orderBy?: AIOutputOrderByWithRelationInput | AIOutputOrderByWithRelationInput[]
    cursor?: AIOutputWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIOutputScalarFieldEnum | AIOutputScalarFieldEnum[]
  }

  /**
   * AIRun.inputSources
   */
  export type AIRun$inputSourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRunInputSource
     */
    select?: AIRunInputSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRunInputSource
     */
    omit?: AIRunInputSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRunInputSourceInclude<ExtArgs> | null
    where?: AIRunInputSourceWhereInput
    orderBy?: AIRunInputSourceOrderByWithRelationInput | AIRunInputSourceOrderByWithRelationInput[]
    cursor?: AIRunInputSourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIRunInputSourceScalarFieldEnum | AIRunInputSourceScalarFieldEnum[]
  }

  /**
   * AIRun.analyses
   */
  export type AIRun$analysesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAnalysis
     */
    select?: AIAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIAnalysis
     */
    omit?: AIAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIAnalysisInclude<ExtArgs> | null
    where?: AIAnalysisWhereInput
    orderBy?: AIAnalysisOrderByWithRelationInput | AIAnalysisOrderByWithRelationInput[]
    cursor?: AIAnalysisWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIAnalysisScalarFieldEnum | AIAnalysisScalarFieldEnum[]
  }

  /**
   * AIRun without action
   */
  export type AIRunDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRun
     */
    select?: AIRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRun
     */
    omit?: AIRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRunInclude<ExtArgs> | null
  }


  /**
   * Model AIRunInputSource
   */

  export type AggregateAIRunInputSource = {
    _count: AIRunInputSourceCountAggregateOutputType | null
    _min: AIRunInputSourceMinAggregateOutputType | null
    _max: AIRunInputSourceMaxAggregateOutputType | null
  }

  export type AIRunInputSourceMinAggregateOutputType = {
    id: string | null
    runId: string | null
    kind: $Enums.AIRunInputKind | null
    sourceDocumentId: string | null
    externalKey: string | null
    notes: string | null
    createdAt: Date | null
  }

  export type AIRunInputSourceMaxAggregateOutputType = {
    id: string | null
    runId: string | null
    kind: $Enums.AIRunInputKind | null
    sourceDocumentId: string | null
    externalKey: string | null
    notes: string | null
    createdAt: Date | null
  }

  export type AIRunInputSourceCountAggregateOutputType = {
    id: number
    runId: number
    kind: number
    sourceDocumentId: number
    externalKey: number
    notes: number
    createdAt: number
    _all: number
  }


  export type AIRunInputSourceMinAggregateInputType = {
    id?: true
    runId?: true
    kind?: true
    sourceDocumentId?: true
    externalKey?: true
    notes?: true
    createdAt?: true
  }

  export type AIRunInputSourceMaxAggregateInputType = {
    id?: true
    runId?: true
    kind?: true
    sourceDocumentId?: true
    externalKey?: true
    notes?: true
    createdAt?: true
  }

  export type AIRunInputSourceCountAggregateInputType = {
    id?: true
    runId?: true
    kind?: true
    sourceDocumentId?: true
    externalKey?: true
    notes?: true
    createdAt?: true
    _all?: true
  }

  export type AIRunInputSourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIRunInputSource to aggregate.
     */
    where?: AIRunInputSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIRunInputSources to fetch.
     */
    orderBy?: AIRunInputSourceOrderByWithRelationInput | AIRunInputSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIRunInputSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIRunInputSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIRunInputSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIRunInputSources
    **/
    _count?: true | AIRunInputSourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIRunInputSourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIRunInputSourceMaxAggregateInputType
  }

  export type GetAIRunInputSourceAggregateType<T extends AIRunInputSourceAggregateArgs> = {
        [P in keyof T & keyof AggregateAIRunInputSource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIRunInputSource[P]>
      : GetScalarType<T[P], AggregateAIRunInputSource[P]>
  }




  export type AIRunInputSourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIRunInputSourceWhereInput
    orderBy?: AIRunInputSourceOrderByWithAggregationInput | AIRunInputSourceOrderByWithAggregationInput[]
    by: AIRunInputSourceScalarFieldEnum[] | AIRunInputSourceScalarFieldEnum
    having?: AIRunInputSourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIRunInputSourceCountAggregateInputType | true
    _min?: AIRunInputSourceMinAggregateInputType
    _max?: AIRunInputSourceMaxAggregateInputType
  }

  export type AIRunInputSourceGroupByOutputType = {
    id: string
    runId: string
    kind: $Enums.AIRunInputKind
    sourceDocumentId: string | null
    externalKey: string | null
    notes: string | null
    createdAt: Date
    _count: AIRunInputSourceCountAggregateOutputType | null
    _min: AIRunInputSourceMinAggregateOutputType | null
    _max: AIRunInputSourceMaxAggregateOutputType | null
  }

  type GetAIRunInputSourceGroupByPayload<T extends AIRunInputSourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIRunInputSourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIRunInputSourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIRunInputSourceGroupByOutputType[P]>
            : GetScalarType<T[P], AIRunInputSourceGroupByOutputType[P]>
        }
      >
    >


  export type AIRunInputSourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runId?: boolean
    kind?: boolean
    sourceDocumentId?: boolean
    externalKey?: boolean
    notes?: boolean
    createdAt?: boolean
    run?: boolean | AIRunDefaultArgs<ExtArgs>
    sourceDocument?: boolean | AIRunInputSource$sourceDocumentArgs<ExtArgs>
  }, ExtArgs["result"]["aIRunInputSource"]>

  export type AIRunInputSourceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runId?: boolean
    kind?: boolean
    sourceDocumentId?: boolean
    externalKey?: boolean
    notes?: boolean
    createdAt?: boolean
    run?: boolean | AIRunDefaultArgs<ExtArgs>
    sourceDocument?: boolean | AIRunInputSource$sourceDocumentArgs<ExtArgs>
  }, ExtArgs["result"]["aIRunInputSource"]>

  export type AIRunInputSourceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runId?: boolean
    kind?: boolean
    sourceDocumentId?: boolean
    externalKey?: boolean
    notes?: boolean
    createdAt?: boolean
    run?: boolean | AIRunDefaultArgs<ExtArgs>
    sourceDocument?: boolean | AIRunInputSource$sourceDocumentArgs<ExtArgs>
  }, ExtArgs["result"]["aIRunInputSource"]>

  export type AIRunInputSourceSelectScalar = {
    id?: boolean
    runId?: boolean
    kind?: boolean
    sourceDocumentId?: boolean
    externalKey?: boolean
    notes?: boolean
    createdAt?: boolean
  }

  export type AIRunInputSourceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "runId" | "kind" | "sourceDocumentId" | "externalKey" | "notes" | "createdAt", ExtArgs["result"]["aIRunInputSource"]>
  export type AIRunInputSourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    run?: boolean | AIRunDefaultArgs<ExtArgs>
    sourceDocument?: boolean | AIRunInputSource$sourceDocumentArgs<ExtArgs>
  }
  export type AIRunInputSourceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    run?: boolean | AIRunDefaultArgs<ExtArgs>
    sourceDocument?: boolean | AIRunInputSource$sourceDocumentArgs<ExtArgs>
  }
  export type AIRunInputSourceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    run?: boolean | AIRunDefaultArgs<ExtArgs>
    sourceDocument?: boolean | AIRunInputSource$sourceDocumentArgs<ExtArgs>
  }

  export type $AIRunInputSourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIRunInputSource"
    objects: {
      run: Prisma.$AIRunPayload<ExtArgs>
      sourceDocument: Prisma.$SourceDocumentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      runId: string
      kind: $Enums.AIRunInputKind
      sourceDocumentId: string | null
      externalKey: string | null
      notes: string | null
      createdAt: Date
    }, ExtArgs["result"]["aIRunInputSource"]>
    composites: {}
  }

  type AIRunInputSourceGetPayload<S extends boolean | null | undefined | AIRunInputSourceDefaultArgs> = $Result.GetResult<Prisma.$AIRunInputSourcePayload, S>

  type AIRunInputSourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AIRunInputSourceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AIRunInputSourceCountAggregateInputType | true
    }

  export interface AIRunInputSourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIRunInputSource'], meta: { name: 'AIRunInputSource' } }
    /**
     * Find zero or one AIRunInputSource that matches the filter.
     * @param {AIRunInputSourceFindUniqueArgs} args - Arguments to find a AIRunInputSource
     * @example
     * // Get one AIRunInputSource
     * const aIRunInputSource = await prisma.aIRunInputSource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIRunInputSourceFindUniqueArgs>(args: SelectSubset<T, AIRunInputSourceFindUniqueArgs<ExtArgs>>): Prisma__AIRunInputSourceClient<$Result.GetResult<Prisma.$AIRunInputSourcePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AIRunInputSource that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AIRunInputSourceFindUniqueOrThrowArgs} args - Arguments to find a AIRunInputSource
     * @example
     * // Get one AIRunInputSource
     * const aIRunInputSource = await prisma.aIRunInputSource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIRunInputSourceFindUniqueOrThrowArgs>(args: SelectSubset<T, AIRunInputSourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIRunInputSourceClient<$Result.GetResult<Prisma.$AIRunInputSourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIRunInputSource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIRunInputSourceFindFirstArgs} args - Arguments to find a AIRunInputSource
     * @example
     * // Get one AIRunInputSource
     * const aIRunInputSource = await prisma.aIRunInputSource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIRunInputSourceFindFirstArgs>(args?: SelectSubset<T, AIRunInputSourceFindFirstArgs<ExtArgs>>): Prisma__AIRunInputSourceClient<$Result.GetResult<Prisma.$AIRunInputSourcePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIRunInputSource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIRunInputSourceFindFirstOrThrowArgs} args - Arguments to find a AIRunInputSource
     * @example
     * // Get one AIRunInputSource
     * const aIRunInputSource = await prisma.aIRunInputSource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIRunInputSourceFindFirstOrThrowArgs>(args?: SelectSubset<T, AIRunInputSourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIRunInputSourceClient<$Result.GetResult<Prisma.$AIRunInputSourcePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AIRunInputSources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIRunInputSourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIRunInputSources
     * const aIRunInputSources = await prisma.aIRunInputSource.findMany()
     * 
     * // Get first 10 AIRunInputSources
     * const aIRunInputSources = await prisma.aIRunInputSource.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIRunInputSourceWithIdOnly = await prisma.aIRunInputSource.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIRunInputSourceFindManyArgs>(args?: SelectSubset<T, AIRunInputSourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIRunInputSourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AIRunInputSource.
     * @param {AIRunInputSourceCreateArgs} args - Arguments to create a AIRunInputSource.
     * @example
     * // Create one AIRunInputSource
     * const AIRunInputSource = await prisma.aIRunInputSource.create({
     *   data: {
     *     // ... data to create a AIRunInputSource
     *   }
     * })
     * 
     */
    create<T extends AIRunInputSourceCreateArgs>(args: SelectSubset<T, AIRunInputSourceCreateArgs<ExtArgs>>): Prisma__AIRunInputSourceClient<$Result.GetResult<Prisma.$AIRunInputSourcePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AIRunInputSources.
     * @param {AIRunInputSourceCreateManyArgs} args - Arguments to create many AIRunInputSources.
     * @example
     * // Create many AIRunInputSources
     * const aIRunInputSource = await prisma.aIRunInputSource.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIRunInputSourceCreateManyArgs>(args?: SelectSubset<T, AIRunInputSourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIRunInputSources and returns the data saved in the database.
     * @param {AIRunInputSourceCreateManyAndReturnArgs} args - Arguments to create many AIRunInputSources.
     * @example
     * // Create many AIRunInputSources
     * const aIRunInputSource = await prisma.aIRunInputSource.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIRunInputSources and only return the `id`
     * const aIRunInputSourceWithIdOnly = await prisma.aIRunInputSource.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIRunInputSourceCreateManyAndReturnArgs>(args?: SelectSubset<T, AIRunInputSourceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIRunInputSourcePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AIRunInputSource.
     * @param {AIRunInputSourceDeleteArgs} args - Arguments to delete one AIRunInputSource.
     * @example
     * // Delete one AIRunInputSource
     * const AIRunInputSource = await prisma.aIRunInputSource.delete({
     *   where: {
     *     // ... filter to delete one AIRunInputSource
     *   }
     * })
     * 
     */
    delete<T extends AIRunInputSourceDeleteArgs>(args: SelectSubset<T, AIRunInputSourceDeleteArgs<ExtArgs>>): Prisma__AIRunInputSourceClient<$Result.GetResult<Prisma.$AIRunInputSourcePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AIRunInputSource.
     * @param {AIRunInputSourceUpdateArgs} args - Arguments to update one AIRunInputSource.
     * @example
     * // Update one AIRunInputSource
     * const aIRunInputSource = await prisma.aIRunInputSource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIRunInputSourceUpdateArgs>(args: SelectSubset<T, AIRunInputSourceUpdateArgs<ExtArgs>>): Prisma__AIRunInputSourceClient<$Result.GetResult<Prisma.$AIRunInputSourcePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AIRunInputSources.
     * @param {AIRunInputSourceDeleteManyArgs} args - Arguments to filter AIRunInputSources to delete.
     * @example
     * // Delete a few AIRunInputSources
     * const { count } = await prisma.aIRunInputSource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIRunInputSourceDeleteManyArgs>(args?: SelectSubset<T, AIRunInputSourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIRunInputSources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIRunInputSourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIRunInputSources
     * const aIRunInputSource = await prisma.aIRunInputSource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIRunInputSourceUpdateManyArgs>(args: SelectSubset<T, AIRunInputSourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIRunInputSources and returns the data updated in the database.
     * @param {AIRunInputSourceUpdateManyAndReturnArgs} args - Arguments to update many AIRunInputSources.
     * @example
     * // Update many AIRunInputSources
     * const aIRunInputSource = await prisma.aIRunInputSource.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AIRunInputSources and only return the `id`
     * const aIRunInputSourceWithIdOnly = await prisma.aIRunInputSource.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AIRunInputSourceUpdateManyAndReturnArgs>(args: SelectSubset<T, AIRunInputSourceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIRunInputSourcePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AIRunInputSource.
     * @param {AIRunInputSourceUpsertArgs} args - Arguments to update or create a AIRunInputSource.
     * @example
     * // Update or create a AIRunInputSource
     * const aIRunInputSource = await prisma.aIRunInputSource.upsert({
     *   create: {
     *     // ... data to create a AIRunInputSource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIRunInputSource we want to update
     *   }
     * })
     */
    upsert<T extends AIRunInputSourceUpsertArgs>(args: SelectSubset<T, AIRunInputSourceUpsertArgs<ExtArgs>>): Prisma__AIRunInputSourceClient<$Result.GetResult<Prisma.$AIRunInputSourcePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AIRunInputSources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIRunInputSourceCountArgs} args - Arguments to filter AIRunInputSources to count.
     * @example
     * // Count the number of AIRunInputSources
     * const count = await prisma.aIRunInputSource.count({
     *   where: {
     *     // ... the filter for the AIRunInputSources we want to count
     *   }
     * })
    **/
    count<T extends AIRunInputSourceCountArgs>(
      args?: Subset<T, AIRunInputSourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIRunInputSourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIRunInputSource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIRunInputSourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIRunInputSourceAggregateArgs>(args: Subset<T, AIRunInputSourceAggregateArgs>): Prisma.PrismaPromise<GetAIRunInputSourceAggregateType<T>>

    /**
     * Group by AIRunInputSource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIRunInputSourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIRunInputSourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIRunInputSourceGroupByArgs['orderBy'] }
        : { orderBy?: AIRunInputSourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIRunInputSourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIRunInputSourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIRunInputSource model
   */
  readonly fields: AIRunInputSourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIRunInputSource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIRunInputSourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    run<T extends AIRunDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AIRunDefaultArgs<ExtArgs>>): Prisma__AIRunClient<$Result.GetResult<Prisma.$AIRunPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sourceDocument<T extends AIRunInputSource$sourceDocumentArgs<ExtArgs> = {}>(args?: Subset<T, AIRunInputSource$sourceDocumentArgs<ExtArgs>>): Prisma__SourceDocumentClient<$Result.GetResult<Prisma.$SourceDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIRunInputSource model
   */
  interface AIRunInputSourceFieldRefs {
    readonly id: FieldRef<"AIRunInputSource", 'String'>
    readonly runId: FieldRef<"AIRunInputSource", 'String'>
    readonly kind: FieldRef<"AIRunInputSource", 'AIRunInputKind'>
    readonly sourceDocumentId: FieldRef<"AIRunInputSource", 'String'>
    readonly externalKey: FieldRef<"AIRunInputSource", 'String'>
    readonly notes: FieldRef<"AIRunInputSource", 'String'>
    readonly createdAt: FieldRef<"AIRunInputSource", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AIRunInputSource findUnique
   */
  export type AIRunInputSourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRunInputSource
     */
    select?: AIRunInputSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRunInputSource
     */
    omit?: AIRunInputSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRunInputSourceInclude<ExtArgs> | null
    /**
     * Filter, which AIRunInputSource to fetch.
     */
    where: AIRunInputSourceWhereUniqueInput
  }

  /**
   * AIRunInputSource findUniqueOrThrow
   */
  export type AIRunInputSourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRunInputSource
     */
    select?: AIRunInputSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRunInputSource
     */
    omit?: AIRunInputSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRunInputSourceInclude<ExtArgs> | null
    /**
     * Filter, which AIRunInputSource to fetch.
     */
    where: AIRunInputSourceWhereUniqueInput
  }

  /**
   * AIRunInputSource findFirst
   */
  export type AIRunInputSourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRunInputSource
     */
    select?: AIRunInputSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRunInputSource
     */
    omit?: AIRunInputSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRunInputSourceInclude<ExtArgs> | null
    /**
     * Filter, which AIRunInputSource to fetch.
     */
    where?: AIRunInputSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIRunInputSources to fetch.
     */
    orderBy?: AIRunInputSourceOrderByWithRelationInput | AIRunInputSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIRunInputSources.
     */
    cursor?: AIRunInputSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIRunInputSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIRunInputSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIRunInputSources.
     */
    distinct?: AIRunInputSourceScalarFieldEnum | AIRunInputSourceScalarFieldEnum[]
  }

  /**
   * AIRunInputSource findFirstOrThrow
   */
  export type AIRunInputSourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRunInputSource
     */
    select?: AIRunInputSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRunInputSource
     */
    omit?: AIRunInputSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRunInputSourceInclude<ExtArgs> | null
    /**
     * Filter, which AIRunInputSource to fetch.
     */
    where?: AIRunInputSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIRunInputSources to fetch.
     */
    orderBy?: AIRunInputSourceOrderByWithRelationInput | AIRunInputSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIRunInputSources.
     */
    cursor?: AIRunInputSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIRunInputSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIRunInputSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIRunInputSources.
     */
    distinct?: AIRunInputSourceScalarFieldEnum | AIRunInputSourceScalarFieldEnum[]
  }

  /**
   * AIRunInputSource findMany
   */
  export type AIRunInputSourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRunInputSource
     */
    select?: AIRunInputSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRunInputSource
     */
    omit?: AIRunInputSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRunInputSourceInclude<ExtArgs> | null
    /**
     * Filter, which AIRunInputSources to fetch.
     */
    where?: AIRunInputSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIRunInputSources to fetch.
     */
    orderBy?: AIRunInputSourceOrderByWithRelationInput | AIRunInputSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIRunInputSources.
     */
    cursor?: AIRunInputSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIRunInputSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIRunInputSources.
     */
    skip?: number
    distinct?: AIRunInputSourceScalarFieldEnum | AIRunInputSourceScalarFieldEnum[]
  }

  /**
   * AIRunInputSource create
   */
  export type AIRunInputSourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRunInputSource
     */
    select?: AIRunInputSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRunInputSource
     */
    omit?: AIRunInputSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRunInputSourceInclude<ExtArgs> | null
    /**
     * The data needed to create a AIRunInputSource.
     */
    data: XOR<AIRunInputSourceCreateInput, AIRunInputSourceUncheckedCreateInput>
  }

  /**
   * AIRunInputSource createMany
   */
  export type AIRunInputSourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIRunInputSources.
     */
    data: AIRunInputSourceCreateManyInput | AIRunInputSourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIRunInputSource createManyAndReturn
   */
  export type AIRunInputSourceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRunInputSource
     */
    select?: AIRunInputSourceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIRunInputSource
     */
    omit?: AIRunInputSourceOmit<ExtArgs> | null
    /**
     * The data used to create many AIRunInputSources.
     */
    data: AIRunInputSourceCreateManyInput | AIRunInputSourceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRunInputSourceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIRunInputSource update
   */
  export type AIRunInputSourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRunInputSource
     */
    select?: AIRunInputSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRunInputSource
     */
    omit?: AIRunInputSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRunInputSourceInclude<ExtArgs> | null
    /**
     * The data needed to update a AIRunInputSource.
     */
    data: XOR<AIRunInputSourceUpdateInput, AIRunInputSourceUncheckedUpdateInput>
    /**
     * Choose, which AIRunInputSource to update.
     */
    where: AIRunInputSourceWhereUniqueInput
  }

  /**
   * AIRunInputSource updateMany
   */
  export type AIRunInputSourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIRunInputSources.
     */
    data: XOR<AIRunInputSourceUpdateManyMutationInput, AIRunInputSourceUncheckedUpdateManyInput>
    /**
     * Filter which AIRunInputSources to update
     */
    where?: AIRunInputSourceWhereInput
    /**
     * Limit how many AIRunInputSources to update.
     */
    limit?: number
  }

  /**
   * AIRunInputSource updateManyAndReturn
   */
  export type AIRunInputSourceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRunInputSource
     */
    select?: AIRunInputSourceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIRunInputSource
     */
    omit?: AIRunInputSourceOmit<ExtArgs> | null
    /**
     * The data used to update AIRunInputSources.
     */
    data: XOR<AIRunInputSourceUpdateManyMutationInput, AIRunInputSourceUncheckedUpdateManyInput>
    /**
     * Filter which AIRunInputSources to update
     */
    where?: AIRunInputSourceWhereInput
    /**
     * Limit how many AIRunInputSources to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRunInputSourceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIRunInputSource upsert
   */
  export type AIRunInputSourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRunInputSource
     */
    select?: AIRunInputSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRunInputSource
     */
    omit?: AIRunInputSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRunInputSourceInclude<ExtArgs> | null
    /**
     * The filter to search for the AIRunInputSource to update in case it exists.
     */
    where: AIRunInputSourceWhereUniqueInput
    /**
     * In case the AIRunInputSource found by the `where` argument doesn't exist, create a new AIRunInputSource with this data.
     */
    create: XOR<AIRunInputSourceCreateInput, AIRunInputSourceUncheckedCreateInput>
    /**
     * In case the AIRunInputSource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIRunInputSourceUpdateInput, AIRunInputSourceUncheckedUpdateInput>
  }

  /**
   * AIRunInputSource delete
   */
  export type AIRunInputSourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRunInputSource
     */
    select?: AIRunInputSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRunInputSource
     */
    omit?: AIRunInputSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRunInputSourceInclude<ExtArgs> | null
    /**
     * Filter which AIRunInputSource to delete.
     */
    where: AIRunInputSourceWhereUniqueInput
  }

  /**
   * AIRunInputSource deleteMany
   */
  export type AIRunInputSourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIRunInputSources to delete
     */
    where?: AIRunInputSourceWhereInput
    /**
     * Limit how many AIRunInputSources to delete.
     */
    limit?: number
  }

  /**
   * AIRunInputSource.sourceDocument
   */
  export type AIRunInputSource$sourceDocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceDocument
     */
    select?: SourceDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceDocument
     */
    omit?: SourceDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceDocumentInclude<ExtArgs> | null
    where?: SourceDocumentWhereInput
  }

  /**
   * AIRunInputSource without action
   */
  export type AIRunInputSourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRunInputSource
     */
    select?: AIRunInputSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRunInputSource
     */
    omit?: AIRunInputSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRunInputSourceInclude<ExtArgs> | null
  }


  /**
   * Model AIOutput
   */

  export type AggregateAIOutput = {
    _count: AIOutputCountAggregateOutputType | null
    _min: AIOutputMinAggregateOutputType | null
    _max: AIOutputMaxAggregateOutputType | null
  }

  export type AIOutputMinAggregateOutputType = {
    id: string | null
    runId: string | null
    outputType: $Enums.AIOutputType | null
    status: $Enums.PublishStatus | null
    title: string | null
    summary: string | null
    contentMd: string | null
    reviewedAt: Date | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AIOutputMaxAggregateOutputType = {
    id: string | null
    runId: string | null
    outputType: $Enums.AIOutputType | null
    status: $Enums.PublishStatus | null
    title: string | null
    summary: string | null
    contentMd: string | null
    reviewedAt: Date | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AIOutputCountAggregateOutputType = {
    id: number
    runId: number
    outputType: number
    status: number
    title: number
    summary: number
    contentMd: number
    reviewedAt: number
    publishedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AIOutputMinAggregateInputType = {
    id?: true
    runId?: true
    outputType?: true
    status?: true
    title?: true
    summary?: true
    contentMd?: true
    reviewedAt?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AIOutputMaxAggregateInputType = {
    id?: true
    runId?: true
    outputType?: true
    status?: true
    title?: true
    summary?: true
    contentMd?: true
    reviewedAt?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AIOutputCountAggregateInputType = {
    id?: true
    runId?: true
    outputType?: true
    status?: true
    title?: true
    summary?: true
    contentMd?: true
    reviewedAt?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AIOutputAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIOutput to aggregate.
     */
    where?: AIOutputWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIOutputs to fetch.
     */
    orderBy?: AIOutputOrderByWithRelationInput | AIOutputOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIOutputWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIOutputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIOutputs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIOutputs
    **/
    _count?: true | AIOutputCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIOutputMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIOutputMaxAggregateInputType
  }

  export type GetAIOutputAggregateType<T extends AIOutputAggregateArgs> = {
        [P in keyof T & keyof AggregateAIOutput]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIOutput[P]>
      : GetScalarType<T[P], AggregateAIOutput[P]>
  }




  export type AIOutputGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIOutputWhereInput
    orderBy?: AIOutputOrderByWithAggregationInput | AIOutputOrderByWithAggregationInput[]
    by: AIOutputScalarFieldEnum[] | AIOutputScalarFieldEnum
    having?: AIOutputScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIOutputCountAggregateInputType | true
    _min?: AIOutputMinAggregateInputType
    _max?: AIOutputMaxAggregateInputType
  }

  export type AIOutputGroupByOutputType = {
    id: string
    runId: string
    outputType: $Enums.AIOutputType
    status: $Enums.PublishStatus
    title: string | null
    summary: string | null
    contentMd: string
    reviewedAt: Date | null
    publishedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: AIOutputCountAggregateOutputType | null
    _min: AIOutputMinAggregateOutputType | null
    _max: AIOutputMaxAggregateOutputType | null
  }

  type GetAIOutputGroupByPayload<T extends AIOutputGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIOutputGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIOutputGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIOutputGroupByOutputType[P]>
            : GetScalarType<T[P], AIOutputGroupByOutputType[P]>
        }
      >
    >


  export type AIOutputSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runId?: boolean
    outputType?: boolean
    status?: boolean
    title?: boolean
    summary?: boolean
    contentMd?: boolean
    reviewedAt?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    run?: boolean | AIRunDefaultArgs<ExtArgs>
    sections?: boolean | AIOutput$sectionsArgs<ExtArgs>
    scopes?: boolean | AIOutput$scopesArgs<ExtArgs>
    _count?: boolean | AIOutputCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIOutput"]>

  export type AIOutputSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runId?: boolean
    outputType?: boolean
    status?: boolean
    title?: boolean
    summary?: boolean
    contentMd?: boolean
    reviewedAt?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    run?: boolean | AIRunDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIOutput"]>

  export type AIOutputSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runId?: boolean
    outputType?: boolean
    status?: boolean
    title?: boolean
    summary?: boolean
    contentMd?: boolean
    reviewedAt?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    run?: boolean | AIRunDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIOutput"]>

  export type AIOutputSelectScalar = {
    id?: boolean
    runId?: boolean
    outputType?: boolean
    status?: boolean
    title?: boolean
    summary?: boolean
    contentMd?: boolean
    reviewedAt?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AIOutputOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "runId" | "outputType" | "status" | "title" | "summary" | "contentMd" | "reviewedAt" | "publishedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["aIOutput"]>
  export type AIOutputInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    run?: boolean | AIRunDefaultArgs<ExtArgs>
    sections?: boolean | AIOutput$sectionsArgs<ExtArgs>
    scopes?: boolean | AIOutput$scopesArgs<ExtArgs>
    _count?: boolean | AIOutputCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AIOutputIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    run?: boolean | AIRunDefaultArgs<ExtArgs>
  }
  export type AIOutputIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    run?: boolean | AIRunDefaultArgs<ExtArgs>
  }

  export type $AIOutputPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIOutput"
    objects: {
      run: Prisma.$AIRunPayload<ExtArgs>
      sections: Prisma.$AIOutputSectionPayload<ExtArgs>[]
      scopes: Prisma.$AIOutputScopePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      runId: string
      outputType: $Enums.AIOutputType
      status: $Enums.PublishStatus
      title: string | null
      summary: string | null
      contentMd: string
      reviewedAt: Date | null
      publishedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["aIOutput"]>
    composites: {}
  }

  type AIOutputGetPayload<S extends boolean | null | undefined | AIOutputDefaultArgs> = $Result.GetResult<Prisma.$AIOutputPayload, S>

  type AIOutputCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AIOutputFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AIOutputCountAggregateInputType | true
    }

  export interface AIOutputDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIOutput'], meta: { name: 'AIOutput' } }
    /**
     * Find zero or one AIOutput that matches the filter.
     * @param {AIOutputFindUniqueArgs} args - Arguments to find a AIOutput
     * @example
     * // Get one AIOutput
     * const aIOutput = await prisma.aIOutput.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIOutputFindUniqueArgs>(args: SelectSubset<T, AIOutputFindUniqueArgs<ExtArgs>>): Prisma__AIOutputClient<$Result.GetResult<Prisma.$AIOutputPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AIOutput that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AIOutputFindUniqueOrThrowArgs} args - Arguments to find a AIOutput
     * @example
     * // Get one AIOutput
     * const aIOutput = await prisma.aIOutput.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIOutputFindUniqueOrThrowArgs>(args: SelectSubset<T, AIOutputFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIOutputClient<$Result.GetResult<Prisma.$AIOutputPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIOutput that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIOutputFindFirstArgs} args - Arguments to find a AIOutput
     * @example
     * // Get one AIOutput
     * const aIOutput = await prisma.aIOutput.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIOutputFindFirstArgs>(args?: SelectSubset<T, AIOutputFindFirstArgs<ExtArgs>>): Prisma__AIOutputClient<$Result.GetResult<Prisma.$AIOutputPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIOutput that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIOutputFindFirstOrThrowArgs} args - Arguments to find a AIOutput
     * @example
     * // Get one AIOutput
     * const aIOutput = await prisma.aIOutput.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIOutputFindFirstOrThrowArgs>(args?: SelectSubset<T, AIOutputFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIOutputClient<$Result.GetResult<Prisma.$AIOutputPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AIOutputs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIOutputFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIOutputs
     * const aIOutputs = await prisma.aIOutput.findMany()
     * 
     * // Get first 10 AIOutputs
     * const aIOutputs = await prisma.aIOutput.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIOutputWithIdOnly = await prisma.aIOutput.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIOutputFindManyArgs>(args?: SelectSubset<T, AIOutputFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIOutputPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AIOutput.
     * @param {AIOutputCreateArgs} args - Arguments to create a AIOutput.
     * @example
     * // Create one AIOutput
     * const AIOutput = await prisma.aIOutput.create({
     *   data: {
     *     // ... data to create a AIOutput
     *   }
     * })
     * 
     */
    create<T extends AIOutputCreateArgs>(args: SelectSubset<T, AIOutputCreateArgs<ExtArgs>>): Prisma__AIOutputClient<$Result.GetResult<Prisma.$AIOutputPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AIOutputs.
     * @param {AIOutputCreateManyArgs} args - Arguments to create many AIOutputs.
     * @example
     * // Create many AIOutputs
     * const aIOutput = await prisma.aIOutput.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIOutputCreateManyArgs>(args?: SelectSubset<T, AIOutputCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIOutputs and returns the data saved in the database.
     * @param {AIOutputCreateManyAndReturnArgs} args - Arguments to create many AIOutputs.
     * @example
     * // Create many AIOutputs
     * const aIOutput = await prisma.aIOutput.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIOutputs and only return the `id`
     * const aIOutputWithIdOnly = await prisma.aIOutput.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIOutputCreateManyAndReturnArgs>(args?: SelectSubset<T, AIOutputCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIOutputPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AIOutput.
     * @param {AIOutputDeleteArgs} args - Arguments to delete one AIOutput.
     * @example
     * // Delete one AIOutput
     * const AIOutput = await prisma.aIOutput.delete({
     *   where: {
     *     // ... filter to delete one AIOutput
     *   }
     * })
     * 
     */
    delete<T extends AIOutputDeleteArgs>(args: SelectSubset<T, AIOutputDeleteArgs<ExtArgs>>): Prisma__AIOutputClient<$Result.GetResult<Prisma.$AIOutputPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AIOutput.
     * @param {AIOutputUpdateArgs} args - Arguments to update one AIOutput.
     * @example
     * // Update one AIOutput
     * const aIOutput = await prisma.aIOutput.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIOutputUpdateArgs>(args: SelectSubset<T, AIOutputUpdateArgs<ExtArgs>>): Prisma__AIOutputClient<$Result.GetResult<Prisma.$AIOutputPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AIOutputs.
     * @param {AIOutputDeleteManyArgs} args - Arguments to filter AIOutputs to delete.
     * @example
     * // Delete a few AIOutputs
     * const { count } = await prisma.aIOutput.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIOutputDeleteManyArgs>(args?: SelectSubset<T, AIOutputDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIOutputs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIOutputUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIOutputs
     * const aIOutput = await prisma.aIOutput.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIOutputUpdateManyArgs>(args: SelectSubset<T, AIOutputUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIOutputs and returns the data updated in the database.
     * @param {AIOutputUpdateManyAndReturnArgs} args - Arguments to update many AIOutputs.
     * @example
     * // Update many AIOutputs
     * const aIOutput = await prisma.aIOutput.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AIOutputs and only return the `id`
     * const aIOutputWithIdOnly = await prisma.aIOutput.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AIOutputUpdateManyAndReturnArgs>(args: SelectSubset<T, AIOutputUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIOutputPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AIOutput.
     * @param {AIOutputUpsertArgs} args - Arguments to update or create a AIOutput.
     * @example
     * // Update or create a AIOutput
     * const aIOutput = await prisma.aIOutput.upsert({
     *   create: {
     *     // ... data to create a AIOutput
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIOutput we want to update
     *   }
     * })
     */
    upsert<T extends AIOutputUpsertArgs>(args: SelectSubset<T, AIOutputUpsertArgs<ExtArgs>>): Prisma__AIOutputClient<$Result.GetResult<Prisma.$AIOutputPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AIOutputs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIOutputCountArgs} args - Arguments to filter AIOutputs to count.
     * @example
     * // Count the number of AIOutputs
     * const count = await prisma.aIOutput.count({
     *   where: {
     *     // ... the filter for the AIOutputs we want to count
     *   }
     * })
    **/
    count<T extends AIOutputCountArgs>(
      args?: Subset<T, AIOutputCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIOutputCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIOutput.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIOutputAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIOutputAggregateArgs>(args: Subset<T, AIOutputAggregateArgs>): Prisma.PrismaPromise<GetAIOutputAggregateType<T>>

    /**
     * Group by AIOutput.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIOutputGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIOutputGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIOutputGroupByArgs['orderBy'] }
        : { orderBy?: AIOutputGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIOutputGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIOutputGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIOutput model
   */
  readonly fields: AIOutputFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIOutput.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIOutputClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    run<T extends AIRunDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AIRunDefaultArgs<ExtArgs>>): Prisma__AIRunClient<$Result.GetResult<Prisma.$AIRunPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sections<T extends AIOutput$sectionsArgs<ExtArgs> = {}>(args?: Subset<T, AIOutput$sectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIOutputSectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    scopes<T extends AIOutput$scopesArgs<ExtArgs> = {}>(args?: Subset<T, AIOutput$scopesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIOutputScopePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIOutput model
   */
  interface AIOutputFieldRefs {
    readonly id: FieldRef<"AIOutput", 'String'>
    readonly runId: FieldRef<"AIOutput", 'String'>
    readonly outputType: FieldRef<"AIOutput", 'AIOutputType'>
    readonly status: FieldRef<"AIOutput", 'PublishStatus'>
    readonly title: FieldRef<"AIOutput", 'String'>
    readonly summary: FieldRef<"AIOutput", 'String'>
    readonly contentMd: FieldRef<"AIOutput", 'String'>
    readonly reviewedAt: FieldRef<"AIOutput", 'DateTime'>
    readonly publishedAt: FieldRef<"AIOutput", 'DateTime'>
    readonly createdAt: FieldRef<"AIOutput", 'DateTime'>
    readonly updatedAt: FieldRef<"AIOutput", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AIOutput findUnique
   */
  export type AIOutputFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIOutput
     */
    select?: AIOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIOutput
     */
    omit?: AIOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIOutputInclude<ExtArgs> | null
    /**
     * Filter, which AIOutput to fetch.
     */
    where: AIOutputWhereUniqueInput
  }

  /**
   * AIOutput findUniqueOrThrow
   */
  export type AIOutputFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIOutput
     */
    select?: AIOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIOutput
     */
    omit?: AIOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIOutputInclude<ExtArgs> | null
    /**
     * Filter, which AIOutput to fetch.
     */
    where: AIOutputWhereUniqueInput
  }

  /**
   * AIOutput findFirst
   */
  export type AIOutputFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIOutput
     */
    select?: AIOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIOutput
     */
    omit?: AIOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIOutputInclude<ExtArgs> | null
    /**
     * Filter, which AIOutput to fetch.
     */
    where?: AIOutputWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIOutputs to fetch.
     */
    orderBy?: AIOutputOrderByWithRelationInput | AIOutputOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIOutputs.
     */
    cursor?: AIOutputWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIOutputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIOutputs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIOutputs.
     */
    distinct?: AIOutputScalarFieldEnum | AIOutputScalarFieldEnum[]
  }

  /**
   * AIOutput findFirstOrThrow
   */
  export type AIOutputFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIOutput
     */
    select?: AIOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIOutput
     */
    omit?: AIOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIOutputInclude<ExtArgs> | null
    /**
     * Filter, which AIOutput to fetch.
     */
    where?: AIOutputWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIOutputs to fetch.
     */
    orderBy?: AIOutputOrderByWithRelationInput | AIOutputOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIOutputs.
     */
    cursor?: AIOutputWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIOutputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIOutputs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIOutputs.
     */
    distinct?: AIOutputScalarFieldEnum | AIOutputScalarFieldEnum[]
  }

  /**
   * AIOutput findMany
   */
  export type AIOutputFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIOutput
     */
    select?: AIOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIOutput
     */
    omit?: AIOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIOutputInclude<ExtArgs> | null
    /**
     * Filter, which AIOutputs to fetch.
     */
    where?: AIOutputWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIOutputs to fetch.
     */
    orderBy?: AIOutputOrderByWithRelationInput | AIOutputOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIOutputs.
     */
    cursor?: AIOutputWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIOutputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIOutputs.
     */
    skip?: number
    distinct?: AIOutputScalarFieldEnum | AIOutputScalarFieldEnum[]
  }

  /**
   * AIOutput create
   */
  export type AIOutputCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIOutput
     */
    select?: AIOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIOutput
     */
    omit?: AIOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIOutputInclude<ExtArgs> | null
    /**
     * The data needed to create a AIOutput.
     */
    data: XOR<AIOutputCreateInput, AIOutputUncheckedCreateInput>
  }

  /**
   * AIOutput createMany
   */
  export type AIOutputCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIOutputs.
     */
    data: AIOutputCreateManyInput | AIOutputCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIOutput createManyAndReturn
   */
  export type AIOutputCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIOutput
     */
    select?: AIOutputSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIOutput
     */
    omit?: AIOutputOmit<ExtArgs> | null
    /**
     * The data used to create many AIOutputs.
     */
    data: AIOutputCreateManyInput | AIOutputCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIOutputIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIOutput update
   */
  export type AIOutputUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIOutput
     */
    select?: AIOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIOutput
     */
    omit?: AIOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIOutputInclude<ExtArgs> | null
    /**
     * The data needed to update a AIOutput.
     */
    data: XOR<AIOutputUpdateInput, AIOutputUncheckedUpdateInput>
    /**
     * Choose, which AIOutput to update.
     */
    where: AIOutputWhereUniqueInput
  }

  /**
   * AIOutput updateMany
   */
  export type AIOutputUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIOutputs.
     */
    data: XOR<AIOutputUpdateManyMutationInput, AIOutputUncheckedUpdateManyInput>
    /**
     * Filter which AIOutputs to update
     */
    where?: AIOutputWhereInput
    /**
     * Limit how many AIOutputs to update.
     */
    limit?: number
  }

  /**
   * AIOutput updateManyAndReturn
   */
  export type AIOutputUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIOutput
     */
    select?: AIOutputSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIOutput
     */
    omit?: AIOutputOmit<ExtArgs> | null
    /**
     * The data used to update AIOutputs.
     */
    data: XOR<AIOutputUpdateManyMutationInput, AIOutputUncheckedUpdateManyInput>
    /**
     * Filter which AIOutputs to update
     */
    where?: AIOutputWhereInput
    /**
     * Limit how many AIOutputs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIOutputIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIOutput upsert
   */
  export type AIOutputUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIOutput
     */
    select?: AIOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIOutput
     */
    omit?: AIOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIOutputInclude<ExtArgs> | null
    /**
     * The filter to search for the AIOutput to update in case it exists.
     */
    where: AIOutputWhereUniqueInput
    /**
     * In case the AIOutput found by the `where` argument doesn't exist, create a new AIOutput with this data.
     */
    create: XOR<AIOutputCreateInput, AIOutputUncheckedCreateInput>
    /**
     * In case the AIOutput was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIOutputUpdateInput, AIOutputUncheckedUpdateInput>
  }

  /**
   * AIOutput delete
   */
  export type AIOutputDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIOutput
     */
    select?: AIOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIOutput
     */
    omit?: AIOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIOutputInclude<ExtArgs> | null
    /**
     * Filter which AIOutput to delete.
     */
    where: AIOutputWhereUniqueInput
  }

  /**
   * AIOutput deleteMany
   */
  export type AIOutputDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIOutputs to delete
     */
    where?: AIOutputWhereInput
    /**
     * Limit how many AIOutputs to delete.
     */
    limit?: number
  }

  /**
   * AIOutput.sections
   */
  export type AIOutput$sectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIOutputSection
     */
    select?: AIOutputSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIOutputSection
     */
    omit?: AIOutputSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIOutputSectionInclude<ExtArgs> | null
    where?: AIOutputSectionWhereInput
    orderBy?: AIOutputSectionOrderByWithRelationInput | AIOutputSectionOrderByWithRelationInput[]
    cursor?: AIOutputSectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIOutputSectionScalarFieldEnum | AIOutputSectionScalarFieldEnum[]
  }

  /**
   * AIOutput.scopes
   */
  export type AIOutput$scopesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIOutputScope
     */
    select?: AIOutputScopeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIOutputScope
     */
    omit?: AIOutputScopeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIOutputScopeInclude<ExtArgs> | null
    where?: AIOutputScopeWhereInput
    orderBy?: AIOutputScopeOrderByWithRelationInput | AIOutputScopeOrderByWithRelationInput[]
    cursor?: AIOutputScopeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIOutputScopeScalarFieldEnum | AIOutputScopeScalarFieldEnum[]
  }

  /**
   * AIOutput without action
   */
  export type AIOutputDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIOutput
     */
    select?: AIOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIOutput
     */
    omit?: AIOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIOutputInclude<ExtArgs> | null
  }


  /**
   * Model AIOutputSection
   */

  export type AggregateAIOutputSection = {
    _count: AIOutputSectionCountAggregateOutputType | null
    _avg: AIOutputSectionAvgAggregateOutputType | null
    _sum: AIOutputSectionSumAggregateOutputType | null
    _min: AIOutputSectionMinAggregateOutputType | null
    _max: AIOutputSectionMaxAggregateOutputType | null
  }

  export type AIOutputSectionAvgAggregateOutputType = {
    order: number | null
  }

  export type AIOutputSectionSumAggregateOutputType = {
    order: number | null
  }

  export type AIOutputSectionMinAggregateOutputType = {
    id: string | null
    outputId: string | null
    sectionKey: string | null
    heading: string | null
    order: number | null
    contentMd: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AIOutputSectionMaxAggregateOutputType = {
    id: string | null
    outputId: string | null
    sectionKey: string | null
    heading: string | null
    order: number | null
    contentMd: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AIOutputSectionCountAggregateOutputType = {
    id: number
    outputId: number
    sectionKey: number
    heading: number
    order: number
    contentMd: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AIOutputSectionAvgAggregateInputType = {
    order?: true
  }

  export type AIOutputSectionSumAggregateInputType = {
    order?: true
  }

  export type AIOutputSectionMinAggregateInputType = {
    id?: true
    outputId?: true
    sectionKey?: true
    heading?: true
    order?: true
    contentMd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AIOutputSectionMaxAggregateInputType = {
    id?: true
    outputId?: true
    sectionKey?: true
    heading?: true
    order?: true
    contentMd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AIOutputSectionCountAggregateInputType = {
    id?: true
    outputId?: true
    sectionKey?: true
    heading?: true
    order?: true
    contentMd?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AIOutputSectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIOutputSection to aggregate.
     */
    where?: AIOutputSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIOutputSections to fetch.
     */
    orderBy?: AIOutputSectionOrderByWithRelationInput | AIOutputSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIOutputSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIOutputSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIOutputSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIOutputSections
    **/
    _count?: true | AIOutputSectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AIOutputSectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AIOutputSectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIOutputSectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIOutputSectionMaxAggregateInputType
  }

  export type GetAIOutputSectionAggregateType<T extends AIOutputSectionAggregateArgs> = {
        [P in keyof T & keyof AggregateAIOutputSection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIOutputSection[P]>
      : GetScalarType<T[P], AggregateAIOutputSection[P]>
  }




  export type AIOutputSectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIOutputSectionWhereInput
    orderBy?: AIOutputSectionOrderByWithAggregationInput | AIOutputSectionOrderByWithAggregationInput[]
    by: AIOutputSectionScalarFieldEnum[] | AIOutputSectionScalarFieldEnum
    having?: AIOutputSectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIOutputSectionCountAggregateInputType | true
    _avg?: AIOutputSectionAvgAggregateInputType
    _sum?: AIOutputSectionSumAggregateInputType
    _min?: AIOutputSectionMinAggregateInputType
    _max?: AIOutputSectionMaxAggregateInputType
  }

  export type AIOutputSectionGroupByOutputType = {
    id: string
    outputId: string
    sectionKey: string
    heading: string | null
    order: number
    contentMd: string
    createdAt: Date
    updatedAt: Date
    _count: AIOutputSectionCountAggregateOutputType | null
    _avg: AIOutputSectionAvgAggregateOutputType | null
    _sum: AIOutputSectionSumAggregateOutputType | null
    _min: AIOutputSectionMinAggregateOutputType | null
    _max: AIOutputSectionMaxAggregateOutputType | null
  }

  type GetAIOutputSectionGroupByPayload<T extends AIOutputSectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIOutputSectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIOutputSectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIOutputSectionGroupByOutputType[P]>
            : GetScalarType<T[P], AIOutputSectionGroupByOutputType[P]>
        }
      >
    >


  export type AIOutputSectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    outputId?: boolean
    sectionKey?: boolean
    heading?: boolean
    order?: boolean
    contentMd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    output?: boolean | AIOutputDefaultArgs<ExtArgs>
    citations?: boolean | AIOutputSection$citationsArgs<ExtArgs>
    _count?: boolean | AIOutputSectionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIOutputSection"]>

  export type AIOutputSectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    outputId?: boolean
    sectionKey?: boolean
    heading?: boolean
    order?: boolean
    contentMd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    output?: boolean | AIOutputDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIOutputSection"]>

  export type AIOutputSectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    outputId?: boolean
    sectionKey?: boolean
    heading?: boolean
    order?: boolean
    contentMd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    output?: boolean | AIOutputDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIOutputSection"]>

  export type AIOutputSectionSelectScalar = {
    id?: boolean
    outputId?: boolean
    sectionKey?: boolean
    heading?: boolean
    order?: boolean
    contentMd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AIOutputSectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "outputId" | "sectionKey" | "heading" | "order" | "contentMd" | "createdAt" | "updatedAt", ExtArgs["result"]["aIOutputSection"]>
  export type AIOutputSectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    output?: boolean | AIOutputDefaultArgs<ExtArgs>
    citations?: boolean | AIOutputSection$citationsArgs<ExtArgs>
    _count?: boolean | AIOutputSectionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AIOutputSectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    output?: boolean | AIOutputDefaultArgs<ExtArgs>
  }
  export type AIOutputSectionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    output?: boolean | AIOutputDefaultArgs<ExtArgs>
  }

  export type $AIOutputSectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIOutputSection"
    objects: {
      output: Prisma.$AIOutputPayload<ExtArgs>
      citations: Prisma.$CitationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      outputId: string
      sectionKey: string
      heading: string | null
      order: number
      contentMd: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["aIOutputSection"]>
    composites: {}
  }

  type AIOutputSectionGetPayload<S extends boolean | null | undefined | AIOutputSectionDefaultArgs> = $Result.GetResult<Prisma.$AIOutputSectionPayload, S>

  type AIOutputSectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AIOutputSectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AIOutputSectionCountAggregateInputType | true
    }

  export interface AIOutputSectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIOutputSection'], meta: { name: 'AIOutputSection' } }
    /**
     * Find zero or one AIOutputSection that matches the filter.
     * @param {AIOutputSectionFindUniqueArgs} args - Arguments to find a AIOutputSection
     * @example
     * // Get one AIOutputSection
     * const aIOutputSection = await prisma.aIOutputSection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIOutputSectionFindUniqueArgs>(args: SelectSubset<T, AIOutputSectionFindUniqueArgs<ExtArgs>>): Prisma__AIOutputSectionClient<$Result.GetResult<Prisma.$AIOutputSectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AIOutputSection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AIOutputSectionFindUniqueOrThrowArgs} args - Arguments to find a AIOutputSection
     * @example
     * // Get one AIOutputSection
     * const aIOutputSection = await prisma.aIOutputSection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIOutputSectionFindUniqueOrThrowArgs>(args: SelectSubset<T, AIOutputSectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIOutputSectionClient<$Result.GetResult<Prisma.$AIOutputSectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIOutputSection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIOutputSectionFindFirstArgs} args - Arguments to find a AIOutputSection
     * @example
     * // Get one AIOutputSection
     * const aIOutputSection = await prisma.aIOutputSection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIOutputSectionFindFirstArgs>(args?: SelectSubset<T, AIOutputSectionFindFirstArgs<ExtArgs>>): Prisma__AIOutputSectionClient<$Result.GetResult<Prisma.$AIOutputSectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIOutputSection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIOutputSectionFindFirstOrThrowArgs} args - Arguments to find a AIOutputSection
     * @example
     * // Get one AIOutputSection
     * const aIOutputSection = await prisma.aIOutputSection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIOutputSectionFindFirstOrThrowArgs>(args?: SelectSubset<T, AIOutputSectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIOutputSectionClient<$Result.GetResult<Prisma.$AIOutputSectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AIOutputSections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIOutputSectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIOutputSections
     * const aIOutputSections = await prisma.aIOutputSection.findMany()
     * 
     * // Get first 10 AIOutputSections
     * const aIOutputSections = await prisma.aIOutputSection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIOutputSectionWithIdOnly = await prisma.aIOutputSection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIOutputSectionFindManyArgs>(args?: SelectSubset<T, AIOutputSectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIOutputSectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AIOutputSection.
     * @param {AIOutputSectionCreateArgs} args - Arguments to create a AIOutputSection.
     * @example
     * // Create one AIOutputSection
     * const AIOutputSection = await prisma.aIOutputSection.create({
     *   data: {
     *     // ... data to create a AIOutputSection
     *   }
     * })
     * 
     */
    create<T extends AIOutputSectionCreateArgs>(args: SelectSubset<T, AIOutputSectionCreateArgs<ExtArgs>>): Prisma__AIOutputSectionClient<$Result.GetResult<Prisma.$AIOutputSectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AIOutputSections.
     * @param {AIOutputSectionCreateManyArgs} args - Arguments to create many AIOutputSections.
     * @example
     * // Create many AIOutputSections
     * const aIOutputSection = await prisma.aIOutputSection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIOutputSectionCreateManyArgs>(args?: SelectSubset<T, AIOutputSectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIOutputSections and returns the data saved in the database.
     * @param {AIOutputSectionCreateManyAndReturnArgs} args - Arguments to create many AIOutputSections.
     * @example
     * // Create many AIOutputSections
     * const aIOutputSection = await prisma.aIOutputSection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIOutputSections and only return the `id`
     * const aIOutputSectionWithIdOnly = await prisma.aIOutputSection.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIOutputSectionCreateManyAndReturnArgs>(args?: SelectSubset<T, AIOutputSectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIOutputSectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AIOutputSection.
     * @param {AIOutputSectionDeleteArgs} args - Arguments to delete one AIOutputSection.
     * @example
     * // Delete one AIOutputSection
     * const AIOutputSection = await prisma.aIOutputSection.delete({
     *   where: {
     *     // ... filter to delete one AIOutputSection
     *   }
     * })
     * 
     */
    delete<T extends AIOutputSectionDeleteArgs>(args: SelectSubset<T, AIOutputSectionDeleteArgs<ExtArgs>>): Prisma__AIOutputSectionClient<$Result.GetResult<Prisma.$AIOutputSectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AIOutputSection.
     * @param {AIOutputSectionUpdateArgs} args - Arguments to update one AIOutputSection.
     * @example
     * // Update one AIOutputSection
     * const aIOutputSection = await prisma.aIOutputSection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIOutputSectionUpdateArgs>(args: SelectSubset<T, AIOutputSectionUpdateArgs<ExtArgs>>): Prisma__AIOutputSectionClient<$Result.GetResult<Prisma.$AIOutputSectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AIOutputSections.
     * @param {AIOutputSectionDeleteManyArgs} args - Arguments to filter AIOutputSections to delete.
     * @example
     * // Delete a few AIOutputSections
     * const { count } = await prisma.aIOutputSection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIOutputSectionDeleteManyArgs>(args?: SelectSubset<T, AIOutputSectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIOutputSections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIOutputSectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIOutputSections
     * const aIOutputSection = await prisma.aIOutputSection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIOutputSectionUpdateManyArgs>(args: SelectSubset<T, AIOutputSectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIOutputSections and returns the data updated in the database.
     * @param {AIOutputSectionUpdateManyAndReturnArgs} args - Arguments to update many AIOutputSections.
     * @example
     * // Update many AIOutputSections
     * const aIOutputSection = await prisma.aIOutputSection.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AIOutputSections and only return the `id`
     * const aIOutputSectionWithIdOnly = await prisma.aIOutputSection.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AIOutputSectionUpdateManyAndReturnArgs>(args: SelectSubset<T, AIOutputSectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIOutputSectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AIOutputSection.
     * @param {AIOutputSectionUpsertArgs} args - Arguments to update or create a AIOutputSection.
     * @example
     * // Update or create a AIOutputSection
     * const aIOutputSection = await prisma.aIOutputSection.upsert({
     *   create: {
     *     // ... data to create a AIOutputSection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIOutputSection we want to update
     *   }
     * })
     */
    upsert<T extends AIOutputSectionUpsertArgs>(args: SelectSubset<T, AIOutputSectionUpsertArgs<ExtArgs>>): Prisma__AIOutputSectionClient<$Result.GetResult<Prisma.$AIOutputSectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AIOutputSections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIOutputSectionCountArgs} args - Arguments to filter AIOutputSections to count.
     * @example
     * // Count the number of AIOutputSections
     * const count = await prisma.aIOutputSection.count({
     *   where: {
     *     // ... the filter for the AIOutputSections we want to count
     *   }
     * })
    **/
    count<T extends AIOutputSectionCountArgs>(
      args?: Subset<T, AIOutputSectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIOutputSectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIOutputSection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIOutputSectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIOutputSectionAggregateArgs>(args: Subset<T, AIOutputSectionAggregateArgs>): Prisma.PrismaPromise<GetAIOutputSectionAggregateType<T>>

    /**
     * Group by AIOutputSection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIOutputSectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIOutputSectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIOutputSectionGroupByArgs['orderBy'] }
        : { orderBy?: AIOutputSectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIOutputSectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIOutputSectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIOutputSection model
   */
  readonly fields: AIOutputSectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIOutputSection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIOutputSectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    output<T extends AIOutputDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AIOutputDefaultArgs<ExtArgs>>): Prisma__AIOutputClient<$Result.GetResult<Prisma.$AIOutputPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    citations<T extends AIOutputSection$citationsArgs<ExtArgs> = {}>(args?: Subset<T, AIOutputSection$citationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIOutputSection model
   */
  interface AIOutputSectionFieldRefs {
    readonly id: FieldRef<"AIOutputSection", 'String'>
    readonly outputId: FieldRef<"AIOutputSection", 'String'>
    readonly sectionKey: FieldRef<"AIOutputSection", 'String'>
    readonly heading: FieldRef<"AIOutputSection", 'String'>
    readonly order: FieldRef<"AIOutputSection", 'Int'>
    readonly contentMd: FieldRef<"AIOutputSection", 'String'>
    readonly createdAt: FieldRef<"AIOutputSection", 'DateTime'>
    readonly updatedAt: FieldRef<"AIOutputSection", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AIOutputSection findUnique
   */
  export type AIOutputSectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIOutputSection
     */
    select?: AIOutputSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIOutputSection
     */
    omit?: AIOutputSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIOutputSectionInclude<ExtArgs> | null
    /**
     * Filter, which AIOutputSection to fetch.
     */
    where: AIOutputSectionWhereUniqueInput
  }

  /**
   * AIOutputSection findUniqueOrThrow
   */
  export type AIOutputSectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIOutputSection
     */
    select?: AIOutputSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIOutputSection
     */
    omit?: AIOutputSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIOutputSectionInclude<ExtArgs> | null
    /**
     * Filter, which AIOutputSection to fetch.
     */
    where: AIOutputSectionWhereUniqueInput
  }

  /**
   * AIOutputSection findFirst
   */
  export type AIOutputSectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIOutputSection
     */
    select?: AIOutputSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIOutputSection
     */
    omit?: AIOutputSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIOutputSectionInclude<ExtArgs> | null
    /**
     * Filter, which AIOutputSection to fetch.
     */
    where?: AIOutputSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIOutputSections to fetch.
     */
    orderBy?: AIOutputSectionOrderByWithRelationInput | AIOutputSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIOutputSections.
     */
    cursor?: AIOutputSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIOutputSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIOutputSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIOutputSections.
     */
    distinct?: AIOutputSectionScalarFieldEnum | AIOutputSectionScalarFieldEnum[]
  }

  /**
   * AIOutputSection findFirstOrThrow
   */
  export type AIOutputSectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIOutputSection
     */
    select?: AIOutputSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIOutputSection
     */
    omit?: AIOutputSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIOutputSectionInclude<ExtArgs> | null
    /**
     * Filter, which AIOutputSection to fetch.
     */
    where?: AIOutputSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIOutputSections to fetch.
     */
    orderBy?: AIOutputSectionOrderByWithRelationInput | AIOutputSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIOutputSections.
     */
    cursor?: AIOutputSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIOutputSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIOutputSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIOutputSections.
     */
    distinct?: AIOutputSectionScalarFieldEnum | AIOutputSectionScalarFieldEnum[]
  }

  /**
   * AIOutputSection findMany
   */
  export type AIOutputSectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIOutputSection
     */
    select?: AIOutputSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIOutputSection
     */
    omit?: AIOutputSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIOutputSectionInclude<ExtArgs> | null
    /**
     * Filter, which AIOutputSections to fetch.
     */
    where?: AIOutputSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIOutputSections to fetch.
     */
    orderBy?: AIOutputSectionOrderByWithRelationInput | AIOutputSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIOutputSections.
     */
    cursor?: AIOutputSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIOutputSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIOutputSections.
     */
    skip?: number
    distinct?: AIOutputSectionScalarFieldEnum | AIOutputSectionScalarFieldEnum[]
  }

  /**
   * AIOutputSection create
   */
  export type AIOutputSectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIOutputSection
     */
    select?: AIOutputSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIOutputSection
     */
    omit?: AIOutputSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIOutputSectionInclude<ExtArgs> | null
    /**
     * The data needed to create a AIOutputSection.
     */
    data: XOR<AIOutputSectionCreateInput, AIOutputSectionUncheckedCreateInput>
  }

  /**
   * AIOutputSection createMany
   */
  export type AIOutputSectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIOutputSections.
     */
    data: AIOutputSectionCreateManyInput | AIOutputSectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIOutputSection createManyAndReturn
   */
  export type AIOutputSectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIOutputSection
     */
    select?: AIOutputSectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIOutputSection
     */
    omit?: AIOutputSectionOmit<ExtArgs> | null
    /**
     * The data used to create many AIOutputSections.
     */
    data: AIOutputSectionCreateManyInput | AIOutputSectionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIOutputSectionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIOutputSection update
   */
  export type AIOutputSectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIOutputSection
     */
    select?: AIOutputSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIOutputSection
     */
    omit?: AIOutputSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIOutputSectionInclude<ExtArgs> | null
    /**
     * The data needed to update a AIOutputSection.
     */
    data: XOR<AIOutputSectionUpdateInput, AIOutputSectionUncheckedUpdateInput>
    /**
     * Choose, which AIOutputSection to update.
     */
    where: AIOutputSectionWhereUniqueInput
  }

  /**
   * AIOutputSection updateMany
   */
  export type AIOutputSectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIOutputSections.
     */
    data: XOR<AIOutputSectionUpdateManyMutationInput, AIOutputSectionUncheckedUpdateManyInput>
    /**
     * Filter which AIOutputSections to update
     */
    where?: AIOutputSectionWhereInput
    /**
     * Limit how many AIOutputSections to update.
     */
    limit?: number
  }

  /**
   * AIOutputSection updateManyAndReturn
   */
  export type AIOutputSectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIOutputSection
     */
    select?: AIOutputSectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIOutputSection
     */
    omit?: AIOutputSectionOmit<ExtArgs> | null
    /**
     * The data used to update AIOutputSections.
     */
    data: XOR<AIOutputSectionUpdateManyMutationInput, AIOutputSectionUncheckedUpdateManyInput>
    /**
     * Filter which AIOutputSections to update
     */
    where?: AIOutputSectionWhereInput
    /**
     * Limit how many AIOutputSections to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIOutputSectionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIOutputSection upsert
   */
  export type AIOutputSectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIOutputSection
     */
    select?: AIOutputSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIOutputSection
     */
    omit?: AIOutputSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIOutputSectionInclude<ExtArgs> | null
    /**
     * The filter to search for the AIOutputSection to update in case it exists.
     */
    where: AIOutputSectionWhereUniqueInput
    /**
     * In case the AIOutputSection found by the `where` argument doesn't exist, create a new AIOutputSection with this data.
     */
    create: XOR<AIOutputSectionCreateInput, AIOutputSectionUncheckedCreateInput>
    /**
     * In case the AIOutputSection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIOutputSectionUpdateInput, AIOutputSectionUncheckedUpdateInput>
  }

  /**
   * AIOutputSection delete
   */
  export type AIOutputSectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIOutputSection
     */
    select?: AIOutputSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIOutputSection
     */
    omit?: AIOutputSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIOutputSectionInclude<ExtArgs> | null
    /**
     * Filter which AIOutputSection to delete.
     */
    where: AIOutputSectionWhereUniqueInput
  }

  /**
   * AIOutputSection deleteMany
   */
  export type AIOutputSectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIOutputSections to delete
     */
    where?: AIOutputSectionWhereInput
    /**
     * Limit how many AIOutputSections to delete.
     */
    limit?: number
  }

  /**
   * AIOutputSection.citations
   */
  export type AIOutputSection$citationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Citation
     */
    select?: CitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Citation
     */
    omit?: CitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CitationInclude<ExtArgs> | null
    where?: CitationWhereInput
    orderBy?: CitationOrderByWithRelationInput | CitationOrderByWithRelationInput[]
    cursor?: CitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CitationScalarFieldEnum | CitationScalarFieldEnum[]
  }

  /**
   * AIOutputSection without action
   */
  export type AIOutputSectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIOutputSection
     */
    select?: AIOutputSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIOutputSection
     */
    omit?: AIOutputSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIOutputSectionInclude<ExtArgs> | null
  }


  /**
   * Model AIOutputScope
   */

  export type AggregateAIOutputScope = {
    _count: AIOutputScopeCountAggregateOutputType | null
    _min: AIOutputScopeMinAggregateOutputType | null
    _max: AIOutputScopeMaxAggregateOutputType | null
  }

  export type AIOutputScopeMinAggregateOutputType = {
    id: string | null
    outputId: string | null
    scopeType: $Enums.AIScopeType | null
    countyId: string | null
    issueId: string | null
    geoZipId: string | null
    districtId: string | null
    customKey: string | null
    createdAt: Date | null
  }

  export type AIOutputScopeMaxAggregateOutputType = {
    id: string | null
    outputId: string | null
    scopeType: $Enums.AIScopeType | null
    countyId: string | null
    issueId: string | null
    geoZipId: string | null
    districtId: string | null
    customKey: string | null
    createdAt: Date | null
  }

  export type AIOutputScopeCountAggregateOutputType = {
    id: number
    outputId: number
    scopeType: number
    countyId: number
    issueId: number
    geoZipId: number
    districtId: number
    customKey: number
    createdAt: number
    _all: number
  }


  export type AIOutputScopeMinAggregateInputType = {
    id?: true
    outputId?: true
    scopeType?: true
    countyId?: true
    issueId?: true
    geoZipId?: true
    districtId?: true
    customKey?: true
    createdAt?: true
  }

  export type AIOutputScopeMaxAggregateInputType = {
    id?: true
    outputId?: true
    scopeType?: true
    countyId?: true
    issueId?: true
    geoZipId?: true
    districtId?: true
    customKey?: true
    createdAt?: true
  }

  export type AIOutputScopeCountAggregateInputType = {
    id?: true
    outputId?: true
    scopeType?: true
    countyId?: true
    issueId?: true
    geoZipId?: true
    districtId?: true
    customKey?: true
    createdAt?: true
    _all?: true
  }

  export type AIOutputScopeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIOutputScope to aggregate.
     */
    where?: AIOutputScopeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIOutputScopes to fetch.
     */
    orderBy?: AIOutputScopeOrderByWithRelationInput | AIOutputScopeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIOutputScopeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIOutputScopes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIOutputScopes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIOutputScopes
    **/
    _count?: true | AIOutputScopeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIOutputScopeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIOutputScopeMaxAggregateInputType
  }

  export type GetAIOutputScopeAggregateType<T extends AIOutputScopeAggregateArgs> = {
        [P in keyof T & keyof AggregateAIOutputScope]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIOutputScope[P]>
      : GetScalarType<T[P], AggregateAIOutputScope[P]>
  }




  export type AIOutputScopeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIOutputScopeWhereInput
    orderBy?: AIOutputScopeOrderByWithAggregationInput | AIOutputScopeOrderByWithAggregationInput[]
    by: AIOutputScopeScalarFieldEnum[] | AIOutputScopeScalarFieldEnum
    having?: AIOutputScopeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIOutputScopeCountAggregateInputType | true
    _min?: AIOutputScopeMinAggregateInputType
    _max?: AIOutputScopeMaxAggregateInputType
  }

  export type AIOutputScopeGroupByOutputType = {
    id: string
    outputId: string
    scopeType: $Enums.AIScopeType
    countyId: string | null
    issueId: string | null
    geoZipId: string | null
    districtId: string | null
    customKey: string | null
    createdAt: Date
    _count: AIOutputScopeCountAggregateOutputType | null
    _min: AIOutputScopeMinAggregateOutputType | null
    _max: AIOutputScopeMaxAggregateOutputType | null
  }

  type GetAIOutputScopeGroupByPayload<T extends AIOutputScopeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIOutputScopeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIOutputScopeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIOutputScopeGroupByOutputType[P]>
            : GetScalarType<T[P], AIOutputScopeGroupByOutputType[P]>
        }
      >
    >


  export type AIOutputScopeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    outputId?: boolean
    scopeType?: boolean
    countyId?: boolean
    issueId?: boolean
    geoZipId?: boolean
    districtId?: boolean
    customKey?: boolean
    createdAt?: boolean
    output?: boolean | AIOutputDefaultArgs<ExtArgs>
    county?: boolean | AIOutputScope$countyArgs<ExtArgs>
    issue?: boolean | AIOutputScope$issueArgs<ExtArgs>
    geoZip?: boolean | AIOutputScope$geoZipArgs<ExtArgs>
    district?: boolean | AIOutputScope$districtArgs<ExtArgs>
  }, ExtArgs["result"]["aIOutputScope"]>

  export type AIOutputScopeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    outputId?: boolean
    scopeType?: boolean
    countyId?: boolean
    issueId?: boolean
    geoZipId?: boolean
    districtId?: boolean
    customKey?: boolean
    createdAt?: boolean
    output?: boolean | AIOutputDefaultArgs<ExtArgs>
    county?: boolean | AIOutputScope$countyArgs<ExtArgs>
    issue?: boolean | AIOutputScope$issueArgs<ExtArgs>
    geoZip?: boolean | AIOutputScope$geoZipArgs<ExtArgs>
    district?: boolean | AIOutputScope$districtArgs<ExtArgs>
  }, ExtArgs["result"]["aIOutputScope"]>

  export type AIOutputScopeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    outputId?: boolean
    scopeType?: boolean
    countyId?: boolean
    issueId?: boolean
    geoZipId?: boolean
    districtId?: boolean
    customKey?: boolean
    createdAt?: boolean
    output?: boolean | AIOutputDefaultArgs<ExtArgs>
    county?: boolean | AIOutputScope$countyArgs<ExtArgs>
    issue?: boolean | AIOutputScope$issueArgs<ExtArgs>
    geoZip?: boolean | AIOutputScope$geoZipArgs<ExtArgs>
    district?: boolean | AIOutputScope$districtArgs<ExtArgs>
  }, ExtArgs["result"]["aIOutputScope"]>

  export type AIOutputScopeSelectScalar = {
    id?: boolean
    outputId?: boolean
    scopeType?: boolean
    countyId?: boolean
    issueId?: boolean
    geoZipId?: boolean
    districtId?: boolean
    customKey?: boolean
    createdAt?: boolean
  }

  export type AIOutputScopeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "outputId" | "scopeType" | "countyId" | "issueId" | "geoZipId" | "districtId" | "customKey" | "createdAt", ExtArgs["result"]["aIOutputScope"]>
  export type AIOutputScopeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    output?: boolean | AIOutputDefaultArgs<ExtArgs>
    county?: boolean | AIOutputScope$countyArgs<ExtArgs>
    issue?: boolean | AIOutputScope$issueArgs<ExtArgs>
    geoZip?: boolean | AIOutputScope$geoZipArgs<ExtArgs>
    district?: boolean | AIOutputScope$districtArgs<ExtArgs>
  }
  export type AIOutputScopeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    output?: boolean | AIOutputDefaultArgs<ExtArgs>
    county?: boolean | AIOutputScope$countyArgs<ExtArgs>
    issue?: boolean | AIOutputScope$issueArgs<ExtArgs>
    geoZip?: boolean | AIOutputScope$geoZipArgs<ExtArgs>
    district?: boolean | AIOutputScope$districtArgs<ExtArgs>
  }
  export type AIOutputScopeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    output?: boolean | AIOutputDefaultArgs<ExtArgs>
    county?: boolean | AIOutputScope$countyArgs<ExtArgs>
    issue?: boolean | AIOutputScope$issueArgs<ExtArgs>
    geoZip?: boolean | AIOutputScope$geoZipArgs<ExtArgs>
    district?: boolean | AIOutputScope$districtArgs<ExtArgs>
  }

  export type $AIOutputScopePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIOutputScope"
    objects: {
      output: Prisma.$AIOutputPayload<ExtArgs>
      county: Prisma.$CountyPayload<ExtArgs> | null
      issue: Prisma.$IssuePayload<ExtArgs> | null
      geoZip: Prisma.$GeoZipPayload<ExtArgs> | null
      district: Prisma.$GeoDistrictPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      outputId: string
      scopeType: $Enums.AIScopeType
      countyId: string | null
      issueId: string | null
      geoZipId: string | null
      districtId: string | null
      customKey: string | null
      createdAt: Date
    }, ExtArgs["result"]["aIOutputScope"]>
    composites: {}
  }

  type AIOutputScopeGetPayload<S extends boolean | null | undefined | AIOutputScopeDefaultArgs> = $Result.GetResult<Prisma.$AIOutputScopePayload, S>

  type AIOutputScopeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AIOutputScopeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AIOutputScopeCountAggregateInputType | true
    }

  export interface AIOutputScopeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIOutputScope'], meta: { name: 'AIOutputScope' } }
    /**
     * Find zero or one AIOutputScope that matches the filter.
     * @param {AIOutputScopeFindUniqueArgs} args - Arguments to find a AIOutputScope
     * @example
     * // Get one AIOutputScope
     * const aIOutputScope = await prisma.aIOutputScope.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIOutputScopeFindUniqueArgs>(args: SelectSubset<T, AIOutputScopeFindUniqueArgs<ExtArgs>>): Prisma__AIOutputScopeClient<$Result.GetResult<Prisma.$AIOutputScopePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AIOutputScope that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AIOutputScopeFindUniqueOrThrowArgs} args - Arguments to find a AIOutputScope
     * @example
     * // Get one AIOutputScope
     * const aIOutputScope = await prisma.aIOutputScope.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIOutputScopeFindUniqueOrThrowArgs>(args: SelectSubset<T, AIOutputScopeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIOutputScopeClient<$Result.GetResult<Prisma.$AIOutputScopePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIOutputScope that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIOutputScopeFindFirstArgs} args - Arguments to find a AIOutputScope
     * @example
     * // Get one AIOutputScope
     * const aIOutputScope = await prisma.aIOutputScope.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIOutputScopeFindFirstArgs>(args?: SelectSubset<T, AIOutputScopeFindFirstArgs<ExtArgs>>): Prisma__AIOutputScopeClient<$Result.GetResult<Prisma.$AIOutputScopePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIOutputScope that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIOutputScopeFindFirstOrThrowArgs} args - Arguments to find a AIOutputScope
     * @example
     * // Get one AIOutputScope
     * const aIOutputScope = await prisma.aIOutputScope.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIOutputScopeFindFirstOrThrowArgs>(args?: SelectSubset<T, AIOutputScopeFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIOutputScopeClient<$Result.GetResult<Prisma.$AIOutputScopePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AIOutputScopes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIOutputScopeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIOutputScopes
     * const aIOutputScopes = await prisma.aIOutputScope.findMany()
     * 
     * // Get first 10 AIOutputScopes
     * const aIOutputScopes = await prisma.aIOutputScope.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIOutputScopeWithIdOnly = await prisma.aIOutputScope.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIOutputScopeFindManyArgs>(args?: SelectSubset<T, AIOutputScopeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIOutputScopePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AIOutputScope.
     * @param {AIOutputScopeCreateArgs} args - Arguments to create a AIOutputScope.
     * @example
     * // Create one AIOutputScope
     * const AIOutputScope = await prisma.aIOutputScope.create({
     *   data: {
     *     // ... data to create a AIOutputScope
     *   }
     * })
     * 
     */
    create<T extends AIOutputScopeCreateArgs>(args: SelectSubset<T, AIOutputScopeCreateArgs<ExtArgs>>): Prisma__AIOutputScopeClient<$Result.GetResult<Prisma.$AIOutputScopePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AIOutputScopes.
     * @param {AIOutputScopeCreateManyArgs} args - Arguments to create many AIOutputScopes.
     * @example
     * // Create many AIOutputScopes
     * const aIOutputScope = await prisma.aIOutputScope.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIOutputScopeCreateManyArgs>(args?: SelectSubset<T, AIOutputScopeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIOutputScopes and returns the data saved in the database.
     * @param {AIOutputScopeCreateManyAndReturnArgs} args - Arguments to create many AIOutputScopes.
     * @example
     * // Create many AIOutputScopes
     * const aIOutputScope = await prisma.aIOutputScope.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIOutputScopes and only return the `id`
     * const aIOutputScopeWithIdOnly = await prisma.aIOutputScope.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIOutputScopeCreateManyAndReturnArgs>(args?: SelectSubset<T, AIOutputScopeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIOutputScopePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AIOutputScope.
     * @param {AIOutputScopeDeleteArgs} args - Arguments to delete one AIOutputScope.
     * @example
     * // Delete one AIOutputScope
     * const AIOutputScope = await prisma.aIOutputScope.delete({
     *   where: {
     *     // ... filter to delete one AIOutputScope
     *   }
     * })
     * 
     */
    delete<T extends AIOutputScopeDeleteArgs>(args: SelectSubset<T, AIOutputScopeDeleteArgs<ExtArgs>>): Prisma__AIOutputScopeClient<$Result.GetResult<Prisma.$AIOutputScopePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AIOutputScope.
     * @param {AIOutputScopeUpdateArgs} args - Arguments to update one AIOutputScope.
     * @example
     * // Update one AIOutputScope
     * const aIOutputScope = await prisma.aIOutputScope.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIOutputScopeUpdateArgs>(args: SelectSubset<T, AIOutputScopeUpdateArgs<ExtArgs>>): Prisma__AIOutputScopeClient<$Result.GetResult<Prisma.$AIOutputScopePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AIOutputScopes.
     * @param {AIOutputScopeDeleteManyArgs} args - Arguments to filter AIOutputScopes to delete.
     * @example
     * // Delete a few AIOutputScopes
     * const { count } = await prisma.aIOutputScope.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIOutputScopeDeleteManyArgs>(args?: SelectSubset<T, AIOutputScopeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIOutputScopes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIOutputScopeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIOutputScopes
     * const aIOutputScope = await prisma.aIOutputScope.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIOutputScopeUpdateManyArgs>(args: SelectSubset<T, AIOutputScopeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIOutputScopes and returns the data updated in the database.
     * @param {AIOutputScopeUpdateManyAndReturnArgs} args - Arguments to update many AIOutputScopes.
     * @example
     * // Update many AIOutputScopes
     * const aIOutputScope = await prisma.aIOutputScope.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AIOutputScopes and only return the `id`
     * const aIOutputScopeWithIdOnly = await prisma.aIOutputScope.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AIOutputScopeUpdateManyAndReturnArgs>(args: SelectSubset<T, AIOutputScopeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIOutputScopePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AIOutputScope.
     * @param {AIOutputScopeUpsertArgs} args - Arguments to update or create a AIOutputScope.
     * @example
     * // Update or create a AIOutputScope
     * const aIOutputScope = await prisma.aIOutputScope.upsert({
     *   create: {
     *     // ... data to create a AIOutputScope
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIOutputScope we want to update
     *   }
     * })
     */
    upsert<T extends AIOutputScopeUpsertArgs>(args: SelectSubset<T, AIOutputScopeUpsertArgs<ExtArgs>>): Prisma__AIOutputScopeClient<$Result.GetResult<Prisma.$AIOutputScopePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AIOutputScopes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIOutputScopeCountArgs} args - Arguments to filter AIOutputScopes to count.
     * @example
     * // Count the number of AIOutputScopes
     * const count = await prisma.aIOutputScope.count({
     *   where: {
     *     // ... the filter for the AIOutputScopes we want to count
     *   }
     * })
    **/
    count<T extends AIOutputScopeCountArgs>(
      args?: Subset<T, AIOutputScopeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIOutputScopeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIOutputScope.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIOutputScopeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIOutputScopeAggregateArgs>(args: Subset<T, AIOutputScopeAggregateArgs>): Prisma.PrismaPromise<GetAIOutputScopeAggregateType<T>>

    /**
     * Group by AIOutputScope.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIOutputScopeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIOutputScopeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIOutputScopeGroupByArgs['orderBy'] }
        : { orderBy?: AIOutputScopeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIOutputScopeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIOutputScopeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIOutputScope model
   */
  readonly fields: AIOutputScopeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIOutputScope.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIOutputScopeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    output<T extends AIOutputDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AIOutputDefaultArgs<ExtArgs>>): Prisma__AIOutputClient<$Result.GetResult<Prisma.$AIOutputPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    county<T extends AIOutputScope$countyArgs<ExtArgs> = {}>(args?: Subset<T, AIOutputScope$countyArgs<ExtArgs>>): Prisma__CountyClient<$Result.GetResult<Prisma.$CountyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    issue<T extends AIOutputScope$issueArgs<ExtArgs> = {}>(args?: Subset<T, AIOutputScope$issueArgs<ExtArgs>>): Prisma__IssueClient<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    geoZip<T extends AIOutputScope$geoZipArgs<ExtArgs> = {}>(args?: Subset<T, AIOutputScope$geoZipArgs<ExtArgs>>): Prisma__GeoZipClient<$Result.GetResult<Prisma.$GeoZipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    district<T extends AIOutputScope$districtArgs<ExtArgs> = {}>(args?: Subset<T, AIOutputScope$districtArgs<ExtArgs>>): Prisma__GeoDistrictClient<$Result.GetResult<Prisma.$GeoDistrictPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIOutputScope model
   */
  interface AIOutputScopeFieldRefs {
    readonly id: FieldRef<"AIOutputScope", 'String'>
    readonly outputId: FieldRef<"AIOutputScope", 'String'>
    readonly scopeType: FieldRef<"AIOutputScope", 'AIScopeType'>
    readonly countyId: FieldRef<"AIOutputScope", 'String'>
    readonly issueId: FieldRef<"AIOutputScope", 'String'>
    readonly geoZipId: FieldRef<"AIOutputScope", 'String'>
    readonly districtId: FieldRef<"AIOutputScope", 'String'>
    readonly customKey: FieldRef<"AIOutputScope", 'String'>
    readonly createdAt: FieldRef<"AIOutputScope", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AIOutputScope findUnique
   */
  export type AIOutputScopeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIOutputScope
     */
    select?: AIOutputScopeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIOutputScope
     */
    omit?: AIOutputScopeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIOutputScopeInclude<ExtArgs> | null
    /**
     * Filter, which AIOutputScope to fetch.
     */
    where: AIOutputScopeWhereUniqueInput
  }

  /**
   * AIOutputScope findUniqueOrThrow
   */
  export type AIOutputScopeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIOutputScope
     */
    select?: AIOutputScopeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIOutputScope
     */
    omit?: AIOutputScopeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIOutputScopeInclude<ExtArgs> | null
    /**
     * Filter, which AIOutputScope to fetch.
     */
    where: AIOutputScopeWhereUniqueInput
  }

  /**
   * AIOutputScope findFirst
   */
  export type AIOutputScopeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIOutputScope
     */
    select?: AIOutputScopeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIOutputScope
     */
    omit?: AIOutputScopeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIOutputScopeInclude<ExtArgs> | null
    /**
     * Filter, which AIOutputScope to fetch.
     */
    where?: AIOutputScopeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIOutputScopes to fetch.
     */
    orderBy?: AIOutputScopeOrderByWithRelationInput | AIOutputScopeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIOutputScopes.
     */
    cursor?: AIOutputScopeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIOutputScopes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIOutputScopes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIOutputScopes.
     */
    distinct?: AIOutputScopeScalarFieldEnum | AIOutputScopeScalarFieldEnum[]
  }

  /**
   * AIOutputScope findFirstOrThrow
   */
  export type AIOutputScopeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIOutputScope
     */
    select?: AIOutputScopeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIOutputScope
     */
    omit?: AIOutputScopeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIOutputScopeInclude<ExtArgs> | null
    /**
     * Filter, which AIOutputScope to fetch.
     */
    where?: AIOutputScopeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIOutputScopes to fetch.
     */
    orderBy?: AIOutputScopeOrderByWithRelationInput | AIOutputScopeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIOutputScopes.
     */
    cursor?: AIOutputScopeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIOutputScopes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIOutputScopes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIOutputScopes.
     */
    distinct?: AIOutputScopeScalarFieldEnum | AIOutputScopeScalarFieldEnum[]
  }

  /**
   * AIOutputScope findMany
   */
  export type AIOutputScopeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIOutputScope
     */
    select?: AIOutputScopeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIOutputScope
     */
    omit?: AIOutputScopeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIOutputScopeInclude<ExtArgs> | null
    /**
     * Filter, which AIOutputScopes to fetch.
     */
    where?: AIOutputScopeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIOutputScopes to fetch.
     */
    orderBy?: AIOutputScopeOrderByWithRelationInput | AIOutputScopeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIOutputScopes.
     */
    cursor?: AIOutputScopeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIOutputScopes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIOutputScopes.
     */
    skip?: number
    distinct?: AIOutputScopeScalarFieldEnum | AIOutputScopeScalarFieldEnum[]
  }

  /**
   * AIOutputScope create
   */
  export type AIOutputScopeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIOutputScope
     */
    select?: AIOutputScopeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIOutputScope
     */
    omit?: AIOutputScopeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIOutputScopeInclude<ExtArgs> | null
    /**
     * The data needed to create a AIOutputScope.
     */
    data: XOR<AIOutputScopeCreateInput, AIOutputScopeUncheckedCreateInput>
  }

  /**
   * AIOutputScope createMany
   */
  export type AIOutputScopeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIOutputScopes.
     */
    data: AIOutputScopeCreateManyInput | AIOutputScopeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIOutputScope createManyAndReturn
   */
  export type AIOutputScopeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIOutputScope
     */
    select?: AIOutputScopeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIOutputScope
     */
    omit?: AIOutputScopeOmit<ExtArgs> | null
    /**
     * The data used to create many AIOutputScopes.
     */
    data: AIOutputScopeCreateManyInput | AIOutputScopeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIOutputScopeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIOutputScope update
   */
  export type AIOutputScopeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIOutputScope
     */
    select?: AIOutputScopeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIOutputScope
     */
    omit?: AIOutputScopeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIOutputScopeInclude<ExtArgs> | null
    /**
     * The data needed to update a AIOutputScope.
     */
    data: XOR<AIOutputScopeUpdateInput, AIOutputScopeUncheckedUpdateInput>
    /**
     * Choose, which AIOutputScope to update.
     */
    where: AIOutputScopeWhereUniqueInput
  }

  /**
   * AIOutputScope updateMany
   */
  export type AIOutputScopeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIOutputScopes.
     */
    data: XOR<AIOutputScopeUpdateManyMutationInput, AIOutputScopeUncheckedUpdateManyInput>
    /**
     * Filter which AIOutputScopes to update
     */
    where?: AIOutputScopeWhereInput
    /**
     * Limit how many AIOutputScopes to update.
     */
    limit?: number
  }

  /**
   * AIOutputScope updateManyAndReturn
   */
  export type AIOutputScopeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIOutputScope
     */
    select?: AIOutputScopeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIOutputScope
     */
    omit?: AIOutputScopeOmit<ExtArgs> | null
    /**
     * The data used to update AIOutputScopes.
     */
    data: XOR<AIOutputScopeUpdateManyMutationInput, AIOutputScopeUncheckedUpdateManyInput>
    /**
     * Filter which AIOutputScopes to update
     */
    where?: AIOutputScopeWhereInput
    /**
     * Limit how many AIOutputScopes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIOutputScopeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIOutputScope upsert
   */
  export type AIOutputScopeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIOutputScope
     */
    select?: AIOutputScopeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIOutputScope
     */
    omit?: AIOutputScopeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIOutputScopeInclude<ExtArgs> | null
    /**
     * The filter to search for the AIOutputScope to update in case it exists.
     */
    where: AIOutputScopeWhereUniqueInput
    /**
     * In case the AIOutputScope found by the `where` argument doesn't exist, create a new AIOutputScope with this data.
     */
    create: XOR<AIOutputScopeCreateInput, AIOutputScopeUncheckedCreateInput>
    /**
     * In case the AIOutputScope was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIOutputScopeUpdateInput, AIOutputScopeUncheckedUpdateInput>
  }

  /**
   * AIOutputScope delete
   */
  export type AIOutputScopeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIOutputScope
     */
    select?: AIOutputScopeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIOutputScope
     */
    omit?: AIOutputScopeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIOutputScopeInclude<ExtArgs> | null
    /**
     * Filter which AIOutputScope to delete.
     */
    where: AIOutputScopeWhereUniqueInput
  }

  /**
   * AIOutputScope deleteMany
   */
  export type AIOutputScopeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIOutputScopes to delete
     */
    where?: AIOutputScopeWhereInput
    /**
     * Limit how many AIOutputScopes to delete.
     */
    limit?: number
  }

  /**
   * AIOutputScope.county
   */
  export type AIOutputScope$countyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the County
     */
    select?: CountySelect<ExtArgs> | null
    /**
     * Omit specific fields from the County
     */
    omit?: CountyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountyInclude<ExtArgs> | null
    where?: CountyWhereInput
  }

  /**
   * AIOutputScope.issue
   */
  export type AIOutputScope$issueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Issue
     */
    omit?: IssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueInclude<ExtArgs> | null
    where?: IssueWhereInput
  }

  /**
   * AIOutputScope.geoZip
   */
  export type AIOutputScope$geoZipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoZip
     */
    select?: GeoZipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeoZip
     */
    omit?: GeoZipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeoZipInclude<ExtArgs> | null
    where?: GeoZipWhereInput
  }

  /**
   * AIOutputScope.district
   */
  export type AIOutputScope$districtArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeoDistrict
     */
    select?: GeoDistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeoDistrict
     */
    omit?: GeoDistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeoDistrictInclude<ExtArgs> | null
    where?: GeoDistrictWhereInput
  }

  /**
   * AIOutputScope without action
   */
  export type AIOutputScopeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIOutputScope
     */
    select?: AIOutputScopeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIOutputScope
     */
    omit?: AIOutputScopeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIOutputScopeInclude<ExtArgs> | null
  }


  /**
   * Model Citation
   */

  export type AggregateCitation = {
    _count: CitationCountAggregateOutputType | null
    _min: CitationMinAggregateOutputType | null
    _max: CitationMaxAggregateOutputType | null
  }

  export type CitationMinAggregateOutputType = {
    id: string | null
    outputSectionId: string | null
    sourceChunkId: string | null
    sourceDocumentId: string | null
    label: string | null
    createdAt: Date | null
  }

  export type CitationMaxAggregateOutputType = {
    id: string | null
    outputSectionId: string | null
    sourceChunkId: string | null
    sourceDocumentId: string | null
    label: string | null
    createdAt: Date | null
  }

  export type CitationCountAggregateOutputType = {
    id: number
    outputSectionId: number
    sourceChunkId: number
    sourceDocumentId: number
    label: number
    locatorJson: number
    createdAt: number
    _all: number
  }


  export type CitationMinAggregateInputType = {
    id?: true
    outputSectionId?: true
    sourceChunkId?: true
    sourceDocumentId?: true
    label?: true
    createdAt?: true
  }

  export type CitationMaxAggregateInputType = {
    id?: true
    outputSectionId?: true
    sourceChunkId?: true
    sourceDocumentId?: true
    label?: true
    createdAt?: true
  }

  export type CitationCountAggregateInputType = {
    id?: true
    outputSectionId?: true
    sourceChunkId?: true
    sourceDocumentId?: true
    label?: true
    locatorJson?: true
    createdAt?: true
    _all?: true
  }

  export type CitationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Citation to aggregate.
     */
    where?: CitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Citations to fetch.
     */
    orderBy?: CitationOrderByWithRelationInput | CitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Citations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Citations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Citations
    **/
    _count?: true | CitationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CitationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CitationMaxAggregateInputType
  }

  export type GetCitationAggregateType<T extends CitationAggregateArgs> = {
        [P in keyof T & keyof AggregateCitation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCitation[P]>
      : GetScalarType<T[P], AggregateCitation[P]>
  }




  export type CitationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CitationWhereInput
    orderBy?: CitationOrderByWithAggregationInput | CitationOrderByWithAggregationInput[]
    by: CitationScalarFieldEnum[] | CitationScalarFieldEnum
    having?: CitationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CitationCountAggregateInputType | true
    _min?: CitationMinAggregateInputType
    _max?: CitationMaxAggregateInputType
  }

  export type CitationGroupByOutputType = {
    id: string
    outputSectionId: string
    sourceChunkId: string | null
    sourceDocumentId: string | null
    label: string | null
    locatorJson: JsonValue | null
    createdAt: Date
    _count: CitationCountAggregateOutputType | null
    _min: CitationMinAggregateOutputType | null
    _max: CitationMaxAggregateOutputType | null
  }

  type GetCitationGroupByPayload<T extends CitationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CitationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CitationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CitationGroupByOutputType[P]>
            : GetScalarType<T[P], CitationGroupByOutputType[P]>
        }
      >
    >


  export type CitationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    outputSectionId?: boolean
    sourceChunkId?: boolean
    sourceDocumentId?: boolean
    label?: boolean
    locatorJson?: boolean
    createdAt?: boolean
    outputSection?: boolean | AIOutputSectionDefaultArgs<ExtArgs>
    sourceChunk?: boolean | Citation$sourceChunkArgs<ExtArgs>
    sourceDocument?: boolean | Citation$sourceDocumentArgs<ExtArgs>
  }, ExtArgs["result"]["citation"]>

  export type CitationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    outputSectionId?: boolean
    sourceChunkId?: boolean
    sourceDocumentId?: boolean
    label?: boolean
    locatorJson?: boolean
    createdAt?: boolean
    outputSection?: boolean | AIOutputSectionDefaultArgs<ExtArgs>
    sourceChunk?: boolean | Citation$sourceChunkArgs<ExtArgs>
    sourceDocument?: boolean | Citation$sourceDocumentArgs<ExtArgs>
  }, ExtArgs["result"]["citation"]>

  export type CitationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    outputSectionId?: boolean
    sourceChunkId?: boolean
    sourceDocumentId?: boolean
    label?: boolean
    locatorJson?: boolean
    createdAt?: boolean
    outputSection?: boolean | AIOutputSectionDefaultArgs<ExtArgs>
    sourceChunk?: boolean | Citation$sourceChunkArgs<ExtArgs>
    sourceDocument?: boolean | Citation$sourceDocumentArgs<ExtArgs>
  }, ExtArgs["result"]["citation"]>

  export type CitationSelectScalar = {
    id?: boolean
    outputSectionId?: boolean
    sourceChunkId?: boolean
    sourceDocumentId?: boolean
    label?: boolean
    locatorJson?: boolean
    createdAt?: boolean
  }

  export type CitationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "outputSectionId" | "sourceChunkId" | "sourceDocumentId" | "label" | "locatorJson" | "createdAt", ExtArgs["result"]["citation"]>
  export type CitationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    outputSection?: boolean | AIOutputSectionDefaultArgs<ExtArgs>
    sourceChunk?: boolean | Citation$sourceChunkArgs<ExtArgs>
    sourceDocument?: boolean | Citation$sourceDocumentArgs<ExtArgs>
  }
  export type CitationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    outputSection?: boolean | AIOutputSectionDefaultArgs<ExtArgs>
    sourceChunk?: boolean | Citation$sourceChunkArgs<ExtArgs>
    sourceDocument?: boolean | Citation$sourceDocumentArgs<ExtArgs>
  }
  export type CitationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    outputSection?: boolean | AIOutputSectionDefaultArgs<ExtArgs>
    sourceChunk?: boolean | Citation$sourceChunkArgs<ExtArgs>
    sourceDocument?: boolean | Citation$sourceDocumentArgs<ExtArgs>
  }

  export type $CitationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Citation"
    objects: {
      outputSection: Prisma.$AIOutputSectionPayload<ExtArgs>
      sourceChunk: Prisma.$SourceChunkPayload<ExtArgs> | null
      sourceDocument: Prisma.$SourceDocumentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      outputSectionId: string
      sourceChunkId: string | null
      sourceDocumentId: string | null
      label: string | null
      locatorJson: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["citation"]>
    composites: {}
  }

  type CitationGetPayload<S extends boolean | null | undefined | CitationDefaultArgs> = $Result.GetResult<Prisma.$CitationPayload, S>

  type CitationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CitationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CitationCountAggregateInputType | true
    }

  export interface CitationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Citation'], meta: { name: 'Citation' } }
    /**
     * Find zero or one Citation that matches the filter.
     * @param {CitationFindUniqueArgs} args - Arguments to find a Citation
     * @example
     * // Get one Citation
     * const citation = await prisma.citation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CitationFindUniqueArgs>(args: SelectSubset<T, CitationFindUniqueArgs<ExtArgs>>): Prisma__CitationClient<$Result.GetResult<Prisma.$CitationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Citation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CitationFindUniqueOrThrowArgs} args - Arguments to find a Citation
     * @example
     * // Get one Citation
     * const citation = await prisma.citation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CitationFindUniqueOrThrowArgs>(args: SelectSubset<T, CitationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CitationClient<$Result.GetResult<Prisma.$CitationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Citation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CitationFindFirstArgs} args - Arguments to find a Citation
     * @example
     * // Get one Citation
     * const citation = await prisma.citation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CitationFindFirstArgs>(args?: SelectSubset<T, CitationFindFirstArgs<ExtArgs>>): Prisma__CitationClient<$Result.GetResult<Prisma.$CitationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Citation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CitationFindFirstOrThrowArgs} args - Arguments to find a Citation
     * @example
     * // Get one Citation
     * const citation = await prisma.citation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CitationFindFirstOrThrowArgs>(args?: SelectSubset<T, CitationFindFirstOrThrowArgs<ExtArgs>>): Prisma__CitationClient<$Result.GetResult<Prisma.$CitationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Citations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CitationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Citations
     * const citations = await prisma.citation.findMany()
     * 
     * // Get first 10 Citations
     * const citations = await prisma.citation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const citationWithIdOnly = await prisma.citation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CitationFindManyArgs>(args?: SelectSubset<T, CitationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Citation.
     * @param {CitationCreateArgs} args - Arguments to create a Citation.
     * @example
     * // Create one Citation
     * const Citation = await prisma.citation.create({
     *   data: {
     *     // ... data to create a Citation
     *   }
     * })
     * 
     */
    create<T extends CitationCreateArgs>(args: SelectSubset<T, CitationCreateArgs<ExtArgs>>): Prisma__CitationClient<$Result.GetResult<Prisma.$CitationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Citations.
     * @param {CitationCreateManyArgs} args - Arguments to create many Citations.
     * @example
     * // Create many Citations
     * const citation = await prisma.citation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CitationCreateManyArgs>(args?: SelectSubset<T, CitationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Citations and returns the data saved in the database.
     * @param {CitationCreateManyAndReturnArgs} args - Arguments to create many Citations.
     * @example
     * // Create many Citations
     * const citation = await prisma.citation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Citations and only return the `id`
     * const citationWithIdOnly = await prisma.citation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CitationCreateManyAndReturnArgs>(args?: SelectSubset<T, CitationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CitationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Citation.
     * @param {CitationDeleteArgs} args - Arguments to delete one Citation.
     * @example
     * // Delete one Citation
     * const Citation = await prisma.citation.delete({
     *   where: {
     *     // ... filter to delete one Citation
     *   }
     * })
     * 
     */
    delete<T extends CitationDeleteArgs>(args: SelectSubset<T, CitationDeleteArgs<ExtArgs>>): Prisma__CitationClient<$Result.GetResult<Prisma.$CitationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Citation.
     * @param {CitationUpdateArgs} args - Arguments to update one Citation.
     * @example
     * // Update one Citation
     * const citation = await prisma.citation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CitationUpdateArgs>(args: SelectSubset<T, CitationUpdateArgs<ExtArgs>>): Prisma__CitationClient<$Result.GetResult<Prisma.$CitationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Citations.
     * @param {CitationDeleteManyArgs} args - Arguments to filter Citations to delete.
     * @example
     * // Delete a few Citations
     * const { count } = await prisma.citation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CitationDeleteManyArgs>(args?: SelectSubset<T, CitationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Citations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CitationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Citations
     * const citation = await prisma.citation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CitationUpdateManyArgs>(args: SelectSubset<T, CitationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Citations and returns the data updated in the database.
     * @param {CitationUpdateManyAndReturnArgs} args - Arguments to update many Citations.
     * @example
     * // Update many Citations
     * const citation = await prisma.citation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Citations and only return the `id`
     * const citationWithIdOnly = await prisma.citation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CitationUpdateManyAndReturnArgs>(args: SelectSubset<T, CitationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CitationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Citation.
     * @param {CitationUpsertArgs} args - Arguments to update or create a Citation.
     * @example
     * // Update or create a Citation
     * const citation = await prisma.citation.upsert({
     *   create: {
     *     // ... data to create a Citation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Citation we want to update
     *   }
     * })
     */
    upsert<T extends CitationUpsertArgs>(args: SelectSubset<T, CitationUpsertArgs<ExtArgs>>): Prisma__CitationClient<$Result.GetResult<Prisma.$CitationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Citations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CitationCountArgs} args - Arguments to filter Citations to count.
     * @example
     * // Count the number of Citations
     * const count = await prisma.citation.count({
     *   where: {
     *     // ... the filter for the Citations we want to count
     *   }
     * })
    **/
    count<T extends CitationCountArgs>(
      args?: Subset<T, CitationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CitationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Citation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CitationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CitationAggregateArgs>(args: Subset<T, CitationAggregateArgs>): Prisma.PrismaPromise<GetCitationAggregateType<T>>

    /**
     * Group by Citation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CitationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CitationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CitationGroupByArgs['orderBy'] }
        : { orderBy?: CitationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CitationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCitationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Citation model
   */
  readonly fields: CitationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Citation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CitationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    outputSection<T extends AIOutputSectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AIOutputSectionDefaultArgs<ExtArgs>>): Prisma__AIOutputSectionClient<$Result.GetResult<Prisma.$AIOutputSectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sourceChunk<T extends Citation$sourceChunkArgs<ExtArgs> = {}>(args?: Subset<T, Citation$sourceChunkArgs<ExtArgs>>): Prisma__SourceChunkClient<$Result.GetResult<Prisma.$SourceChunkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sourceDocument<T extends Citation$sourceDocumentArgs<ExtArgs> = {}>(args?: Subset<T, Citation$sourceDocumentArgs<ExtArgs>>): Prisma__SourceDocumentClient<$Result.GetResult<Prisma.$SourceDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Citation model
   */
  interface CitationFieldRefs {
    readonly id: FieldRef<"Citation", 'String'>
    readonly outputSectionId: FieldRef<"Citation", 'String'>
    readonly sourceChunkId: FieldRef<"Citation", 'String'>
    readonly sourceDocumentId: FieldRef<"Citation", 'String'>
    readonly label: FieldRef<"Citation", 'String'>
    readonly locatorJson: FieldRef<"Citation", 'Json'>
    readonly createdAt: FieldRef<"Citation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Citation findUnique
   */
  export type CitationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Citation
     */
    select?: CitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Citation
     */
    omit?: CitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CitationInclude<ExtArgs> | null
    /**
     * Filter, which Citation to fetch.
     */
    where: CitationWhereUniqueInput
  }

  /**
   * Citation findUniqueOrThrow
   */
  export type CitationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Citation
     */
    select?: CitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Citation
     */
    omit?: CitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CitationInclude<ExtArgs> | null
    /**
     * Filter, which Citation to fetch.
     */
    where: CitationWhereUniqueInput
  }

  /**
   * Citation findFirst
   */
  export type CitationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Citation
     */
    select?: CitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Citation
     */
    omit?: CitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CitationInclude<ExtArgs> | null
    /**
     * Filter, which Citation to fetch.
     */
    where?: CitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Citations to fetch.
     */
    orderBy?: CitationOrderByWithRelationInput | CitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Citations.
     */
    cursor?: CitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Citations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Citations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Citations.
     */
    distinct?: CitationScalarFieldEnum | CitationScalarFieldEnum[]
  }

  /**
   * Citation findFirstOrThrow
   */
  export type CitationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Citation
     */
    select?: CitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Citation
     */
    omit?: CitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CitationInclude<ExtArgs> | null
    /**
     * Filter, which Citation to fetch.
     */
    where?: CitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Citations to fetch.
     */
    orderBy?: CitationOrderByWithRelationInput | CitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Citations.
     */
    cursor?: CitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Citations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Citations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Citations.
     */
    distinct?: CitationScalarFieldEnum | CitationScalarFieldEnum[]
  }

  /**
   * Citation findMany
   */
  export type CitationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Citation
     */
    select?: CitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Citation
     */
    omit?: CitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CitationInclude<ExtArgs> | null
    /**
     * Filter, which Citations to fetch.
     */
    where?: CitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Citations to fetch.
     */
    orderBy?: CitationOrderByWithRelationInput | CitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Citations.
     */
    cursor?: CitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Citations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Citations.
     */
    skip?: number
    distinct?: CitationScalarFieldEnum | CitationScalarFieldEnum[]
  }

  /**
   * Citation create
   */
  export type CitationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Citation
     */
    select?: CitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Citation
     */
    omit?: CitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CitationInclude<ExtArgs> | null
    /**
     * The data needed to create a Citation.
     */
    data: XOR<CitationCreateInput, CitationUncheckedCreateInput>
  }

  /**
   * Citation createMany
   */
  export type CitationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Citations.
     */
    data: CitationCreateManyInput | CitationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Citation createManyAndReturn
   */
  export type CitationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Citation
     */
    select?: CitationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Citation
     */
    omit?: CitationOmit<ExtArgs> | null
    /**
     * The data used to create many Citations.
     */
    data: CitationCreateManyInput | CitationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CitationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Citation update
   */
  export type CitationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Citation
     */
    select?: CitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Citation
     */
    omit?: CitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CitationInclude<ExtArgs> | null
    /**
     * The data needed to update a Citation.
     */
    data: XOR<CitationUpdateInput, CitationUncheckedUpdateInput>
    /**
     * Choose, which Citation to update.
     */
    where: CitationWhereUniqueInput
  }

  /**
   * Citation updateMany
   */
  export type CitationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Citations.
     */
    data: XOR<CitationUpdateManyMutationInput, CitationUncheckedUpdateManyInput>
    /**
     * Filter which Citations to update
     */
    where?: CitationWhereInput
    /**
     * Limit how many Citations to update.
     */
    limit?: number
  }

  /**
   * Citation updateManyAndReturn
   */
  export type CitationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Citation
     */
    select?: CitationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Citation
     */
    omit?: CitationOmit<ExtArgs> | null
    /**
     * The data used to update Citations.
     */
    data: XOR<CitationUpdateManyMutationInput, CitationUncheckedUpdateManyInput>
    /**
     * Filter which Citations to update
     */
    where?: CitationWhereInput
    /**
     * Limit how many Citations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CitationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Citation upsert
   */
  export type CitationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Citation
     */
    select?: CitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Citation
     */
    omit?: CitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CitationInclude<ExtArgs> | null
    /**
     * The filter to search for the Citation to update in case it exists.
     */
    where: CitationWhereUniqueInput
    /**
     * In case the Citation found by the `where` argument doesn't exist, create a new Citation with this data.
     */
    create: XOR<CitationCreateInput, CitationUncheckedCreateInput>
    /**
     * In case the Citation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CitationUpdateInput, CitationUncheckedUpdateInput>
  }

  /**
   * Citation delete
   */
  export type CitationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Citation
     */
    select?: CitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Citation
     */
    omit?: CitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CitationInclude<ExtArgs> | null
    /**
     * Filter which Citation to delete.
     */
    where: CitationWhereUniqueInput
  }

  /**
   * Citation deleteMany
   */
  export type CitationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Citations to delete
     */
    where?: CitationWhereInput
    /**
     * Limit how many Citations to delete.
     */
    limit?: number
  }

  /**
   * Citation.sourceChunk
   */
  export type Citation$sourceChunkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceChunk
     */
    select?: SourceChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceChunk
     */
    omit?: SourceChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceChunkInclude<ExtArgs> | null
    where?: SourceChunkWhereInput
  }

  /**
   * Citation.sourceDocument
   */
  export type Citation$sourceDocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceDocument
     */
    select?: SourceDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceDocument
     */
    omit?: SourceDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceDocumentInclude<ExtArgs> | null
    where?: SourceDocumentWhereInput
  }

  /**
   * Citation without action
   */
  export type CitationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Citation
     */
    select?: CitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Citation
     */
    omit?: CitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CitationInclude<ExtArgs> | null
  }


  /**
   * Model SurveyForm
   */

  export type AggregateSurveyForm = {
    _count: SurveyFormCountAggregateOutputType | null
    _min: SurveyFormMinAggregateOutputType | null
    _max: SurveyFormMaxAggregateOutputType | null
  }

  export type SurveyFormMinAggregateOutputType = {
    id: string | null
    title: string | null
    descriptionMd: string | null
    slug: string | null
    status: $Enums.SurveyFormStatus | null
    startAt: Date | null
    endAt: Date | null
    countyId: string | null
    contextLabel: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SurveyFormMaxAggregateOutputType = {
    id: string | null
    title: string | null
    descriptionMd: string | null
    slug: string | null
    status: $Enums.SurveyFormStatus | null
    startAt: Date | null
    endAt: Date | null
    countyId: string | null
    contextLabel: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SurveyFormCountAggregateOutputType = {
    id: number
    title: number
    descriptionMd: number
    slug: number
    status: number
    startAt: number
    endAt: number
    countyId: number
    contextLabel: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SurveyFormMinAggregateInputType = {
    id?: true
    title?: true
    descriptionMd?: true
    slug?: true
    status?: true
    startAt?: true
    endAt?: true
    countyId?: true
    contextLabel?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SurveyFormMaxAggregateInputType = {
    id?: true
    title?: true
    descriptionMd?: true
    slug?: true
    status?: true
    startAt?: true
    endAt?: true
    countyId?: true
    contextLabel?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SurveyFormCountAggregateInputType = {
    id?: true
    title?: true
    descriptionMd?: true
    slug?: true
    status?: true
    startAt?: true
    endAt?: true
    countyId?: true
    contextLabel?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SurveyFormAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SurveyForm to aggregate.
     */
    where?: SurveyFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyForms to fetch.
     */
    orderBy?: SurveyFormOrderByWithRelationInput | SurveyFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SurveyFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SurveyForms
    **/
    _count?: true | SurveyFormCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SurveyFormMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SurveyFormMaxAggregateInputType
  }

  export type GetSurveyFormAggregateType<T extends SurveyFormAggregateArgs> = {
        [P in keyof T & keyof AggregateSurveyForm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSurveyForm[P]>
      : GetScalarType<T[P], AggregateSurveyForm[P]>
  }




  export type SurveyFormGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyFormWhereInput
    orderBy?: SurveyFormOrderByWithAggregationInput | SurveyFormOrderByWithAggregationInput[]
    by: SurveyFormScalarFieldEnum[] | SurveyFormScalarFieldEnum
    having?: SurveyFormScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SurveyFormCountAggregateInputType | true
    _min?: SurveyFormMinAggregateInputType
    _max?: SurveyFormMaxAggregateInputType
  }

  export type SurveyFormGroupByOutputType = {
    id: string
    title: string
    descriptionMd: string | null
    slug: string
    status: $Enums.SurveyFormStatus
    startAt: Date | null
    endAt: Date | null
    countyId: string | null
    contextLabel: string | null
    createdAt: Date
    updatedAt: Date
    _count: SurveyFormCountAggregateOutputType | null
    _min: SurveyFormMinAggregateOutputType | null
    _max: SurveyFormMaxAggregateOutputType | null
  }

  type GetSurveyFormGroupByPayload<T extends SurveyFormGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SurveyFormGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SurveyFormGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SurveyFormGroupByOutputType[P]>
            : GetScalarType<T[P], SurveyFormGroupByOutputType[P]>
        }
      >
    >


  export type SurveyFormSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    descriptionMd?: boolean
    slug?: boolean
    status?: boolean
    startAt?: boolean
    endAt?: boolean
    countyId?: boolean
    contextLabel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    county?: boolean | SurveyForm$countyArgs<ExtArgs>
    questions?: boolean | SurveyForm$questionsArgs<ExtArgs>
    responses?: boolean | SurveyForm$responsesArgs<ExtArgs>
    sourceLinks?: boolean | SurveyForm$sourceLinksArgs<ExtArgs>
    _count?: boolean | SurveyFormCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["surveyForm"]>

  export type SurveyFormSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    descriptionMd?: boolean
    slug?: boolean
    status?: boolean
    startAt?: boolean
    endAt?: boolean
    countyId?: boolean
    contextLabel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    county?: boolean | SurveyForm$countyArgs<ExtArgs>
  }, ExtArgs["result"]["surveyForm"]>

  export type SurveyFormSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    descriptionMd?: boolean
    slug?: boolean
    status?: boolean
    startAt?: boolean
    endAt?: boolean
    countyId?: boolean
    contextLabel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    county?: boolean | SurveyForm$countyArgs<ExtArgs>
  }, ExtArgs["result"]["surveyForm"]>

  export type SurveyFormSelectScalar = {
    id?: boolean
    title?: boolean
    descriptionMd?: boolean
    slug?: boolean
    status?: boolean
    startAt?: boolean
    endAt?: boolean
    countyId?: boolean
    contextLabel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SurveyFormOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "descriptionMd" | "slug" | "status" | "startAt" | "endAt" | "countyId" | "contextLabel" | "createdAt" | "updatedAt", ExtArgs["result"]["surveyForm"]>
  export type SurveyFormInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    county?: boolean | SurveyForm$countyArgs<ExtArgs>
    questions?: boolean | SurveyForm$questionsArgs<ExtArgs>
    responses?: boolean | SurveyForm$responsesArgs<ExtArgs>
    sourceLinks?: boolean | SurveyForm$sourceLinksArgs<ExtArgs>
    _count?: boolean | SurveyFormCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SurveyFormIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    county?: boolean | SurveyForm$countyArgs<ExtArgs>
  }
  export type SurveyFormIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    county?: boolean | SurveyForm$countyArgs<ExtArgs>
  }

  export type $SurveyFormPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SurveyForm"
    objects: {
      county: Prisma.$CountyPayload<ExtArgs> | null
      questions: Prisma.$SurveyQuestionPayload<ExtArgs>[]
      responses: Prisma.$SurveyResponsePayload<ExtArgs>[]
      sourceLinks: Prisma.$SourceDocumentLinkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      descriptionMd: string | null
      slug: string
      status: $Enums.SurveyFormStatus
      startAt: Date | null
      endAt: Date | null
      countyId: string | null
      contextLabel: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["surveyForm"]>
    composites: {}
  }

  type SurveyFormGetPayload<S extends boolean | null | undefined | SurveyFormDefaultArgs> = $Result.GetResult<Prisma.$SurveyFormPayload, S>

  type SurveyFormCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SurveyFormFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SurveyFormCountAggregateInputType | true
    }

  export interface SurveyFormDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SurveyForm'], meta: { name: 'SurveyForm' } }
    /**
     * Find zero or one SurveyForm that matches the filter.
     * @param {SurveyFormFindUniqueArgs} args - Arguments to find a SurveyForm
     * @example
     * // Get one SurveyForm
     * const surveyForm = await prisma.surveyForm.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SurveyFormFindUniqueArgs>(args: SelectSubset<T, SurveyFormFindUniqueArgs<ExtArgs>>): Prisma__SurveyFormClient<$Result.GetResult<Prisma.$SurveyFormPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SurveyForm that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SurveyFormFindUniqueOrThrowArgs} args - Arguments to find a SurveyForm
     * @example
     * // Get one SurveyForm
     * const surveyForm = await prisma.surveyForm.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SurveyFormFindUniqueOrThrowArgs>(args: SelectSubset<T, SurveyFormFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SurveyFormClient<$Result.GetResult<Prisma.$SurveyFormPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SurveyForm that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyFormFindFirstArgs} args - Arguments to find a SurveyForm
     * @example
     * // Get one SurveyForm
     * const surveyForm = await prisma.surveyForm.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SurveyFormFindFirstArgs>(args?: SelectSubset<T, SurveyFormFindFirstArgs<ExtArgs>>): Prisma__SurveyFormClient<$Result.GetResult<Prisma.$SurveyFormPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SurveyForm that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyFormFindFirstOrThrowArgs} args - Arguments to find a SurveyForm
     * @example
     * // Get one SurveyForm
     * const surveyForm = await prisma.surveyForm.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SurveyFormFindFirstOrThrowArgs>(args?: SelectSubset<T, SurveyFormFindFirstOrThrowArgs<ExtArgs>>): Prisma__SurveyFormClient<$Result.GetResult<Prisma.$SurveyFormPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SurveyForms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyFormFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SurveyForms
     * const surveyForms = await prisma.surveyForm.findMany()
     * 
     * // Get first 10 SurveyForms
     * const surveyForms = await prisma.surveyForm.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const surveyFormWithIdOnly = await prisma.surveyForm.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SurveyFormFindManyArgs>(args?: SelectSubset<T, SurveyFormFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyFormPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SurveyForm.
     * @param {SurveyFormCreateArgs} args - Arguments to create a SurveyForm.
     * @example
     * // Create one SurveyForm
     * const SurveyForm = await prisma.surveyForm.create({
     *   data: {
     *     // ... data to create a SurveyForm
     *   }
     * })
     * 
     */
    create<T extends SurveyFormCreateArgs>(args: SelectSubset<T, SurveyFormCreateArgs<ExtArgs>>): Prisma__SurveyFormClient<$Result.GetResult<Prisma.$SurveyFormPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SurveyForms.
     * @param {SurveyFormCreateManyArgs} args - Arguments to create many SurveyForms.
     * @example
     * // Create many SurveyForms
     * const surveyForm = await prisma.surveyForm.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SurveyFormCreateManyArgs>(args?: SelectSubset<T, SurveyFormCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SurveyForms and returns the data saved in the database.
     * @param {SurveyFormCreateManyAndReturnArgs} args - Arguments to create many SurveyForms.
     * @example
     * // Create many SurveyForms
     * const surveyForm = await prisma.surveyForm.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SurveyForms and only return the `id`
     * const surveyFormWithIdOnly = await prisma.surveyForm.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SurveyFormCreateManyAndReturnArgs>(args?: SelectSubset<T, SurveyFormCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyFormPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SurveyForm.
     * @param {SurveyFormDeleteArgs} args - Arguments to delete one SurveyForm.
     * @example
     * // Delete one SurveyForm
     * const SurveyForm = await prisma.surveyForm.delete({
     *   where: {
     *     // ... filter to delete one SurveyForm
     *   }
     * })
     * 
     */
    delete<T extends SurveyFormDeleteArgs>(args: SelectSubset<T, SurveyFormDeleteArgs<ExtArgs>>): Prisma__SurveyFormClient<$Result.GetResult<Prisma.$SurveyFormPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SurveyForm.
     * @param {SurveyFormUpdateArgs} args - Arguments to update one SurveyForm.
     * @example
     * // Update one SurveyForm
     * const surveyForm = await prisma.surveyForm.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SurveyFormUpdateArgs>(args: SelectSubset<T, SurveyFormUpdateArgs<ExtArgs>>): Prisma__SurveyFormClient<$Result.GetResult<Prisma.$SurveyFormPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SurveyForms.
     * @param {SurveyFormDeleteManyArgs} args - Arguments to filter SurveyForms to delete.
     * @example
     * // Delete a few SurveyForms
     * const { count } = await prisma.surveyForm.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SurveyFormDeleteManyArgs>(args?: SelectSubset<T, SurveyFormDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SurveyForms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyFormUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SurveyForms
     * const surveyForm = await prisma.surveyForm.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SurveyFormUpdateManyArgs>(args: SelectSubset<T, SurveyFormUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SurveyForms and returns the data updated in the database.
     * @param {SurveyFormUpdateManyAndReturnArgs} args - Arguments to update many SurveyForms.
     * @example
     * // Update many SurveyForms
     * const surveyForm = await prisma.surveyForm.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SurveyForms and only return the `id`
     * const surveyFormWithIdOnly = await prisma.surveyForm.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SurveyFormUpdateManyAndReturnArgs>(args: SelectSubset<T, SurveyFormUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyFormPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SurveyForm.
     * @param {SurveyFormUpsertArgs} args - Arguments to update or create a SurveyForm.
     * @example
     * // Update or create a SurveyForm
     * const surveyForm = await prisma.surveyForm.upsert({
     *   create: {
     *     // ... data to create a SurveyForm
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SurveyForm we want to update
     *   }
     * })
     */
    upsert<T extends SurveyFormUpsertArgs>(args: SelectSubset<T, SurveyFormUpsertArgs<ExtArgs>>): Prisma__SurveyFormClient<$Result.GetResult<Prisma.$SurveyFormPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SurveyForms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyFormCountArgs} args - Arguments to filter SurveyForms to count.
     * @example
     * // Count the number of SurveyForms
     * const count = await prisma.surveyForm.count({
     *   where: {
     *     // ... the filter for the SurveyForms we want to count
     *   }
     * })
    **/
    count<T extends SurveyFormCountArgs>(
      args?: Subset<T, SurveyFormCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SurveyFormCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SurveyForm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyFormAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SurveyFormAggregateArgs>(args: Subset<T, SurveyFormAggregateArgs>): Prisma.PrismaPromise<GetSurveyFormAggregateType<T>>

    /**
     * Group by SurveyForm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyFormGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SurveyFormGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SurveyFormGroupByArgs['orderBy'] }
        : { orderBy?: SurveyFormGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SurveyFormGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSurveyFormGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SurveyForm model
   */
  readonly fields: SurveyFormFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SurveyForm.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SurveyFormClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    county<T extends SurveyForm$countyArgs<ExtArgs> = {}>(args?: Subset<T, SurveyForm$countyArgs<ExtArgs>>): Prisma__CountyClient<$Result.GetResult<Prisma.$CountyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    questions<T extends SurveyForm$questionsArgs<ExtArgs> = {}>(args?: Subset<T, SurveyForm$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    responses<T extends SurveyForm$responsesArgs<ExtArgs> = {}>(args?: Subset<T, SurveyForm$responsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sourceLinks<T extends SurveyForm$sourceLinksArgs<ExtArgs> = {}>(args?: Subset<T, SurveyForm$sourceLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourceDocumentLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SurveyForm model
   */
  interface SurveyFormFieldRefs {
    readonly id: FieldRef<"SurveyForm", 'String'>
    readonly title: FieldRef<"SurveyForm", 'String'>
    readonly descriptionMd: FieldRef<"SurveyForm", 'String'>
    readonly slug: FieldRef<"SurveyForm", 'String'>
    readonly status: FieldRef<"SurveyForm", 'SurveyFormStatus'>
    readonly startAt: FieldRef<"SurveyForm", 'DateTime'>
    readonly endAt: FieldRef<"SurveyForm", 'DateTime'>
    readonly countyId: FieldRef<"SurveyForm", 'String'>
    readonly contextLabel: FieldRef<"SurveyForm", 'String'>
    readonly createdAt: FieldRef<"SurveyForm", 'DateTime'>
    readonly updatedAt: FieldRef<"SurveyForm", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SurveyForm findUnique
   */
  export type SurveyFormFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyForm
     */
    select?: SurveyFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyForm
     */
    omit?: SurveyFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyFormInclude<ExtArgs> | null
    /**
     * Filter, which SurveyForm to fetch.
     */
    where: SurveyFormWhereUniqueInput
  }

  /**
   * SurveyForm findUniqueOrThrow
   */
  export type SurveyFormFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyForm
     */
    select?: SurveyFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyForm
     */
    omit?: SurveyFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyFormInclude<ExtArgs> | null
    /**
     * Filter, which SurveyForm to fetch.
     */
    where: SurveyFormWhereUniqueInput
  }

  /**
   * SurveyForm findFirst
   */
  export type SurveyFormFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyForm
     */
    select?: SurveyFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyForm
     */
    omit?: SurveyFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyFormInclude<ExtArgs> | null
    /**
     * Filter, which SurveyForm to fetch.
     */
    where?: SurveyFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyForms to fetch.
     */
    orderBy?: SurveyFormOrderByWithRelationInput | SurveyFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SurveyForms.
     */
    cursor?: SurveyFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SurveyForms.
     */
    distinct?: SurveyFormScalarFieldEnum | SurveyFormScalarFieldEnum[]
  }

  /**
   * SurveyForm findFirstOrThrow
   */
  export type SurveyFormFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyForm
     */
    select?: SurveyFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyForm
     */
    omit?: SurveyFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyFormInclude<ExtArgs> | null
    /**
     * Filter, which SurveyForm to fetch.
     */
    where?: SurveyFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyForms to fetch.
     */
    orderBy?: SurveyFormOrderByWithRelationInput | SurveyFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SurveyForms.
     */
    cursor?: SurveyFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SurveyForms.
     */
    distinct?: SurveyFormScalarFieldEnum | SurveyFormScalarFieldEnum[]
  }

  /**
   * SurveyForm findMany
   */
  export type SurveyFormFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyForm
     */
    select?: SurveyFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyForm
     */
    omit?: SurveyFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyFormInclude<ExtArgs> | null
    /**
     * Filter, which SurveyForms to fetch.
     */
    where?: SurveyFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyForms to fetch.
     */
    orderBy?: SurveyFormOrderByWithRelationInput | SurveyFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SurveyForms.
     */
    cursor?: SurveyFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyForms.
     */
    skip?: number
    distinct?: SurveyFormScalarFieldEnum | SurveyFormScalarFieldEnum[]
  }

  /**
   * SurveyForm create
   */
  export type SurveyFormCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyForm
     */
    select?: SurveyFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyForm
     */
    omit?: SurveyFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyFormInclude<ExtArgs> | null
    /**
     * The data needed to create a SurveyForm.
     */
    data: XOR<SurveyFormCreateInput, SurveyFormUncheckedCreateInput>
  }

  /**
   * SurveyForm createMany
   */
  export type SurveyFormCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SurveyForms.
     */
    data: SurveyFormCreateManyInput | SurveyFormCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SurveyForm createManyAndReturn
   */
  export type SurveyFormCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyForm
     */
    select?: SurveyFormSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyForm
     */
    omit?: SurveyFormOmit<ExtArgs> | null
    /**
     * The data used to create many SurveyForms.
     */
    data: SurveyFormCreateManyInput | SurveyFormCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyFormIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SurveyForm update
   */
  export type SurveyFormUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyForm
     */
    select?: SurveyFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyForm
     */
    omit?: SurveyFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyFormInclude<ExtArgs> | null
    /**
     * The data needed to update a SurveyForm.
     */
    data: XOR<SurveyFormUpdateInput, SurveyFormUncheckedUpdateInput>
    /**
     * Choose, which SurveyForm to update.
     */
    where: SurveyFormWhereUniqueInput
  }

  /**
   * SurveyForm updateMany
   */
  export type SurveyFormUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SurveyForms.
     */
    data: XOR<SurveyFormUpdateManyMutationInput, SurveyFormUncheckedUpdateManyInput>
    /**
     * Filter which SurveyForms to update
     */
    where?: SurveyFormWhereInput
    /**
     * Limit how many SurveyForms to update.
     */
    limit?: number
  }

  /**
   * SurveyForm updateManyAndReturn
   */
  export type SurveyFormUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyForm
     */
    select?: SurveyFormSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyForm
     */
    omit?: SurveyFormOmit<ExtArgs> | null
    /**
     * The data used to update SurveyForms.
     */
    data: XOR<SurveyFormUpdateManyMutationInput, SurveyFormUncheckedUpdateManyInput>
    /**
     * Filter which SurveyForms to update
     */
    where?: SurveyFormWhereInput
    /**
     * Limit how many SurveyForms to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyFormIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SurveyForm upsert
   */
  export type SurveyFormUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyForm
     */
    select?: SurveyFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyForm
     */
    omit?: SurveyFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyFormInclude<ExtArgs> | null
    /**
     * The filter to search for the SurveyForm to update in case it exists.
     */
    where: SurveyFormWhereUniqueInput
    /**
     * In case the SurveyForm found by the `where` argument doesn't exist, create a new SurveyForm with this data.
     */
    create: XOR<SurveyFormCreateInput, SurveyFormUncheckedCreateInput>
    /**
     * In case the SurveyForm was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SurveyFormUpdateInput, SurveyFormUncheckedUpdateInput>
  }

  /**
   * SurveyForm delete
   */
  export type SurveyFormDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyForm
     */
    select?: SurveyFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyForm
     */
    omit?: SurveyFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyFormInclude<ExtArgs> | null
    /**
     * Filter which SurveyForm to delete.
     */
    where: SurveyFormWhereUniqueInput
  }

  /**
   * SurveyForm deleteMany
   */
  export type SurveyFormDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SurveyForms to delete
     */
    where?: SurveyFormWhereInput
    /**
     * Limit how many SurveyForms to delete.
     */
    limit?: number
  }

  /**
   * SurveyForm.county
   */
  export type SurveyForm$countyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the County
     */
    select?: CountySelect<ExtArgs> | null
    /**
     * Omit specific fields from the County
     */
    omit?: CountyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountyInclude<ExtArgs> | null
    where?: CountyWhereInput
  }

  /**
   * SurveyForm.questions
   */
  export type SurveyForm$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyQuestion
     */
    select?: SurveyQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyQuestion
     */
    omit?: SurveyQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyQuestionInclude<ExtArgs> | null
    where?: SurveyQuestionWhereInput
    orderBy?: SurveyQuestionOrderByWithRelationInput | SurveyQuestionOrderByWithRelationInput[]
    cursor?: SurveyQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SurveyQuestionScalarFieldEnum | SurveyQuestionScalarFieldEnum[]
  }

  /**
   * SurveyForm.responses
   */
  export type SurveyForm$responsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponse
     */
    select?: SurveyResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyResponse
     */
    omit?: SurveyResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseInclude<ExtArgs> | null
    where?: SurveyResponseWhereInput
    orderBy?: SurveyResponseOrderByWithRelationInput | SurveyResponseOrderByWithRelationInput[]
    cursor?: SurveyResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SurveyResponseScalarFieldEnum | SurveyResponseScalarFieldEnum[]
  }

  /**
   * SurveyForm.sourceLinks
   */
  export type SurveyForm$sourceLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceDocumentLink
     */
    select?: SourceDocumentLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceDocumentLink
     */
    omit?: SourceDocumentLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceDocumentLinkInclude<ExtArgs> | null
    where?: SourceDocumentLinkWhereInput
    orderBy?: SourceDocumentLinkOrderByWithRelationInput | SourceDocumentLinkOrderByWithRelationInput[]
    cursor?: SourceDocumentLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SourceDocumentLinkScalarFieldEnum | SourceDocumentLinkScalarFieldEnum[]
  }

  /**
   * SurveyForm without action
   */
  export type SurveyFormDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyForm
     */
    select?: SurveyFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyForm
     */
    omit?: SurveyFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyFormInclude<ExtArgs> | null
  }


  /**
   * Model SurveyQuestion
   */

  export type AggregateSurveyQuestion = {
    _count: SurveyQuestionCountAggregateOutputType | null
    _avg: SurveyQuestionAvgAggregateOutputType | null
    _sum: SurveyQuestionSumAggregateOutputType | null
    _min: SurveyQuestionMinAggregateOutputType | null
    _max: SurveyQuestionMaxAggregateOutputType | null
  }

  export type SurveyQuestionAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type SurveyQuestionSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type SurveyQuestionMinAggregateOutputType = {
    id: string | null
    formId: string | null
    questionKey: string | null
    prompt: string | null
    helpText: string | null
    questionType: $Enums.SurveyQuestionType | null
    required: boolean | null
    sortOrder: number | null
    isActive: boolean | null
    allowVoice: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SurveyQuestionMaxAggregateOutputType = {
    id: string | null
    formId: string | null
    questionKey: string | null
    prompt: string | null
    helpText: string | null
    questionType: $Enums.SurveyQuestionType | null
    required: boolean | null
    sortOrder: number | null
    isActive: boolean | null
    allowVoice: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SurveyQuestionCountAggregateOutputType = {
    id: number
    formId: number
    questionKey: number
    prompt: number
    helpText: number
    questionType: number
    required: number
    sortOrder: number
    isActive: number
    allowVoice: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SurveyQuestionAvgAggregateInputType = {
    sortOrder?: true
  }

  export type SurveyQuestionSumAggregateInputType = {
    sortOrder?: true
  }

  export type SurveyQuestionMinAggregateInputType = {
    id?: true
    formId?: true
    questionKey?: true
    prompt?: true
    helpText?: true
    questionType?: true
    required?: true
    sortOrder?: true
    isActive?: true
    allowVoice?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SurveyQuestionMaxAggregateInputType = {
    id?: true
    formId?: true
    questionKey?: true
    prompt?: true
    helpText?: true
    questionType?: true
    required?: true
    sortOrder?: true
    isActive?: true
    allowVoice?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SurveyQuestionCountAggregateInputType = {
    id?: true
    formId?: true
    questionKey?: true
    prompt?: true
    helpText?: true
    questionType?: true
    required?: true
    sortOrder?: true
    isActive?: true
    allowVoice?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SurveyQuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SurveyQuestion to aggregate.
     */
    where?: SurveyQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyQuestions to fetch.
     */
    orderBy?: SurveyQuestionOrderByWithRelationInput | SurveyQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SurveyQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SurveyQuestions
    **/
    _count?: true | SurveyQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SurveyQuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SurveyQuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SurveyQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SurveyQuestionMaxAggregateInputType
  }

  export type GetSurveyQuestionAggregateType<T extends SurveyQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateSurveyQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSurveyQuestion[P]>
      : GetScalarType<T[P], AggregateSurveyQuestion[P]>
  }




  export type SurveyQuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyQuestionWhereInput
    orderBy?: SurveyQuestionOrderByWithAggregationInput | SurveyQuestionOrderByWithAggregationInput[]
    by: SurveyQuestionScalarFieldEnum[] | SurveyQuestionScalarFieldEnum
    having?: SurveyQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SurveyQuestionCountAggregateInputType | true
    _avg?: SurveyQuestionAvgAggregateInputType
    _sum?: SurveyQuestionSumAggregateInputType
    _min?: SurveyQuestionMinAggregateInputType
    _max?: SurveyQuestionMaxAggregateInputType
  }

  export type SurveyQuestionGroupByOutputType = {
    id: string
    formId: string
    questionKey: string
    prompt: string
    helpText: string | null
    questionType: $Enums.SurveyQuestionType
    required: boolean
    sortOrder: number
    isActive: boolean
    allowVoice: boolean
    createdAt: Date
    updatedAt: Date
    _count: SurveyQuestionCountAggregateOutputType | null
    _avg: SurveyQuestionAvgAggregateOutputType | null
    _sum: SurveyQuestionSumAggregateOutputType | null
    _min: SurveyQuestionMinAggregateOutputType | null
    _max: SurveyQuestionMaxAggregateOutputType | null
  }

  type GetSurveyQuestionGroupByPayload<T extends SurveyQuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SurveyQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SurveyQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SurveyQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], SurveyQuestionGroupByOutputType[P]>
        }
      >
    >


  export type SurveyQuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    formId?: boolean
    questionKey?: boolean
    prompt?: boolean
    helpText?: boolean
    questionType?: boolean
    required?: boolean
    sortOrder?: boolean
    isActive?: boolean
    allowVoice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    form?: boolean | SurveyFormDefaultArgs<ExtArgs>
    options?: boolean | SurveyQuestion$optionsArgs<ExtArgs>
    responseItems?: boolean | SurveyQuestion$responseItemsArgs<ExtArgs>
    _count?: boolean | SurveyQuestionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["surveyQuestion"]>

  export type SurveyQuestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    formId?: boolean
    questionKey?: boolean
    prompt?: boolean
    helpText?: boolean
    questionType?: boolean
    required?: boolean
    sortOrder?: boolean
    isActive?: boolean
    allowVoice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    form?: boolean | SurveyFormDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["surveyQuestion"]>

  export type SurveyQuestionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    formId?: boolean
    questionKey?: boolean
    prompt?: boolean
    helpText?: boolean
    questionType?: boolean
    required?: boolean
    sortOrder?: boolean
    isActive?: boolean
    allowVoice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    form?: boolean | SurveyFormDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["surveyQuestion"]>

  export type SurveyQuestionSelectScalar = {
    id?: boolean
    formId?: boolean
    questionKey?: boolean
    prompt?: boolean
    helpText?: boolean
    questionType?: boolean
    required?: boolean
    sortOrder?: boolean
    isActive?: boolean
    allowVoice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SurveyQuestionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "formId" | "questionKey" | "prompt" | "helpText" | "questionType" | "required" | "sortOrder" | "isActive" | "allowVoice" | "createdAt" | "updatedAt", ExtArgs["result"]["surveyQuestion"]>
  export type SurveyQuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    form?: boolean | SurveyFormDefaultArgs<ExtArgs>
    options?: boolean | SurveyQuestion$optionsArgs<ExtArgs>
    responseItems?: boolean | SurveyQuestion$responseItemsArgs<ExtArgs>
    _count?: boolean | SurveyQuestionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SurveyQuestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    form?: boolean | SurveyFormDefaultArgs<ExtArgs>
  }
  export type SurveyQuestionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    form?: boolean | SurveyFormDefaultArgs<ExtArgs>
  }

  export type $SurveyQuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SurveyQuestion"
    objects: {
      form: Prisma.$SurveyFormPayload<ExtArgs>
      options: Prisma.$SurveyQuestionOptionPayload<ExtArgs>[]
      responseItems: Prisma.$SurveyResponseItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      formId: string
      questionKey: string
      prompt: string
      helpText: string | null
      questionType: $Enums.SurveyQuestionType
      required: boolean
      sortOrder: number
      isActive: boolean
      allowVoice: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["surveyQuestion"]>
    composites: {}
  }

  type SurveyQuestionGetPayload<S extends boolean | null | undefined | SurveyQuestionDefaultArgs> = $Result.GetResult<Prisma.$SurveyQuestionPayload, S>

  type SurveyQuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SurveyQuestionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SurveyQuestionCountAggregateInputType | true
    }

  export interface SurveyQuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SurveyQuestion'], meta: { name: 'SurveyQuestion' } }
    /**
     * Find zero or one SurveyQuestion that matches the filter.
     * @param {SurveyQuestionFindUniqueArgs} args - Arguments to find a SurveyQuestion
     * @example
     * // Get one SurveyQuestion
     * const surveyQuestion = await prisma.surveyQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SurveyQuestionFindUniqueArgs>(args: SelectSubset<T, SurveyQuestionFindUniqueArgs<ExtArgs>>): Prisma__SurveyQuestionClient<$Result.GetResult<Prisma.$SurveyQuestionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SurveyQuestion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SurveyQuestionFindUniqueOrThrowArgs} args - Arguments to find a SurveyQuestion
     * @example
     * // Get one SurveyQuestion
     * const surveyQuestion = await prisma.surveyQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SurveyQuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, SurveyQuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SurveyQuestionClient<$Result.GetResult<Prisma.$SurveyQuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SurveyQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyQuestionFindFirstArgs} args - Arguments to find a SurveyQuestion
     * @example
     * // Get one SurveyQuestion
     * const surveyQuestion = await prisma.surveyQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SurveyQuestionFindFirstArgs>(args?: SelectSubset<T, SurveyQuestionFindFirstArgs<ExtArgs>>): Prisma__SurveyQuestionClient<$Result.GetResult<Prisma.$SurveyQuestionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SurveyQuestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyQuestionFindFirstOrThrowArgs} args - Arguments to find a SurveyQuestion
     * @example
     * // Get one SurveyQuestion
     * const surveyQuestion = await prisma.surveyQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SurveyQuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, SurveyQuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SurveyQuestionClient<$Result.GetResult<Prisma.$SurveyQuestionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SurveyQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyQuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SurveyQuestions
     * const surveyQuestions = await prisma.surveyQuestion.findMany()
     * 
     * // Get first 10 SurveyQuestions
     * const surveyQuestions = await prisma.surveyQuestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const surveyQuestionWithIdOnly = await prisma.surveyQuestion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SurveyQuestionFindManyArgs>(args?: SelectSubset<T, SurveyQuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SurveyQuestion.
     * @param {SurveyQuestionCreateArgs} args - Arguments to create a SurveyQuestion.
     * @example
     * // Create one SurveyQuestion
     * const SurveyQuestion = await prisma.surveyQuestion.create({
     *   data: {
     *     // ... data to create a SurveyQuestion
     *   }
     * })
     * 
     */
    create<T extends SurveyQuestionCreateArgs>(args: SelectSubset<T, SurveyQuestionCreateArgs<ExtArgs>>): Prisma__SurveyQuestionClient<$Result.GetResult<Prisma.$SurveyQuestionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SurveyQuestions.
     * @param {SurveyQuestionCreateManyArgs} args - Arguments to create many SurveyQuestions.
     * @example
     * // Create many SurveyQuestions
     * const surveyQuestion = await prisma.surveyQuestion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SurveyQuestionCreateManyArgs>(args?: SelectSubset<T, SurveyQuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SurveyQuestions and returns the data saved in the database.
     * @param {SurveyQuestionCreateManyAndReturnArgs} args - Arguments to create many SurveyQuestions.
     * @example
     * // Create many SurveyQuestions
     * const surveyQuestion = await prisma.surveyQuestion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SurveyQuestions and only return the `id`
     * const surveyQuestionWithIdOnly = await prisma.surveyQuestion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SurveyQuestionCreateManyAndReturnArgs>(args?: SelectSubset<T, SurveyQuestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyQuestionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SurveyQuestion.
     * @param {SurveyQuestionDeleteArgs} args - Arguments to delete one SurveyQuestion.
     * @example
     * // Delete one SurveyQuestion
     * const SurveyQuestion = await prisma.surveyQuestion.delete({
     *   where: {
     *     // ... filter to delete one SurveyQuestion
     *   }
     * })
     * 
     */
    delete<T extends SurveyQuestionDeleteArgs>(args: SelectSubset<T, SurveyQuestionDeleteArgs<ExtArgs>>): Prisma__SurveyQuestionClient<$Result.GetResult<Prisma.$SurveyQuestionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SurveyQuestion.
     * @param {SurveyQuestionUpdateArgs} args - Arguments to update one SurveyQuestion.
     * @example
     * // Update one SurveyQuestion
     * const surveyQuestion = await prisma.surveyQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SurveyQuestionUpdateArgs>(args: SelectSubset<T, SurveyQuestionUpdateArgs<ExtArgs>>): Prisma__SurveyQuestionClient<$Result.GetResult<Prisma.$SurveyQuestionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SurveyQuestions.
     * @param {SurveyQuestionDeleteManyArgs} args - Arguments to filter SurveyQuestions to delete.
     * @example
     * // Delete a few SurveyQuestions
     * const { count } = await prisma.surveyQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SurveyQuestionDeleteManyArgs>(args?: SelectSubset<T, SurveyQuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SurveyQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SurveyQuestions
     * const surveyQuestion = await prisma.surveyQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SurveyQuestionUpdateManyArgs>(args: SelectSubset<T, SurveyQuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SurveyQuestions and returns the data updated in the database.
     * @param {SurveyQuestionUpdateManyAndReturnArgs} args - Arguments to update many SurveyQuestions.
     * @example
     * // Update many SurveyQuestions
     * const surveyQuestion = await prisma.surveyQuestion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SurveyQuestions and only return the `id`
     * const surveyQuestionWithIdOnly = await prisma.surveyQuestion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SurveyQuestionUpdateManyAndReturnArgs>(args: SelectSubset<T, SurveyQuestionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyQuestionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SurveyQuestion.
     * @param {SurveyQuestionUpsertArgs} args - Arguments to update or create a SurveyQuestion.
     * @example
     * // Update or create a SurveyQuestion
     * const surveyQuestion = await prisma.surveyQuestion.upsert({
     *   create: {
     *     // ... data to create a SurveyQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SurveyQuestion we want to update
     *   }
     * })
     */
    upsert<T extends SurveyQuestionUpsertArgs>(args: SelectSubset<T, SurveyQuestionUpsertArgs<ExtArgs>>): Prisma__SurveyQuestionClient<$Result.GetResult<Prisma.$SurveyQuestionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SurveyQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyQuestionCountArgs} args - Arguments to filter SurveyQuestions to count.
     * @example
     * // Count the number of SurveyQuestions
     * const count = await prisma.surveyQuestion.count({
     *   where: {
     *     // ... the filter for the SurveyQuestions we want to count
     *   }
     * })
    **/
    count<T extends SurveyQuestionCountArgs>(
      args?: Subset<T, SurveyQuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SurveyQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SurveyQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SurveyQuestionAggregateArgs>(args: Subset<T, SurveyQuestionAggregateArgs>): Prisma.PrismaPromise<GetSurveyQuestionAggregateType<T>>

    /**
     * Group by SurveyQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SurveyQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SurveyQuestionGroupByArgs['orderBy'] }
        : { orderBy?: SurveyQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SurveyQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSurveyQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SurveyQuestion model
   */
  readonly fields: SurveyQuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SurveyQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SurveyQuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    form<T extends SurveyFormDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SurveyFormDefaultArgs<ExtArgs>>): Prisma__SurveyFormClient<$Result.GetResult<Prisma.$SurveyFormPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    options<T extends SurveyQuestion$optionsArgs<ExtArgs> = {}>(args?: Subset<T, SurveyQuestion$optionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyQuestionOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    responseItems<T extends SurveyQuestion$responseItemsArgs<ExtArgs> = {}>(args?: Subset<T, SurveyQuestion$responseItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyResponseItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SurveyQuestion model
   */
  interface SurveyQuestionFieldRefs {
    readonly id: FieldRef<"SurveyQuestion", 'String'>
    readonly formId: FieldRef<"SurveyQuestion", 'String'>
    readonly questionKey: FieldRef<"SurveyQuestion", 'String'>
    readonly prompt: FieldRef<"SurveyQuestion", 'String'>
    readonly helpText: FieldRef<"SurveyQuestion", 'String'>
    readonly questionType: FieldRef<"SurveyQuestion", 'SurveyQuestionType'>
    readonly required: FieldRef<"SurveyQuestion", 'Boolean'>
    readonly sortOrder: FieldRef<"SurveyQuestion", 'Int'>
    readonly isActive: FieldRef<"SurveyQuestion", 'Boolean'>
    readonly allowVoice: FieldRef<"SurveyQuestion", 'Boolean'>
    readonly createdAt: FieldRef<"SurveyQuestion", 'DateTime'>
    readonly updatedAt: FieldRef<"SurveyQuestion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SurveyQuestion findUnique
   */
  export type SurveyQuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyQuestion
     */
    select?: SurveyQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyQuestion
     */
    omit?: SurveyQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyQuestionInclude<ExtArgs> | null
    /**
     * Filter, which SurveyQuestion to fetch.
     */
    where: SurveyQuestionWhereUniqueInput
  }

  /**
   * SurveyQuestion findUniqueOrThrow
   */
  export type SurveyQuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyQuestion
     */
    select?: SurveyQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyQuestion
     */
    omit?: SurveyQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyQuestionInclude<ExtArgs> | null
    /**
     * Filter, which SurveyQuestion to fetch.
     */
    where: SurveyQuestionWhereUniqueInput
  }

  /**
   * SurveyQuestion findFirst
   */
  export type SurveyQuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyQuestion
     */
    select?: SurveyQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyQuestion
     */
    omit?: SurveyQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyQuestionInclude<ExtArgs> | null
    /**
     * Filter, which SurveyQuestion to fetch.
     */
    where?: SurveyQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyQuestions to fetch.
     */
    orderBy?: SurveyQuestionOrderByWithRelationInput | SurveyQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SurveyQuestions.
     */
    cursor?: SurveyQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SurveyQuestions.
     */
    distinct?: SurveyQuestionScalarFieldEnum | SurveyQuestionScalarFieldEnum[]
  }

  /**
   * SurveyQuestion findFirstOrThrow
   */
  export type SurveyQuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyQuestion
     */
    select?: SurveyQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyQuestion
     */
    omit?: SurveyQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyQuestionInclude<ExtArgs> | null
    /**
     * Filter, which SurveyQuestion to fetch.
     */
    where?: SurveyQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyQuestions to fetch.
     */
    orderBy?: SurveyQuestionOrderByWithRelationInput | SurveyQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SurveyQuestions.
     */
    cursor?: SurveyQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SurveyQuestions.
     */
    distinct?: SurveyQuestionScalarFieldEnum | SurveyQuestionScalarFieldEnum[]
  }

  /**
   * SurveyQuestion findMany
   */
  export type SurveyQuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyQuestion
     */
    select?: SurveyQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyQuestion
     */
    omit?: SurveyQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyQuestionInclude<ExtArgs> | null
    /**
     * Filter, which SurveyQuestions to fetch.
     */
    where?: SurveyQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyQuestions to fetch.
     */
    orderBy?: SurveyQuestionOrderByWithRelationInput | SurveyQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SurveyQuestions.
     */
    cursor?: SurveyQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyQuestions.
     */
    skip?: number
    distinct?: SurveyQuestionScalarFieldEnum | SurveyQuestionScalarFieldEnum[]
  }

  /**
   * SurveyQuestion create
   */
  export type SurveyQuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyQuestion
     */
    select?: SurveyQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyQuestion
     */
    omit?: SurveyQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyQuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a SurveyQuestion.
     */
    data: XOR<SurveyQuestionCreateInput, SurveyQuestionUncheckedCreateInput>
  }

  /**
   * SurveyQuestion createMany
   */
  export type SurveyQuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SurveyQuestions.
     */
    data: SurveyQuestionCreateManyInput | SurveyQuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SurveyQuestion createManyAndReturn
   */
  export type SurveyQuestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyQuestion
     */
    select?: SurveyQuestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyQuestion
     */
    omit?: SurveyQuestionOmit<ExtArgs> | null
    /**
     * The data used to create many SurveyQuestions.
     */
    data: SurveyQuestionCreateManyInput | SurveyQuestionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyQuestionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SurveyQuestion update
   */
  export type SurveyQuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyQuestion
     */
    select?: SurveyQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyQuestion
     */
    omit?: SurveyQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyQuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a SurveyQuestion.
     */
    data: XOR<SurveyQuestionUpdateInput, SurveyQuestionUncheckedUpdateInput>
    /**
     * Choose, which SurveyQuestion to update.
     */
    where: SurveyQuestionWhereUniqueInput
  }

  /**
   * SurveyQuestion updateMany
   */
  export type SurveyQuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SurveyQuestions.
     */
    data: XOR<SurveyQuestionUpdateManyMutationInput, SurveyQuestionUncheckedUpdateManyInput>
    /**
     * Filter which SurveyQuestions to update
     */
    where?: SurveyQuestionWhereInput
    /**
     * Limit how many SurveyQuestions to update.
     */
    limit?: number
  }

  /**
   * SurveyQuestion updateManyAndReturn
   */
  export type SurveyQuestionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyQuestion
     */
    select?: SurveyQuestionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyQuestion
     */
    omit?: SurveyQuestionOmit<ExtArgs> | null
    /**
     * The data used to update SurveyQuestions.
     */
    data: XOR<SurveyQuestionUpdateManyMutationInput, SurveyQuestionUncheckedUpdateManyInput>
    /**
     * Filter which SurveyQuestions to update
     */
    where?: SurveyQuestionWhereInput
    /**
     * Limit how many SurveyQuestions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyQuestionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SurveyQuestion upsert
   */
  export type SurveyQuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyQuestion
     */
    select?: SurveyQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyQuestion
     */
    omit?: SurveyQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyQuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the SurveyQuestion to update in case it exists.
     */
    where: SurveyQuestionWhereUniqueInput
    /**
     * In case the SurveyQuestion found by the `where` argument doesn't exist, create a new SurveyQuestion with this data.
     */
    create: XOR<SurveyQuestionCreateInput, SurveyQuestionUncheckedCreateInput>
    /**
     * In case the SurveyQuestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SurveyQuestionUpdateInput, SurveyQuestionUncheckedUpdateInput>
  }

  /**
   * SurveyQuestion delete
   */
  export type SurveyQuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyQuestion
     */
    select?: SurveyQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyQuestion
     */
    omit?: SurveyQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyQuestionInclude<ExtArgs> | null
    /**
     * Filter which SurveyQuestion to delete.
     */
    where: SurveyQuestionWhereUniqueInput
  }

  /**
   * SurveyQuestion deleteMany
   */
  export type SurveyQuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SurveyQuestions to delete
     */
    where?: SurveyQuestionWhereInput
    /**
     * Limit how many SurveyQuestions to delete.
     */
    limit?: number
  }

  /**
   * SurveyQuestion.options
   */
  export type SurveyQuestion$optionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyQuestionOption
     */
    select?: SurveyQuestionOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyQuestionOption
     */
    omit?: SurveyQuestionOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyQuestionOptionInclude<ExtArgs> | null
    where?: SurveyQuestionOptionWhereInput
    orderBy?: SurveyQuestionOptionOrderByWithRelationInput | SurveyQuestionOptionOrderByWithRelationInput[]
    cursor?: SurveyQuestionOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SurveyQuestionOptionScalarFieldEnum | SurveyQuestionOptionScalarFieldEnum[]
  }

  /**
   * SurveyQuestion.responseItems
   */
  export type SurveyQuestion$responseItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponseItem
     */
    select?: SurveyResponseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyResponseItem
     */
    omit?: SurveyResponseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseItemInclude<ExtArgs> | null
    where?: SurveyResponseItemWhereInput
    orderBy?: SurveyResponseItemOrderByWithRelationInput | SurveyResponseItemOrderByWithRelationInput[]
    cursor?: SurveyResponseItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SurveyResponseItemScalarFieldEnum | SurveyResponseItemScalarFieldEnum[]
  }

  /**
   * SurveyQuestion without action
   */
  export type SurveyQuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyQuestion
     */
    select?: SurveyQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyQuestion
     */
    omit?: SurveyQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyQuestionInclude<ExtArgs> | null
  }


  /**
   * Model SurveyQuestionOption
   */

  export type AggregateSurveyQuestionOption = {
    _count: SurveyQuestionOptionCountAggregateOutputType | null
    _avg: SurveyQuestionOptionAvgAggregateOutputType | null
    _sum: SurveyQuestionOptionSumAggregateOutputType | null
    _min: SurveyQuestionOptionMinAggregateOutputType | null
    _max: SurveyQuestionOptionMaxAggregateOutputType | null
  }

  export type SurveyQuestionOptionAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type SurveyQuestionOptionSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type SurveyQuestionOptionMinAggregateOutputType = {
    id: string | null
    questionId: string | null
    valueKey: string | null
    label: string | null
    sortOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type SurveyQuestionOptionMaxAggregateOutputType = {
    id: string | null
    questionId: string | null
    valueKey: string | null
    label: string | null
    sortOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type SurveyQuestionOptionCountAggregateOutputType = {
    id: number
    questionId: number
    valueKey: number
    label: number
    sortOrder: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type SurveyQuestionOptionAvgAggregateInputType = {
    sortOrder?: true
  }

  export type SurveyQuestionOptionSumAggregateInputType = {
    sortOrder?: true
  }

  export type SurveyQuestionOptionMinAggregateInputType = {
    id?: true
    questionId?: true
    valueKey?: true
    label?: true
    sortOrder?: true
    isActive?: true
    createdAt?: true
  }

  export type SurveyQuestionOptionMaxAggregateInputType = {
    id?: true
    questionId?: true
    valueKey?: true
    label?: true
    sortOrder?: true
    isActive?: true
    createdAt?: true
  }

  export type SurveyQuestionOptionCountAggregateInputType = {
    id?: true
    questionId?: true
    valueKey?: true
    label?: true
    sortOrder?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type SurveyQuestionOptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SurveyQuestionOption to aggregate.
     */
    where?: SurveyQuestionOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyQuestionOptions to fetch.
     */
    orderBy?: SurveyQuestionOptionOrderByWithRelationInput | SurveyQuestionOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SurveyQuestionOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyQuestionOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyQuestionOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SurveyQuestionOptions
    **/
    _count?: true | SurveyQuestionOptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SurveyQuestionOptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SurveyQuestionOptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SurveyQuestionOptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SurveyQuestionOptionMaxAggregateInputType
  }

  export type GetSurveyQuestionOptionAggregateType<T extends SurveyQuestionOptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSurveyQuestionOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSurveyQuestionOption[P]>
      : GetScalarType<T[P], AggregateSurveyQuestionOption[P]>
  }




  export type SurveyQuestionOptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyQuestionOptionWhereInput
    orderBy?: SurveyQuestionOptionOrderByWithAggregationInput | SurveyQuestionOptionOrderByWithAggregationInput[]
    by: SurveyQuestionOptionScalarFieldEnum[] | SurveyQuestionOptionScalarFieldEnum
    having?: SurveyQuestionOptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SurveyQuestionOptionCountAggregateInputType | true
    _avg?: SurveyQuestionOptionAvgAggregateInputType
    _sum?: SurveyQuestionOptionSumAggregateInputType
    _min?: SurveyQuestionOptionMinAggregateInputType
    _max?: SurveyQuestionOptionMaxAggregateInputType
  }

  export type SurveyQuestionOptionGroupByOutputType = {
    id: string
    questionId: string
    valueKey: string
    label: string
    sortOrder: number
    isActive: boolean
    createdAt: Date
    _count: SurveyQuestionOptionCountAggregateOutputType | null
    _avg: SurveyQuestionOptionAvgAggregateOutputType | null
    _sum: SurveyQuestionOptionSumAggregateOutputType | null
    _min: SurveyQuestionOptionMinAggregateOutputType | null
    _max: SurveyQuestionOptionMaxAggregateOutputType | null
  }

  type GetSurveyQuestionOptionGroupByPayload<T extends SurveyQuestionOptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SurveyQuestionOptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SurveyQuestionOptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SurveyQuestionOptionGroupByOutputType[P]>
            : GetScalarType<T[P], SurveyQuestionOptionGroupByOutputType[P]>
        }
      >
    >


  export type SurveyQuestionOptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionId?: boolean
    valueKey?: boolean
    label?: boolean
    sortOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    question?: boolean | SurveyQuestionDefaultArgs<ExtArgs>
    responseItemOptions?: boolean | SurveyQuestionOption$responseItemOptionsArgs<ExtArgs>
    selectedByResponseItems?: boolean | SurveyQuestionOption$selectedByResponseItemsArgs<ExtArgs>
    _count?: boolean | SurveyQuestionOptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["surveyQuestionOption"]>

  export type SurveyQuestionOptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionId?: boolean
    valueKey?: boolean
    label?: boolean
    sortOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    question?: boolean | SurveyQuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["surveyQuestionOption"]>

  export type SurveyQuestionOptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionId?: boolean
    valueKey?: boolean
    label?: boolean
    sortOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    question?: boolean | SurveyQuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["surveyQuestionOption"]>

  export type SurveyQuestionOptionSelectScalar = {
    id?: boolean
    questionId?: boolean
    valueKey?: boolean
    label?: boolean
    sortOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type SurveyQuestionOptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "questionId" | "valueKey" | "label" | "sortOrder" | "isActive" | "createdAt", ExtArgs["result"]["surveyQuestionOption"]>
  export type SurveyQuestionOptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | SurveyQuestionDefaultArgs<ExtArgs>
    responseItemOptions?: boolean | SurveyQuestionOption$responseItemOptionsArgs<ExtArgs>
    selectedByResponseItems?: boolean | SurveyQuestionOption$selectedByResponseItemsArgs<ExtArgs>
    _count?: boolean | SurveyQuestionOptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SurveyQuestionOptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | SurveyQuestionDefaultArgs<ExtArgs>
  }
  export type SurveyQuestionOptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | SurveyQuestionDefaultArgs<ExtArgs>
  }

  export type $SurveyQuestionOptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SurveyQuestionOption"
    objects: {
      question: Prisma.$SurveyQuestionPayload<ExtArgs>
      responseItemOptions: Prisma.$SurveyResponseItemOptionPayload<ExtArgs>[]
      selectedByResponseItems: Prisma.$SurveyResponseItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      questionId: string
      valueKey: string
      label: string
      sortOrder: number
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["surveyQuestionOption"]>
    composites: {}
  }

  type SurveyQuestionOptionGetPayload<S extends boolean | null | undefined | SurveyQuestionOptionDefaultArgs> = $Result.GetResult<Prisma.$SurveyQuestionOptionPayload, S>

  type SurveyQuestionOptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SurveyQuestionOptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SurveyQuestionOptionCountAggregateInputType | true
    }

  export interface SurveyQuestionOptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SurveyQuestionOption'], meta: { name: 'SurveyQuestionOption' } }
    /**
     * Find zero or one SurveyQuestionOption that matches the filter.
     * @param {SurveyQuestionOptionFindUniqueArgs} args - Arguments to find a SurveyQuestionOption
     * @example
     * // Get one SurveyQuestionOption
     * const surveyQuestionOption = await prisma.surveyQuestionOption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SurveyQuestionOptionFindUniqueArgs>(args: SelectSubset<T, SurveyQuestionOptionFindUniqueArgs<ExtArgs>>): Prisma__SurveyQuestionOptionClient<$Result.GetResult<Prisma.$SurveyQuestionOptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SurveyQuestionOption that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SurveyQuestionOptionFindUniqueOrThrowArgs} args - Arguments to find a SurveyQuestionOption
     * @example
     * // Get one SurveyQuestionOption
     * const surveyQuestionOption = await prisma.surveyQuestionOption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SurveyQuestionOptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SurveyQuestionOptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SurveyQuestionOptionClient<$Result.GetResult<Prisma.$SurveyQuestionOptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SurveyQuestionOption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyQuestionOptionFindFirstArgs} args - Arguments to find a SurveyQuestionOption
     * @example
     * // Get one SurveyQuestionOption
     * const surveyQuestionOption = await prisma.surveyQuestionOption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SurveyQuestionOptionFindFirstArgs>(args?: SelectSubset<T, SurveyQuestionOptionFindFirstArgs<ExtArgs>>): Prisma__SurveyQuestionOptionClient<$Result.GetResult<Prisma.$SurveyQuestionOptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SurveyQuestionOption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyQuestionOptionFindFirstOrThrowArgs} args - Arguments to find a SurveyQuestionOption
     * @example
     * // Get one SurveyQuestionOption
     * const surveyQuestionOption = await prisma.surveyQuestionOption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SurveyQuestionOptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SurveyQuestionOptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SurveyQuestionOptionClient<$Result.GetResult<Prisma.$SurveyQuestionOptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SurveyQuestionOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyQuestionOptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SurveyQuestionOptions
     * const surveyQuestionOptions = await prisma.surveyQuestionOption.findMany()
     * 
     * // Get first 10 SurveyQuestionOptions
     * const surveyQuestionOptions = await prisma.surveyQuestionOption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const surveyQuestionOptionWithIdOnly = await prisma.surveyQuestionOption.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SurveyQuestionOptionFindManyArgs>(args?: SelectSubset<T, SurveyQuestionOptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyQuestionOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SurveyQuestionOption.
     * @param {SurveyQuestionOptionCreateArgs} args - Arguments to create a SurveyQuestionOption.
     * @example
     * // Create one SurveyQuestionOption
     * const SurveyQuestionOption = await prisma.surveyQuestionOption.create({
     *   data: {
     *     // ... data to create a SurveyQuestionOption
     *   }
     * })
     * 
     */
    create<T extends SurveyQuestionOptionCreateArgs>(args: SelectSubset<T, SurveyQuestionOptionCreateArgs<ExtArgs>>): Prisma__SurveyQuestionOptionClient<$Result.GetResult<Prisma.$SurveyQuestionOptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SurveyQuestionOptions.
     * @param {SurveyQuestionOptionCreateManyArgs} args - Arguments to create many SurveyQuestionOptions.
     * @example
     * // Create many SurveyQuestionOptions
     * const surveyQuestionOption = await prisma.surveyQuestionOption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SurveyQuestionOptionCreateManyArgs>(args?: SelectSubset<T, SurveyQuestionOptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SurveyQuestionOptions and returns the data saved in the database.
     * @param {SurveyQuestionOptionCreateManyAndReturnArgs} args - Arguments to create many SurveyQuestionOptions.
     * @example
     * // Create many SurveyQuestionOptions
     * const surveyQuestionOption = await prisma.surveyQuestionOption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SurveyQuestionOptions and only return the `id`
     * const surveyQuestionOptionWithIdOnly = await prisma.surveyQuestionOption.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SurveyQuestionOptionCreateManyAndReturnArgs>(args?: SelectSubset<T, SurveyQuestionOptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyQuestionOptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SurveyQuestionOption.
     * @param {SurveyQuestionOptionDeleteArgs} args - Arguments to delete one SurveyQuestionOption.
     * @example
     * // Delete one SurveyQuestionOption
     * const SurveyQuestionOption = await prisma.surveyQuestionOption.delete({
     *   where: {
     *     // ... filter to delete one SurveyQuestionOption
     *   }
     * })
     * 
     */
    delete<T extends SurveyQuestionOptionDeleteArgs>(args: SelectSubset<T, SurveyQuestionOptionDeleteArgs<ExtArgs>>): Prisma__SurveyQuestionOptionClient<$Result.GetResult<Prisma.$SurveyQuestionOptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SurveyQuestionOption.
     * @param {SurveyQuestionOptionUpdateArgs} args - Arguments to update one SurveyQuestionOption.
     * @example
     * // Update one SurveyQuestionOption
     * const surveyQuestionOption = await prisma.surveyQuestionOption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SurveyQuestionOptionUpdateArgs>(args: SelectSubset<T, SurveyQuestionOptionUpdateArgs<ExtArgs>>): Prisma__SurveyQuestionOptionClient<$Result.GetResult<Prisma.$SurveyQuestionOptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SurveyQuestionOptions.
     * @param {SurveyQuestionOptionDeleteManyArgs} args - Arguments to filter SurveyQuestionOptions to delete.
     * @example
     * // Delete a few SurveyQuestionOptions
     * const { count } = await prisma.surveyQuestionOption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SurveyQuestionOptionDeleteManyArgs>(args?: SelectSubset<T, SurveyQuestionOptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SurveyQuestionOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyQuestionOptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SurveyQuestionOptions
     * const surveyQuestionOption = await prisma.surveyQuestionOption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SurveyQuestionOptionUpdateManyArgs>(args: SelectSubset<T, SurveyQuestionOptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SurveyQuestionOptions and returns the data updated in the database.
     * @param {SurveyQuestionOptionUpdateManyAndReturnArgs} args - Arguments to update many SurveyQuestionOptions.
     * @example
     * // Update many SurveyQuestionOptions
     * const surveyQuestionOption = await prisma.surveyQuestionOption.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SurveyQuestionOptions and only return the `id`
     * const surveyQuestionOptionWithIdOnly = await prisma.surveyQuestionOption.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SurveyQuestionOptionUpdateManyAndReturnArgs>(args: SelectSubset<T, SurveyQuestionOptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyQuestionOptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SurveyQuestionOption.
     * @param {SurveyQuestionOptionUpsertArgs} args - Arguments to update or create a SurveyQuestionOption.
     * @example
     * // Update or create a SurveyQuestionOption
     * const surveyQuestionOption = await prisma.surveyQuestionOption.upsert({
     *   create: {
     *     // ... data to create a SurveyQuestionOption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SurveyQuestionOption we want to update
     *   }
     * })
     */
    upsert<T extends SurveyQuestionOptionUpsertArgs>(args: SelectSubset<T, SurveyQuestionOptionUpsertArgs<ExtArgs>>): Prisma__SurveyQuestionOptionClient<$Result.GetResult<Prisma.$SurveyQuestionOptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SurveyQuestionOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyQuestionOptionCountArgs} args - Arguments to filter SurveyQuestionOptions to count.
     * @example
     * // Count the number of SurveyQuestionOptions
     * const count = await prisma.surveyQuestionOption.count({
     *   where: {
     *     // ... the filter for the SurveyQuestionOptions we want to count
     *   }
     * })
    **/
    count<T extends SurveyQuestionOptionCountArgs>(
      args?: Subset<T, SurveyQuestionOptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SurveyQuestionOptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SurveyQuestionOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyQuestionOptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SurveyQuestionOptionAggregateArgs>(args: Subset<T, SurveyQuestionOptionAggregateArgs>): Prisma.PrismaPromise<GetSurveyQuestionOptionAggregateType<T>>

    /**
     * Group by SurveyQuestionOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyQuestionOptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SurveyQuestionOptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SurveyQuestionOptionGroupByArgs['orderBy'] }
        : { orderBy?: SurveyQuestionOptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SurveyQuestionOptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSurveyQuestionOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SurveyQuestionOption model
   */
  readonly fields: SurveyQuestionOptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SurveyQuestionOption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SurveyQuestionOptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    question<T extends SurveyQuestionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SurveyQuestionDefaultArgs<ExtArgs>>): Prisma__SurveyQuestionClient<$Result.GetResult<Prisma.$SurveyQuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    responseItemOptions<T extends SurveyQuestionOption$responseItemOptionsArgs<ExtArgs> = {}>(args?: Subset<T, SurveyQuestionOption$responseItemOptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyResponseItemOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    selectedByResponseItems<T extends SurveyQuestionOption$selectedByResponseItemsArgs<ExtArgs> = {}>(args?: Subset<T, SurveyQuestionOption$selectedByResponseItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyResponseItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SurveyQuestionOption model
   */
  interface SurveyQuestionOptionFieldRefs {
    readonly id: FieldRef<"SurveyQuestionOption", 'String'>
    readonly questionId: FieldRef<"SurveyQuestionOption", 'String'>
    readonly valueKey: FieldRef<"SurveyQuestionOption", 'String'>
    readonly label: FieldRef<"SurveyQuestionOption", 'String'>
    readonly sortOrder: FieldRef<"SurveyQuestionOption", 'Int'>
    readonly isActive: FieldRef<"SurveyQuestionOption", 'Boolean'>
    readonly createdAt: FieldRef<"SurveyQuestionOption", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SurveyQuestionOption findUnique
   */
  export type SurveyQuestionOptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyQuestionOption
     */
    select?: SurveyQuestionOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyQuestionOption
     */
    omit?: SurveyQuestionOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyQuestionOptionInclude<ExtArgs> | null
    /**
     * Filter, which SurveyQuestionOption to fetch.
     */
    where: SurveyQuestionOptionWhereUniqueInput
  }

  /**
   * SurveyQuestionOption findUniqueOrThrow
   */
  export type SurveyQuestionOptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyQuestionOption
     */
    select?: SurveyQuestionOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyQuestionOption
     */
    omit?: SurveyQuestionOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyQuestionOptionInclude<ExtArgs> | null
    /**
     * Filter, which SurveyQuestionOption to fetch.
     */
    where: SurveyQuestionOptionWhereUniqueInput
  }

  /**
   * SurveyQuestionOption findFirst
   */
  export type SurveyQuestionOptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyQuestionOption
     */
    select?: SurveyQuestionOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyQuestionOption
     */
    omit?: SurveyQuestionOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyQuestionOptionInclude<ExtArgs> | null
    /**
     * Filter, which SurveyQuestionOption to fetch.
     */
    where?: SurveyQuestionOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyQuestionOptions to fetch.
     */
    orderBy?: SurveyQuestionOptionOrderByWithRelationInput | SurveyQuestionOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SurveyQuestionOptions.
     */
    cursor?: SurveyQuestionOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyQuestionOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyQuestionOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SurveyQuestionOptions.
     */
    distinct?: SurveyQuestionOptionScalarFieldEnum | SurveyQuestionOptionScalarFieldEnum[]
  }

  /**
   * SurveyQuestionOption findFirstOrThrow
   */
  export type SurveyQuestionOptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyQuestionOption
     */
    select?: SurveyQuestionOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyQuestionOption
     */
    omit?: SurveyQuestionOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyQuestionOptionInclude<ExtArgs> | null
    /**
     * Filter, which SurveyQuestionOption to fetch.
     */
    where?: SurveyQuestionOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyQuestionOptions to fetch.
     */
    orderBy?: SurveyQuestionOptionOrderByWithRelationInput | SurveyQuestionOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SurveyQuestionOptions.
     */
    cursor?: SurveyQuestionOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyQuestionOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyQuestionOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SurveyQuestionOptions.
     */
    distinct?: SurveyQuestionOptionScalarFieldEnum | SurveyQuestionOptionScalarFieldEnum[]
  }

  /**
   * SurveyQuestionOption findMany
   */
  export type SurveyQuestionOptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyQuestionOption
     */
    select?: SurveyQuestionOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyQuestionOption
     */
    omit?: SurveyQuestionOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyQuestionOptionInclude<ExtArgs> | null
    /**
     * Filter, which SurveyQuestionOptions to fetch.
     */
    where?: SurveyQuestionOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyQuestionOptions to fetch.
     */
    orderBy?: SurveyQuestionOptionOrderByWithRelationInput | SurveyQuestionOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SurveyQuestionOptions.
     */
    cursor?: SurveyQuestionOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyQuestionOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyQuestionOptions.
     */
    skip?: number
    distinct?: SurveyQuestionOptionScalarFieldEnum | SurveyQuestionOptionScalarFieldEnum[]
  }

  /**
   * SurveyQuestionOption create
   */
  export type SurveyQuestionOptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyQuestionOption
     */
    select?: SurveyQuestionOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyQuestionOption
     */
    omit?: SurveyQuestionOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyQuestionOptionInclude<ExtArgs> | null
    /**
     * The data needed to create a SurveyQuestionOption.
     */
    data: XOR<SurveyQuestionOptionCreateInput, SurveyQuestionOptionUncheckedCreateInput>
  }

  /**
   * SurveyQuestionOption createMany
   */
  export type SurveyQuestionOptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SurveyQuestionOptions.
     */
    data: SurveyQuestionOptionCreateManyInput | SurveyQuestionOptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SurveyQuestionOption createManyAndReturn
   */
  export type SurveyQuestionOptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyQuestionOption
     */
    select?: SurveyQuestionOptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyQuestionOption
     */
    omit?: SurveyQuestionOptionOmit<ExtArgs> | null
    /**
     * The data used to create many SurveyQuestionOptions.
     */
    data: SurveyQuestionOptionCreateManyInput | SurveyQuestionOptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyQuestionOptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SurveyQuestionOption update
   */
  export type SurveyQuestionOptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyQuestionOption
     */
    select?: SurveyQuestionOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyQuestionOption
     */
    omit?: SurveyQuestionOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyQuestionOptionInclude<ExtArgs> | null
    /**
     * The data needed to update a SurveyQuestionOption.
     */
    data: XOR<SurveyQuestionOptionUpdateInput, SurveyQuestionOptionUncheckedUpdateInput>
    /**
     * Choose, which SurveyQuestionOption to update.
     */
    where: SurveyQuestionOptionWhereUniqueInput
  }

  /**
   * SurveyQuestionOption updateMany
   */
  export type SurveyQuestionOptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SurveyQuestionOptions.
     */
    data: XOR<SurveyQuestionOptionUpdateManyMutationInput, SurveyQuestionOptionUncheckedUpdateManyInput>
    /**
     * Filter which SurveyQuestionOptions to update
     */
    where?: SurveyQuestionOptionWhereInput
    /**
     * Limit how many SurveyQuestionOptions to update.
     */
    limit?: number
  }

  /**
   * SurveyQuestionOption updateManyAndReturn
   */
  export type SurveyQuestionOptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyQuestionOption
     */
    select?: SurveyQuestionOptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyQuestionOption
     */
    omit?: SurveyQuestionOptionOmit<ExtArgs> | null
    /**
     * The data used to update SurveyQuestionOptions.
     */
    data: XOR<SurveyQuestionOptionUpdateManyMutationInput, SurveyQuestionOptionUncheckedUpdateManyInput>
    /**
     * Filter which SurveyQuestionOptions to update
     */
    where?: SurveyQuestionOptionWhereInput
    /**
     * Limit how many SurveyQuestionOptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyQuestionOptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SurveyQuestionOption upsert
   */
  export type SurveyQuestionOptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyQuestionOption
     */
    select?: SurveyQuestionOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyQuestionOption
     */
    omit?: SurveyQuestionOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyQuestionOptionInclude<ExtArgs> | null
    /**
     * The filter to search for the SurveyQuestionOption to update in case it exists.
     */
    where: SurveyQuestionOptionWhereUniqueInput
    /**
     * In case the SurveyQuestionOption found by the `where` argument doesn't exist, create a new SurveyQuestionOption with this data.
     */
    create: XOR<SurveyQuestionOptionCreateInput, SurveyQuestionOptionUncheckedCreateInput>
    /**
     * In case the SurveyQuestionOption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SurveyQuestionOptionUpdateInput, SurveyQuestionOptionUncheckedUpdateInput>
  }

  /**
   * SurveyQuestionOption delete
   */
  export type SurveyQuestionOptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyQuestionOption
     */
    select?: SurveyQuestionOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyQuestionOption
     */
    omit?: SurveyQuestionOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyQuestionOptionInclude<ExtArgs> | null
    /**
     * Filter which SurveyQuestionOption to delete.
     */
    where: SurveyQuestionOptionWhereUniqueInput
  }

  /**
   * SurveyQuestionOption deleteMany
   */
  export type SurveyQuestionOptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SurveyQuestionOptions to delete
     */
    where?: SurveyQuestionOptionWhereInput
    /**
     * Limit how many SurveyQuestionOptions to delete.
     */
    limit?: number
  }

  /**
   * SurveyQuestionOption.responseItemOptions
   */
  export type SurveyQuestionOption$responseItemOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponseItemOption
     */
    select?: SurveyResponseItemOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyResponseItemOption
     */
    omit?: SurveyResponseItemOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseItemOptionInclude<ExtArgs> | null
    where?: SurveyResponseItemOptionWhereInput
    orderBy?: SurveyResponseItemOptionOrderByWithRelationInput | SurveyResponseItemOptionOrderByWithRelationInput[]
    cursor?: SurveyResponseItemOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SurveyResponseItemOptionScalarFieldEnum | SurveyResponseItemOptionScalarFieldEnum[]
  }

  /**
   * SurveyQuestionOption.selectedByResponseItems
   */
  export type SurveyQuestionOption$selectedByResponseItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponseItem
     */
    select?: SurveyResponseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyResponseItem
     */
    omit?: SurveyResponseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseItemInclude<ExtArgs> | null
    where?: SurveyResponseItemWhereInput
    orderBy?: SurveyResponseItemOrderByWithRelationInput | SurveyResponseItemOrderByWithRelationInput[]
    cursor?: SurveyResponseItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SurveyResponseItemScalarFieldEnum | SurveyResponseItemScalarFieldEnum[]
  }

  /**
   * SurveyQuestionOption without action
   */
  export type SurveyQuestionOptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyQuestionOption
     */
    select?: SurveyQuestionOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyQuestionOption
     */
    omit?: SurveyQuestionOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyQuestionOptionInclude<ExtArgs> | null
  }


  /**
   * Model SurveyResponse
   */

  export type AggregateSurveyResponse = {
    _count: SurveyResponseCountAggregateOutputType | null
    _min: SurveyResponseMinAggregateOutputType | null
    _max: SurveyResponseMaxAggregateOutputType | null
  }

  export type SurveyResponseMinAggregateOutputType = {
    id: string | null
    formId: string | null
    countyId: string | null
    sourceLabel: string | null
    submittedAt: Date | null
    ipHash: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type SurveyResponseMaxAggregateOutputType = {
    id: string | null
    formId: string | null
    countyId: string | null
    sourceLabel: string | null
    submittedAt: Date | null
    ipHash: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type SurveyResponseCountAggregateOutputType = {
    id: number
    formId: number
    countyId: number
    sourceLabel: number
    submittedAt: number
    ipHash: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type SurveyResponseMinAggregateInputType = {
    id?: true
    formId?: true
    countyId?: true
    sourceLabel?: true
    submittedAt?: true
    ipHash?: true
    userAgent?: true
    createdAt?: true
  }

  export type SurveyResponseMaxAggregateInputType = {
    id?: true
    formId?: true
    countyId?: true
    sourceLabel?: true
    submittedAt?: true
    ipHash?: true
    userAgent?: true
    createdAt?: true
  }

  export type SurveyResponseCountAggregateInputType = {
    id?: true
    formId?: true
    countyId?: true
    sourceLabel?: true
    submittedAt?: true
    ipHash?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type SurveyResponseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SurveyResponse to aggregate.
     */
    where?: SurveyResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyResponses to fetch.
     */
    orderBy?: SurveyResponseOrderByWithRelationInput | SurveyResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SurveyResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SurveyResponses
    **/
    _count?: true | SurveyResponseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SurveyResponseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SurveyResponseMaxAggregateInputType
  }

  export type GetSurveyResponseAggregateType<T extends SurveyResponseAggregateArgs> = {
        [P in keyof T & keyof AggregateSurveyResponse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSurveyResponse[P]>
      : GetScalarType<T[P], AggregateSurveyResponse[P]>
  }




  export type SurveyResponseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyResponseWhereInput
    orderBy?: SurveyResponseOrderByWithAggregationInput | SurveyResponseOrderByWithAggregationInput[]
    by: SurveyResponseScalarFieldEnum[] | SurveyResponseScalarFieldEnum
    having?: SurveyResponseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SurveyResponseCountAggregateInputType | true
    _min?: SurveyResponseMinAggregateInputType
    _max?: SurveyResponseMaxAggregateInputType
  }

  export type SurveyResponseGroupByOutputType = {
    id: string
    formId: string
    countyId: string | null
    sourceLabel: string | null
    submittedAt: Date
    ipHash: string | null
    userAgent: string | null
    createdAt: Date
    _count: SurveyResponseCountAggregateOutputType | null
    _min: SurveyResponseMinAggregateOutputType | null
    _max: SurveyResponseMaxAggregateOutputType | null
  }

  type GetSurveyResponseGroupByPayload<T extends SurveyResponseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SurveyResponseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SurveyResponseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SurveyResponseGroupByOutputType[P]>
            : GetScalarType<T[P], SurveyResponseGroupByOutputType[P]>
        }
      >
    >


  export type SurveyResponseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    formId?: boolean
    countyId?: boolean
    sourceLabel?: boolean
    submittedAt?: boolean
    ipHash?: boolean
    userAgent?: boolean
    createdAt?: boolean
    form?: boolean | SurveyFormDefaultArgs<ExtArgs>
    county?: boolean | SurveyResponse$countyArgs<ExtArgs>
    items?: boolean | SurveyResponse$itemsArgs<ExtArgs>
    _count?: boolean | SurveyResponseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["surveyResponse"]>

  export type SurveyResponseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    formId?: boolean
    countyId?: boolean
    sourceLabel?: boolean
    submittedAt?: boolean
    ipHash?: boolean
    userAgent?: boolean
    createdAt?: boolean
    form?: boolean | SurveyFormDefaultArgs<ExtArgs>
    county?: boolean | SurveyResponse$countyArgs<ExtArgs>
  }, ExtArgs["result"]["surveyResponse"]>

  export type SurveyResponseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    formId?: boolean
    countyId?: boolean
    sourceLabel?: boolean
    submittedAt?: boolean
    ipHash?: boolean
    userAgent?: boolean
    createdAt?: boolean
    form?: boolean | SurveyFormDefaultArgs<ExtArgs>
    county?: boolean | SurveyResponse$countyArgs<ExtArgs>
  }, ExtArgs["result"]["surveyResponse"]>

  export type SurveyResponseSelectScalar = {
    id?: boolean
    formId?: boolean
    countyId?: boolean
    sourceLabel?: boolean
    submittedAt?: boolean
    ipHash?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type SurveyResponseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "formId" | "countyId" | "sourceLabel" | "submittedAt" | "ipHash" | "userAgent" | "createdAt", ExtArgs["result"]["surveyResponse"]>
  export type SurveyResponseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    form?: boolean | SurveyFormDefaultArgs<ExtArgs>
    county?: boolean | SurveyResponse$countyArgs<ExtArgs>
    items?: boolean | SurveyResponse$itemsArgs<ExtArgs>
    _count?: boolean | SurveyResponseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SurveyResponseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    form?: boolean | SurveyFormDefaultArgs<ExtArgs>
    county?: boolean | SurveyResponse$countyArgs<ExtArgs>
  }
  export type SurveyResponseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    form?: boolean | SurveyFormDefaultArgs<ExtArgs>
    county?: boolean | SurveyResponse$countyArgs<ExtArgs>
  }

  export type $SurveyResponsePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SurveyResponse"
    objects: {
      form: Prisma.$SurveyFormPayload<ExtArgs>
      county: Prisma.$CountyPayload<ExtArgs> | null
      items: Prisma.$SurveyResponseItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      formId: string
      countyId: string | null
      sourceLabel: string | null
      submittedAt: Date
      ipHash: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["surveyResponse"]>
    composites: {}
  }

  type SurveyResponseGetPayload<S extends boolean | null | undefined | SurveyResponseDefaultArgs> = $Result.GetResult<Prisma.$SurveyResponsePayload, S>

  type SurveyResponseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SurveyResponseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SurveyResponseCountAggregateInputType | true
    }

  export interface SurveyResponseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SurveyResponse'], meta: { name: 'SurveyResponse' } }
    /**
     * Find zero or one SurveyResponse that matches the filter.
     * @param {SurveyResponseFindUniqueArgs} args - Arguments to find a SurveyResponse
     * @example
     * // Get one SurveyResponse
     * const surveyResponse = await prisma.surveyResponse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SurveyResponseFindUniqueArgs>(args: SelectSubset<T, SurveyResponseFindUniqueArgs<ExtArgs>>): Prisma__SurveyResponseClient<$Result.GetResult<Prisma.$SurveyResponsePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SurveyResponse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SurveyResponseFindUniqueOrThrowArgs} args - Arguments to find a SurveyResponse
     * @example
     * // Get one SurveyResponse
     * const surveyResponse = await prisma.surveyResponse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SurveyResponseFindUniqueOrThrowArgs>(args: SelectSubset<T, SurveyResponseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SurveyResponseClient<$Result.GetResult<Prisma.$SurveyResponsePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SurveyResponse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyResponseFindFirstArgs} args - Arguments to find a SurveyResponse
     * @example
     * // Get one SurveyResponse
     * const surveyResponse = await prisma.surveyResponse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SurveyResponseFindFirstArgs>(args?: SelectSubset<T, SurveyResponseFindFirstArgs<ExtArgs>>): Prisma__SurveyResponseClient<$Result.GetResult<Prisma.$SurveyResponsePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SurveyResponse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyResponseFindFirstOrThrowArgs} args - Arguments to find a SurveyResponse
     * @example
     * // Get one SurveyResponse
     * const surveyResponse = await prisma.surveyResponse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SurveyResponseFindFirstOrThrowArgs>(args?: SelectSubset<T, SurveyResponseFindFirstOrThrowArgs<ExtArgs>>): Prisma__SurveyResponseClient<$Result.GetResult<Prisma.$SurveyResponsePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SurveyResponses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyResponseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SurveyResponses
     * const surveyResponses = await prisma.surveyResponse.findMany()
     * 
     * // Get first 10 SurveyResponses
     * const surveyResponses = await prisma.surveyResponse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const surveyResponseWithIdOnly = await prisma.surveyResponse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SurveyResponseFindManyArgs>(args?: SelectSubset<T, SurveyResponseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SurveyResponse.
     * @param {SurveyResponseCreateArgs} args - Arguments to create a SurveyResponse.
     * @example
     * // Create one SurveyResponse
     * const SurveyResponse = await prisma.surveyResponse.create({
     *   data: {
     *     // ... data to create a SurveyResponse
     *   }
     * })
     * 
     */
    create<T extends SurveyResponseCreateArgs>(args: SelectSubset<T, SurveyResponseCreateArgs<ExtArgs>>): Prisma__SurveyResponseClient<$Result.GetResult<Prisma.$SurveyResponsePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SurveyResponses.
     * @param {SurveyResponseCreateManyArgs} args - Arguments to create many SurveyResponses.
     * @example
     * // Create many SurveyResponses
     * const surveyResponse = await prisma.surveyResponse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SurveyResponseCreateManyArgs>(args?: SelectSubset<T, SurveyResponseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SurveyResponses and returns the data saved in the database.
     * @param {SurveyResponseCreateManyAndReturnArgs} args - Arguments to create many SurveyResponses.
     * @example
     * // Create many SurveyResponses
     * const surveyResponse = await prisma.surveyResponse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SurveyResponses and only return the `id`
     * const surveyResponseWithIdOnly = await prisma.surveyResponse.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SurveyResponseCreateManyAndReturnArgs>(args?: SelectSubset<T, SurveyResponseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyResponsePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SurveyResponse.
     * @param {SurveyResponseDeleteArgs} args - Arguments to delete one SurveyResponse.
     * @example
     * // Delete one SurveyResponse
     * const SurveyResponse = await prisma.surveyResponse.delete({
     *   where: {
     *     // ... filter to delete one SurveyResponse
     *   }
     * })
     * 
     */
    delete<T extends SurveyResponseDeleteArgs>(args: SelectSubset<T, SurveyResponseDeleteArgs<ExtArgs>>): Prisma__SurveyResponseClient<$Result.GetResult<Prisma.$SurveyResponsePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SurveyResponse.
     * @param {SurveyResponseUpdateArgs} args - Arguments to update one SurveyResponse.
     * @example
     * // Update one SurveyResponse
     * const surveyResponse = await prisma.surveyResponse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SurveyResponseUpdateArgs>(args: SelectSubset<T, SurveyResponseUpdateArgs<ExtArgs>>): Prisma__SurveyResponseClient<$Result.GetResult<Prisma.$SurveyResponsePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SurveyResponses.
     * @param {SurveyResponseDeleteManyArgs} args - Arguments to filter SurveyResponses to delete.
     * @example
     * // Delete a few SurveyResponses
     * const { count } = await prisma.surveyResponse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SurveyResponseDeleteManyArgs>(args?: SelectSubset<T, SurveyResponseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SurveyResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyResponseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SurveyResponses
     * const surveyResponse = await prisma.surveyResponse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SurveyResponseUpdateManyArgs>(args: SelectSubset<T, SurveyResponseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SurveyResponses and returns the data updated in the database.
     * @param {SurveyResponseUpdateManyAndReturnArgs} args - Arguments to update many SurveyResponses.
     * @example
     * // Update many SurveyResponses
     * const surveyResponse = await prisma.surveyResponse.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SurveyResponses and only return the `id`
     * const surveyResponseWithIdOnly = await prisma.surveyResponse.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SurveyResponseUpdateManyAndReturnArgs>(args: SelectSubset<T, SurveyResponseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyResponsePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SurveyResponse.
     * @param {SurveyResponseUpsertArgs} args - Arguments to update or create a SurveyResponse.
     * @example
     * // Update or create a SurveyResponse
     * const surveyResponse = await prisma.surveyResponse.upsert({
     *   create: {
     *     // ... data to create a SurveyResponse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SurveyResponse we want to update
     *   }
     * })
     */
    upsert<T extends SurveyResponseUpsertArgs>(args: SelectSubset<T, SurveyResponseUpsertArgs<ExtArgs>>): Prisma__SurveyResponseClient<$Result.GetResult<Prisma.$SurveyResponsePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SurveyResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyResponseCountArgs} args - Arguments to filter SurveyResponses to count.
     * @example
     * // Count the number of SurveyResponses
     * const count = await prisma.surveyResponse.count({
     *   where: {
     *     // ... the filter for the SurveyResponses we want to count
     *   }
     * })
    **/
    count<T extends SurveyResponseCountArgs>(
      args?: Subset<T, SurveyResponseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SurveyResponseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SurveyResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyResponseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SurveyResponseAggregateArgs>(args: Subset<T, SurveyResponseAggregateArgs>): Prisma.PrismaPromise<GetSurveyResponseAggregateType<T>>

    /**
     * Group by SurveyResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyResponseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SurveyResponseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SurveyResponseGroupByArgs['orderBy'] }
        : { orderBy?: SurveyResponseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SurveyResponseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSurveyResponseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SurveyResponse model
   */
  readonly fields: SurveyResponseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SurveyResponse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SurveyResponseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    form<T extends SurveyFormDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SurveyFormDefaultArgs<ExtArgs>>): Prisma__SurveyFormClient<$Result.GetResult<Prisma.$SurveyFormPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    county<T extends SurveyResponse$countyArgs<ExtArgs> = {}>(args?: Subset<T, SurveyResponse$countyArgs<ExtArgs>>): Prisma__CountyClient<$Result.GetResult<Prisma.$CountyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    items<T extends SurveyResponse$itemsArgs<ExtArgs> = {}>(args?: Subset<T, SurveyResponse$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyResponseItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SurveyResponse model
   */
  interface SurveyResponseFieldRefs {
    readonly id: FieldRef<"SurveyResponse", 'String'>
    readonly formId: FieldRef<"SurveyResponse", 'String'>
    readonly countyId: FieldRef<"SurveyResponse", 'String'>
    readonly sourceLabel: FieldRef<"SurveyResponse", 'String'>
    readonly submittedAt: FieldRef<"SurveyResponse", 'DateTime'>
    readonly ipHash: FieldRef<"SurveyResponse", 'String'>
    readonly userAgent: FieldRef<"SurveyResponse", 'String'>
    readonly createdAt: FieldRef<"SurveyResponse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SurveyResponse findUnique
   */
  export type SurveyResponseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponse
     */
    select?: SurveyResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyResponse
     */
    omit?: SurveyResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseInclude<ExtArgs> | null
    /**
     * Filter, which SurveyResponse to fetch.
     */
    where: SurveyResponseWhereUniqueInput
  }

  /**
   * SurveyResponse findUniqueOrThrow
   */
  export type SurveyResponseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponse
     */
    select?: SurveyResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyResponse
     */
    omit?: SurveyResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseInclude<ExtArgs> | null
    /**
     * Filter, which SurveyResponse to fetch.
     */
    where: SurveyResponseWhereUniqueInput
  }

  /**
   * SurveyResponse findFirst
   */
  export type SurveyResponseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponse
     */
    select?: SurveyResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyResponse
     */
    omit?: SurveyResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseInclude<ExtArgs> | null
    /**
     * Filter, which SurveyResponse to fetch.
     */
    where?: SurveyResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyResponses to fetch.
     */
    orderBy?: SurveyResponseOrderByWithRelationInput | SurveyResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SurveyResponses.
     */
    cursor?: SurveyResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SurveyResponses.
     */
    distinct?: SurveyResponseScalarFieldEnum | SurveyResponseScalarFieldEnum[]
  }

  /**
   * SurveyResponse findFirstOrThrow
   */
  export type SurveyResponseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponse
     */
    select?: SurveyResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyResponse
     */
    omit?: SurveyResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseInclude<ExtArgs> | null
    /**
     * Filter, which SurveyResponse to fetch.
     */
    where?: SurveyResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyResponses to fetch.
     */
    orderBy?: SurveyResponseOrderByWithRelationInput | SurveyResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SurveyResponses.
     */
    cursor?: SurveyResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SurveyResponses.
     */
    distinct?: SurveyResponseScalarFieldEnum | SurveyResponseScalarFieldEnum[]
  }

  /**
   * SurveyResponse findMany
   */
  export type SurveyResponseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponse
     */
    select?: SurveyResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyResponse
     */
    omit?: SurveyResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseInclude<ExtArgs> | null
    /**
     * Filter, which SurveyResponses to fetch.
     */
    where?: SurveyResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyResponses to fetch.
     */
    orderBy?: SurveyResponseOrderByWithRelationInput | SurveyResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SurveyResponses.
     */
    cursor?: SurveyResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyResponses.
     */
    skip?: number
    distinct?: SurveyResponseScalarFieldEnum | SurveyResponseScalarFieldEnum[]
  }

  /**
   * SurveyResponse create
   */
  export type SurveyResponseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponse
     */
    select?: SurveyResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyResponse
     */
    omit?: SurveyResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseInclude<ExtArgs> | null
    /**
     * The data needed to create a SurveyResponse.
     */
    data: XOR<SurveyResponseCreateInput, SurveyResponseUncheckedCreateInput>
  }

  /**
   * SurveyResponse createMany
   */
  export type SurveyResponseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SurveyResponses.
     */
    data: SurveyResponseCreateManyInput | SurveyResponseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SurveyResponse createManyAndReturn
   */
  export type SurveyResponseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponse
     */
    select?: SurveyResponseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyResponse
     */
    omit?: SurveyResponseOmit<ExtArgs> | null
    /**
     * The data used to create many SurveyResponses.
     */
    data: SurveyResponseCreateManyInput | SurveyResponseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SurveyResponse update
   */
  export type SurveyResponseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponse
     */
    select?: SurveyResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyResponse
     */
    omit?: SurveyResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseInclude<ExtArgs> | null
    /**
     * The data needed to update a SurveyResponse.
     */
    data: XOR<SurveyResponseUpdateInput, SurveyResponseUncheckedUpdateInput>
    /**
     * Choose, which SurveyResponse to update.
     */
    where: SurveyResponseWhereUniqueInput
  }

  /**
   * SurveyResponse updateMany
   */
  export type SurveyResponseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SurveyResponses.
     */
    data: XOR<SurveyResponseUpdateManyMutationInput, SurveyResponseUncheckedUpdateManyInput>
    /**
     * Filter which SurveyResponses to update
     */
    where?: SurveyResponseWhereInput
    /**
     * Limit how many SurveyResponses to update.
     */
    limit?: number
  }

  /**
   * SurveyResponse updateManyAndReturn
   */
  export type SurveyResponseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponse
     */
    select?: SurveyResponseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyResponse
     */
    omit?: SurveyResponseOmit<ExtArgs> | null
    /**
     * The data used to update SurveyResponses.
     */
    data: XOR<SurveyResponseUpdateManyMutationInput, SurveyResponseUncheckedUpdateManyInput>
    /**
     * Filter which SurveyResponses to update
     */
    where?: SurveyResponseWhereInput
    /**
     * Limit how many SurveyResponses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SurveyResponse upsert
   */
  export type SurveyResponseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponse
     */
    select?: SurveyResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyResponse
     */
    omit?: SurveyResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseInclude<ExtArgs> | null
    /**
     * The filter to search for the SurveyResponse to update in case it exists.
     */
    where: SurveyResponseWhereUniqueInput
    /**
     * In case the SurveyResponse found by the `where` argument doesn't exist, create a new SurveyResponse with this data.
     */
    create: XOR<SurveyResponseCreateInput, SurveyResponseUncheckedCreateInput>
    /**
     * In case the SurveyResponse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SurveyResponseUpdateInput, SurveyResponseUncheckedUpdateInput>
  }

  /**
   * SurveyResponse delete
   */
  export type SurveyResponseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponse
     */
    select?: SurveyResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyResponse
     */
    omit?: SurveyResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseInclude<ExtArgs> | null
    /**
     * Filter which SurveyResponse to delete.
     */
    where: SurveyResponseWhereUniqueInput
  }

  /**
   * SurveyResponse deleteMany
   */
  export type SurveyResponseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SurveyResponses to delete
     */
    where?: SurveyResponseWhereInput
    /**
     * Limit how many SurveyResponses to delete.
     */
    limit?: number
  }

  /**
   * SurveyResponse.county
   */
  export type SurveyResponse$countyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the County
     */
    select?: CountySelect<ExtArgs> | null
    /**
     * Omit specific fields from the County
     */
    omit?: CountyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountyInclude<ExtArgs> | null
    where?: CountyWhereInput
  }

  /**
   * SurveyResponse.items
   */
  export type SurveyResponse$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponseItem
     */
    select?: SurveyResponseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyResponseItem
     */
    omit?: SurveyResponseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseItemInclude<ExtArgs> | null
    where?: SurveyResponseItemWhereInput
    orderBy?: SurveyResponseItemOrderByWithRelationInput | SurveyResponseItemOrderByWithRelationInput[]
    cursor?: SurveyResponseItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SurveyResponseItemScalarFieldEnum | SurveyResponseItemScalarFieldEnum[]
  }

  /**
   * SurveyResponse without action
   */
  export type SurveyResponseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponse
     */
    select?: SurveyResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyResponse
     */
    omit?: SurveyResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseInclude<ExtArgs> | null
  }


  /**
   * Model SurveyResponseItem
   */

  export type AggregateSurveyResponseItem = {
    _count: SurveyResponseItemCountAggregateOutputType | null
    _avg: SurveyResponseItemAvgAggregateOutputType | null
    _sum: SurveyResponseItemSumAggregateOutputType | null
    _min: SurveyResponseItemMinAggregateOutputType | null
    _max: SurveyResponseItemMaxAggregateOutputType | null
  }

  export type SurveyResponseItemAvgAggregateOutputType = {
    valueNumber: number | null
  }

  export type SurveyResponseItemSumAggregateOutputType = {
    valueNumber: number | null
  }

  export type SurveyResponseItemMinAggregateOutputType = {
    id: string | null
    responseId: string | null
    questionId: string | null
    valueText: string | null
    valueNumber: number | null
    valueBoolean: boolean | null
    selectedOptionId: string | null
    mediaAssetId: string | null
    createdAt: Date | null
  }

  export type SurveyResponseItemMaxAggregateOutputType = {
    id: string | null
    responseId: string | null
    questionId: string | null
    valueText: string | null
    valueNumber: number | null
    valueBoolean: boolean | null
    selectedOptionId: string | null
    mediaAssetId: string | null
    createdAt: Date | null
  }

  export type SurveyResponseItemCountAggregateOutputType = {
    id: number
    responseId: number
    questionId: number
    valueText: number
    valueNumber: number
    valueBoolean: number
    selectedOptionId: number
    mediaAssetId: number
    createdAt: number
    _all: number
  }


  export type SurveyResponseItemAvgAggregateInputType = {
    valueNumber?: true
  }

  export type SurveyResponseItemSumAggregateInputType = {
    valueNumber?: true
  }

  export type SurveyResponseItemMinAggregateInputType = {
    id?: true
    responseId?: true
    questionId?: true
    valueText?: true
    valueNumber?: true
    valueBoolean?: true
    selectedOptionId?: true
    mediaAssetId?: true
    createdAt?: true
  }

  export type SurveyResponseItemMaxAggregateInputType = {
    id?: true
    responseId?: true
    questionId?: true
    valueText?: true
    valueNumber?: true
    valueBoolean?: true
    selectedOptionId?: true
    mediaAssetId?: true
    createdAt?: true
  }

  export type SurveyResponseItemCountAggregateInputType = {
    id?: true
    responseId?: true
    questionId?: true
    valueText?: true
    valueNumber?: true
    valueBoolean?: true
    selectedOptionId?: true
    mediaAssetId?: true
    createdAt?: true
    _all?: true
  }

  export type SurveyResponseItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SurveyResponseItem to aggregate.
     */
    where?: SurveyResponseItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyResponseItems to fetch.
     */
    orderBy?: SurveyResponseItemOrderByWithRelationInput | SurveyResponseItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SurveyResponseItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyResponseItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyResponseItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SurveyResponseItems
    **/
    _count?: true | SurveyResponseItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SurveyResponseItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SurveyResponseItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SurveyResponseItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SurveyResponseItemMaxAggregateInputType
  }

  export type GetSurveyResponseItemAggregateType<T extends SurveyResponseItemAggregateArgs> = {
        [P in keyof T & keyof AggregateSurveyResponseItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSurveyResponseItem[P]>
      : GetScalarType<T[P], AggregateSurveyResponseItem[P]>
  }




  export type SurveyResponseItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyResponseItemWhereInput
    orderBy?: SurveyResponseItemOrderByWithAggregationInput | SurveyResponseItemOrderByWithAggregationInput[]
    by: SurveyResponseItemScalarFieldEnum[] | SurveyResponseItemScalarFieldEnum
    having?: SurveyResponseItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SurveyResponseItemCountAggregateInputType | true
    _avg?: SurveyResponseItemAvgAggregateInputType
    _sum?: SurveyResponseItemSumAggregateInputType
    _min?: SurveyResponseItemMinAggregateInputType
    _max?: SurveyResponseItemMaxAggregateInputType
  }

  export type SurveyResponseItemGroupByOutputType = {
    id: string
    responseId: string
    questionId: string
    valueText: string | null
    valueNumber: number | null
    valueBoolean: boolean | null
    selectedOptionId: string | null
    mediaAssetId: string | null
    createdAt: Date
    _count: SurveyResponseItemCountAggregateOutputType | null
    _avg: SurveyResponseItemAvgAggregateOutputType | null
    _sum: SurveyResponseItemSumAggregateOutputType | null
    _min: SurveyResponseItemMinAggregateOutputType | null
    _max: SurveyResponseItemMaxAggregateOutputType | null
  }

  type GetSurveyResponseItemGroupByPayload<T extends SurveyResponseItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SurveyResponseItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SurveyResponseItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SurveyResponseItemGroupByOutputType[P]>
            : GetScalarType<T[P], SurveyResponseItemGroupByOutputType[P]>
        }
      >
    >


  export type SurveyResponseItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    responseId?: boolean
    questionId?: boolean
    valueText?: boolean
    valueNumber?: boolean
    valueBoolean?: boolean
    selectedOptionId?: boolean
    mediaAssetId?: boolean
    createdAt?: boolean
    response?: boolean | SurveyResponseDefaultArgs<ExtArgs>
    question?: boolean | SurveyQuestionDefaultArgs<ExtArgs>
    selectedOption?: boolean | SurveyResponseItem$selectedOptionArgs<ExtArgs>
    mediaAsset?: boolean | SurveyResponseItem$mediaAssetArgs<ExtArgs>
    multiSelectedOptions?: boolean | SurveyResponseItem$multiSelectedOptionsArgs<ExtArgs>
    _count?: boolean | SurveyResponseItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["surveyResponseItem"]>

  export type SurveyResponseItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    responseId?: boolean
    questionId?: boolean
    valueText?: boolean
    valueNumber?: boolean
    valueBoolean?: boolean
    selectedOptionId?: boolean
    mediaAssetId?: boolean
    createdAt?: boolean
    response?: boolean | SurveyResponseDefaultArgs<ExtArgs>
    question?: boolean | SurveyQuestionDefaultArgs<ExtArgs>
    selectedOption?: boolean | SurveyResponseItem$selectedOptionArgs<ExtArgs>
    mediaAsset?: boolean | SurveyResponseItem$mediaAssetArgs<ExtArgs>
  }, ExtArgs["result"]["surveyResponseItem"]>

  export type SurveyResponseItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    responseId?: boolean
    questionId?: boolean
    valueText?: boolean
    valueNumber?: boolean
    valueBoolean?: boolean
    selectedOptionId?: boolean
    mediaAssetId?: boolean
    createdAt?: boolean
    response?: boolean | SurveyResponseDefaultArgs<ExtArgs>
    question?: boolean | SurveyQuestionDefaultArgs<ExtArgs>
    selectedOption?: boolean | SurveyResponseItem$selectedOptionArgs<ExtArgs>
    mediaAsset?: boolean | SurveyResponseItem$mediaAssetArgs<ExtArgs>
  }, ExtArgs["result"]["surveyResponseItem"]>

  export type SurveyResponseItemSelectScalar = {
    id?: boolean
    responseId?: boolean
    questionId?: boolean
    valueText?: boolean
    valueNumber?: boolean
    valueBoolean?: boolean
    selectedOptionId?: boolean
    mediaAssetId?: boolean
    createdAt?: boolean
  }

  export type SurveyResponseItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "responseId" | "questionId" | "valueText" | "valueNumber" | "valueBoolean" | "selectedOptionId" | "mediaAssetId" | "createdAt", ExtArgs["result"]["surveyResponseItem"]>
  export type SurveyResponseItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    response?: boolean | SurveyResponseDefaultArgs<ExtArgs>
    question?: boolean | SurveyQuestionDefaultArgs<ExtArgs>
    selectedOption?: boolean | SurveyResponseItem$selectedOptionArgs<ExtArgs>
    mediaAsset?: boolean | SurveyResponseItem$mediaAssetArgs<ExtArgs>
    multiSelectedOptions?: boolean | SurveyResponseItem$multiSelectedOptionsArgs<ExtArgs>
    _count?: boolean | SurveyResponseItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SurveyResponseItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    response?: boolean | SurveyResponseDefaultArgs<ExtArgs>
    question?: boolean | SurveyQuestionDefaultArgs<ExtArgs>
    selectedOption?: boolean | SurveyResponseItem$selectedOptionArgs<ExtArgs>
    mediaAsset?: boolean | SurveyResponseItem$mediaAssetArgs<ExtArgs>
  }
  export type SurveyResponseItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    response?: boolean | SurveyResponseDefaultArgs<ExtArgs>
    question?: boolean | SurveyQuestionDefaultArgs<ExtArgs>
    selectedOption?: boolean | SurveyResponseItem$selectedOptionArgs<ExtArgs>
    mediaAsset?: boolean | SurveyResponseItem$mediaAssetArgs<ExtArgs>
  }

  export type $SurveyResponseItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SurveyResponseItem"
    objects: {
      response: Prisma.$SurveyResponsePayload<ExtArgs>
      question: Prisma.$SurveyQuestionPayload<ExtArgs>
      selectedOption: Prisma.$SurveyQuestionOptionPayload<ExtArgs> | null
      mediaAsset: Prisma.$MediaAssetPayload<ExtArgs> | null
      multiSelectedOptions: Prisma.$SurveyResponseItemOptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      responseId: string
      questionId: string
      valueText: string | null
      valueNumber: number | null
      valueBoolean: boolean | null
      selectedOptionId: string | null
      mediaAssetId: string | null
      createdAt: Date
    }, ExtArgs["result"]["surveyResponseItem"]>
    composites: {}
  }

  type SurveyResponseItemGetPayload<S extends boolean | null | undefined | SurveyResponseItemDefaultArgs> = $Result.GetResult<Prisma.$SurveyResponseItemPayload, S>

  type SurveyResponseItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SurveyResponseItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SurveyResponseItemCountAggregateInputType | true
    }

  export interface SurveyResponseItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SurveyResponseItem'], meta: { name: 'SurveyResponseItem' } }
    /**
     * Find zero or one SurveyResponseItem that matches the filter.
     * @param {SurveyResponseItemFindUniqueArgs} args - Arguments to find a SurveyResponseItem
     * @example
     * // Get one SurveyResponseItem
     * const surveyResponseItem = await prisma.surveyResponseItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SurveyResponseItemFindUniqueArgs>(args: SelectSubset<T, SurveyResponseItemFindUniqueArgs<ExtArgs>>): Prisma__SurveyResponseItemClient<$Result.GetResult<Prisma.$SurveyResponseItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SurveyResponseItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SurveyResponseItemFindUniqueOrThrowArgs} args - Arguments to find a SurveyResponseItem
     * @example
     * // Get one SurveyResponseItem
     * const surveyResponseItem = await prisma.surveyResponseItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SurveyResponseItemFindUniqueOrThrowArgs>(args: SelectSubset<T, SurveyResponseItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SurveyResponseItemClient<$Result.GetResult<Prisma.$SurveyResponseItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SurveyResponseItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyResponseItemFindFirstArgs} args - Arguments to find a SurveyResponseItem
     * @example
     * // Get one SurveyResponseItem
     * const surveyResponseItem = await prisma.surveyResponseItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SurveyResponseItemFindFirstArgs>(args?: SelectSubset<T, SurveyResponseItemFindFirstArgs<ExtArgs>>): Prisma__SurveyResponseItemClient<$Result.GetResult<Prisma.$SurveyResponseItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SurveyResponseItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyResponseItemFindFirstOrThrowArgs} args - Arguments to find a SurveyResponseItem
     * @example
     * // Get one SurveyResponseItem
     * const surveyResponseItem = await prisma.surveyResponseItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SurveyResponseItemFindFirstOrThrowArgs>(args?: SelectSubset<T, SurveyResponseItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__SurveyResponseItemClient<$Result.GetResult<Prisma.$SurveyResponseItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SurveyResponseItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyResponseItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SurveyResponseItems
     * const surveyResponseItems = await prisma.surveyResponseItem.findMany()
     * 
     * // Get first 10 SurveyResponseItems
     * const surveyResponseItems = await prisma.surveyResponseItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const surveyResponseItemWithIdOnly = await prisma.surveyResponseItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SurveyResponseItemFindManyArgs>(args?: SelectSubset<T, SurveyResponseItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyResponseItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SurveyResponseItem.
     * @param {SurveyResponseItemCreateArgs} args - Arguments to create a SurveyResponseItem.
     * @example
     * // Create one SurveyResponseItem
     * const SurveyResponseItem = await prisma.surveyResponseItem.create({
     *   data: {
     *     // ... data to create a SurveyResponseItem
     *   }
     * })
     * 
     */
    create<T extends SurveyResponseItemCreateArgs>(args: SelectSubset<T, SurveyResponseItemCreateArgs<ExtArgs>>): Prisma__SurveyResponseItemClient<$Result.GetResult<Prisma.$SurveyResponseItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SurveyResponseItems.
     * @param {SurveyResponseItemCreateManyArgs} args - Arguments to create many SurveyResponseItems.
     * @example
     * // Create many SurveyResponseItems
     * const surveyResponseItem = await prisma.surveyResponseItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SurveyResponseItemCreateManyArgs>(args?: SelectSubset<T, SurveyResponseItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SurveyResponseItems and returns the data saved in the database.
     * @param {SurveyResponseItemCreateManyAndReturnArgs} args - Arguments to create many SurveyResponseItems.
     * @example
     * // Create many SurveyResponseItems
     * const surveyResponseItem = await prisma.surveyResponseItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SurveyResponseItems and only return the `id`
     * const surveyResponseItemWithIdOnly = await prisma.surveyResponseItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SurveyResponseItemCreateManyAndReturnArgs>(args?: SelectSubset<T, SurveyResponseItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyResponseItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SurveyResponseItem.
     * @param {SurveyResponseItemDeleteArgs} args - Arguments to delete one SurveyResponseItem.
     * @example
     * // Delete one SurveyResponseItem
     * const SurveyResponseItem = await prisma.surveyResponseItem.delete({
     *   where: {
     *     // ... filter to delete one SurveyResponseItem
     *   }
     * })
     * 
     */
    delete<T extends SurveyResponseItemDeleteArgs>(args: SelectSubset<T, SurveyResponseItemDeleteArgs<ExtArgs>>): Prisma__SurveyResponseItemClient<$Result.GetResult<Prisma.$SurveyResponseItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SurveyResponseItem.
     * @param {SurveyResponseItemUpdateArgs} args - Arguments to update one SurveyResponseItem.
     * @example
     * // Update one SurveyResponseItem
     * const surveyResponseItem = await prisma.surveyResponseItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SurveyResponseItemUpdateArgs>(args: SelectSubset<T, SurveyResponseItemUpdateArgs<ExtArgs>>): Prisma__SurveyResponseItemClient<$Result.GetResult<Prisma.$SurveyResponseItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SurveyResponseItems.
     * @param {SurveyResponseItemDeleteManyArgs} args - Arguments to filter SurveyResponseItems to delete.
     * @example
     * // Delete a few SurveyResponseItems
     * const { count } = await prisma.surveyResponseItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SurveyResponseItemDeleteManyArgs>(args?: SelectSubset<T, SurveyResponseItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SurveyResponseItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyResponseItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SurveyResponseItems
     * const surveyResponseItem = await prisma.surveyResponseItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SurveyResponseItemUpdateManyArgs>(args: SelectSubset<T, SurveyResponseItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SurveyResponseItems and returns the data updated in the database.
     * @param {SurveyResponseItemUpdateManyAndReturnArgs} args - Arguments to update many SurveyResponseItems.
     * @example
     * // Update many SurveyResponseItems
     * const surveyResponseItem = await prisma.surveyResponseItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SurveyResponseItems and only return the `id`
     * const surveyResponseItemWithIdOnly = await prisma.surveyResponseItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SurveyResponseItemUpdateManyAndReturnArgs>(args: SelectSubset<T, SurveyResponseItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyResponseItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SurveyResponseItem.
     * @param {SurveyResponseItemUpsertArgs} args - Arguments to update or create a SurveyResponseItem.
     * @example
     * // Update or create a SurveyResponseItem
     * const surveyResponseItem = await prisma.surveyResponseItem.upsert({
     *   create: {
     *     // ... data to create a SurveyResponseItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SurveyResponseItem we want to update
     *   }
     * })
     */
    upsert<T extends SurveyResponseItemUpsertArgs>(args: SelectSubset<T, SurveyResponseItemUpsertArgs<ExtArgs>>): Prisma__SurveyResponseItemClient<$Result.GetResult<Prisma.$SurveyResponseItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SurveyResponseItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyResponseItemCountArgs} args - Arguments to filter SurveyResponseItems to count.
     * @example
     * // Count the number of SurveyResponseItems
     * const count = await prisma.surveyResponseItem.count({
     *   where: {
     *     // ... the filter for the SurveyResponseItems we want to count
     *   }
     * })
    **/
    count<T extends SurveyResponseItemCountArgs>(
      args?: Subset<T, SurveyResponseItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SurveyResponseItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SurveyResponseItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyResponseItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SurveyResponseItemAggregateArgs>(args: Subset<T, SurveyResponseItemAggregateArgs>): Prisma.PrismaPromise<GetSurveyResponseItemAggregateType<T>>

    /**
     * Group by SurveyResponseItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyResponseItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SurveyResponseItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SurveyResponseItemGroupByArgs['orderBy'] }
        : { orderBy?: SurveyResponseItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SurveyResponseItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSurveyResponseItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SurveyResponseItem model
   */
  readonly fields: SurveyResponseItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SurveyResponseItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SurveyResponseItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    response<T extends SurveyResponseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SurveyResponseDefaultArgs<ExtArgs>>): Prisma__SurveyResponseClient<$Result.GetResult<Prisma.$SurveyResponsePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    question<T extends SurveyQuestionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SurveyQuestionDefaultArgs<ExtArgs>>): Prisma__SurveyQuestionClient<$Result.GetResult<Prisma.$SurveyQuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    selectedOption<T extends SurveyResponseItem$selectedOptionArgs<ExtArgs> = {}>(args?: Subset<T, SurveyResponseItem$selectedOptionArgs<ExtArgs>>): Prisma__SurveyQuestionOptionClient<$Result.GetResult<Prisma.$SurveyQuestionOptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    mediaAsset<T extends SurveyResponseItem$mediaAssetArgs<ExtArgs> = {}>(args?: Subset<T, SurveyResponseItem$mediaAssetArgs<ExtArgs>>): Prisma__MediaAssetClient<$Result.GetResult<Prisma.$MediaAssetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    multiSelectedOptions<T extends SurveyResponseItem$multiSelectedOptionsArgs<ExtArgs> = {}>(args?: Subset<T, SurveyResponseItem$multiSelectedOptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyResponseItemOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SurveyResponseItem model
   */
  interface SurveyResponseItemFieldRefs {
    readonly id: FieldRef<"SurveyResponseItem", 'String'>
    readonly responseId: FieldRef<"SurveyResponseItem", 'String'>
    readonly questionId: FieldRef<"SurveyResponseItem", 'String'>
    readonly valueText: FieldRef<"SurveyResponseItem", 'String'>
    readonly valueNumber: FieldRef<"SurveyResponseItem", 'Float'>
    readonly valueBoolean: FieldRef<"SurveyResponseItem", 'Boolean'>
    readonly selectedOptionId: FieldRef<"SurveyResponseItem", 'String'>
    readonly mediaAssetId: FieldRef<"SurveyResponseItem", 'String'>
    readonly createdAt: FieldRef<"SurveyResponseItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SurveyResponseItem findUnique
   */
  export type SurveyResponseItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponseItem
     */
    select?: SurveyResponseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyResponseItem
     */
    omit?: SurveyResponseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseItemInclude<ExtArgs> | null
    /**
     * Filter, which SurveyResponseItem to fetch.
     */
    where: SurveyResponseItemWhereUniqueInput
  }

  /**
   * SurveyResponseItem findUniqueOrThrow
   */
  export type SurveyResponseItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponseItem
     */
    select?: SurveyResponseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyResponseItem
     */
    omit?: SurveyResponseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseItemInclude<ExtArgs> | null
    /**
     * Filter, which SurveyResponseItem to fetch.
     */
    where: SurveyResponseItemWhereUniqueInput
  }

  /**
   * SurveyResponseItem findFirst
   */
  export type SurveyResponseItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponseItem
     */
    select?: SurveyResponseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyResponseItem
     */
    omit?: SurveyResponseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseItemInclude<ExtArgs> | null
    /**
     * Filter, which SurveyResponseItem to fetch.
     */
    where?: SurveyResponseItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyResponseItems to fetch.
     */
    orderBy?: SurveyResponseItemOrderByWithRelationInput | SurveyResponseItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SurveyResponseItems.
     */
    cursor?: SurveyResponseItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyResponseItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyResponseItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SurveyResponseItems.
     */
    distinct?: SurveyResponseItemScalarFieldEnum | SurveyResponseItemScalarFieldEnum[]
  }

  /**
   * SurveyResponseItem findFirstOrThrow
   */
  export type SurveyResponseItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponseItem
     */
    select?: SurveyResponseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyResponseItem
     */
    omit?: SurveyResponseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseItemInclude<ExtArgs> | null
    /**
     * Filter, which SurveyResponseItem to fetch.
     */
    where?: SurveyResponseItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyResponseItems to fetch.
     */
    orderBy?: SurveyResponseItemOrderByWithRelationInput | SurveyResponseItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SurveyResponseItems.
     */
    cursor?: SurveyResponseItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyResponseItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyResponseItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SurveyResponseItems.
     */
    distinct?: SurveyResponseItemScalarFieldEnum | SurveyResponseItemScalarFieldEnum[]
  }

  /**
   * SurveyResponseItem findMany
   */
  export type SurveyResponseItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponseItem
     */
    select?: SurveyResponseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyResponseItem
     */
    omit?: SurveyResponseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseItemInclude<ExtArgs> | null
    /**
     * Filter, which SurveyResponseItems to fetch.
     */
    where?: SurveyResponseItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyResponseItems to fetch.
     */
    orderBy?: SurveyResponseItemOrderByWithRelationInput | SurveyResponseItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SurveyResponseItems.
     */
    cursor?: SurveyResponseItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyResponseItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyResponseItems.
     */
    skip?: number
    distinct?: SurveyResponseItemScalarFieldEnum | SurveyResponseItemScalarFieldEnum[]
  }

  /**
   * SurveyResponseItem create
   */
  export type SurveyResponseItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponseItem
     */
    select?: SurveyResponseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyResponseItem
     */
    omit?: SurveyResponseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseItemInclude<ExtArgs> | null
    /**
     * The data needed to create a SurveyResponseItem.
     */
    data: XOR<SurveyResponseItemCreateInput, SurveyResponseItemUncheckedCreateInput>
  }

  /**
   * SurveyResponseItem createMany
   */
  export type SurveyResponseItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SurveyResponseItems.
     */
    data: SurveyResponseItemCreateManyInput | SurveyResponseItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SurveyResponseItem createManyAndReturn
   */
  export type SurveyResponseItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponseItem
     */
    select?: SurveyResponseItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyResponseItem
     */
    omit?: SurveyResponseItemOmit<ExtArgs> | null
    /**
     * The data used to create many SurveyResponseItems.
     */
    data: SurveyResponseItemCreateManyInput | SurveyResponseItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SurveyResponseItem update
   */
  export type SurveyResponseItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponseItem
     */
    select?: SurveyResponseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyResponseItem
     */
    omit?: SurveyResponseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseItemInclude<ExtArgs> | null
    /**
     * The data needed to update a SurveyResponseItem.
     */
    data: XOR<SurveyResponseItemUpdateInput, SurveyResponseItemUncheckedUpdateInput>
    /**
     * Choose, which SurveyResponseItem to update.
     */
    where: SurveyResponseItemWhereUniqueInput
  }

  /**
   * SurveyResponseItem updateMany
   */
  export type SurveyResponseItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SurveyResponseItems.
     */
    data: XOR<SurveyResponseItemUpdateManyMutationInput, SurveyResponseItemUncheckedUpdateManyInput>
    /**
     * Filter which SurveyResponseItems to update
     */
    where?: SurveyResponseItemWhereInput
    /**
     * Limit how many SurveyResponseItems to update.
     */
    limit?: number
  }

  /**
   * SurveyResponseItem updateManyAndReturn
   */
  export type SurveyResponseItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponseItem
     */
    select?: SurveyResponseItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyResponseItem
     */
    omit?: SurveyResponseItemOmit<ExtArgs> | null
    /**
     * The data used to update SurveyResponseItems.
     */
    data: XOR<SurveyResponseItemUpdateManyMutationInput, SurveyResponseItemUncheckedUpdateManyInput>
    /**
     * Filter which SurveyResponseItems to update
     */
    where?: SurveyResponseItemWhereInput
    /**
     * Limit how many SurveyResponseItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SurveyResponseItem upsert
   */
  export type SurveyResponseItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponseItem
     */
    select?: SurveyResponseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyResponseItem
     */
    omit?: SurveyResponseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseItemInclude<ExtArgs> | null
    /**
     * The filter to search for the SurveyResponseItem to update in case it exists.
     */
    where: SurveyResponseItemWhereUniqueInput
    /**
     * In case the SurveyResponseItem found by the `where` argument doesn't exist, create a new SurveyResponseItem with this data.
     */
    create: XOR<SurveyResponseItemCreateInput, SurveyResponseItemUncheckedCreateInput>
    /**
     * In case the SurveyResponseItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SurveyResponseItemUpdateInput, SurveyResponseItemUncheckedUpdateInput>
  }

  /**
   * SurveyResponseItem delete
   */
  export type SurveyResponseItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponseItem
     */
    select?: SurveyResponseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyResponseItem
     */
    omit?: SurveyResponseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseItemInclude<ExtArgs> | null
    /**
     * Filter which SurveyResponseItem to delete.
     */
    where: SurveyResponseItemWhereUniqueInput
  }

  /**
   * SurveyResponseItem deleteMany
   */
  export type SurveyResponseItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SurveyResponseItems to delete
     */
    where?: SurveyResponseItemWhereInput
    /**
     * Limit how many SurveyResponseItems to delete.
     */
    limit?: number
  }

  /**
   * SurveyResponseItem.selectedOption
   */
  export type SurveyResponseItem$selectedOptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyQuestionOption
     */
    select?: SurveyQuestionOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyQuestionOption
     */
    omit?: SurveyQuestionOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyQuestionOptionInclude<ExtArgs> | null
    where?: SurveyQuestionOptionWhereInput
  }

  /**
   * SurveyResponseItem.mediaAsset
   */
  export type SurveyResponseItem$mediaAssetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAsset
     */
    select?: MediaAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaAsset
     */
    omit?: MediaAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAssetInclude<ExtArgs> | null
    where?: MediaAssetWhereInput
  }

  /**
   * SurveyResponseItem.multiSelectedOptions
   */
  export type SurveyResponseItem$multiSelectedOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponseItemOption
     */
    select?: SurveyResponseItemOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyResponseItemOption
     */
    omit?: SurveyResponseItemOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseItemOptionInclude<ExtArgs> | null
    where?: SurveyResponseItemOptionWhereInput
    orderBy?: SurveyResponseItemOptionOrderByWithRelationInput | SurveyResponseItemOptionOrderByWithRelationInput[]
    cursor?: SurveyResponseItemOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SurveyResponseItemOptionScalarFieldEnum | SurveyResponseItemOptionScalarFieldEnum[]
  }

  /**
   * SurveyResponseItem without action
   */
  export type SurveyResponseItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponseItem
     */
    select?: SurveyResponseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyResponseItem
     */
    omit?: SurveyResponseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseItemInclude<ExtArgs> | null
  }


  /**
   * Model SurveyResponseItemOption
   */

  export type AggregateSurveyResponseItemOption = {
    _count: SurveyResponseItemOptionCountAggregateOutputType | null
    _min: SurveyResponseItemOptionMinAggregateOutputType | null
    _max: SurveyResponseItemOptionMaxAggregateOutputType | null
  }

  export type SurveyResponseItemOptionMinAggregateOutputType = {
    id: string | null
    responseItemId: string | null
    optionId: string | null
    createdAt: Date | null
  }

  export type SurveyResponseItemOptionMaxAggregateOutputType = {
    id: string | null
    responseItemId: string | null
    optionId: string | null
    createdAt: Date | null
  }

  export type SurveyResponseItemOptionCountAggregateOutputType = {
    id: number
    responseItemId: number
    optionId: number
    createdAt: number
    _all: number
  }


  export type SurveyResponseItemOptionMinAggregateInputType = {
    id?: true
    responseItemId?: true
    optionId?: true
    createdAt?: true
  }

  export type SurveyResponseItemOptionMaxAggregateInputType = {
    id?: true
    responseItemId?: true
    optionId?: true
    createdAt?: true
  }

  export type SurveyResponseItemOptionCountAggregateInputType = {
    id?: true
    responseItemId?: true
    optionId?: true
    createdAt?: true
    _all?: true
  }

  export type SurveyResponseItemOptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SurveyResponseItemOption to aggregate.
     */
    where?: SurveyResponseItemOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyResponseItemOptions to fetch.
     */
    orderBy?: SurveyResponseItemOptionOrderByWithRelationInput | SurveyResponseItemOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SurveyResponseItemOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyResponseItemOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyResponseItemOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SurveyResponseItemOptions
    **/
    _count?: true | SurveyResponseItemOptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SurveyResponseItemOptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SurveyResponseItemOptionMaxAggregateInputType
  }

  export type GetSurveyResponseItemOptionAggregateType<T extends SurveyResponseItemOptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSurveyResponseItemOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSurveyResponseItemOption[P]>
      : GetScalarType<T[P], AggregateSurveyResponseItemOption[P]>
  }




  export type SurveyResponseItemOptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyResponseItemOptionWhereInput
    orderBy?: SurveyResponseItemOptionOrderByWithAggregationInput | SurveyResponseItemOptionOrderByWithAggregationInput[]
    by: SurveyResponseItemOptionScalarFieldEnum[] | SurveyResponseItemOptionScalarFieldEnum
    having?: SurveyResponseItemOptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SurveyResponseItemOptionCountAggregateInputType | true
    _min?: SurveyResponseItemOptionMinAggregateInputType
    _max?: SurveyResponseItemOptionMaxAggregateInputType
  }

  export type SurveyResponseItemOptionGroupByOutputType = {
    id: string
    responseItemId: string
    optionId: string
    createdAt: Date
    _count: SurveyResponseItemOptionCountAggregateOutputType | null
    _min: SurveyResponseItemOptionMinAggregateOutputType | null
    _max: SurveyResponseItemOptionMaxAggregateOutputType | null
  }

  type GetSurveyResponseItemOptionGroupByPayload<T extends SurveyResponseItemOptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SurveyResponseItemOptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SurveyResponseItemOptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SurveyResponseItemOptionGroupByOutputType[P]>
            : GetScalarType<T[P], SurveyResponseItemOptionGroupByOutputType[P]>
        }
      >
    >


  export type SurveyResponseItemOptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    responseItemId?: boolean
    optionId?: boolean
    createdAt?: boolean
    responseItem?: boolean | SurveyResponseItemDefaultArgs<ExtArgs>
    option?: boolean | SurveyQuestionOptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["surveyResponseItemOption"]>

  export type SurveyResponseItemOptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    responseItemId?: boolean
    optionId?: boolean
    createdAt?: boolean
    responseItem?: boolean | SurveyResponseItemDefaultArgs<ExtArgs>
    option?: boolean | SurveyQuestionOptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["surveyResponseItemOption"]>

  export type SurveyResponseItemOptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    responseItemId?: boolean
    optionId?: boolean
    createdAt?: boolean
    responseItem?: boolean | SurveyResponseItemDefaultArgs<ExtArgs>
    option?: boolean | SurveyQuestionOptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["surveyResponseItemOption"]>

  export type SurveyResponseItemOptionSelectScalar = {
    id?: boolean
    responseItemId?: boolean
    optionId?: boolean
    createdAt?: boolean
  }

  export type SurveyResponseItemOptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "responseItemId" | "optionId" | "createdAt", ExtArgs["result"]["surveyResponseItemOption"]>
  export type SurveyResponseItemOptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responseItem?: boolean | SurveyResponseItemDefaultArgs<ExtArgs>
    option?: boolean | SurveyQuestionOptionDefaultArgs<ExtArgs>
  }
  export type SurveyResponseItemOptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responseItem?: boolean | SurveyResponseItemDefaultArgs<ExtArgs>
    option?: boolean | SurveyQuestionOptionDefaultArgs<ExtArgs>
  }
  export type SurveyResponseItemOptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responseItem?: boolean | SurveyResponseItemDefaultArgs<ExtArgs>
    option?: boolean | SurveyQuestionOptionDefaultArgs<ExtArgs>
  }

  export type $SurveyResponseItemOptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SurveyResponseItemOption"
    objects: {
      responseItem: Prisma.$SurveyResponseItemPayload<ExtArgs>
      option: Prisma.$SurveyQuestionOptionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      responseItemId: string
      optionId: string
      createdAt: Date
    }, ExtArgs["result"]["surveyResponseItemOption"]>
    composites: {}
  }

  type SurveyResponseItemOptionGetPayload<S extends boolean | null | undefined | SurveyResponseItemOptionDefaultArgs> = $Result.GetResult<Prisma.$SurveyResponseItemOptionPayload, S>

  type SurveyResponseItemOptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SurveyResponseItemOptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SurveyResponseItemOptionCountAggregateInputType | true
    }

  export interface SurveyResponseItemOptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SurveyResponseItemOption'], meta: { name: 'SurveyResponseItemOption' } }
    /**
     * Find zero or one SurveyResponseItemOption that matches the filter.
     * @param {SurveyResponseItemOptionFindUniqueArgs} args - Arguments to find a SurveyResponseItemOption
     * @example
     * // Get one SurveyResponseItemOption
     * const surveyResponseItemOption = await prisma.surveyResponseItemOption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SurveyResponseItemOptionFindUniqueArgs>(args: SelectSubset<T, SurveyResponseItemOptionFindUniqueArgs<ExtArgs>>): Prisma__SurveyResponseItemOptionClient<$Result.GetResult<Prisma.$SurveyResponseItemOptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SurveyResponseItemOption that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SurveyResponseItemOptionFindUniqueOrThrowArgs} args - Arguments to find a SurveyResponseItemOption
     * @example
     * // Get one SurveyResponseItemOption
     * const surveyResponseItemOption = await prisma.surveyResponseItemOption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SurveyResponseItemOptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SurveyResponseItemOptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SurveyResponseItemOptionClient<$Result.GetResult<Prisma.$SurveyResponseItemOptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SurveyResponseItemOption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyResponseItemOptionFindFirstArgs} args - Arguments to find a SurveyResponseItemOption
     * @example
     * // Get one SurveyResponseItemOption
     * const surveyResponseItemOption = await prisma.surveyResponseItemOption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SurveyResponseItemOptionFindFirstArgs>(args?: SelectSubset<T, SurveyResponseItemOptionFindFirstArgs<ExtArgs>>): Prisma__SurveyResponseItemOptionClient<$Result.GetResult<Prisma.$SurveyResponseItemOptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SurveyResponseItemOption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyResponseItemOptionFindFirstOrThrowArgs} args - Arguments to find a SurveyResponseItemOption
     * @example
     * // Get one SurveyResponseItemOption
     * const surveyResponseItemOption = await prisma.surveyResponseItemOption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SurveyResponseItemOptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SurveyResponseItemOptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SurveyResponseItemOptionClient<$Result.GetResult<Prisma.$SurveyResponseItemOptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SurveyResponseItemOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyResponseItemOptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SurveyResponseItemOptions
     * const surveyResponseItemOptions = await prisma.surveyResponseItemOption.findMany()
     * 
     * // Get first 10 SurveyResponseItemOptions
     * const surveyResponseItemOptions = await prisma.surveyResponseItemOption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const surveyResponseItemOptionWithIdOnly = await prisma.surveyResponseItemOption.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SurveyResponseItemOptionFindManyArgs>(args?: SelectSubset<T, SurveyResponseItemOptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyResponseItemOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SurveyResponseItemOption.
     * @param {SurveyResponseItemOptionCreateArgs} args - Arguments to create a SurveyResponseItemOption.
     * @example
     * // Create one SurveyResponseItemOption
     * const SurveyResponseItemOption = await prisma.surveyResponseItemOption.create({
     *   data: {
     *     // ... data to create a SurveyResponseItemOption
     *   }
     * })
     * 
     */
    create<T extends SurveyResponseItemOptionCreateArgs>(args: SelectSubset<T, SurveyResponseItemOptionCreateArgs<ExtArgs>>): Prisma__SurveyResponseItemOptionClient<$Result.GetResult<Prisma.$SurveyResponseItemOptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SurveyResponseItemOptions.
     * @param {SurveyResponseItemOptionCreateManyArgs} args - Arguments to create many SurveyResponseItemOptions.
     * @example
     * // Create many SurveyResponseItemOptions
     * const surveyResponseItemOption = await prisma.surveyResponseItemOption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SurveyResponseItemOptionCreateManyArgs>(args?: SelectSubset<T, SurveyResponseItemOptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SurveyResponseItemOptions and returns the data saved in the database.
     * @param {SurveyResponseItemOptionCreateManyAndReturnArgs} args - Arguments to create many SurveyResponseItemOptions.
     * @example
     * // Create many SurveyResponseItemOptions
     * const surveyResponseItemOption = await prisma.surveyResponseItemOption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SurveyResponseItemOptions and only return the `id`
     * const surveyResponseItemOptionWithIdOnly = await prisma.surveyResponseItemOption.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SurveyResponseItemOptionCreateManyAndReturnArgs>(args?: SelectSubset<T, SurveyResponseItemOptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyResponseItemOptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SurveyResponseItemOption.
     * @param {SurveyResponseItemOptionDeleteArgs} args - Arguments to delete one SurveyResponseItemOption.
     * @example
     * // Delete one SurveyResponseItemOption
     * const SurveyResponseItemOption = await prisma.surveyResponseItemOption.delete({
     *   where: {
     *     // ... filter to delete one SurveyResponseItemOption
     *   }
     * })
     * 
     */
    delete<T extends SurveyResponseItemOptionDeleteArgs>(args: SelectSubset<T, SurveyResponseItemOptionDeleteArgs<ExtArgs>>): Prisma__SurveyResponseItemOptionClient<$Result.GetResult<Prisma.$SurveyResponseItemOptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SurveyResponseItemOption.
     * @param {SurveyResponseItemOptionUpdateArgs} args - Arguments to update one SurveyResponseItemOption.
     * @example
     * // Update one SurveyResponseItemOption
     * const surveyResponseItemOption = await prisma.surveyResponseItemOption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SurveyResponseItemOptionUpdateArgs>(args: SelectSubset<T, SurveyResponseItemOptionUpdateArgs<ExtArgs>>): Prisma__SurveyResponseItemOptionClient<$Result.GetResult<Prisma.$SurveyResponseItemOptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SurveyResponseItemOptions.
     * @param {SurveyResponseItemOptionDeleteManyArgs} args - Arguments to filter SurveyResponseItemOptions to delete.
     * @example
     * // Delete a few SurveyResponseItemOptions
     * const { count } = await prisma.surveyResponseItemOption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SurveyResponseItemOptionDeleteManyArgs>(args?: SelectSubset<T, SurveyResponseItemOptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SurveyResponseItemOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyResponseItemOptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SurveyResponseItemOptions
     * const surveyResponseItemOption = await prisma.surveyResponseItemOption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SurveyResponseItemOptionUpdateManyArgs>(args: SelectSubset<T, SurveyResponseItemOptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SurveyResponseItemOptions and returns the data updated in the database.
     * @param {SurveyResponseItemOptionUpdateManyAndReturnArgs} args - Arguments to update many SurveyResponseItemOptions.
     * @example
     * // Update many SurveyResponseItemOptions
     * const surveyResponseItemOption = await prisma.surveyResponseItemOption.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SurveyResponseItemOptions and only return the `id`
     * const surveyResponseItemOptionWithIdOnly = await prisma.surveyResponseItemOption.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SurveyResponseItemOptionUpdateManyAndReturnArgs>(args: SelectSubset<T, SurveyResponseItemOptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyResponseItemOptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SurveyResponseItemOption.
     * @param {SurveyResponseItemOptionUpsertArgs} args - Arguments to update or create a SurveyResponseItemOption.
     * @example
     * // Update or create a SurveyResponseItemOption
     * const surveyResponseItemOption = await prisma.surveyResponseItemOption.upsert({
     *   create: {
     *     // ... data to create a SurveyResponseItemOption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SurveyResponseItemOption we want to update
     *   }
     * })
     */
    upsert<T extends SurveyResponseItemOptionUpsertArgs>(args: SelectSubset<T, SurveyResponseItemOptionUpsertArgs<ExtArgs>>): Prisma__SurveyResponseItemOptionClient<$Result.GetResult<Prisma.$SurveyResponseItemOptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SurveyResponseItemOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyResponseItemOptionCountArgs} args - Arguments to filter SurveyResponseItemOptions to count.
     * @example
     * // Count the number of SurveyResponseItemOptions
     * const count = await prisma.surveyResponseItemOption.count({
     *   where: {
     *     // ... the filter for the SurveyResponseItemOptions we want to count
     *   }
     * })
    **/
    count<T extends SurveyResponseItemOptionCountArgs>(
      args?: Subset<T, SurveyResponseItemOptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SurveyResponseItemOptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SurveyResponseItemOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyResponseItemOptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SurveyResponseItemOptionAggregateArgs>(args: Subset<T, SurveyResponseItemOptionAggregateArgs>): Prisma.PrismaPromise<GetSurveyResponseItemOptionAggregateType<T>>

    /**
     * Group by SurveyResponseItemOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyResponseItemOptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SurveyResponseItemOptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SurveyResponseItemOptionGroupByArgs['orderBy'] }
        : { orderBy?: SurveyResponseItemOptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SurveyResponseItemOptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSurveyResponseItemOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SurveyResponseItemOption model
   */
  readonly fields: SurveyResponseItemOptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SurveyResponseItemOption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SurveyResponseItemOptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    responseItem<T extends SurveyResponseItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SurveyResponseItemDefaultArgs<ExtArgs>>): Prisma__SurveyResponseItemClient<$Result.GetResult<Prisma.$SurveyResponseItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    option<T extends SurveyQuestionOptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SurveyQuestionOptionDefaultArgs<ExtArgs>>): Prisma__SurveyQuestionOptionClient<$Result.GetResult<Prisma.$SurveyQuestionOptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SurveyResponseItemOption model
   */
  interface SurveyResponseItemOptionFieldRefs {
    readonly id: FieldRef<"SurveyResponseItemOption", 'String'>
    readonly responseItemId: FieldRef<"SurveyResponseItemOption", 'String'>
    readonly optionId: FieldRef<"SurveyResponseItemOption", 'String'>
    readonly createdAt: FieldRef<"SurveyResponseItemOption", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SurveyResponseItemOption findUnique
   */
  export type SurveyResponseItemOptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponseItemOption
     */
    select?: SurveyResponseItemOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyResponseItemOption
     */
    omit?: SurveyResponseItemOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseItemOptionInclude<ExtArgs> | null
    /**
     * Filter, which SurveyResponseItemOption to fetch.
     */
    where: SurveyResponseItemOptionWhereUniqueInput
  }

  /**
   * SurveyResponseItemOption findUniqueOrThrow
   */
  export type SurveyResponseItemOptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponseItemOption
     */
    select?: SurveyResponseItemOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyResponseItemOption
     */
    omit?: SurveyResponseItemOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseItemOptionInclude<ExtArgs> | null
    /**
     * Filter, which SurveyResponseItemOption to fetch.
     */
    where: SurveyResponseItemOptionWhereUniqueInput
  }

  /**
   * SurveyResponseItemOption findFirst
   */
  export type SurveyResponseItemOptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponseItemOption
     */
    select?: SurveyResponseItemOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyResponseItemOption
     */
    omit?: SurveyResponseItemOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseItemOptionInclude<ExtArgs> | null
    /**
     * Filter, which SurveyResponseItemOption to fetch.
     */
    where?: SurveyResponseItemOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyResponseItemOptions to fetch.
     */
    orderBy?: SurveyResponseItemOptionOrderByWithRelationInput | SurveyResponseItemOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SurveyResponseItemOptions.
     */
    cursor?: SurveyResponseItemOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyResponseItemOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyResponseItemOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SurveyResponseItemOptions.
     */
    distinct?: SurveyResponseItemOptionScalarFieldEnum | SurveyResponseItemOptionScalarFieldEnum[]
  }

  /**
   * SurveyResponseItemOption findFirstOrThrow
   */
  export type SurveyResponseItemOptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponseItemOption
     */
    select?: SurveyResponseItemOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyResponseItemOption
     */
    omit?: SurveyResponseItemOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseItemOptionInclude<ExtArgs> | null
    /**
     * Filter, which SurveyResponseItemOption to fetch.
     */
    where?: SurveyResponseItemOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyResponseItemOptions to fetch.
     */
    orderBy?: SurveyResponseItemOptionOrderByWithRelationInput | SurveyResponseItemOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SurveyResponseItemOptions.
     */
    cursor?: SurveyResponseItemOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyResponseItemOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyResponseItemOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SurveyResponseItemOptions.
     */
    distinct?: SurveyResponseItemOptionScalarFieldEnum | SurveyResponseItemOptionScalarFieldEnum[]
  }

  /**
   * SurveyResponseItemOption findMany
   */
  export type SurveyResponseItemOptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponseItemOption
     */
    select?: SurveyResponseItemOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyResponseItemOption
     */
    omit?: SurveyResponseItemOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseItemOptionInclude<ExtArgs> | null
    /**
     * Filter, which SurveyResponseItemOptions to fetch.
     */
    where?: SurveyResponseItemOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyResponseItemOptions to fetch.
     */
    orderBy?: SurveyResponseItemOptionOrderByWithRelationInput | SurveyResponseItemOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SurveyResponseItemOptions.
     */
    cursor?: SurveyResponseItemOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyResponseItemOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyResponseItemOptions.
     */
    skip?: number
    distinct?: SurveyResponseItemOptionScalarFieldEnum | SurveyResponseItemOptionScalarFieldEnum[]
  }

  /**
   * SurveyResponseItemOption create
   */
  export type SurveyResponseItemOptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponseItemOption
     */
    select?: SurveyResponseItemOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyResponseItemOption
     */
    omit?: SurveyResponseItemOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseItemOptionInclude<ExtArgs> | null
    /**
     * The data needed to create a SurveyResponseItemOption.
     */
    data: XOR<SurveyResponseItemOptionCreateInput, SurveyResponseItemOptionUncheckedCreateInput>
  }

  /**
   * SurveyResponseItemOption createMany
   */
  export type SurveyResponseItemOptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SurveyResponseItemOptions.
     */
    data: SurveyResponseItemOptionCreateManyInput | SurveyResponseItemOptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SurveyResponseItemOption createManyAndReturn
   */
  export type SurveyResponseItemOptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponseItemOption
     */
    select?: SurveyResponseItemOptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyResponseItemOption
     */
    omit?: SurveyResponseItemOptionOmit<ExtArgs> | null
    /**
     * The data used to create many SurveyResponseItemOptions.
     */
    data: SurveyResponseItemOptionCreateManyInput | SurveyResponseItemOptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseItemOptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SurveyResponseItemOption update
   */
  export type SurveyResponseItemOptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponseItemOption
     */
    select?: SurveyResponseItemOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyResponseItemOption
     */
    omit?: SurveyResponseItemOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseItemOptionInclude<ExtArgs> | null
    /**
     * The data needed to update a SurveyResponseItemOption.
     */
    data: XOR<SurveyResponseItemOptionUpdateInput, SurveyResponseItemOptionUncheckedUpdateInput>
    /**
     * Choose, which SurveyResponseItemOption to update.
     */
    where: SurveyResponseItemOptionWhereUniqueInput
  }

  /**
   * SurveyResponseItemOption updateMany
   */
  export type SurveyResponseItemOptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SurveyResponseItemOptions.
     */
    data: XOR<SurveyResponseItemOptionUpdateManyMutationInput, SurveyResponseItemOptionUncheckedUpdateManyInput>
    /**
     * Filter which SurveyResponseItemOptions to update
     */
    where?: SurveyResponseItemOptionWhereInput
    /**
     * Limit how many SurveyResponseItemOptions to update.
     */
    limit?: number
  }

  /**
   * SurveyResponseItemOption updateManyAndReturn
   */
  export type SurveyResponseItemOptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponseItemOption
     */
    select?: SurveyResponseItemOptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyResponseItemOption
     */
    omit?: SurveyResponseItemOptionOmit<ExtArgs> | null
    /**
     * The data used to update SurveyResponseItemOptions.
     */
    data: XOR<SurveyResponseItemOptionUpdateManyMutationInput, SurveyResponseItemOptionUncheckedUpdateManyInput>
    /**
     * Filter which SurveyResponseItemOptions to update
     */
    where?: SurveyResponseItemOptionWhereInput
    /**
     * Limit how many SurveyResponseItemOptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseItemOptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SurveyResponseItemOption upsert
   */
  export type SurveyResponseItemOptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponseItemOption
     */
    select?: SurveyResponseItemOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyResponseItemOption
     */
    omit?: SurveyResponseItemOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseItemOptionInclude<ExtArgs> | null
    /**
     * The filter to search for the SurveyResponseItemOption to update in case it exists.
     */
    where: SurveyResponseItemOptionWhereUniqueInput
    /**
     * In case the SurveyResponseItemOption found by the `where` argument doesn't exist, create a new SurveyResponseItemOption with this data.
     */
    create: XOR<SurveyResponseItemOptionCreateInput, SurveyResponseItemOptionUncheckedCreateInput>
    /**
     * In case the SurveyResponseItemOption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SurveyResponseItemOptionUpdateInput, SurveyResponseItemOptionUncheckedUpdateInput>
  }

  /**
   * SurveyResponseItemOption delete
   */
  export type SurveyResponseItemOptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponseItemOption
     */
    select?: SurveyResponseItemOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyResponseItemOption
     */
    omit?: SurveyResponseItemOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseItemOptionInclude<ExtArgs> | null
    /**
     * Filter which SurveyResponseItemOption to delete.
     */
    where: SurveyResponseItemOptionWhereUniqueInput
  }

  /**
   * SurveyResponseItemOption deleteMany
   */
  export type SurveyResponseItemOptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SurveyResponseItemOptions to delete
     */
    where?: SurveyResponseItemOptionWhereInput
    /**
     * Limit how many SurveyResponseItemOptions to delete.
     */
    limit?: number
  }

  /**
   * SurveyResponseItemOption without action
   */
  export type SurveyResponseItemOptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponseItemOption
     */
    select?: SurveyResponseItemOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyResponseItemOption
     */
    omit?: SurveyResponseItemOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseItemOptionInclude<ExtArgs> | null
  }


  /**
   * Model MediaAsset
   */

  export type AggregateMediaAsset = {
    _count: MediaAssetCountAggregateOutputType | null
    _avg: MediaAssetAvgAggregateOutputType | null
    _sum: MediaAssetSumAggregateOutputType | null
    _min: MediaAssetMinAggregateOutputType | null
    _max: MediaAssetMaxAggregateOutputType | null
  }

  export type MediaAssetAvgAggregateOutputType = {
    sizeBytes: number | null
    durationMs: number | null
  }

  export type MediaAssetSumAggregateOutputType = {
    sizeBytes: number | null
    durationMs: number | null
  }

  export type MediaAssetMinAggregateOutputType = {
    id: string | null
    assetType: $Enums.AssetType | null
    storageProvider: string | null
    storageKey: string | null
    url: string | null
    mimeType: string | null
    sizeBytes: number | null
    durationMs: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MediaAssetMaxAggregateOutputType = {
    id: string | null
    assetType: $Enums.AssetType | null
    storageProvider: string | null
    storageKey: string | null
    url: string | null
    mimeType: string | null
    sizeBytes: number | null
    durationMs: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MediaAssetCountAggregateOutputType = {
    id: number
    assetType: number
    storageProvider: number
    storageKey: number
    url: number
    mimeType: number
    sizeBytes: number
    durationMs: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MediaAssetAvgAggregateInputType = {
    sizeBytes?: true
    durationMs?: true
  }

  export type MediaAssetSumAggregateInputType = {
    sizeBytes?: true
    durationMs?: true
  }

  export type MediaAssetMinAggregateInputType = {
    id?: true
    assetType?: true
    storageProvider?: true
    storageKey?: true
    url?: true
    mimeType?: true
    sizeBytes?: true
    durationMs?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MediaAssetMaxAggregateInputType = {
    id?: true
    assetType?: true
    storageProvider?: true
    storageKey?: true
    url?: true
    mimeType?: true
    sizeBytes?: true
    durationMs?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MediaAssetCountAggregateInputType = {
    id?: true
    assetType?: true
    storageProvider?: true
    storageKey?: true
    url?: true
    mimeType?: true
    sizeBytes?: true
    durationMs?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MediaAssetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MediaAsset to aggregate.
     */
    where?: MediaAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaAssets to fetch.
     */
    orderBy?: MediaAssetOrderByWithRelationInput | MediaAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MediaAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MediaAssets
    **/
    _count?: true | MediaAssetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MediaAssetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MediaAssetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MediaAssetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MediaAssetMaxAggregateInputType
  }

  export type GetMediaAssetAggregateType<T extends MediaAssetAggregateArgs> = {
        [P in keyof T & keyof AggregateMediaAsset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMediaAsset[P]>
      : GetScalarType<T[P], AggregateMediaAsset[P]>
  }




  export type MediaAssetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaAssetWhereInput
    orderBy?: MediaAssetOrderByWithAggregationInput | MediaAssetOrderByWithAggregationInput[]
    by: MediaAssetScalarFieldEnum[] | MediaAssetScalarFieldEnum
    having?: MediaAssetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MediaAssetCountAggregateInputType | true
    _avg?: MediaAssetAvgAggregateInputType
    _sum?: MediaAssetSumAggregateInputType
    _min?: MediaAssetMinAggregateInputType
    _max?: MediaAssetMaxAggregateInputType
  }

  export type MediaAssetGroupByOutputType = {
    id: string
    assetType: $Enums.AssetType
    storageProvider: string | null
    storageKey: string | null
    url: string | null
    mimeType: string | null
    sizeBytes: number | null
    durationMs: number | null
    createdAt: Date
    updatedAt: Date
    _count: MediaAssetCountAggregateOutputType | null
    _avg: MediaAssetAvgAggregateOutputType | null
    _sum: MediaAssetSumAggregateOutputType | null
    _min: MediaAssetMinAggregateOutputType | null
    _max: MediaAssetMaxAggregateOutputType | null
  }

  type GetMediaAssetGroupByPayload<T extends MediaAssetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MediaAssetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MediaAssetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MediaAssetGroupByOutputType[P]>
            : GetScalarType<T[P], MediaAssetGroupByOutputType[P]>
        }
      >
    >


  export type MediaAssetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assetType?: boolean
    storageProvider?: boolean
    storageKey?: boolean
    url?: boolean
    mimeType?: boolean
    sizeBytes?: boolean
    durationMs?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    surveyResponseItems?: boolean | MediaAsset$surveyResponseItemsArgs<ExtArgs>
    transcripts?: boolean | MediaAsset$transcriptsArgs<ExtArgs>
    analyses?: boolean | MediaAsset$analysesArgs<ExtArgs>
    _count?: boolean | MediaAssetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mediaAsset"]>

  export type MediaAssetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assetType?: boolean
    storageProvider?: boolean
    storageKey?: boolean
    url?: boolean
    mimeType?: boolean
    sizeBytes?: boolean
    durationMs?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["mediaAsset"]>

  export type MediaAssetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assetType?: boolean
    storageProvider?: boolean
    storageKey?: boolean
    url?: boolean
    mimeType?: boolean
    sizeBytes?: boolean
    durationMs?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["mediaAsset"]>

  export type MediaAssetSelectScalar = {
    id?: boolean
    assetType?: boolean
    storageProvider?: boolean
    storageKey?: boolean
    url?: boolean
    mimeType?: boolean
    sizeBytes?: boolean
    durationMs?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MediaAssetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "assetType" | "storageProvider" | "storageKey" | "url" | "mimeType" | "sizeBytes" | "durationMs" | "createdAt" | "updatedAt", ExtArgs["result"]["mediaAsset"]>
  export type MediaAssetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    surveyResponseItems?: boolean | MediaAsset$surveyResponseItemsArgs<ExtArgs>
    transcripts?: boolean | MediaAsset$transcriptsArgs<ExtArgs>
    analyses?: boolean | MediaAsset$analysesArgs<ExtArgs>
    _count?: boolean | MediaAssetCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MediaAssetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MediaAssetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MediaAssetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MediaAsset"
    objects: {
      surveyResponseItems: Prisma.$SurveyResponseItemPayload<ExtArgs>[]
      transcripts: Prisma.$TranscriptPayload<ExtArgs>[]
      analyses: Prisma.$AIAnalysisPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      assetType: $Enums.AssetType
      storageProvider: string | null
      storageKey: string | null
      url: string | null
      mimeType: string | null
      sizeBytes: number | null
      durationMs: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["mediaAsset"]>
    composites: {}
  }

  type MediaAssetGetPayload<S extends boolean | null | undefined | MediaAssetDefaultArgs> = $Result.GetResult<Prisma.$MediaAssetPayload, S>

  type MediaAssetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MediaAssetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MediaAssetCountAggregateInputType | true
    }

  export interface MediaAssetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MediaAsset'], meta: { name: 'MediaAsset' } }
    /**
     * Find zero or one MediaAsset that matches the filter.
     * @param {MediaAssetFindUniqueArgs} args - Arguments to find a MediaAsset
     * @example
     * // Get one MediaAsset
     * const mediaAsset = await prisma.mediaAsset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MediaAssetFindUniqueArgs>(args: SelectSubset<T, MediaAssetFindUniqueArgs<ExtArgs>>): Prisma__MediaAssetClient<$Result.GetResult<Prisma.$MediaAssetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MediaAsset that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MediaAssetFindUniqueOrThrowArgs} args - Arguments to find a MediaAsset
     * @example
     * // Get one MediaAsset
     * const mediaAsset = await prisma.mediaAsset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MediaAssetFindUniqueOrThrowArgs>(args: SelectSubset<T, MediaAssetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MediaAssetClient<$Result.GetResult<Prisma.$MediaAssetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MediaAsset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAssetFindFirstArgs} args - Arguments to find a MediaAsset
     * @example
     * // Get one MediaAsset
     * const mediaAsset = await prisma.mediaAsset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MediaAssetFindFirstArgs>(args?: SelectSubset<T, MediaAssetFindFirstArgs<ExtArgs>>): Prisma__MediaAssetClient<$Result.GetResult<Prisma.$MediaAssetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MediaAsset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAssetFindFirstOrThrowArgs} args - Arguments to find a MediaAsset
     * @example
     * // Get one MediaAsset
     * const mediaAsset = await prisma.mediaAsset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MediaAssetFindFirstOrThrowArgs>(args?: SelectSubset<T, MediaAssetFindFirstOrThrowArgs<ExtArgs>>): Prisma__MediaAssetClient<$Result.GetResult<Prisma.$MediaAssetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MediaAssets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAssetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MediaAssets
     * const mediaAssets = await prisma.mediaAsset.findMany()
     * 
     * // Get first 10 MediaAssets
     * const mediaAssets = await prisma.mediaAsset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mediaAssetWithIdOnly = await prisma.mediaAsset.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MediaAssetFindManyArgs>(args?: SelectSubset<T, MediaAssetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaAssetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MediaAsset.
     * @param {MediaAssetCreateArgs} args - Arguments to create a MediaAsset.
     * @example
     * // Create one MediaAsset
     * const MediaAsset = await prisma.mediaAsset.create({
     *   data: {
     *     // ... data to create a MediaAsset
     *   }
     * })
     * 
     */
    create<T extends MediaAssetCreateArgs>(args: SelectSubset<T, MediaAssetCreateArgs<ExtArgs>>): Prisma__MediaAssetClient<$Result.GetResult<Prisma.$MediaAssetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MediaAssets.
     * @param {MediaAssetCreateManyArgs} args - Arguments to create many MediaAssets.
     * @example
     * // Create many MediaAssets
     * const mediaAsset = await prisma.mediaAsset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MediaAssetCreateManyArgs>(args?: SelectSubset<T, MediaAssetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MediaAssets and returns the data saved in the database.
     * @param {MediaAssetCreateManyAndReturnArgs} args - Arguments to create many MediaAssets.
     * @example
     * // Create many MediaAssets
     * const mediaAsset = await prisma.mediaAsset.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MediaAssets and only return the `id`
     * const mediaAssetWithIdOnly = await prisma.mediaAsset.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MediaAssetCreateManyAndReturnArgs>(args?: SelectSubset<T, MediaAssetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaAssetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MediaAsset.
     * @param {MediaAssetDeleteArgs} args - Arguments to delete one MediaAsset.
     * @example
     * // Delete one MediaAsset
     * const MediaAsset = await prisma.mediaAsset.delete({
     *   where: {
     *     // ... filter to delete one MediaAsset
     *   }
     * })
     * 
     */
    delete<T extends MediaAssetDeleteArgs>(args: SelectSubset<T, MediaAssetDeleteArgs<ExtArgs>>): Prisma__MediaAssetClient<$Result.GetResult<Prisma.$MediaAssetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MediaAsset.
     * @param {MediaAssetUpdateArgs} args - Arguments to update one MediaAsset.
     * @example
     * // Update one MediaAsset
     * const mediaAsset = await prisma.mediaAsset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MediaAssetUpdateArgs>(args: SelectSubset<T, MediaAssetUpdateArgs<ExtArgs>>): Prisma__MediaAssetClient<$Result.GetResult<Prisma.$MediaAssetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MediaAssets.
     * @param {MediaAssetDeleteManyArgs} args - Arguments to filter MediaAssets to delete.
     * @example
     * // Delete a few MediaAssets
     * const { count } = await prisma.mediaAsset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MediaAssetDeleteManyArgs>(args?: SelectSubset<T, MediaAssetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MediaAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAssetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MediaAssets
     * const mediaAsset = await prisma.mediaAsset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MediaAssetUpdateManyArgs>(args: SelectSubset<T, MediaAssetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MediaAssets and returns the data updated in the database.
     * @param {MediaAssetUpdateManyAndReturnArgs} args - Arguments to update many MediaAssets.
     * @example
     * // Update many MediaAssets
     * const mediaAsset = await prisma.mediaAsset.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MediaAssets and only return the `id`
     * const mediaAssetWithIdOnly = await prisma.mediaAsset.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MediaAssetUpdateManyAndReturnArgs>(args: SelectSubset<T, MediaAssetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaAssetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MediaAsset.
     * @param {MediaAssetUpsertArgs} args - Arguments to update or create a MediaAsset.
     * @example
     * // Update or create a MediaAsset
     * const mediaAsset = await prisma.mediaAsset.upsert({
     *   create: {
     *     // ... data to create a MediaAsset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MediaAsset we want to update
     *   }
     * })
     */
    upsert<T extends MediaAssetUpsertArgs>(args: SelectSubset<T, MediaAssetUpsertArgs<ExtArgs>>): Prisma__MediaAssetClient<$Result.GetResult<Prisma.$MediaAssetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MediaAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAssetCountArgs} args - Arguments to filter MediaAssets to count.
     * @example
     * // Count the number of MediaAssets
     * const count = await prisma.mediaAsset.count({
     *   where: {
     *     // ... the filter for the MediaAssets we want to count
     *   }
     * })
    **/
    count<T extends MediaAssetCountArgs>(
      args?: Subset<T, MediaAssetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MediaAssetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MediaAsset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAssetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MediaAssetAggregateArgs>(args: Subset<T, MediaAssetAggregateArgs>): Prisma.PrismaPromise<GetMediaAssetAggregateType<T>>

    /**
     * Group by MediaAsset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAssetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MediaAssetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MediaAssetGroupByArgs['orderBy'] }
        : { orderBy?: MediaAssetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MediaAssetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMediaAssetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MediaAsset model
   */
  readonly fields: MediaAssetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MediaAsset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MediaAssetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    surveyResponseItems<T extends MediaAsset$surveyResponseItemsArgs<ExtArgs> = {}>(args?: Subset<T, MediaAsset$surveyResponseItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyResponseItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transcripts<T extends MediaAsset$transcriptsArgs<ExtArgs> = {}>(args?: Subset<T, MediaAsset$transcriptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    analyses<T extends MediaAsset$analysesArgs<ExtArgs> = {}>(args?: Subset<T, MediaAsset$analysesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIAnalysisPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MediaAsset model
   */
  interface MediaAssetFieldRefs {
    readonly id: FieldRef<"MediaAsset", 'String'>
    readonly assetType: FieldRef<"MediaAsset", 'AssetType'>
    readonly storageProvider: FieldRef<"MediaAsset", 'String'>
    readonly storageKey: FieldRef<"MediaAsset", 'String'>
    readonly url: FieldRef<"MediaAsset", 'String'>
    readonly mimeType: FieldRef<"MediaAsset", 'String'>
    readonly sizeBytes: FieldRef<"MediaAsset", 'Int'>
    readonly durationMs: FieldRef<"MediaAsset", 'Int'>
    readonly createdAt: FieldRef<"MediaAsset", 'DateTime'>
    readonly updatedAt: FieldRef<"MediaAsset", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MediaAsset findUnique
   */
  export type MediaAssetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAsset
     */
    select?: MediaAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaAsset
     */
    omit?: MediaAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAssetInclude<ExtArgs> | null
    /**
     * Filter, which MediaAsset to fetch.
     */
    where: MediaAssetWhereUniqueInput
  }

  /**
   * MediaAsset findUniqueOrThrow
   */
  export type MediaAssetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAsset
     */
    select?: MediaAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaAsset
     */
    omit?: MediaAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAssetInclude<ExtArgs> | null
    /**
     * Filter, which MediaAsset to fetch.
     */
    where: MediaAssetWhereUniqueInput
  }

  /**
   * MediaAsset findFirst
   */
  export type MediaAssetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAsset
     */
    select?: MediaAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaAsset
     */
    omit?: MediaAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAssetInclude<ExtArgs> | null
    /**
     * Filter, which MediaAsset to fetch.
     */
    where?: MediaAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaAssets to fetch.
     */
    orderBy?: MediaAssetOrderByWithRelationInput | MediaAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MediaAssets.
     */
    cursor?: MediaAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MediaAssets.
     */
    distinct?: MediaAssetScalarFieldEnum | MediaAssetScalarFieldEnum[]
  }

  /**
   * MediaAsset findFirstOrThrow
   */
  export type MediaAssetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAsset
     */
    select?: MediaAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaAsset
     */
    omit?: MediaAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAssetInclude<ExtArgs> | null
    /**
     * Filter, which MediaAsset to fetch.
     */
    where?: MediaAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaAssets to fetch.
     */
    orderBy?: MediaAssetOrderByWithRelationInput | MediaAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MediaAssets.
     */
    cursor?: MediaAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MediaAssets.
     */
    distinct?: MediaAssetScalarFieldEnum | MediaAssetScalarFieldEnum[]
  }

  /**
   * MediaAsset findMany
   */
  export type MediaAssetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAsset
     */
    select?: MediaAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaAsset
     */
    omit?: MediaAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAssetInclude<ExtArgs> | null
    /**
     * Filter, which MediaAssets to fetch.
     */
    where?: MediaAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaAssets to fetch.
     */
    orderBy?: MediaAssetOrderByWithRelationInput | MediaAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MediaAssets.
     */
    cursor?: MediaAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaAssets.
     */
    skip?: number
    distinct?: MediaAssetScalarFieldEnum | MediaAssetScalarFieldEnum[]
  }

  /**
   * MediaAsset create
   */
  export type MediaAssetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAsset
     */
    select?: MediaAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaAsset
     */
    omit?: MediaAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAssetInclude<ExtArgs> | null
    /**
     * The data needed to create a MediaAsset.
     */
    data: XOR<MediaAssetCreateInput, MediaAssetUncheckedCreateInput>
  }

  /**
   * MediaAsset createMany
   */
  export type MediaAssetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MediaAssets.
     */
    data: MediaAssetCreateManyInput | MediaAssetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MediaAsset createManyAndReturn
   */
  export type MediaAssetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAsset
     */
    select?: MediaAssetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MediaAsset
     */
    omit?: MediaAssetOmit<ExtArgs> | null
    /**
     * The data used to create many MediaAssets.
     */
    data: MediaAssetCreateManyInput | MediaAssetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MediaAsset update
   */
  export type MediaAssetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAsset
     */
    select?: MediaAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaAsset
     */
    omit?: MediaAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAssetInclude<ExtArgs> | null
    /**
     * The data needed to update a MediaAsset.
     */
    data: XOR<MediaAssetUpdateInput, MediaAssetUncheckedUpdateInput>
    /**
     * Choose, which MediaAsset to update.
     */
    where: MediaAssetWhereUniqueInput
  }

  /**
   * MediaAsset updateMany
   */
  export type MediaAssetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MediaAssets.
     */
    data: XOR<MediaAssetUpdateManyMutationInput, MediaAssetUncheckedUpdateManyInput>
    /**
     * Filter which MediaAssets to update
     */
    where?: MediaAssetWhereInput
    /**
     * Limit how many MediaAssets to update.
     */
    limit?: number
  }

  /**
   * MediaAsset updateManyAndReturn
   */
  export type MediaAssetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAsset
     */
    select?: MediaAssetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MediaAsset
     */
    omit?: MediaAssetOmit<ExtArgs> | null
    /**
     * The data used to update MediaAssets.
     */
    data: XOR<MediaAssetUpdateManyMutationInput, MediaAssetUncheckedUpdateManyInput>
    /**
     * Filter which MediaAssets to update
     */
    where?: MediaAssetWhereInput
    /**
     * Limit how many MediaAssets to update.
     */
    limit?: number
  }

  /**
   * MediaAsset upsert
   */
  export type MediaAssetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAsset
     */
    select?: MediaAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaAsset
     */
    omit?: MediaAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAssetInclude<ExtArgs> | null
    /**
     * The filter to search for the MediaAsset to update in case it exists.
     */
    where: MediaAssetWhereUniqueInput
    /**
     * In case the MediaAsset found by the `where` argument doesn't exist, create a new MediaAsset with this data.
     */
    create: XOR<MediaAssetCreateInput, MediaAssetUncheckedCreateInput>
    /**
     * In case the MediaAsset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MediaAssetUpdateInput, MediaAssetUncheckedUpdateInput>
  }

  /**
   * MediaAsset delete
   */
  export type MediaAssetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAsset
     */
    select?: MediaAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaAsset
     */
    omit?: MediaAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAssetInclude<ExtArgs> | null
    /**
     * Filter which MediaAsset to delete.
     */
    where: MediaAssetWhereUniqueInput
  }

  /**
   * MediaAsset deleteMany
   */
  export type MediaAssetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MediaAssets to delete
     */
    where?: MediaAssetWhereInput
    /**
     * Limit how many MediaAssets to delete.
     */
    limit?: number
  }

  /**
   * MediaAsset.surveyResponseItems
   */
  export type MediaAsset$surveyResponseItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponseItem
     */
    select?: SurveyResponseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyResponseItem
     */
    omit?: SurveyResponseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseItemInclude<ExtArgs> | null
    where?: SurveyResponseItemWhereInput
    orderBy?: SurveyResponseItemOrderByWithRelationInput | SurveyResponseItemOrderByWithRelationInput[]
    cursor?: SurveyResponseItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SurveyResponseItemScalarFieldEnum | SurveyResponseItemScalarFieldEnum[]
  }

  /**
   * MediaAsset.transcripts
   */
  export type MediaAsset$transcriptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transcript
     */
    omit?: TranscriptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
    where?: TranscriptWhereInput
    orderBy?: TranscriptOrderByWithRelationInput | TranscriptOrderByWithRelationInput[]
    cursor?: TranscriptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TranscriptScalarFieldEnum | TranscriptScalarFieldEnum[]
  }

  /**
   * MediaAsset.analyses
   */
  export type MediaAsset$analysesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAnalysis
     */
    select?: AIAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIAnalysis
     */
    omit?: AIAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIAnalysisInclude<ExtArgs> | null
    where?: AIAnalysisWhereInput
    orderBy?: AIAnalysisOrderByWithRelationInput | AIAnalysisOrderByWithRelationInput[]
    cursor?: AIAnalysisWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIAnalysisScalarFieldEnum | AIAnalysisScalarFieldEnum[]
  }

  /**
   * MediaAsset without action
   */
  export type MediaAssetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAsset
     */
    select?: MediaAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaAsset
     */
    omit?: MediaAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAssetInclude<ExtArgs> | null
  }


  /**
   * Model Transcript
   */

  export type AggregateTranscript = {
    _count: TranscriptCountAggregateOutputType | null
    _min: TranscriptMinAggregateOutputType | null
    _max: TranscriptMaxAggregateOutputType | null
  }

  export type TranscriptMinAggregateOutputType = {
    id: string | null
    mediaAssetId: string | null
    provider: string | null
    providerVersion: string | null
    language: string | null
    transcriptText: string | null
    createdAt: Date | null
  }

  export type TranscriptMaxAggregateOutputType = {
    id: string | null
    mediaAssetId: string | null
    provider: string | null
    providerVersion: string | null
    language: string | null
    transcriptText: string | null
    createdAt: Date | null
  }

  export type TranscriptCountAggregateOutputType = {
    id: number
    mediaAssetId: number
    provider: number
    providerVersion: number
    language: number
    transcriptText: number
    segmentsJson: number
    createdAt: number
    _all: number
  }


  export type TranscriptMinAggregateInputType = {
    id?: true
    mediaAssetId?: true
    provider?: true
    providerVersion?: true
    language?: true
    transcriptText?: true
    createdAt?: true
  }

  export type TranscriptMaxAggregateInputType = {
    id?: true
    mediaAssetId?: true
    provider?: true
    providerVersion?: true
    language?: true
    transcriptText?: true
    createdAt?: true
  }

  export type TranscriptCountAggregateInputType = {
    id?: true
    mediaAssetId?: true
    provider?: true
    providerVersion?: true
    language?: true
    transcriptText?: true
    segmentsJson?: true
    createdAt?: true
    _all?: true
  }

  export type TranscriptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transcript to aggregate.
     */
    where?: TranscriptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transcripts to fetch.
     */
    orderBy?: TranscriptOrderByWithRelationInput | TranscriptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TranscriptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transcripts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transcripts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transcripts
    **/
    _count?: true | TranscriptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TranscriptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TranscriptMaxAggregateInputType
  }

  export type GetTranscriptAggregateType<T extends TranscriptAggregateArgs> = {
        [P in keyof T & keyof AggregateTranscript]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTranscript[P]>
      : GetScalarType<T[P], AggregateTranscript[P]>
  }




  export type TranscriptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TranscriptWhereInput
    orderBy?: TranscriptOrderByWithAggregationInput | TranscriptOrderByWithAggregationInput[]
    by: TranscriptScalarFieldEnum[] | TranscriptScalarFieldEnum
    having?: TranscriptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TranscriptCountAggregateInputType | true
    _min?: TranscriptMinAggregateInputType
    _max?: TranscriptMaxAggregateInputType
  }

  export type TranscriptGroupByOutputType = {
    id: string
    mediaAssetId: string
    provider: string | null
    providerVersion: string | null
    language: string | null
    transcriptText: string
    segmentsJson: JsonValue | null
    createdAt: Date
    _count: TranscriptCountAggregateOutputType | null
    _min: TranscriptMinAggregateOutputType | null
    _max: TranscriptMaxAggregateOutputType | null
  }

  type GetTranscriptGroupByPayload<T extends TranscriptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TranscriptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TranscriptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TranscriptGroupByOutputType[P]>
            : GetScalarType<T[P], TranscriptGroupByOutputType[P]>
        }
      >
    >


  export type TranscriptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mediaAssetId?: boolean
    provider?: boolean
    providerVersion?: boolean
    language?: boolean
    transcriptText?: boolean
    segmentsJson?: boolean
    createdAt?: boolean
    mediaAsset?: boolean | MediaAssetDefaultArgs<ExtArgs>
    analyses?: boolean | Transcript$analysesArgs<ExtArgs>
    _count?: boolean | TranscriptCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transcript"]>

  export type TranscriptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mediaAssetId?: boolean
    provider?: boolean
    providerVersion?: boolean
    language?: boolean
    transcriptText?: boolean
    segmentsJson?: boolean
    createdAt?: boolean
    mediaAsset?: boolean | MediaAssetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transcript"]>

  export type TranscriptSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mediaAssetId?: boolean
    provider?: boolean
    providerVersion?: boolean
    language?: boolean
    transcriptText?: boolean
    segmentsJson?: boolean
    createdAt?: boolean
    mediaAsset?: boolean | MediaAssetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transcript"]>

  export type TranscriptSelectScalar = {
    id?: boolean
    mediaAssetId?: boolean
    provider?: boolean
    providerVersion?: boolean
    language?: boolean
    transcriptText?: boolean
    segmentsJson?: boolean
    createdAt?: boolean
  }

  export type TranscriptOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "mediaAssetId" | "provider" | "providerVersion" | "language" | "transcriptText" | "segmentsJson" | "createdAt", ExtArgs["result"]["transcript"]>
  export type TranscriptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mediaAsset?: boolean | MediaAssetDefaultArgs<ExtArgs>
    analyses?: boolean | Transcript$analysesArgs<ExtArgs>
    _count?: boolean | TranscriptCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TranscriptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mediaAsset?: boolean | MediaAssetDefaultArgs<ExtArgs>
  }
  export type TranscriptIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mediaAsset?: boolean | MediaAssetDefaultArgs<ExtArgs>
  }

  export type $TranscriptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transcript"
    objects: {
      mediaAsset: Prisma.$MediaAssetPayload<ExtArgs>
      analyses: Prisma.$AIAnalysisPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      mediaAssetId: string
      provider: string | null
      providerVersion: string | null
      language: string | null
      transcriptText: string
      segmentsJson: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["transcript"]>
    composites: {}
  }

  type TranscriptGetPayload<S extends boolean | null | undefined | TranscriptDefaultArgs> = $Result.GetResult<Prisma.$TranscriptPayload, S>

  type TranscriptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TranscriptFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TranscriptCountAggregateInputType | true
    }

  export interface TranscriptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transcript'], meta: { name: 'Transcript' } }
    /**
     * Find zero or one Transcript that matches the filter.
     * @param {TranscriptFindUniqueArgs} args - Arguments to find a Transcript
     * @example
     * // Get one Transcript
     * const transcript = await prisma.transcript.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TranscriptFindUniqueArgs>(args: SelectSubset<T, TranscriptFindUniqueArgs<ExtArgs>>): Prisma__TranscriptClient<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transcript that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TranscriptFindUniqueOrThrowArgs} args - Arguments to find a Transcript
     * @example
     * // Get one Transcript
     * const transcript = await prisma.transcript.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TranscriptFindUniqueOrThrowArgs>(args: SelectSubset<T, TranscriptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TranscriptClient<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transcript that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptFindFirstArgs} args - Arguments to find a Transcript
     * @example
     * // Get one Transcript
     * const transcript = await prisma.transcript.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TranscriptFindFirstArgs>(args?: SelectSubset<T, TranscriptFindFirstArgs<ExtArgs>>): Prisma__TranscriptClient<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transcript that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptFindFirstOrThrowArgs} args - Arguments to find a Transcript
     * @example
     * // Get one Transcript
     * const transcript = await prisma.transcript.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TranscriptFindFirstOrThrowArgs>(args?: SelectSubset<T, TranscriptFindFirstOrThrowArgs<ExtArgs>>): Prisma__TranscriptClient<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transcripts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transcripts
     * const transcripts = await prisma.transcript.findMany()
     * 
     * // Get first 10 Transcripts
     * const transcripts = await prisma.transcript.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transcriptWithIdOnly = await prisma.transcript.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TranscriptFindManyArgs>(args?: SelectSubset<T, TranscriptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transcript.
     * @param {TranscriptCreateArgs} args - Arguments to create a Transcript.
     * @example
     * // Create one Transcript
     * const Transcript = await prisma.transcript.create({
     *   data: {
     *     // ... data to create a Transcript
     *   }
     * })
     * 
     */
    create<T extends TranscriptCreateArgs>(args: SelectSubset<T, TranscriptCreateArgs<ExtArgs>>): Prisma__TranscriptClient<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transcripts.
     * @param {TranscriptCreateManyArgs} args - Arguments to create many Transcripts.
     * @example
     * // Create many Transcripts
     * const transcript = await prisma.transcript.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TranscriptCreateManyArgs>(args?: SelectSubset<T, TranscriptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transcripts and returns the data saved in the database.
     * @param {TranscriptCreateManyAndReturnArgs} args - Arguments to create many Transcripts.
     * @example
     * // Create many Transcripts
     * const transcript = await prisma.transcript.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transcripts and only return the `id`
     * const transcriptWithIdOnly = await prisma.transcript.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TranscriptCreateManyAndReturnArgs>(args?: SelectSubset<T, TranscriptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transcript.
     * @param {TranscriptDeleteArgs} args - Arguments to delete one Transcript.
     * @example
     * // Delete one Transcript
     * const Transcript = await prisma.transcript.delete({
     *   where: {
     *     // ... filter to delete one Transcript
     *   }
     * })
     * 
     */
    delete<T extends TranscriptDeleteArgs>(args: SelectSubset<T, TranscriptDeleteArgs<ExtArgs>>): Prisma__TranscriptClient<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transcript.
     * @param {TranscriptUpdateArgs} args - Arguments to update one Transcript.
     * @example
     * // Update one Transcript
     * const transcript = await prisma.transcript.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TranscriptUpdateArgs>(args: SelectSubset<T, TranscriptUpdateArgs<ExtArgs>>): Prisma__TranscriptClient<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transcripts.
     * @param {TranscriptDeleteManyArgs} args - Arguments to filter Transcripts to delete.
     * @example
     * // Delete a few Transcripts
     * const { count } = await prisma.transcript.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TranscriptDeleteManyArgs>(args?: SelectSubset<T, TranscriptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transcripts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transcripts
     * const transcript = await prisma.transcript.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TranscriptUpdateManyArgs>(args: SelectSubset<T, TranscriptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transcripts and returns the data updated in the database.
     * @param {TranscriptUpdateManyAndReturnArgs} args - Arguments to update many Transcripts.
     * @example
     * // Update many Transcripts
     * const transcript = await prisma.transcript.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transcripts and only return the `id`
     * const transcriptWithIdOnly = await prisma.transcript.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TranscriptUpdateManyAndReturnArgs>(args: SelectSubset<T, TranscriptUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transcript.
     * @param {TranscriptUpsertArgs} args - Arguments to update or create a Transcript.
     * @example
     * // Update or create a Transcript
     * const transcript = await prisma.transcript.upsert({
     *   create: {
     *     // ... data to create a Transcript
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transcript we want to update
     *   }
     * })
     */
    upsert<T extends TranscriptUpsertArgs>(args: SelectSubset<T, TranscriptUpsertArgs<ExtArgs>>): Prisma__TranscriptClient<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transcripts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptCountArgs} args - Arguments to filter Transcripts to count.
     * @example
     * // Count the number of Transcripts
     * const count = await prisma.transcript.count({
     *   where: {
     *     // ... the filter for the Transcripts we want to count
     *   }
     * })
    **/
    count<T extends TranscriptCountArgs>(
      args?: Subset<T, TranscriptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TranscriptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transcript.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TranscriptAggregateArgs>(args: Subset<T, TranscriptAggregateArgs>): Prisma.PrismaPromise<GetTranscriptAggregateType<T>>

    /**
     * Group by Transcript.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TranscriptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TranscriptGroupByArgs['orderBy'] }
        : { orderBy?: TranscriptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TranscriptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTranscriptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transcript model
   */
  readonly fields: TranscriptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transcript.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TranscriptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mediaAsset<T extends MediaAssetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MediaAssetDefaultArgs<ExtArgs>>): Prisma__MediaAssetClient<$Result.GetResult<Prisma.$MediaAssetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    analyses<T extends Transcript$analysesArgs<ExtArgs> = {}>(args?: Subset<T, Transcript$analysesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIAnalysisPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transcript model
   */
  interface TranscriptFieldRefs {
    readonly id: FieldRef<"Transcript", 'String'>
    readonly mediaAssetId: FieldRef<"Transcript", 'String'>
    readonly provider: FieldRef<"Transcript", 'String'>
    readonly providerVersion: FieldRef<"Transcript", 'String'>
    readonly language: FieldRef<"Transcript", 'String'>
    readonly transcriptText: FieldRef<"Transcript", 'String'>
    readonly segmentsJson: FieldRef<"Transcript", 'Json'>
    readonly createdAt: FieldRef<"Transcript", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transcript findUnique
   */
  export type TranscriptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transcript
     */
    omit?: TranscriptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
    /**
     * Filter, which Transcript to fetch.
     */
    where: TranscriptWhereUniqueInput
  }

  /**
   * Transcript findUniqueOrThrow
   */
  export type TranscriptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transcript
     */
    omit?: TranscriptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
    /**
     * Filter, which Transcript to fetch.
     */
    where: TranscriptWhereUniqueInput
  }

  /**
   * Transcript findFirst
   */
  export type TranscriptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transcript
     */
    omit?: TranscriptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
    /**
     * Filter, which Transcript to fetch.
     */
    where?: TranscriptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transcripts to fetch.
     */
    orderBy?: TranscriptOrderByWithRelationInput | TranscriptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transcripts.
     */
    cursor?: TranscriptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transcripts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transcripts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transcripts.
     */
    distinct?: TranscriptScalarFieldEnum | TranscriptScalarFieldEnum[]
  }

  /**
   * Transcript findFirstOrThrow
   */
  export type TranscriptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transcript
     */
    omit?: TranscriptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
    /**
     * Filter, which Transcript to fetch.
     */
    where?: TranscriptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transcripts to fetch.
     */
    orderBy?: TranscriptOrderByWithRelationInput | TranscriptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transcripts.
     */
    cursor?: TranscriptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transcripts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transcripts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transcripts.
     */
    distinct?: TranscriptScalarFieldEnum | TranscriptScalarFieldEnum[]
  }

  /**
   * Transcript findMany
   */
  export type TranscriptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transcript
     */
    omit?: TranscriptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
    /**
     * Filter, which Transcripts to fetch.
     */
    where?: TranscriptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transcripts to fetch.
     */
    orderBy?: TranscriptOrderByWithRelationInput | TranscriptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transcripts.
     */
    cursor?: TranscriptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transcripts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transcripts.
     */
    skip?: number
    distinct?: TranscriptScalarFieldEnum | TranscriptScalarFieldEnum[]
  }

  /**
   * Transcript create
   */
  export type TranscriptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transcript
     */
    omit?: TranscriptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
    /**
     * The data needed to create a Transcript.
     */
    data: XOR<TranscriptCreateInput, TranscriptUncheckedCreateInput>
  }

  /**
   * Transcript createMany
   */
  export type TranscriptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transcripts.
     */
    data: TranscriptCreateManyInput | TranscriptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transcript createManyAndReturn
   */
  export type TranscriptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transcript
     */
    omit?: TranscriptOmit<ExtArgs> | null
    /**
     * The data used to create many Transcripts.
     */
    data: TranscriptCreateManyInput | TranscriptCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transcript update
   */
  export type TranscriptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transcript
     */
    omit?: TranscriptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
    /**
     * The data needed to update a Transcript.
     */
    data: XOR<TranscriptUpdateInput, TranscriptUncheckedUpdateInput>
    /**
     * Choose, which Transcript to update.
     */
    where: TranscriptWhereUniqueInput
  }

  /**
   * Transcript updateMany
   */
  export type TranscriptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transcripts.
     */
    data: XOR<TranscriptUpdateManyMutationInput, TranscriptUncheckedUpdateManyInput>
    /**
     * Filter which Transcripts to update
     */
    where?: TranscriptWhereInput
    /**
     * Limit how many Transcripts to update.
     */
    limit?: number
  }

  /**
   * Transcript updateManyAndReturn
   */
  export type TranscriptUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transcript
     */
    omit?: TranscriptOmit<ExtArgs> | null
    /**
     * The data used to update Transcripts.
     */
    data: XOR<TranscriptUpdateManyMutationInput, TranscriptUncheckedUpdateManyInput>
    /**
     * Filter which Transcripts to update
     */
    where?: TranscriptWhereInput
    /**
     * Limit how many Transcripts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transcript upsert
   */
  export type TranscriptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transcript
     */
    omit?: TranscriptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
    /**
     * The filter to search for the Transcript to update in case it exists.
     */
    where: TranscriptWhereUniqueInput
    /**
     * In case the Transcript found by the `where` argument doesn't exist, create a new Transcript with this data.
     */
    create: XOR<TranscriptCreateInput, TranscriptUncheckedCreateInput>
    /**
     * In case the Transcript was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TranscriptUpdateInput, TranscriptUncheckedUpdateInput>
  }

  /**
   * Transcript delete
   */
  export type TranscriptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transcript
     */
    omit?: TranscriptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
    /**
     * Filter which Transcript to delete.
     */
    where: TranscriptWhereUniqueInput
  }

  /**
   * Transcript deleteMany
   */
  export type TranscriptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transcripts to delete
     */
    where?: TranscriptWhereInput
    /**
     * Limit how many Transcripts to delete.
     */
    limit?: number
  }

  /**
   * Transcript.analyses
   */
  export type Transcript$analysesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAnalysis
     */
    select?: AIAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIAnalysis
     */
    omit?: AIAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIAnalysisInclude<ExtArgs> | null
    where?: AIAnalysisWhereInput
    orderBy?: AIAnalysisOrderByWithRelationInput | AIAnalysisOrderByWithRelationInput[]
    cursor?: AIAnalysisWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIAnalysisScalarFieldEnum | AIAnalysisScalarFieldEnum[]
  }

  /**
   * Transcript without action
   */
  export type TranscriptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transcript
     */
    omit?: TranscriptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
  }


  /**
   * Model AIAnalysis
   */

  export type AggregateAIAnalysis = {
    _count: AIAnalysisCountAggregateOutputType | null
    _min: AIAnalysisMinAggregateOutputType | null
    _max: AIAnalysisMaxAggregateOutputType | null
  }

  export type AIAnalysisMinAggregateOutputType = {
    id: string | null
    transcriptId: string | null
    mediaAssetId: string | null
    aiRunId: string | null
    analysisType: $Enums.AnalysisType | null
    notes: string | null
    createdAt: Date | null
  }

  export type AIAnalysisMaxAggregateOutputType = {
    id: string | null
    transcriptId: string | null
    mediaAssetId: string | null
    aiRunId: string | null
    analysisType: $Enums.AnalysisType | null
    notes: string | null
    createdAt: Date | null
  }

  export type AIAnalysisCountAggregateOutputType = {
    id: number
    transcriptId: number
    mediaAssetId: number
    aiRunId: number
    analysisType: number
    contentJson: number
    notes: number
    createdAt: number
    _all: number
  }


  export type AIAnalysisMinAggregateInputType = {
    id?: true
    transcriptId?: true
    mediaAssetId?: true
    aiRunId?: true
    analysisType?: true
    notes?: true
    createdAt?: true
  }

  export type AIAnalysisMaxAggregateInputType = {
    id?: true
    transcriptId?: true
    mediaAssetId?: true
    aiRunId?: true
    analysisType?: true
    notes?: true
    createdAt?: true
  }

  export type AIAnalysisCountAggregateInputType = {
    id?: true
    transcriptId?: true
    mediaAssetId?: true
    aiRunId?: true
    analysisType?: true
    contentJson?: true
    notes?: true
    createdAt?: true
    _all?: true
  }

  export type AIAnalysisAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIAnalysis to aggregate.
     */
    where?: AIAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIAnalyses to fetch.
     */
    orderBy?: AIAnalysisOrderByWithRelationInput | AIAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIAnalyses
    **/
    _count?: true | AIAnalysisCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIAnalysisMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIAnalysisMaxAggregateInputType
  }

  export type GetAIAnalysisAggregateType<T extends AIAnalysisAggregateArgs> = {
        [P in keyof T & keyof AggregateAIAnalysis]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIAnalysis[P]>
      : GetScalarType<T[P], AggregateAIAnalysis[P]>
  }




  export type AIAnalysisGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIAnalysisWhereInput
    orderBy?: AIAnalysisOrderByWithAggregationInput | AIAnalysisOrderByWithAggregationInput[]
    by: AIAnalysisScalarFieldEnum[] | AIAnalysisScalarFieldEnum
    having?: AIAnalysisScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIAnalysisCountAggregateInputType | true
    _min?: AIAnalysisMinAggregateInputType
    _max?: AIAnalysisMaxAggregateInputType
  }

  export type AIAnalysisGroupByOutputType = {
    id: string
    transcriptId: string | null
    mediaAssetId: string | null
    aiRunId: string | null
    analysisType: $Enums.AnalysisType
    contentJson: JsonValue
    notes: string | null
    createdAt: Date
    _count: AIAnalysisCountAggregateOutputType | null
    _min: AIAnalysisMinAggregateOutputType | null
    _max: AIAnalysisMaxAggregateOutputType | null
  }

  type GetAIAnalysisGroupByPayload<T extends AIAnalysisGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIAnalysisGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIAnalysisGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIAnalysisGroupByOutputType[P]>
            : GetScalarType<T[P], AIAnalysisGroupByOutputType[P]>
        }
      >
    >


  export type AIAnalysisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transcriptId?: boolean
    mediaAssetId?: boolean
    aiRunId?: boolean
    analysisType?: boolean
    contentJson?: boolean
    notes?: boolean
    createdAt?: boolean
    transcript?: boolean | AIAnalysis$transcriptArgs<ExtArgs>
    mediaAsset?: boolean | AIAnalysis$mediaAssetArgs<ExtArgs>
    aiRun?: boolean | AIAnalysis$aiRunArgs<ExtArgs>
  }, ExtArgs["result"]["aIAnalysis"]>

  export type AIAnalysisSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transcriptId?: boolean
    mediaAssetId?: boolean
    aiRunId?: boolean
    analysisType?: boolean
    contentJson?: boolean
    notes?: boolean
    createdAt?: boolean
    transcript?: boolean | AIAnalysis$transcriptArgs<ExtArgs>
    mediaAsset?: boolean | AIAnalysis$mediaAssetArgs<ExtArgs>
    aiRun?: boolean | AIAnalysis$aiRunArgs<ExtArgs>
  }, ExtArgs["result"]["aIAnalysis"]>

  export type AIAnalysisSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transcriptId?: boolean
    mediaAssetId?: boolean
    aiRunId?: boolean
    analysisType?: boolean
    contentJson?: boolean
    notes?: boolean
    createdAt?: boolean
    transcript?: boolean | AIAnalysis$transcriptArgs<ExtArgs>
    mediaAsset?: boolean | AIAnalysis$mediaAssetArgs<ExtArgs>
    aiRun?: boolean | AIAnalysis$aiRunArgs<ExtArgs>
  }, ExtArgs["result"]["aIAnalysis"]>

  export type AIAnalysisSelectScalar = {
    id?: boolean
    transcriptId?: boolean
    mediaAssetId?: boolean
    aiRunId?: boolean
    analysisType?: boolean
    contentJson?: boolean
    notes?: boolean
    createdAt?: boolean
  }

  export type AIAnalysisOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transcriptId" | "mediaAssetId" | "aiRunId" | "analysisType" | "contentJson" | "notes" | "createdAt", ExtArgs["result"]["aIAnalysis"]>
  export type AIAnalysisInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transcript?: boolean | AIAnalysis$transcriptArgs<ExtArgs>
    mediaAsset?: boolean | AIAnalysis$mediaAssetArgs<ExtArgs>
    aiRun?: boolean | AIAnalysis$aiRunArgs<ExtArgs>
  }
  export type AIAnalysisIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transcript?: boolean | AIAnalysis$transcriptArgs<ExtArgs>
    mediaAsset?: boolean | AIAnalysis$mediaAssetArgs<ExtArgs>
    aiRun?: boolean | AIAnalysis$aiRunArgs<ExtArgs>
  }
  export type AIAnalysisIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transcript?: boolean | AIAnalysis$transcriptArgs<ExtArgs>
    mediaAsset?: boolean | AIAnalysis$mediaAssetArgs<ExtArgs>
    aiRun?: boolean | AIAnalysis$aiRunArgs<ExtArgs>
  }

  export type $AIAnalysisPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIAnalysis"
    objects: {
      transcript: Prisma.$TranscriptPayload<ExtArgs> | null
      mediaAsset: Prisma.$MediaAssetPayload<ExtArgs> | null
      aiRun: Prisma.$AIRunPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      transcriptId: string | null
      mediaAssetId: string | null
      aiRunId: string | null
      analysisType: $Enums.AnalysisType
      contentJson: Prisma.JsonValue
      notes: string | null
      createdAt: Date
    }, ExtArgs["result"]["aIAnalysis"]>
    composites: {}
  }

  type AIAnalysisGetPayload<S extends boolean | null | undefined | AIAnalysisDefaultArgs> = $Result.GetResult<Prisma.$AIAnalysisPayload, S>

  type AIAnalysisCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AIAnalysisFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AIAnalysisCountAggregateInputType | true
    }

  export interface AIAnalysisDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIAnalysis'], meta: { name: 'AIAnalysis' } }
    /**
     * Find zero or one AIAnalysis that matches the filter.
     * @param {AIAnalysisFindUniqueArgs} args - Arguments to find a AIAnalysis
     * @example
     * // Get one AIAnalysis
     * const aIAnalysis = await prisma.aIAnalysis.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIAnalysisFindUniqueArgs>(args: SelectSubset<T, AIAnalysisFindUniqueArgs<ExtArgs>>): Prisma__AIAnalysisClient<$Result.GetResult<Prisma.$AIAnalysisPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AIAnalysis that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AIAnalysisFindUniqueOrThrowArgs} args - Arguments to find a AIAnalysis
     * @example
     * // Get one AIAnalysis
     * const aIAnalysis = await prisma.aIAnalysis.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIAnalysisFindUniqueOrThrowArgs>(args: SelectSubset<T, AIAnalysisFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIAnalysisClient<$Result.GetResult<Prisma.$AIAnalysisPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIAnalysis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIAnalysisFindFirstArgs} args - Arguments to find a AIAnalysis
     * @example
     * // Get one AIAnalysis
     * const aIAnalysis = await prisma.aIAnalysis.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIAnalysisFindFirstArgs>(args?: SelectSubset<T, AIAnalysisFindFirstArgs<ExtArgs>>): Prisma__AIAnalysisClient<$Result.GetResult<Prisma.$AIAnalysisPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIAnalysis that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIAnalysisFindFirstOrThrowArgs} args - Arguments to find a AIAnalysis
     * @example
     * // Get one AIAnalysis
     * const aIAnalysis = await prisma.aIAnalysis.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIAnalysisFindFirstOrThrowArgs>(args?: SelectSubset<T, AIAnalysisFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIAnalysisClient<$Result.GetResult<Prisma.$AIAnalysisPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AIAnalyses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIAnalysisFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIAnalyses
     * const aIAnalyses = await prisma.aIAnalysis.findMany()
     * 
     * // Get first 10 AIAnalyses
     * const aIAnalyses = await prisma.aIAnalysis.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIAnalysisWithIdOnly = await prisma.aIAnalysis.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIAnalysisFindManyArgs>(args?: SelectSubset<T, AIAnalysisFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIAnalysisPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AIAnalysis.
     * @param {AIAnalysisCreateArgs} args - Arguments to create a AIAnalysis.
     * @example
     * // Create one AIAnalysis
     * const AIAnalysis = await prisma.aIAnalysis.create({
     *   data: {
     *     // ... data to create a AIAnalysis
     *   }
     * })
     * 
     */
    create<T extends AIAnalysisCreateArgs>(args: SelectSubset<T, AIAnalysisCreateArgs<ExtArgs>>): Prisma__AIAnalysisClient<$Result.GetResult<Prisma.$AIAnalysisPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AIAnalyses.
     * @param {AIAnalysisCreateManyArgs} args - Arguments to create many AIAnalyses.
     * @example
     * // Create many AIAnalyses
     * const aIAnalysis = await prisma.aIAnalysis.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIAnalysisCreateManyArgs>(args?: SelectSubset<T, AIAnalysisCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIAnalyses and returns the data saved in the database.
     * @param {AIAnalysisCreateManyAndReturnArgs} args - Arguments to create many AIAnalyses.
     * @example
     * // Create many AIAnalyses
     * const aIAnalysis = await prisma.aIAnalysis.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIAnalyses and only return the `id`
     * const aIAnalysisWithIdOnly = await prisma.aIAnalysis.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIAnalysisCreateManyAndReturnArgs>(args?: SelectSubset<T, AIAnalysisCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIAnalysisPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AIAnalysis.
     * @param {AIAnalysisDeleteArgs} args - Arguments to delete one AIAnalysis.
     * @example
     * // Delete one AIAnalysis
     * const AIAnalysis = await prisma.aIAnalysis.delete({
     *   where: {
     *     // ... filter to delete one AIAnalysis
     *   }
     * })
     * 
     */
    delete<T extends AIAnalysisDeleteArgs>(args: SelectSubset<T, AIAnalysisDeleteArgs<ExtArgs>>): Prisma__AIAnalysisClient<$Result.GetResult<Prisma.$AIAnalysisPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AIAnalysis.
     * @param {AIAnalysisUpdateArgs} args - Arguments to update one AIAnalysis.
     * @example
     * // Update one AIAnalysis
     * const aIAnalysis = await prisma.aIAnalysis.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIAnalysisUpdateArgs>(args: SelectSubset<T, AIAnalysisUpdateArgs<ExtArgs>>): Prisma__AIAnalysisClient<$Result.GetResult<Prisma.$AIAnalysisPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AIAnalyses.
     * @param {AIAnalysisDeleteManyArgs} args - Arguments to filter AIAnalyses to delete.
     * @example
     * // Delete a few AIAnalyses
     * const { count } = await prisma.aIAnalysis.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIAnalysisDeleteManyArgs>(args?: SelectSubset<T, AIAnalysisDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIAnalyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIAnalysisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIAnalyses
     * const aIAnalysis = await prisma.aIAnalysis.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIAnalysisUpdateManyArgs>(args: SelectSubset<T, AIAnalysisUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIAnalyses and returns the data updated in the database.
     * @param {AIAnalysisUpdateManyAndReturnArgs} args - Arguments to update many AIAnalyses.
     * @example
     * // Update many AIAnalyses
     * const aIAnalysis = await prisma.aIAnalysis.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AIAnalyses and only return the `id`
     * const aIAnalysisWithIdOnly = await prisma.aIAnalysis.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AIAnalysisUpdateManyAndReturnArgs>(args: SelectSubset<T, AIAnalysisUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIAnalysisPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AIAnalysis.
     * @param {AIAnalysisUpsertArgs} args - Arguments to update or create a AIAnalysis.
     * @example
     * // Update or create a AIAnalysis
     * const aIAnalysis = await prisma.aIAnalysis.upsert({
     *   create: {
     *     // ... data to create a AIAnalysis
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIAnalysis we want to update
     *   }
     * })
     */
    upsert<T extends AIAnalysisUpsertArgs>(args: SelectSubset<T, AIAnalysisUpsertArgs<ExtArgs>>): Prisma__AIAnalysisClient<$Result.GetResult<Prisma.$AIAnalysisPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AIAnalyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIAnalysisCountArgs} args - Arguments to filter AIAnalyses to count.
     * @example
     * // Count the number of AIAnalyses
     * const count = await prisma.aIAnalysis.count({
     *   where: {
     *     // ... the filter for the AIAnalyses we want to count
     *   }
     * })
    **/
    count<T extends AIAnalysisCountArgs>(
      args?: Subset<T, AIAnalysisCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIAnalysisCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIAnalysis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIAnalysisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIAnalysisAggregateArgs>(args: Subset<T, AIAnalysisAggregateArgs>): Prisma.PrismaPromise<GetAIAnalysisAggregateType<T>>

    /**
     * Group by AIAnalysis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIAnalysisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIAnalysisGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIAnalysisGroupByArgs['orderBy'] }
        : { orderBy?: AIAnalysisGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIAnalysisGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIAnalysisGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIAnalysis model
   */
  readonly fields: AIAnalysisFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIAnalysis.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIAnalysisClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transcript<T extends AIAnalysis$transcriptArgs<ExtArgs> = {}>(args?: Subset<T, AIAnalysis$transcriptArgs<ExtArgs>>): Prisma__TranscriptClient<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    mediaAsset<T extends AIAnalysis$mediaAssetArgs<ExtArgs> = {}>(args?: Subset<T, AIAnalysis$mediaAssetArgs<ExtArgs>>): Prisma__MediaAssetClient<$Result.GetResult<Prisma.$MediaAssetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    aiRun<T extends AIAnalysis$aiRunArgs<ExtArgs> = {}>(args?: Subset<T, AIAnalysis$aiRunArgs<ExtArgs>>): Prisma__AIRunClient<$Result.GetResult<Prisma.$AIRunPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIAnalysis model
   */
  interface AIAnalysisFieldRefs {
    readonly id: FieldRef<"AIAnalysis", 'String'>
    readonly transcriptId: FieldRef<"AIAnalysis", 'String'>
    readonly mediaAssetId: FieldRef<"AIAnalysis", 'String'>
    readonly aiRunId: FieldRef<"AIAnalysis", 'String'>
    readonly analysisType: FieldRef<"AIAnalysis", 'AnalysisType'>
    readonly contentJson: FieldRef<"AIAnalysis", 'Json'>
    readonly notes: FieldRef<"AIAnalysis", 'String'>
    readonly createdAt: FieldRef<"AIAnalysis", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AIAnalysis findUnique
   */
  export type AIAnalysisFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAnalysis
     */
    select?: AIAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIAnalysis
     */
    omit?: AIAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which AIAnalysis to fetch.
     */
    where: AIAnalysisWhereUniqueInput
  }

  /**
   * AIAnalysis findUniqueOrThrow
   */
  export type AIAnalysisFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAnalysis
     */
    select?: AIAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIAnalysis
     */
    omit?: AIAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which AIAnalysis to fetch.
     */
    where: AIAnalysisWhereUniqueInput
  }

  /**
   * AIAnalysis findFirst
   */
  export type AIAnalysisFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAnalysis
     */
    select?: AIAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIAnalysis
     */
    omit?: AIAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which AIAnalysis to fetch.
     */
    where?: AIAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIAnalyses to fetch.
     */
    orderBy?: AIAnalysisOrderByWithRelationInput | AIAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIAnalyses.
     */
    cursor?: AIAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIAnalyses.
     */
    distinct?: AIAnalysisScalarFieldEnum | AIAnalysisScalarFieldEnum[]
  }

  /**
   * AIAnalysis findFirstOrThrow
   */
  export type AIAnalysisFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAnalysis
     */
    select?: AIAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIAnalysis
     */
    omit?: AIAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which AIAnalysis to fetch.
     */
    where?: AIAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIAnalyses to fetch.
     */
    orderBy?: AIAnalysisOrderByWithRelationInput | AIAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIAnalyses.
     */
    cursor?: AIAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIAnalyses.
     */
    distinct?: AIAnalysisScalarFieldEnum | AIAnalysisScalarFieldEnum[]
  }

  /**
   * AIAnalysis findMany
   */
  export type AIAnalysisFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAnalysis
     */
    select?: AIAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIAnalysis
     */
    omit?: AIAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which AIAnalyses to fetch.
     */
    where?: AIAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIAnalyses to fetch.
     */
    orderBy?: AIAnalysisOrderByWithRelationInput | AIAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIAnalyses.
     */
    cursor?: AIAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIAnalyses.
     */
    skip?: number
    distinct?: AIAnalysisScalarFieldEnum | AIAnalysisScalarFieldEnum[]
  }

  /**
   * AIAnalysis create
   */
  export type AIAnalysisCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAnalysis
     */
    select?: AIAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIAnalysis
     */
    omit?: AIAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIAnalysisInclude<ExtArgs> | null
    /**
     * The data needed to create a AIAnalysis.
     */
    data: XOR<AIAnalysisCreateInput, AIAnalysisUncheckedCreateInput>
  }

  /**
   * AIAnalysis createMany
   */
  export type AIAnalysisCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIAnalyses.
     */
    data: AIAnalysisCreateManyInput | AIAnalysisCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIAnalysis createManyAndReturn
   */
  export type AIAnalysisCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAnalysis
     */
    select?: AIAnalysisSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIAnalysis
     */
    omit?: AIAnalysisOmit<ExtArgs> | null
    /**
     * The data used to create many AIAnalyses.
     */
    data: AIAnalysisCreateManyInput | AIAnalysisCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIAnalysisIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIAnalysis update
   */
  export type AIAnalysisUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAnalysis
     */
    select?: AIAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIAnalysis
     */
    omit?: AIAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIAnalysisInclude<ExtArgs> | null
    /**
     * The data needed to update a AIAnalysis.
     */
    data: XOR<AIAnalysisUpdateInput, AIAnalysisUncheckedUpdateInput>
    /**
     * Choose, which AIAnalysis to update.
     */
    where: AIAnalysisWhereUniqueInput
  }

  /**
   * AIAnalysis updateMany
   */
  export type AIAnalysisUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIAnalyses.
     */
    data: XOR<AIAnalysisUpdateManyMutationInput, AIAnalysisUncheckedUpdateManyInput>
    /**
     * Filter which AIAnalyses to update
     */
    where?: AIAnalysisWhereInput
    /**
     * Limit how many AIAnalyses to update.
     */
    limit?: number
  }

  /**
   * AIAnalysis updateManyAndReturn
   */
  export type AIAnalysisUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAnalysis
     */
    select?: AIAnalysisSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIAnalysis
     */
    omit?: AIAnalysisOmit<ExtArgs> | null
    /**
     * The data used to update AIAnalyses.
     */
    data: XOR<AIAnalysisUpdateManyMutationInput, AIAnalysisUncheckedUpdateManyInput>
    /**
     * Filter which AIAnalyses to update
     */
    where?: AIAnalysisWhereInput
    /**
     * Limit how many AIAnalyses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIAnalysisIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIAnalysis upsert
   */
  export type AIAnalysisUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAnalysis
     */
    select?: AIAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIAnalysis
     */
    omit?: AIAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIAnalysisInclude<ExtArgs> | null
    /**
     * The filter to search for the AIAnalysis to update in case it exists.
     */
    where: AIAnalysisWhereUniqueInput
    /**
     * In case the AIAnalysis found by the `where` argument doesn't exist, create a new AIAnalysis with this data.
     */
    create: XOR<AIAnalysisCreateInput, AIAnalysisUncheckedCreateInput>
    /**
     * In case the AIAnalysis was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIAnalysisUpdateInput, AIAnalysisUncheckedUpdateInput>
  }

  /**
   * AIAnalysis delete
   */
  export type AIAnalysisDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAnalysis
     */
    select?: AIAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIAnalysis
     */
    omit?: AIAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIAnalysisInclude<ExtArgs> | null
    /**
     * Filter which AIAnalysis to delete.
     */
    where: AIAnalysisWhereUniqueInput
  }

  /**
   * AIAnalysis deleteMany
   */
  export type AIAnalysisDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIAnalyses to delete
     */
    where?: AIAnalysisWhereInput
    /**
     * Limit how many AIAnalyses to delete.
     */
    limit?: number
  }

  /**
   * AIAnalysis.transcript
   */
  export type AIAnalysis$transcriptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transcript
     */
    omit?: TranscriptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
    where?: TranscriptWhereInput
  }

  /**
   * AIAnalysis.mediaAsset
   */
  export type AIAnalysis$mediaAssetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAsset
     */
    select?: MediaAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaAsset
     */
    omit?: MediaAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAssetInclude<ExtArgs> | null
    where?: MediaAssetWhereInput
  }

  /**
   * AIAnalysis.aiRun
   */
  export type AIAnalysis$aiRunArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRun
     */
    select?: AIRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRun
     */
    omit?: AIRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRunInclude<ExtArgs> | null
    where?: AIRunWhereInput
  }

  /**
   * AIAnalysis without action
   */
  export type AIAnalysisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAnalysis
     */
    select?: AIAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIAnalysis
     */
    omit?: AIAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIAnalysisInclude<ExtArgs> | null
  }


  /**
   * Model VoterRegistration
   */

  export type AggregateVoterRegistration = {
    _count: VoterRegistrationCountAggregateOutputType | null
    _min: VoterRegistrationMinAggregateOutputType | null
    _max: VoterRegistrationMaxAggregateOutputType | null
  }

  export type VoterRegistrationMinAggregateOutputType = {
    id: string | null
    stateVoterId: string | null
    firstName: string | null
    middleName: string | null
    lastName: string | null
    suffix: string | null
    dateOfBirth: Date | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    state: string | null
    zip: string | null
    party: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VoterRegistrationMaxAggregateOutputType = {
    id: string | null
    stateVoterId: string | null
    firstName: string | null
    middleName: string | null
    lastName: string | null
    suffix: string | null
    dateOfBirth: Date | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    state: string | null
    zip: string | null
    party: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VoterRegistrationCountAggregateOutputType = {
    id: number
    stateVoterId: number
    firstName: number
    middleName: number
    lastName: number
    suffix: number
    dateOfBirth: number
    addressLine1: number
    addressLine2: number
    city: number
    state: number
    zip: number
    party: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VoterRegistrationMinAggregateInputType = {
    id?: true
    stateVoterId?: true
    firstName?: true
    middleName?: true
    lastName?: true
    suffix?: true
    dateOfBirth?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    state?: true
    zip?: true
    party?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VoterRegistrationMaxAggregateInputType = {
    id?: true
    stateVoterId?: true
    firstName?: true
    middleName?: true
    lastName?: true
    suffix?: true
    dateOfBirth?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    state?: true
    zip?: true
    party?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VoterRegistrationCountAggregateInputType = {
    id?: true
    stateVoterId?: true
    firstName?: true
    middleName?: true
    lastName?: true
    suffix?: true
    dateOfBirth?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    state?: true
    zip?: true
    party?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VoterRegistrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VoterRegistration to aggregate.
     */
    where?: VoterRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoterRegistrations to fetch.
     */
    orderBy?: VoterRegistrationOrderByWithRelationInput | VoterRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VoterRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoterRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoterRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VoterRegistrations
    **/
    _count?: true | VoterRegistrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VoterRegistrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VoterRegistrationMaxAggregateInputType
  }

  export type GetVoterRegistrationAggregateType<T extends VoterRegistrationAggregateArgs> = {
        [P in keyof T & keyof AggregateVoterRegistration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVoterRegistration[P]>
      : GetScalarType<T[P], AggregateVoterRegistration[P]>
  }




  export type VoterRegistrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoterRegistrationWhereInput
    orderBy?: VoterRegistrationOrderByWithAggregationInput | VoterRegistrationOrderByWithAggregationInput[]
    by: VoterRegistrationScalarFieldEnum[] | VoterRegistrationScalarFieldEnum
    having?: VoterRegistrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VoterRegistrationCountAggregateInputType | true
    _min?: VoterRegistrationMinAggregateInputType
    _max?: VoterRegistrationMaxAggregateInputType
  }

  export type VoterRegistrationGroupByOutputType = {
    id: string
    stateVoterId: string
    firstName: string | null
    middleName: string | null
    lastName: string | null
    suffix: string | null
    dateOfBirth: Date | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    state: string | null
    zip: string | null
    party: string | null
    status: string | null
    createdAt: Date
    updatedAt: Date
    _count: VoterRegistrationCountAggregateOutputType | null
    _min: VoterRegistrationMinAggregateOutputType | null
    _max: VoterRegistrationMaxAggregateOutputType | null
  }

  type GetVoterRegistrationGroupByPayload<T extends VoterRegistrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VoterRegistrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VoterRegistrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VoterRegistrationGroupByOutputType[P]>
            : GetScalarType<T[P], VoterRegistrationGroupByOutputType[P]>
        }
      >
    >


  export type VoterRegistrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stateVoterId?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    suffix?: boolean
    dateOfBirth?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    zip?: boolean
    party?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    voteHistory?: boolean | VoterRegistration$voteHistoryArgs<ExtArgs>
    segmentMemberships?: boolean | VoterRegistration$segmentMembershipsArgs<ExtArgs>
    _count?: boolean | VoterRegistrationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["voterRegistration"]>

  export type VoterRegistrationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stateVoterId?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    suffix?: boolean
    dateOfBirth?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    zip?: boolean
    party?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["voterRegistration"]>

  export type VoterRegistrationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stateVoterId?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    suffix?: boolean
    dateOfBirth?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    zip?: boolean
    party?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["voterRegistration"]>

  export type VoterRegistrationSelectScalar = {
    id?: boolean
    stateVoterId?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    suffix?: boolean
    dateOfBirth?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    zip?: boolean
    party?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VoterRegistrationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "stateVoterId" | "firstName" | "middleName" | "lastName" | "suffix" | "dateOfBirth" | "addressLine1" | "addressLine2" | "city" | "state" | "zip" | "party" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["voterRegistration"]>
  export type VoterRegistrationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    voteHistory?: boolean | VoterRegistration$voteHistoryArgs<ExtArgs>
    segmentMemberships?: boolean | VoterRegistration$segmentMembershipsArgs<ExtArgs>
    _count?: boolean | VoterRegistrationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VoterRegistrationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type VoterRegistrationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $VoterRegistrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VoterRegistration"
    objects: {
      voteHistory: Prisma.$VoteHistoryPayload<ExtArgs>[]
      segmentMemberships: Prisma.$SegmentMemberPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      stateVoterId: string
      firstName: string | null
      middleName: string | null
      lastName: string | null
      suffix: string | null
      dateOfBirth: Date | null
      addressLine1: string | null
      addressLine2: string | null
      city: string | null
      state: string | null
      zip: string | null
      party: string | null
      status: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["voterRegistration"]>
    composites: {}
  }

  type VoterRegistrationGetPayload<S extends boolean | null | undefined | VoterRegistrationDefaultArgs> = $Result.GetResult<Prisma.$VoterRegistrationPayload, S>

  type VoterRegistrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VoterRegistrationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VoterRegistrationCountAggregateInputType | true
    }

  export interface VoterRegistrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VoterRegistration'], meta: { name: 'VoterRegistration' } }
    /**
     * Find zero or one VoterRegistration that matches the filter.
     * @param {VoterRegistrationFindUniqueArgs} args - Arguments to find a VoterRegistration
     * @example
     * // Get one VoterRegistration
     * const voterRegistration = await prisma.voterRegistration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VoterRegistrationFindUniqueArgs>(args: SelectSubset<T, VoterRegistrationFindUniqueArgs<ExtArgs>>): Prisma__VoterRegistrationClient<$Result.GetResult<Prisma.$VoterRegistrationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VoterRegistration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VoterRegistrationFindUniqueOrThrowArgs} args - Arguments to find a VoterRegistration
     * @example
     * // Get one VoterRegistration
     * const voterRegistration = await prisma.voterRegistration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VoterRegistrationFindUniqueOrThrowArgs>(args: SelectSubset<T, VoterRegistrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VoterRegistrationClient<$Result.GetResult<Prisma.$VoterRegistrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VoterRegistration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoterRegistrationFindFirstArgs} args - Arguments to find a VoterRegistration
     * @example
     * // Get one VoterRegistration
     * const voterRegistration = await prisma.voterRegistration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VoterRegistrationFindFirstArgs>(args?: SelectSubset<T, VoterRegistrationFindFirstArgs<ExtArgs>>): Prisma__VoterRegistrationClient<$Result.GetResult<Prisma.$VoterRegistrationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VoterRegistration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoterRegistrationFindFirstOrThrowArgs} args - Arguments to find a VoterRegistration
     * @example
     * // Get one VoterRegistration
     * const voterRegistration = await prisma.voterRegistration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VoterRegistrationFindFirstOrThrowArgs>(args?: SelectSubset<T, VoterRegistrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__VoterRegistrationClient<$Result.GetResult<Prisma.$VoterRegistrationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VoterRegistrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoterRegistrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VoterRegistrations
     * const voterRegistrations = await prisma.voterRegistration.findMany()
     * 
     * // Get first 10 VoterRegistrations
     * const voterRegistrations = await prisma.voterRegistration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const voterRegistrationWithIdOnly = await prisma.voterRegistration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VoterRegistrationFindManyArgs>(args?: SelectSubset<T, VoterRegistrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoterRegistrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VoterRegistration.
     * @param {VoterRegistrationCreateArgs} args - Arguments to create a VoterRegistration.
     * @example
     * // Create one VoterRegistration
     * const VoterRegistration = await prisma.voterRegistration.create({
     *   data: {
     *     // ... data to create a VoterRegistration
     *   }
     * })
     * 
     */
    create<T extends VoterRegistrationCreateArgs>(args: SelectSubset<T, VoterRegistrationCreateArgs<ExtArgs>>): Prisma__VoterRegistrationClient<$Result.GetResult<Prisma.$VoterRegistrationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VoterRegistrations.
     * @param {VoterRegistrationCreateManyArgs} args - Arguments to create many VoterRegistrations.
     * @example
     * // Create many VoterRegistrations
     * const voterRegistration = await prisma.voterRegistration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VoterRegistrationCreateManyArgs>(args?: SelectSubset<T, VoterRegistrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VoterRegistrations and returns the data saved in the database.
     * @param {VoterRegistrationCreateManyAndReturnArgs} args - Arguments to create many VoterRegistrations.
     * @example
     * // Create many VoterRegistrations
     * const voterRegistration = await prisma.voterRegistration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VoterRegistrations and only return the `id`
     * const voterRegistrationWithIdOnly = await prisma.voterRegistration.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VoterRegistrationCreateManyAndReturnArgs>(args?: SelectSubset<T, VoterRegistrationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoterRegistrationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VoterRegistration.
     * @param {VoterRegistrationDeleteArgs} args - Arguments to delete one VoterRegistration.
     * @example
     * // Delete one VoterRegistration
     * const VoterRegistration = await prisma.voterRegistration.delete({
     *   where: {
     *     // ... filter to delete one VoterRegistration
     *   }
     * })
     * 
     */
    delete<T extends VoterRegistrationDeleteArgs>(args: SelectSubset<T, VoterRegistrationDeleteArgs<ExtArgs>>): Prisma__VoterRegistrationClient<$Result.GetResult<Prisma.$VoterRegistrationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VoterRegistration.
     * @param {VoterRegistrationUpdateArgs} args - Arguments to update one VoterRegistration.
     * @example
     * // Update one VoterRegistration
     * const voterRegistration = await prisma.voterRegistration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VoterRegistrationUpdateArgs>(args: SelectSubset<T, VoterRegistrationUpdateArgs<ExtArgs>>): Prisma__VoterRegistrationClient<$Result.GetResult<Prisma.$VoterRegistrationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VoterRegistrations.
     * @param {VoterRegistrationDeleteManyArgs} args - Arguments to filter VoterRegistrations to delete.
     * @example
     * // Delete a few VoterRegistrations
     * const { count } = await prisma.voterRegistration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VoterRegistrationDeleteManyArgs>(args?: SelectSubset<T, VoterRegistrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VoterRegistrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoterRegistrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VoterRegistrations
     * const voterRegistration = await prisma.voterRegistration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VoterRegistrationUpdateManyArgs>(args: SelectSubset<T, VoterRegistrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VoterRegistrations and returns the data updated in the database.
     * @param {VoterRegistrationUpdateManyAndReturnArgs} args - Arguments to update many VoterRegistrations.
     * @example
     * // Update many VoterRegistrations
     * const voterRegistration = await prisma.voterRegistration.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VoterRegistrations and only return the `id`
     * const voterRegistrationWithIdOnly = await prisma.voterRegistration.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VoterRegistrationUpdateManyAndReturnArgs>(args: SelectSubset<T, VoterRegistrationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoterRegistrationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VoterRegistration.
     * @param {VoterRegistrationUpsertArgs} args - Arguments to update or create a VoterRegistration.
     * @example
     * // Update or create a VoterRegistration
     * const voterRegistration = await prisma.voterRegistration.upsert({
     *   create: {
     *     // ... data to create a VoterRegistration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VoterRegistration we want to update
     *   }
     * })
     */
    upsert<T extends VoterRegistrationUpsertArgs>(args: SelectSubset<T, VoterRegistrationUpsertArgs<ExtArgs>>): Prisma__VoterRegistrationClient<$Result.GetResult<Prisma.$VoterRegistrationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VoterRegistrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoterRegistrationCountArgs} args - Arguments to filter VoterRegistrations to count.
     * @example
     * // Count the number of VoterRegistrations
     * const count = await prisma.voterRegistration.count({
     *   where: {
     *     // ... the filter for the VoterRegistrations we want to count
     *   }
     * })
    **/
    count<T extends VoterRegistrationCountArgs>(
      args?: Subset<T, VoterRegistrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VoterRegistrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VoterRegistration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoterRegistrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VoterRegistrationAggregateArgs>(args: Subset<T, VoterRegistrationAggregateArgs>): Prisma.PrismaPromise<GetVoterRegistrationAggregateType<T>>

    /**
     * Group by VoterRegistration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoterRegistrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VoterRegistrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VoterRegistrationGroupByArgs['orderBy'] }
        : { orderBy?: VoterRegistrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VoterRegistrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVoterRegistrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VoterRegistration model
   */
  readonly fields: VoterRegistrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VoterRegistration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VoterRegistrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    voteHistory<T extends VoterRegistration$voteHistoryArgs<ExtArgs> = {}>(args?: Subset<T, VoterRegistration$voteHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoteHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    segmentMemberships<T extends VoterRegistration$segmentMembershipsArgs<ExtArgs> = {}>(args?: Subset<T, VoterRegistration$segmentMembershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SegmentMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VoterRegistration model
   */
  interface VoterRegistrationFieldRefs {
    readonly id: FieldRef<"VoterRegistration", 'String'>
    readonly stateVoterId: FieldRef<"VoterRegistration", 'String'>
    readonly firstName: FieldRef<"VoterRegistration", 'String'>
    readonly middleName: FieldRef<"VoterRegistration", 'String'>
    readonly lastName: FieldRef<"VoterRegistration", 'String'>
    readonly suffix: FieldRef<"VoterRegistration", 'String'>
    readonly dateOfBirth: FieldRef<"VoterRegistration", 'DateTime'>
    readonly addressLine1: FieldRef<"VoterRegistration", 'String'>
    readonly addressLine2: FieldRef<"VoterRegistration", 'String'>
    readonly city: FieldRef<"VoterRegistration", 'String'>
    readonly state: FieldRef<"VoterRegistration", 'String'>
    readonly zip: FieldRef<"VoterRegistration", 'String'>
    readonly party: FieldRef<"VoterRegistration", 'String'>
    readonly status: FieldRef<"VoterRegistration", 'String'>
    readonly createdAt: FieldRef<"VoterRegistration", 'DateTime'>
    readonly updatedAt: FieldRef<"VoterRegistration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VoterRegistration findUnique
   */
  export type VoterRegistrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoterRegistration
     */
    select?: VoterRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoterRegistration
     */
    omit?: VoterRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoterRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which VoterRegistration to fetch.
     */
    where: VoterRegistrationWhereUniqueInput
  }

  /**
   * VoterRegistration findUniqueOrThrow
   */
  export type VoterRegistrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoterRegistration
     */
    select?: VoterRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoterRegistration
     */
    omit?: VoterRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoterRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which VoterRegistration to fetch.
     */
    where: VoterRegistrationWhereUniqueInput
  }

  /**
   * VoterRegistration findFirst
   */
  export type VoterRegistrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoterRegistration
     */
    select?: VoterRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoterRegistration
     */
    omit?: VoterRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoterRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which VoterRegistration to fetch.
     */
    where?: VoterRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoterRegistrations to fetch.
     */
    orderBy?: VoterRegistrationOrderByWithRelationInput | VoterRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VoterRegistrations.
     */
    cursor?: VoterRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoterRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoterRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VoterRegistrations.
     */
    distinct?: VoterRegistrationScalarFieldEnum | VoterRegistrationScalarFieldEnum[]
  }

  /**
   * VoterRegistration findFirstOrThrow
   */
  export type VoterRegistrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoterRegistration
     */
    select?: VoterRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoterRegistration
     */
    omit?: VoterRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoterRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which VoterRegistration to fetch.
     */
    where?: VoterRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoterRegistrations to fetch.
     */
    orderBy?: VoterRegistrationOrderByWithRelationInput | VoterRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VoterRegistrations.
     */
    cursor?: VoterRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoterRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoterRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VoterRegistrations.
     */
    distinct?: VoterRegistrationScalarFieldEnum | VoterRegistrationScalarFieldEnum[]
  }

  /**
   * VoterRegistration findMany
   */
  export type VoterRegistrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoterRegistration
     */
    select?: VoterRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoterRegistration
     */
    omit?: VoterRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoterRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which VoterRegistrations to fetch.
     */
    where?: VoterRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoterRegistrations to fetch.
     */
    orderBy?: VoterRegistrationOrderByWithRelationInput | VoterRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VoterRegistrations.
     */
    cursor?: VoterRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoterRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoterRegistrations.
     */
    skip?: number
    distinct?: VoterRegistrationScalarFieldEnum | VoterRegistrationScalarFieldEnum[]
  }

  /**
   * VoterRegistration create
   */
  export type VoterRegistrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoterRegistration
     */
    select?: VoterRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoterRegistration
     */
    omit?: VoterRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoterRegistrationInclude<ExtArgs> | null
    /**
     * The data needed to create a VoterRegistration.
     */
    data: XOR<VoterRegistrationCreateInput, VoterRegistrationUncheckedCreateInput>
  }

  /**
   * VoterRegistration createMany
   */
  export type VoterRegistrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VoterRegistrations.
     */
    data: VoterRegistrationCreateManyInput | VoterRegistrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VoterRegistration createManyAndReturn
   */
  export type VoterRegistrationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoterRegistration
     */
    select?: VoterRegistrationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VoterRegistration
     */
    omit?: VoterRegistrationOmit<ExtArgs> | null
    /**
     * The data used to create many VoterRegistrations.
     */
    data: VoterRegistrationCreateManyInput | VoterRegistrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VoterRegistration update
   */
  export type VoterRegistrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoterRegistration
     */
    select?: VoterRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoterRegistration
     */
    omit?: VoterRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoterRegistrationInclude<ExtArgs> | null
    /**
     * The data needed to update a VoterRegistration.
     */
    data: XOR<VoterRegistrationUpdateInput, VoterRegistrationUncheckedUpdateInput>
    /**
     * Choose, which VoterRegistration to update.
     */
    where: VoterRegistrationWhereUniqueInput
  }

  /**
   * VoterRegistration updateMany
   */
  export type VoterRegistrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VoterRegistrations.
     */
    data: XOR<VoterRegistrationUpdateManyMutationInput, VoterRegistrationUncheckedUpdateManyInput>
    /**
     * Filter which VoterRegistrations to update
     */
    where?: VoterRegistrationWhereInput
    /**
     * Limit how many VoterRegistrations to update.
     */
    limit?: number
  }

  /**
   * VoterRegistration updateManyAndReturn
   */
  export type VoterRegistrationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoterRegistration
     */
    select?: VoterRegistrationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VoterRegistration
     */
    omit?: VoterRegistrationOmit<ExtArgs> | null
    /**
     * The data used to update VoterRegistrations.
     */
    data: XOR<VoterRegistrationUpdateManyMutationInput, VoterRegistrationUncheckedUpdateManyInput>
    /**
     * Filter which VoterRegistrations to update
     */
    where?: VoterRegistrationWhereInput
    /**
     * Limit how many VoterRegistrations to update.
     */
    limit?: number
  }

  /**
   * VoterRegistration upsert
   */
  export type VoterRegistrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoterRegistration
     */
    select?: VoterRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoterRegistration
     */
    omit?: VoterRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoterRegistrationInclude<ExtArgs> | null
    /**
     * The filter to search for the VoterRegistration to update in case it exists.
     */
    where: VoterRegistrationWhereUniqueInput
    /**
     * In case the VoterRegistration found by the `where` argument doesn't exist, create a new VoterRegistration with this data.
     */
    create: XOR<VoterRegistrationCreateInput, VoterRegistrationUncheckedCreateInput>
    /**
     * In case the VoterRegistration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VoterRegistrationUpdateInput, VoterRegistrationUncheckedUpdateInput>
  }

  /**
   * VoterRegistration delete
   */
  export type VoterRegistrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoterRegistration
     */
    select?: VoterRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoterRegistration
     */
    omit?: VoterRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoterRegistrationInclude<ExtArgs> | null
    /**
     * Filter which VoterRegistration to delete.
     */
    where: VoterRegistrationWhereUniqueInput
  }

  /**
   * VoterRegistration deleteMany
   */
  export type VoterRegistrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VoterRegistrations to delete
     */
    where?: VoterRegistrationWhereInput
    /**
     * Limit how many VoterRegistrations to delete.
     */
    limit?: number
  }

  /**
   * VoterRegistration.voteHistory
   */
  export type VoterRegistration$voteHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoteHistory
     */
    select?: VoteHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoteHistory
     */
    omit?: VoteHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteHistoryInclude<ExtArgs> | null
    where?: VoteHistoryWhereInput
    orderBy?: VoteHistoryOrderByWithRelationInput | VoteHistoryOrderByWithRelationInput[]
    cursor?: VoteHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VoteHistoryScalarFieldEnum | VoteHistoryScalarFieldEnum[]
  }

  /**
   * VoterRegistration.segmentMemberships
   */
  export type VoterRegistration$segmentMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SegmentMember
     */
    select?: SegmentMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SegmentMember
     */
    omit?: SegmentMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentMemberInclude<ExtArgs> | null
    where?: SegmentMemberWhereInput
    orderBy?: SegmentMemberOrderByWithRelationInput | SegmentMemberOrderByWithRelationInput[]
    cursor?: SegmentMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SegmentMemberScalarFieldEnum | SegmentMemberScalarFieldEnum[]
  }

  /**
   * VoterRegistration without action
   */
  export type VoterRegistrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoterRegistration
     */
    select?: VoterRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoterRegistration
     */
    omit?: VoterRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoterRegistrationInclude<ExtArgs> | null
  }


  /**
   * Model VoteHistory
   */

  export type AggregateVoteHistory = {
    _count: VoteHistoryCountAggregateOutputType | null
    _min: VoteHistoryMinAggregateOutputType | null
    _max: VoteHistoryMaxAggregateOutputType | null
  }

  export type VoteHistoryMinAggregateOutputType = {
    id: string | null
    voterId: string | null
    electionDate: Date | null
    electionName: string | null
    voteType: string | null
    createdAt: Date | null
  }

  export type VoteHistoryMaxAggregateOutputType = {
    id: string | null
    voterId: string | null
    electionDate: Date | null
    electionName: string | null
    voteType: string | null
    createdAt: Date | null
  }

  export type VoteHistoryCountAggregateOutputType = {
    id: number
    voterId: number
    electionDate: number
    electionName: number
    voteType: number
    createdAt: number
    _all: number
  }


  export type VoteHistoryMinAggregateInputType = {
    id?: true
    voterId?: true
    electionDate?: true
    electionName?: true
    voteType?: true
    createdAt?: true
  }

  export type VoteHistoryMaxAggregateInputType = {
    id?: true
    voterId?: true
    electionDate?: true
    electionName?: true
    voteType?: true
    createdAt?: true
  }

  export type VoteHistoryCountAggregateInputType = {
    id?: true
    voterId?: true
    electionDate?: true
    electionName?: true
    voteType?: true
    createdAt?: true
    _all?: true
  }

  export type VoteHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VoteHistory to aggregate.
     */
    where?: VoteHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoteHistories to fetch.
     */
    orderBy?: VoteHistoryOrderByWithRelationInput | VoteHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VoteHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoteHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoteHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VoteHistories
    **/
    _count?: true | VoteHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VoteHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VoteHistoryMaxAggregateInputType
  }

  export type GetVoteHistoryAggregateType<T extends VoteHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateVoteHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVoteHistory[P]>
      : GetScalarType<T[P], AggregateVoteHistory[P]>
  }




  export type VoteHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoteHistoryWhereInput
    orderBy?: VoteHistoryOrderByWithAggregationInput | VoteHistoryOrderByWithAggregationInput[]
    by: VoteHistoryScalarFieldEnum[] | VoteHistoryScalarFieldEnum
    having?: VoteHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VoteHistoryCountAggregateInputType | true
    _min?: VoteHistoryMinAggregateInputType
    _max?: VoteHistoryMaxAggregateInputType
  }

  export type VoteHistoryGroupByOutputType = {
    id: string
    voterId: string
    electionDate: Date | null
    electionName: string | null
    voteType: string | null
    createdAt: Date
    _count: VoteHistoryCountAggregateOutputType | null
    _min: VoteHistoryMinAggregateOutputType | null
    _max: VoteHistoryMaxAggregateOutputType | null
  }

  type GetVoteHistoryGroupByPayload<T extends VoteHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VoteHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VoteHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VoteHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], VoteHistoryGroupByOutputType[P]>
        }
      >
    >


  export type VoteHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    voterId?: boolean
    electionDate?: boolean
    electionName?: boolean
    voteType?: boolean
    createdAt?: boolean
    voter?: boolean | VoterRegistrationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["voteHistory"]>

  export type VoteHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    voterId?: boolean
    electionDate?: boolean
    electionName?: boolean
    voteType?: boolean
    createdAt?: boolean
    voter?: boolean | VoterRegistrationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["voteHistory"]>

  export type VoteHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    voterId?: boolean
    electionDate?: boolean
    electionName?: boolean
    voteType?: boolean
    createdAt?: boolean
    voter?: boolean | VoterRegistrationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["voteHistory"]>

  export type VoteHistorySelectScalar = {
    id?: boolean
    voterId?: boolean
    electionDate?: boolean
    electionName?: boolean
    voteType?: boolean
    createdAt?: boolean
  }

  export type VoteHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "voterId" | "electionDate" | "electionName" | "voteType" | "createdAt", ExtArgs["result"]["voteHistory"]>
  export type VoteHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    voter?: boolean | VoterRegistrationDefaultArgs<ExtArgs>
  }
  export type VoteHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    voter?: boolean | VoterRegistrationDefaultArgs<ExtArgs>
  }
  export type VoteHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    voter?: boolean | VoterRegistrationDefaultArgs<ExtArgs>
  }

  export type $VoteHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VoteHistory"
    objects: {
      voter: Prisma.$VoterRegistrationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      voterId: string
      electionDate: Date | null
      electionName: string | null
      voteType: string | null
      createdAt: Date
    }, ExtArgs["result"]["voteHistory"]>
    composites: {}
  }

  type VoteHistoryGetPayload<S extends boolean | null | undefined | VoteHistoryDefaultArgs> = $Result.GetResult<Prisma.$VoteHistoryPayload, S>

  type VoteHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VoteHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VoteHistoryCountAggregateInputType | true
    }

  export interface VoteHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VoteHistory'], meta: { name: 'VoteHistory' } }
    /**
     * Find zero or one VoteHistory that matches the filter.
     * @param {VoteHistoryFindUniqueArgs} args - Arguments to find a VoteHistory
     * @example
     * // Get one VoteHistory
     * const voteHistory = await prisma.voteHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VoteHistoryFindUniqueArgs>(args: SelectSubset<T, VoteHistoryFindUniqueArgs<ExtArgs>>): Prisma__VoteHistoryClient<$Result.GetResult<Prisma.$VoteHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VoteHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VoteHistoryFindUniqueOrThrowArgs} args - Arguments to find a VoteHistory
     * @example
     * // Get one VoteHistory
     * const voteHistory = await prisma.voteHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VoteHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, VoteHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VoteHistoryClient<$Result.GetResult<Prisma.$VoteHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VoteHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteHistoryFindFirstArgs} args - Arguments to find a VoteHistory
     * @example
     * // Get one VoteHistory
     * const voteHistory = await prisma.voteHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VoteHistoryFindFirstArgs>(args?: SelectSubset<T, VoteHistoryFindFirstArgs<ExtArgs>>): Prisma__VoteHistoryClient<$Result.GetResult<Prisma.$VoteHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VoteHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteHistoryFindFirstOrThrowArgs} args - Arguments to find a VoteHistory
     * @example
     * // Get one VoteHistory
     * const voteHistory = await prisma.voteHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VoteHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, VoteHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__VoteHistoryClient<$Result.GetResult<Prisma.$VoteHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VoteHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VoteHistories
     * const voteHistories = await prisma.voteHistory.findMany()
     * 
     * // Get first 10 VoteHistories
     * const voteHistories = await prisma.voteHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const voteHistoryWithIdOnly = await prisma.voteHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VoteHistoryFindManyArgs>(args?: SelectSubset<T, VoteHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoteHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VoteHistory.
     * @param {VoteHistoryCreateArgs} args - Arguments to create a VoteHistory.
     * @example
     * // Create one VoteHistory
     * const VoteHistory = await prisma.voteHistory.create({
     *   data: {
     *     // ... data to create a VoteHistory
     *   }
     * })
     * 
     */
    create<T extends VoteHistoryCreateArgs>(args: SelectSubset<T, VoteHistoryCreateArgs<ExtArgs>>): Prisma__VoteHistoryClient<$Result.GetResult<Prisma.$VoteHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VoteHistories.
     * @param {VoteHistoryCreateManyArgs} args - Arguments to create many VoteHistories.
     * @example
     * // Create many VoteHistories
     * const voteHistory = await prisma.voteHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VoteHistoryCreateManyArgs>(args?: SelectSubset<T, VoteHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VoteHistories and returns the data saved in the database.
     * @param {VoteHistoryCreateManyAndReturnArgs} args - Arguments to create many VoteHistories.
     * @example
     * // Create many VoteHistories
     * const voteHistory = await prisma.voteHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VoteHistories and only return the `id`
     * const voteHistoryWithIdOnly = await prisma.voteHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VoteHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, VoteHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoteHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VoteHistory.
     * @param {VoteHistoryDeleteArgs} args - Arguments to delete one VoteHistory.
     * @example
     * // Delete one VoteHistory
     * const VoteHistory = await prisma.voteHistory.delete({
     *   where: {
     *     // ... filter to delete one VoteHistory
     *   }
     * })
     * 
     */
    delete<T extends VoteHistoryDeleteArgs>(args: SelectSubset<T, VoteHistoryDeleteArgs<ExtArgs>>): Prisma__VoteHistoryClient<$Result.GetResult<Prisma.$VoteHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VoteHistory.
     * @param {VoteHistoryUpdateArgs} args - Arguments to update one VoteHistory.
     * @example
     * // Update one VoteHistory
     * const voteHistory = await prisma.voteHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VoteHistoryUpdateArgs>(args: SelectSubset<T, VoteHistoryUpdateArgs<ExtArgs>>): Prisma__VoteHistoryClient<$Result.GetResult<Prisma.$VoteHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VoteHistories.
     * @param {VoteHistoryDeleteManyArgs} args - Arguments to filter VoteHistories to delete.
     * @example
     * // Delete a few VoteHistories
     * const { count } = await prisma.voteHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VoteHistoryDeleteManyArgs>(args?: SelectSubset<T, VoteHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VoteHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VoteHistories
     * const voteHistory = await prisma.voteHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VoteHistoryUpdateManyArgs>(args: SelectSubset<T, VoteHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VoteHistories and returns the data updated in the database.
     * @param {VoteHistoryUpdateManyAndReturnArgs} args - Arguments to update many VoteHistories.
     * @example
     * // Update many VoteHistories
     * const voteHistory = await prisma.voteHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VoteHistories and only return the `id`
     * const voteHistoryWithIdOnly = await prisma.voteHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VoteHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, VoteHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoteHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VoteHistory.
     * @param {VoteHistoryUpsertArgs} args - Arguments to update or create a VoteHistory.
     * @example
     * // Update or create a VoteHistory
     * const voteHistory = await prisma.voteHistory.upsert({
     *   create: {
     *     // ... data to create a VoteHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VoteHistory we want to update
     *   }
     * })
     */
    upsert<T extends VoteHistoryUpsertArgs>(args: SelectSubset<T, VoteHistoryUpsertArgs<ExtArgs>>): Prisma__VoteHistoryClient<$Result.GetResult<Prisma.$VoteHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VoteHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteHistoryCountArgs} args - Arguments to filter VoteHistories to count.
     * @example
     * // Count the number of VoteHistories
     * const count = await prisma.voteHistory.count({
     *   where: {
     *     // ... the filter for the VoteHistories we want to count
     *   }
     * })
    **/
    count<T extends VoteHistoryCountArgs>(
      args?: Subset<T, VoteHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VoteHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VoteHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VoteHistoryAggregateArgs>(args: Subset<T, VoteHistoryAggregateArgs>): Prisma.PrismaPromise<GetVoteHistoryAggregateType<T>>

    /**
     * Group by VoteHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VoteHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VoteHistoryGroupByArgs['orderBy'] }
        : { orderBy?: VoteHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VoteHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVoteHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VoteHistory model
   */
  readonly fields: VoteHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VoteHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VoteHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    voter<T extends VoterRegistrationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VoterRegistrationDefaultArgs<ExtArgs>>): Prisma__VoterRegistrationClient<$Result.GetResult<Prisma.$VoterRegistrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VoteHistory model
   */
  interface VoteHistoryFieldRefs {
    readonly id: FieldRef<"VoteHistory", 'String'>
    readonly voterId: FieldRef<"VoteHistory", 'String'>
    readonly electionDate: FieldRef<"VoteHistory", 'DateTime'>
    readonly electionName: FieldRef<"VoteHistory", 'String'>
    readonly voteType: FieldRef<"VoteHistory", 'String'>
    readonly createdAt: FieldRef<"VoteHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VoteHistory findUnique
   */
  export type VoteHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoteHistory
     */
    select?: VoteHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoteHistory
     */
    omit?: VoteHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteHistoryInclude<ExtArgs> | null
    /**
     * Filter, which VoteHistory to fetch.
     */
    where: VoteHistoryWhereUniqueInput
  }

  /**
   * VoteHistory findUniqueOrThrow
   */
  export type VoteHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoteHistory
     */
    select?: VoteHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoteHistory
     */
    omit?: VoteHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteHistoryInclude<ExtArgs> | null
    /**
     * Filter, which VoteHistory to fetch.
     */
    where: VoteHistoryWhereUniqueInput
  }

  /**
   * VoteHistory findFirst
   */
  export type VoteHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoteHistory
     */
    select?: VoteHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoteHistory
     */
    omit?: VoteHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteHistoryInclude<ExtArgs> | null
    /**
     * Filter, which VoteHistory to fetch.
     */
    where?: VoteHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoteHistories to fetch.
     */
    orderBy?: VoteHistoryOrderByWithRelationInput | VoteHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VoteHistories.
     */
    cursor?: VoteHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoteHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoteHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VoteHistories.
     */
    distinct?: VoteHistoryScalarFieldEnum | VoteHistoryScalarFieldEnum[]
  }

  /**
   * VoteHistory findFirstOrThrow
   */
  export type VoteHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoteHistory
     */
    select?: VoteHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoteHistory
     */
    omit?: VoteHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteHistoryInclude<ExtArgs> | null
    /**
     * Filter, which VoteHistory to fetch.
     */
    where?: VoteHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoteHistories to fetch.
     */
    orderBy?: VoteHistoryOrderByWithRelationInput | VoteHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VoteHistories.
     */
    cursor?: VoteHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoteHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoteHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VoteHistories.
     */
    distinct?: VoteHistoryScalarFieldEnum | VoteHistoryScalarFieldEnum[]
  }

  /**
   * VoteHistory findMany
   */
  export type VoteHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoteHistory
     */
    select?: VoteHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoteHistory
     */
    omit?: VoteHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteHistoryInclude<ExtArgs> | null
    /**
     * Filter, which VoteHistories to fetch.
     */
    where?: VoteHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoteHistories to fetch.
     */
    orderBy?: VoteHistoryOrderByWithRelationInput | VoteHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VoteHistories.
     */
    cursor?: VoteHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoteHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoteHistories.
     */
    skip?: number
    distinct?: VoteHistoryScalarFieldEnum | VoteHistoryScalarFieldEnum[]
  }

  /**
   * VoteHistory create
   */
  export type VoteHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoteHistory
     */
    select?: VoteHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoteHistory
     */
    omit?: VoteHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a VoteHistory.
     */
    data: XOR<VoteHistoryCreateInput, VoteHistoryUncheckedCreateInput>
  }

  /**
   * VoteHistory createMany
   */
  export type VoteHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VoteHistories.
     */
    data: VoteHistoryCreateManyInput | VoteHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VoteHistory createManyAndReturn
   */
  export type VoteHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoteHistory
     */
    select?: VoteHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VoteHistory
     */
    omit?: VoteHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many VoteHistories.
     */
    data: VoteHistoryCreateManyInput | VoteHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VoteHistory update
   */
  export type VoteHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoteHistory
     */
    select?: VoteHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoteHistory
     */
    omit?: VoteHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a VoteHistory.
     */
    data: XOR<VoteHistoryUpdateInput, VoteHistoryUncheckedUpdateInput>
    /**
     * Choose, which VoteHistory to update.
     */
    where: VoteHistoryWhereUniqueInput
  }

  /**
   * VoteHistory updateMany
   */
  export type VoteHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VoteHistories.
     */
    data: XOR<VoteHistoryUpdateManyMutationInput, VoteHistoryUncheckedUpdateManyInput>
    /**
     * Filter which VoteHistories to update
     */
    where?: VoteHistoryWhereInput
    /**
     * Limit how many VoteHistories to update.
     */
    limit?: number
  }

  /**
   * VoteHistory updateManyAndReturn
   */
  export type VoteHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoteHistory
     */
    select?: VoteHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VoteHistory
     */
    omit?: VoteHistoryOmit<ExtArgs> | null
    /**
     * The data used to update VoteHistories.
     */
    data: XOR<VoteHistoryUpdateManyMutationInput, VoteHistoryUncheckedUpdateManyInput>
    /**
     * Filter which VoteHistories to update
     */
    where?: VoteHistoryWhereInput
    /**
     * Limit how many VoteHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VoteHistory upsert
   */
  export type VoteHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoteHistory
     */
    select?: VoteHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoteHistory
     */
    omit?: VoteHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the VoteHistory to update in case it exists.
     */
    where: VoteHistoryWhereUniqueInput
    /**
     * In case the VoteHistory found by the `where` argument doesn't exist, create a new VoteHistory with this data.
     */
    create: XOR<VoteHistoryCreateInput, VoteHistoryUncheckedCreateInput>
    /**
     * In case the VoteHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VoteHistoryUpdateInput, VoteHistoryUncheckedUpdateInput>
  }

  /**
   * VoteHistory delete
   */
  export type VoteHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoteHistory
     */
    select?: VoteHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoteHistory
     */
    omit?: VoteHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteHistoryInclude<ExtArgs> | null
    /**
     * Filter which VoteHistory to delete.
     */
    where: VoteHistoryWhereUniqueInput
  }

  /**
   * VoteHistory deleteMany
   */
  export type VoteHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VoteHistories to delete
     */
    where?: VoteHistoryWhereInput
    /**
     * Limit how many VoteHistories to delete.
     */
    limit?: number
  }

  /**
   * VoteHistory without action
   */
  export type VoteHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoteHistory
     */
    select?: VoteHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoteHistory
     */
    omit?: VoteHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteHistoryInclude<ExtArgs> | null
  }


  /**
   * Model Segment
   */

  export type AggregateSegment = {
    _count: SegmentCountAggregateOutputType | null
    _min: SegmentMinAggregateOutputType | null
    _max: SegmentMaxAggregateOutputType | null
  }

  export type SegmentMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SegmentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SegmentCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SegmentMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SegmentMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SegmentCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SegmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Segment to aggregate.
     */
    where?: SegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Segments to fetch.
     */
    orderBy?: SegmentOrderByWithRelationInput | SegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Segments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Segments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Segments
    **/
    _count?: true | SegmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SegmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SegmentMaxAggregateInputType
  }

  export type GetSegmentAggregateType<T extends SegmentAggregateArgs> = {
        [P in keyof T & keyof AggregateSegment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSegment[P]>
      : GetScalarType<T[P], AggregateSegment[P]>
  }




  export type SegmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SegmentWhereInput
    orderBy?: SegmentOrderByWithAggregationInput | SegmentOrderByWithAggregationInput[]
    by: SegmentScalarFieldEnum[] | SegmentScalarFieldEnum
    having?: SegmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SegmentCountAggregateInputType | true
    _min?: SegmentMinAggregateInputType
    _max?: SegmentMaxAggregateInputType
  }

  export type SegmentGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: SegmentCountAggregateOutputType | null
    _min: SegmentMinAggregateOutputType | null
    _max: SegmentMaxAggregateOutputType | null
  }

  type GetSegmentGroupByPayload<T extends SegmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SegmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SegmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SegmentGroupByOutputType[P]>
            : GetScalarType<T[P], SegmentGroupByOutputType[P]>
        }
      >
    >


  export type SegmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    members?: boolean | Segment$membersArgs<ExtArgs>
    _count?: boolean | SegmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["segment"]>

  export type SegmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["segment"]>

  export type SegmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["segment"]>

  export type SegmentSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SegmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["segment"]>
  export type SegmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | Segment$membersArgs<ExtArgs>
    _count?: boolean | SegmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SegmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SegmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SegmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Segment"
    objects: {
      members: Prisma.$SegmentMemberPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["segment"]>
    composites: {}
  }

  type SegmentGetPayload<S extends boolean | null | undefined | SegmentDefaultArgs> = $Result.GetResult<Prisma.$SegmentPayload, S>

  type SegmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SegmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SegmentCountAggregateInputType | true
    }

  export interface SegmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Segment'], meta: { name: 'Segment' } }
    /**
     * Find zero or one Segment that matches the filter.
     * @param {SegmentFindUniqueArgs} args - Arguments to find a Segment
     * @example
     * // Get one Segment
     * const segment = await prisma.segment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SegmentFindUniqueArgs>(args: SelectSubset<T, SegmentFindUniqueArgs<ExtArgs>>): Prisma__SegmentClient<$Result.GetResult<Prisma.$SegmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Segment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SegmentFindUniqueOrThrowArgs} args - Arguments to find a Segment
     * @example
     * // Get one Segment
     * const segment = await prisma.segment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SegmentFindUniqueOrThrowArgs>(args: SelectSubset<T, SegmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SegmentClient<$Result.GetResult<Prisma.$SegmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Segment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SegmentFindFirstArgs} args - Arguments to find a Segment
     * @example
     * // Get one Segment
     * const segment = await prisma.segment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SegmentFindFirstArgs>(args?: SelectSubset<T, SegmentFindFirstArgs<ExtArgs>>): Prisma__SegmentClient<$Result.GetResult<Prisma.$SegmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Segment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SegmentFindFirstOrThrowArgs} args - Arguments to find a Segment
     * @example
     * // Get one Segment
     * const segment = await prisma.segment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SegmentFindFirstOrThrowArgs>(args?: SelectSubset<T, SegmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__SegmentClient<$Result.GetResult<Prisma.$SegmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Segments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SegmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Segments
     * const segments = await prisma.segment.findMany()
     * 
     * // Get first 10 Segments
     * const segments = await prisma.segment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const segmentWithIdOnly = await prisma.segment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SegmentFindManyArgs>(args?: SelectSubset<T, SegmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SegmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Segment.
     * @param {SegmentCreateArgs} args - Arguments to create a Segment.
     * @example
     * // Create one Segment
     * const Segment = await prisma.segment.create({
     *   data: {
     *     // ... data to create a Segment
     *   }
     * })
     * 
     */
    create<T extends SegmentCreateArgs>(args: SelectSubset<T, SegmentCreateArgs<ExtArgs>>): Prisma__SegmentClient<$Result.GetResult<Prisma.$SegmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Segments.
     * @param {SegmentCreateManyArgs} args - Arguments to create many Segments.
     * @example
     * // Create many Segments
     * const segment = await prisma.segment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SegmentCreateManyArgs>(args?: SelectSubset<T, SegmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Segments and returns the data saved in the database.
     * @param {SegmentCreateManyAndReturnArgs} args - Arguments to create many Segments.
     * @example
     * // Create many Segments
     * const segment = await prisma.segment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Segments and only return the `id`
     * const segmentWithIdOnly = await prisma.segment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SegmentCreateManyAndReturnArgs>(args?: SelectSubset<T, SegmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SegmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Segment.
     * @param {SegmentDeleteArgs} args - Arguments to delete one Segment.
     * @example
     * // Delete one Segment
     * const Segment = await prisma.segment.delete({
     *   where: {
     *     // ... filter to delete one Segment
     *   }
     * })
     * 
     */
    delete<T extends SegmentDeleteArgs>(args: SelectSubset<T, SegmentDeleteArgs<ExtArgs>>): Prisma__SegmentClient<$Result.GetResult<Prisma.$SegmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Segment.
     * @param {SegmentUpdateArgs} args - Arguments to update one Segment.
     * @example
     * // Update one Segment
     * const segment = await prisma.segment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SegmentUpdateArgs>(args: SelectSubset<T, SegmentUpdateArgs<ExtArgs>>): Prisma__SegmentClient<$Result.GetResult<Prisma.$SegmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Segments.
     * @param {SegmentDeleteManyArgs} args - Arguments to filter Segments to delete.
     * @example
     * // Delete a few Segments
     * const { count } = await prisma.segment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SegmentDeleteManyArgs>(args?: SelectSubset<T, SegmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Segments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SegmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Segments
     * const segment = await prisma.segment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SegmentUpdateManyArgs>(args: SelectSubset<T, SegmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Segments and returns the data updated in the database.
     * @param {SegmentUpdateManyAndReturnArgs} args - Arguments to update many Segments.
     * @example
     * // Update many Segments
     * const segment = await prisma.segment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Segments and only return the `id`
     * const segmentWithIdOnly = await prisma.segment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SegmentUpdateManyAndReturnArgs>(args: SelectSubset<T, SegmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SegmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Segment.
     * @param {SegmentUpsertArgs} args - Arguments to update or create a Segment.
     * @example
     * // Update or create a Segment
     * const segment = await prisma.segment.upsert({
     *   create: {
     *     // ... data to create a Segment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Segment we want to update
     *   }
     * })
     */
    upsert<T extends SegmentUpsertArgs>(args: SelectSubset<T, SegmentUpsertArgs<ExtArgs>>): Prisma__SegmentClient<$Result.GetResult<Prisma.$SegmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Segments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SegmentCountArgs} args - Arguments to filter Segments to count.
     * @example
     * // Count the number of Segments
     * const count = await prisma.segment.count({
     *   where: {
     *     // ... the filter for the Segments we want to count
     *   }
     * })
    **/
    count<T extends SegmentCountArgs>(
      args?: Subset<T, SegmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SegmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Segment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SegmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SegmentAggregateArgs>(args: Subset<T, SegmentAggregateArgs>): Prisma.PrismaPromise<GetSegmentAggregateType<T>>

    /**
     * Group by Segment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SegmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SegmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SegmentGroupByArgs['orderBy'] }
        : { orderBy?: SegmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SegmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSegmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Segment model
   */
  readonly fields: SegmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Segment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SegmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    members<T extends Segment$membersArgs<ExtArgs> = {}>(args?: Subset<T, Segment$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SegmentMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Segment model
   */
  interface SegmentFieldRefs {
    readonly id: FieldRef<"Segment", 'String'>
    readonly name: FieldRef<"Segment", 'String'>
    readonly slug: FieldRef<"Segment", 'String'>
    readonly description: FieldRef<"Segment", 'String'>
    readonly createdAt: FieldRef<"Segment", 'DateTime'>
    readonly updatedAt: FieldRef<"Segment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Segment findUnique
   */
  export type SegmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Segment
     */
    select?: SegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Segment
     */
    omit?: SegmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentInclude<ExtArgs> | null
    /**
     * Filter, which Segment to fetch.
     */
    where: SegmentWhereUniqueInput
  }

  /**
   * Segment findUniqueOrThrow
   */
  export type SegmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Segment
     */
    select?: SegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Segment
     */
    omit?: SegmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentInclude<ExtArgs> | null
    /**
     * Filter, which Segment to fetch.
     */
    where: SegmentWhereUniqueInput
  }

  /**
   * Segment findFirst
   */
  export type SegmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Segment
     */
    select?: SegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Segment
     */
    omit?: SegmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentInclude<ExtArgs> | null
    /**
     * Filter, which Segment to fetch.
     */
    where?: SegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Segments to fetch.
     */
    orderBy?: SegmentOrderByWithRelationInput | SegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Segments.
     */
    cursor?: SegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Segments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Segments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Segments.
     */
    distinct?: SegmentScalarFieldEnum | SegmentScalarFieldEnum[]
  }

  /**
   * Segment findFirstOrThrow
   */
  export type SegmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Segment
     */
    select?: SegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Segment
     */
    omit?: SegmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentInclude<ExtArgs> | null
    /**
     * Filter, which Segment to fetch.
     */
    where?: SegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Segments to fetch.
     */
    orderBy?: SegmentOrderByWithRelationInput | SegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Segments.
     */
    cursor?: SegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Segments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Segments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Segments.
     */
    distinct?: SegmentScalarFieldEnum | SegmentScalarFieldEnum[]
  }

  /**
   * Segment findMany
   */
  export type SegmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Segment
     */
    select?: SegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Segment
     */
    omit?: SegmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentInclude<ExtArgs> | null
    /**
     * Filter, which Segments to fetch.
     */
    where?: SegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Segments to fetch.
     */
    orderBy?: SegmentOrderByWithRelationInput | SegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Segments.
     */
    cursor?: SegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Segments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Segments.
     */
    skip?: number
    distinct?: SegmentScalarFieldEnum | SegmentScalarFieldEnum[]
  }

  /**
   * Segment create
   */
  export type SegmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Segment
     */
    select?: SegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Segment
     */
    omit?: SegmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Segment.
     */
    data: XOR<SegmentCreateInput, SegmentUncheckedCreateInput>
  }

  /**
   * Segment createMany
   */
  export type SegmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Segments.
     */
    data: SegmentCreateManyInput | SegmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Segment createManyAndReturn
   */
  export type SegmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Segment
     */
    select?: SegmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Segment
     */
    omit?: SegmentOmit<ExtArgs> | null
    /**
     * The data used to create many Segments.
     */
    data: SegmentCreateManyInput | SegmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Segment update
   */
  export type SegmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Segment
     */
    select?: SegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Segment
     */
    omit?: SegmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Segment.
     */
    data: XOR<SegmentUpdateInput, SegmentUncheckedUpdateInput>
    /**
     * Choose, which Segment to update.
     */
    where: SegmentWhereUniqueInput
  }

  /**
   * Segment updateMany
   */
  export type SegmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Segments.
     */
    data: XOR<SegmentUpdateManyMutationInput, SegmentUncheckedUpdateManyInput>
    /**
     * Filter which Segments to update
     */
    where?: SegmentWhereInput
    /**
     * Limit how many Segments to update.
     */
    limit?: number
  }

  /**
   * Segment updateManyAndReturn
   */
  export type SegmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Segment
     */
    select?: SegmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Segment
     */
    omit?: SegmentOmit<ExtArgs> | null
    /**
     * The data used to update Segments.
     */
    data: XOR<SegmentUpdateManyMutationInput, SegmentUncheckedUpdateManyInput>
    /**
     * Filter which Segments to update
     */
    where?: SegmentWhereInput
    /**
     * Limit how many Segments to update.
     */
    limit?: number
  }

  /**
   * Segment upsert
   */
  export type SegmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Segment
     */
    select?: SegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Segment
     */
    omit?: SegmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Segment to update in case it exists.
     */
    where: SegmentWhereUniqueInput
    /**
     * In case the Segment found by the `where` argument doesn't exist, create a new Segment with this data.
     */
    create: XOR<SegmentCreateInput, SegmentUncheckedCreateInput>
    /**
     * In case the Segment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SegmentUpdateInput, SegmentUncheckedUpdateInput>
  }

  /**
   * Segment delete
   */
  export type SegmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Segment
     */
    select?: SegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Segment
     */
    omit?: SegmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentInclude<ExtArgs> | null
    /**
     * Filter which Segment to delete.
     */
    where: SegmentWhereUniqueInput
  }

  /**
   * Segment deleteMany
   */
  export type SegmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Segments to delete
     */
    where?: SegmentWhereInput
    /**
     * Limit how many Segments to delete.
     */
    limit?: number
  }

  /**
   * Segment.members
   */
  export type Segment$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SegmentMember
     */
    select?: SegmentMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SegmentMember
     */
    omit?: SegmentMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentMemberInclude<ExtArgs> | null
    where?: SegmentMemberWhereInput
    orderBy?: SegmentMemberOrderByWithRelationInput | SegmentMemberOrderByWithRelationInput[]
    cursor?: SegmentMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SegmentMemberScalarFieldEnum | SegmentMemberScalarFieldEnum[]
  }

  /**
   * Segment without action
   */
  export type SegmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Segment
     */
    select?: SegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Segment
     */
    omit?: SegmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentInclude<ExtArgs> | null
  }


  /**
   * Model SegmentMember
   */

  export type AggregateSegmentMember = {
    _count: SegmentMemberCountAggregateOutputType | null
    _min: SegmentMemberMinAggregateOutputType | null
    _max: SegmentMemberMaxAggregateOutputType | null
  }

  export type SegmentMemberMinAggregateOutputType = {
    id: string | null
    segmentId: string | null
    voterId: string | null
    createdAt: Date | null
  }

  export type SegmentMemberMaxAggregateOutputType = {
    id: string | null
    segmentId: string | null
    voterId: string | null
    createdAt: Date | null
  }

  export type SegmentMemberCountAggregateOutputType = {
    id: number
    segmentId: number
    voterId: number
    createdAt: number
    _all: number
  }


  export type SegmentMemberMinAggregateInputType = {
    id?: true
    segmentId?: true
    voterId?: true
    createdAt?: true
  }

  export type SegmentMemberMaxAggregateInputType = {
    id?: true
    segmentId?: true
    voterId?: true
    createdAt?: true
  }

  export type SegmentMemberCountAggregateInputType = {
    id?: true
    segmentId?: true
    voterId?: true
    createdAt?: true
    _all?: true
  }

  export type SegmentMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SegmentMember to aggregate.
     */
    where?: SegmentMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SegmentMembers to fetch.
     */
    orderBy?: SegmentMemberOrderByWithRelationInput | SegmentMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SegmentMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SegmentMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SegmentMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SegmentMembers
    **/
    _count?: true | SegmentMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SegmentMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SegmentMemberMaxAggregateInputType
  }

  export type GetSegmentMemberAggregateType<T extends SegmentMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateSegmentMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSegmentMember[P]>
      : GetScalarType<T[P], AggregateSegmentMember[P]>
  }




  export type SegmentMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SegmentMemberWhereInput
    orderBy?: SegmentMemberOrderByWithAggregationInput | SegmentMemberOrderByWithAggregationInput[]
    by: SegmentMemberScalarFieldEnum[] | SegmentMemberScalarFieldEnum
    having?: SegmentMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SegmentMemberCountAggregateInputType | true
    _min?: SegmentMemberMinAggregateInputType
    _max?: SegmentMemberMaxAggregateInputType
  }

  export type SegmentMemberGroupByOutputType = {
    id: string
    segmentId: string
    voterId: string
    createdAt: Date
    _count: SegmentMemberCountAggregateOutputType | null
    _min: SegmentMemberMinAggregateOutputType | null
    _max: SegmentMemberMaxAggregateOutputType | null
  }

  type GetSegmentMemberGroupByPayload<T extends SegmentMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SegmentMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SegmentMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SegmentMemberGroupByOutputType[P]>
            : GetScalarType<T[P], SegmentMemberGroupByOutputType[P]>
        }
      >
    >


  export type SegmentMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    segmentId?: boolean
    voterId?: boolean
    createdAt?: boolean
    segment?: boolean | SegmentDefaultArgs<ExtArgs>
    voter?: boolean | VoterRegistrationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["segmentMember"]>

  export type SegmentMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    segmentId?: boolean
    voterId?: boolean
    createdAt?: boolean
    segment?: boolean | SegmentDefaultArgs<ExtArgs>
    voter?: boolean | VoterRegistrationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["segmentMember"]>

  export type SegmentMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    segmentId?: boolean
    voterId?: boolean
    createdAt?: boolean
    segment?: boolean | SegmentDefaultArgs<ExtArgs>
    voter?: boolean | VoterRegistrationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["segmentMember"]>

  export type SegmentMemberSelectScalar = {
    id?: boolean
    segmentId?: boolean
    voterId?: boolean
    createdAt?: boolean
  }

  export type SegmentMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "segmentId" | "voterId" | "createdAt", ExtArgs["result"]["segmentMember"]>
  export type SegmentMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    segment?: boolean | SegmentDefaultArgs<ExtArgs>
    voter?: boolean | VoterRegistrationDefaultArgs<ExtArgs>
  }
  export type SegmentMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    segment?: boolean | SegmentDefaultArgs<ExtArgs>
    voter?: boolean | VoterRegistrationDefaultArgs<ExtArgs>
  }
  export type SegmentMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    segment?: boolean | SegmentDefaultArgs<ExtArgs>
    voter?: boolean | VoterRegistrationDefaultArgs<ExtArgs>
  }

  export type $SegmentMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SegmentMember"
    objects: {
      segment: Prisma.$SegmentPayload<ExtArgs>
      voter: Prisma.$VoterRegistrationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      segmentId: string
      voterId: string
      createdAt: Date
    }, ExtArgs["result"]["segmentMember"]>
    composites: {}
  }

  type SegmentMemberGetPayload<S extends boolean | null | undefined | SegmentMemberDefaultArgs> = $Result.GetResult<Prisma.$SegmentMemberPayload, S>

  type SegmentMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SegmentMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SegmentMemberCountAggregateInputType | true
    }

  export interface SegmentMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SegmentMember'], meta: { name: 'SegmentMember' } }
    /**
     * Find zero or one SegmentMember that matches the filter.
     * @param {SegmentMemberFindUniqueArgs} args - Arguments to find a SegmentMember
     * @example
     * // Get one SegmentMember
     * const segmentMember = await prisma.segmentMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SegmentMemberFindUniqueArgs>(args: SelectSubset<T, SegmentMemberFindUniqueArgs<ExtArgs>>): Prisma__SegmentMemberClient<$Result.GetResult<Prisma.$SegmentMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SegmentMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SegmentMemberFindUniqueOrThrowArgs} args - Arguments to find a SegmentMember
     * @example
     * // Get one SegmentMember
     * const segmentMember = await prisma.segmentMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SegmentMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, SegmentMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SegmentMemberClient<$Result.GetResult<Prisma.$SegmentMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SegmentMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SegmentMemberFindFirstArgs} args - Arguments to find a SegmentMember
     * @example
     * // Get one SegmentMember
     * const segmentMember = await prisma.segmentMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SegmentMemberFindFirstArgs>(args?: SelectSubset<T, SegmentMemberFindFirstArgs<ExtArgs>>): Prisma__SegmentMemberClient<$Result.GetResult<Prisma.$SegmentMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SegmentMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SegmentMemberFindFirstOrThrowArgs} args - Arguments to find a SegmentMember
     * @example
     * // Get one SegmentMember
     * const segmentMember = await prisma.segmentMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SegmentMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, SegmentMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__SegmentMemberClient<$Result.GetResult<Prisma.$SegmentMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SegmentMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SegmentMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SegmentMembers
     * const segmentMembers = await prisma.segmentMember.findMany()
     * 
     * // Get first 10 SegmentMembers
     * const segmentMembers = await prisma.segmentMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const segmentMemberWithIdOnly = await prisma.segmentMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SegmentMemberFindManyArgs>(args?: SelectSubset<T, SegmentMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SegmentMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SegmentMember.
     * @param {SegmentMemberCreateArgs} args - Arguments to create a SegmentMember.
     * @example
     * // Create one SegmentMember
     * const SegmentMember = await prisma.segmentMember.create({
     *   data: {
     *     // ... data to create a SegmentMember
     *   }
     * })
     * 
     */
    create<T extends SegmentMemberCreateArgs>(args: SelectSubset<T, SegmentMemberCreateArgs<ExtArgs>>): Prisma__SegmentMemberClient<$Result.GetResult<Prisma.$SegmentMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SegmentMembers.
     * @param {SegmentMemberCreateManyArgs} args - Arguments to create many SegmentMembers.
     * @example
     * // Create many SegmentMembers
     * const segmentMember = await prisma.segmentMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SegmentMemberCreateManyArgs>(args?: SelectSubset<T, SegmentMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SegmentMembers and returns the data saved in the database.
     * @param {SegmentMemberCreateManyAndReturnArgs} args - Arguments to create many SegmentMembers.
     * @example
     * // Create many SegmentMembers
     * const segmentMember = await prisma.segmentMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SegmentMembers and only return the `id`
     * const segmentMemberWithIdOnly = await prisma.segmentMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SegmentMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, SegmentMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SegmentMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SegmentMember.
     * @param {SegmentMemberDeleteArgs} args - Arguments to delete one SegmentMember.
     * @example
     * // Delete one SegmentMember
     * const SegmentMember = await prisma.segmentMember.delete({
     *   where: {
     *     // ... filter to delete one SegmentMember
     *   }
     * })
     * 
     */
    delete<T extends SegmentMemberDeleteArgs>(args: SelectSubset<T, SegmentMemberDeleteArgs<ExtArgs>>): Prisma__SegmentMemberClient<$Result.GetResult<Prisma.$SegmentMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SegmentMember.
     * @param {SegmentMemberUpdateArgs} args - Arguments to update one SegmentMember.
     * @example
     * // Update one SegmentMember
     * const segmentMember = await prisma.segmentMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SegmentMemberUpdateArgs>(args: SelectSubset<T, SegmentMemberUpdateArgs<ExtArgs>>): Prisma__SegmentMemberClient<$Result.GetResult<Prisma.$SegmentMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SegmentMembers.
     * @param {SegmentMemberDeleteManyArgs} args - Arguments to filter SegmentMembers to delete.
     * @example
     * // Delete a few SegmentMembers
     * const { count } = await prisma.segmentMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SegmentMemberDeleteManyArgs>(args?: SelectSubset<T, SegmentMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SegmentMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SegmentMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SegmentMembers
     * const segmentMember = await prisma.segmentMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SegmentMemberUpdateManyArgs>(args: SelectSubset<T, SegmentMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SegmentMembers and returns the data updated in the database.
     * @param {SegmentMemberUpdateManyAndReturnArgs} args - Arguments to update many SegmentMembers.
     * @example
     * // Update many SegmentMembers
     * const segmentMember = await prisma.segmentMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SegmentMembers and only return the `id`
     * const segmentMemberWithIdOnly = await prisma.segmentMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SegmentMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, SegmentMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SegmentMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SegmentMember.
     * @param {SegmentMemberUpsertArgs} args - Arguments to update or create a SegmentMember.
     * @example
     * // Update or create a SegmentMember
     * const segmentMember = await prisma.segmentMember.upsert({
     *   create: {
     *     // ... data to create a SegmentMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SegmentMember we want to update
     *   }
     * })
     */
    upsert<T extends SegmentMemberUpsertArgs>(args: SelectSubset<T, SegmentMemberUpsertArgs<ExtArgs>>): Prisma__SegmentMemberClient<$Result.GetResult<Prisma.$SegmentMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SegmentMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SegmentMemberCountArgs} args - Arguments to filter SegmentMembers to count.
     * @example
     * // Count the number of SegmentMembers
     * const count = await prisma.segmentMember.count({
     *   where: {
     *     // ... the filter for the SegmentMembers we want to count
     *   }
     * })
    **/
    count<T extends SegmentMemberCountArgs>(
      args?: Subset<T, SegmentMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SegmentMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SegmentMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SegmentMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SegmentMemberAggregateArgs>(args: Subset<T, SegmentMemberAggregateArgs>): Prisma.PrismaPromise<GetSegmentMemberAggregateType<T>>

    /**
     * Group by SegmentMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SegmentMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SegmentMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SegmentMemberGroupByArgs['orderBy'] }
        : { orderBy?: SegmentMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SegmentMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSegmentMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SegmentMember model
   */
  readonly fields: SegmentMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SegmentMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SegmentMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    segment<T extends SegmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SegmentDefaultArgs<ExtArgs>>): Prisma__SegmentClient<$Result.GetResult<Prisma.$SegmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    voter<T extends VoterRegistrationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VoterRegistrationDefaultArgs<ExtArgs>>): Prisma__VoterRegistrationClient<$Result.GetResult<Prisma.$VoterRegistrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SegmentMember model
   */
  interface SegmentMemberFieldRefs {
    readonly id: FieldRef<"SegmentMember", 'String'>
    readonly segmentId: FieldRef<"SegmentMember", 'String'>
    readonly voterId: FieldRef<"SegmentMember", 'String'>
    readonly createdAt: FieldRef<"SegmentMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SegmentMember findUnique
   */
  export type SegmentMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SegmentMember
     */
    select?: SegmentMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SegmentMember
     */
    omit?: SegmentMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentMemberInclude<ExtArgs> | null
    /**
     * Filter, which SegmentMember to fetch.
     */
    where: SegmentMemberWhereUniqueInput
  }

  /**
   * SegmentMember findUniqueOrThrow
   */
  export type SegmentMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SegmentMember
     */
    select?: SegmentMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SegmentMember
     */
    omit?: SegmentMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentMemberInclude<ExtArgs> | null
    /**
     * Filter, which SegmentMember to fetch.
     */
    where: SegmentMemberWhereUniqueInput
  }

  /**
   * SegmentMember findFirst
   */
  export type SegmentMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SegmentMember
     */
    select?: SegmentMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SegmentMember
     */
    omit?: SegmentMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentMemberInclude<ExtArgs> | null
    /**
     * Filter, which SegmentMember to fetch.
     */
    where?: SegmentMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SegmentMembers to fetch.
     */
    orderBy?: SegmentMemberOrderByWithRelationInput | SegmentMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SegmentMembers.
     */
    cursor?: SegmentMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SegmentMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SegmentMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SegmentMembers.
     */
    distinct?: SegmentMemberScalarFieldEnum | SegmentMemberScalarFieldEnum[]
  }

  /**
   * SegmentMember findFirstOrThrow
   */
  export type SegmentMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SegmentMember
     */
    select?: SegmentMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SegmentMember
     */
    omit?: SegmentMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentMemberInclude<ExtArgs> | null
    /**
     * Filter, which SegmentMember to fetch.
     */
    where?: SegmentMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SegmentMembers to fetch.
     */
    orderBy?: SegmentMemberOrderByWithRelationInput | SegmentMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SegmentMembers.
     */
    cursor?: SegmentMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SegmentMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SegmentMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SegmentMembers.
     */
    distinct?: SegmentMemberScalarFieldEnum | SegmentMemberScalarFieldEnum[]
  }

  /**
   * SegmentMember findMany
   */
  export type SegmentMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SegmentMember
     */
    select?: SegmentMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SegmentMember
     */
    omit?: SegmentMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentMemberInclude<ExtArgs> | null
    /**
     * Filter, which SegmentMembers to fetch.
     */
    where?: SegmentMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SegmentMembers to fetch.
     */
    orderBy?: SegmentMemberOrderByWithRelationInput | SegmentMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SegmentMembers.
     */
    cursor?: SegmentMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SegmentMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SegmentMembers.
     */
    skip?: number
    distinct?: SegmentMemberScalarFieldEnum | SegmentMemberScalarFieldEnum[]
  }

  /**
   * SegmentMember create
   */
  export type SegmentMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SegmentMember
     */
    select?: SegmentMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SegmentMember
     */
    omit?: SegmentMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a SegmentMember.
     */
    data: XOR<SegmentMemberCreateInput, SegmentMemberUncheckedCreateInput>
  }

  /**
   * SegmentMember createMany
   */
  export type SegmentMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SegmentMembers.
     */
    data: SegmentMemberCreateManyInput | SegmentMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SegmentMember createManyAndReturn
   */
  export type SegmentMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SegmentMember
     */
    select?: SegmentMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SegmentMember
     */
    omit?: SegmentMemberOmit<ExtArgs> | null
    /**
     * The data used to create many SegmentMembers.
     */
    data: SegmentMemberCreateManyInput | SegmentMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SegmentMember update
   */
  export type SegmentMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SegmentMember
     */
    select?: SegmentMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SegmentMember
     */
    omit?: SegmentMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a SegmentMember.
     */
    data: XOR<SegmentMemberUpdateInput, SegmentMemberUncheckedUpdateInput>
    /**
     * Choose, which SegmentMember to update.
     */
    where: SegmentMemberWhereUniqueInput
  }

  /**
   * SegmentMember updateMany
   */
  export type SegmentMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SegmentMembers.
     */
    data: XOR<SegmentMemberUpdateManyMutationInput, SegmentMemberUncheckedUpdateManyInput>
    /**
     * Filter which SegmentMembers to update
     */
    where?: SegmentMemberWhereInput
    /**
     * Limit how many SegmentMembers to update.
     */
    limit?: number
  }

  /**
   * SegmentMember updateManyAndReturn
   */
  export type SegmentMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SegmentMember
     */
    select?: SegmentMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SegmentMember
     */
    omit?: SegmentMemberOmit<ExtArgs> | null
    /**
     * The data used to update SegmentMembers.
     */
    data: XOR<SegmentMemberUpdateManyMutationInput, SegmentMemberUncheckedUpdateManyInput>
    /**
     * Filter which SegmentMembers to update
     */
    where?: SegmentMemberWhereInput
    /**
     * Limit how many SegmentMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SegmentMember upsert
   */
  export type SegmentMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SegmentMember
     */
    select?: SegmentMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SegmentMember
     */
    omit?: SegmentMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the SegmentMember to update in case it exists.
     */
    where: SegmentMemberWhereUniqueInput
    /**
     * In case the SegmentMember found by the `where` argument doesn't exist, create a new SegmentMember with this data.
     */
    create: XOR<SegmentMemberCreateInput, SegmentMemberUncheckedCreateInput>
    /**
     * In case the SegmentMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SegmentMemberUpdateInput, SegmentMemberUncheckedUpdateInput>
  }

  /**
   * SegmentMember delete
   */
  export type SegmentMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SegmentMember
     */
    select?: SegmentMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SegmentMember
     */
    omit?: SegmentMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentMemberInclude<ExtArgs> | null
    /**
     * Filter which SegmentMember to delete.
     */
    where: SegmentMemberWhereUniqueInput
  }

  /**
   * SegmentMember deleteMany
   */
  export type SegmentMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SegmentMembers to delete
     */
    where?: SegmentMemberWhereInput
    /**
     * Limit how many SegmentMembers to delete.
     */
    limit?: number
  }

  /**
   * SegmentMember without action
   */
  export type SegmentMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SegmentMember
     */
    select?: SegmentMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SegmentMember
     */
    omit?: SegmentMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentMemberInclude<ExtArgs> | null
  }


  /**
   * Model ImportJob
   */

  export type AggregateImportJob = {
    _count: ImportJobCountAggregateOutputType | null
    _avg: ImportJobAvgAggregateOutputType | null
    _sum: ImportJobSumAggregateOutputType | null
    _min: ImportJobMinAggregateOutputType | null
    _max: ImportJobMaxAggregateOutputType | null
  }

  export type ImportJobAvgAggregateOutputType = {
    rowCount: number | null
  }

  export type ImportJobSumAggregateOutputType = {
    rowCount: number | null
  }

  export type ImportJobMinAggregateOutputType = {
    id: string | null
    kind: $Enums.ImportJobKind | null
    status: $Enums.ImportJobStatus | null
    fileName: string | null
    fileHash: string | null
    rowCount: number | null
    startedAt: Date | null
    completedAt: Date | null
    errorText: string | null
    createdAt: Date | null
  }

  export type ImportJobMaxAggregateOutputType = {
    id: string | null
    kind: $Enums.ImportJobKind | null
    status: $Enums.ImportJobStatus | null
    fileName: string | null
    fileHash: string | null
    rowCount: number | null
    startedAt: Date | null
    completedAt: Date | null
    errorText: string | null
    createdAt: Date | null
  }

  export type ImportJobCountAggregateOutputType = {
    id: number
    kind: number
    status: number
    fileName: number
    fileHash: number
    rowCount: number
    startedAt: number
    completedAt: number
    errorText: number
    createdAt: number
    _all: number
  }


  export type ImportJobAvgAggregateInputType = {
    rowCount?: true
  }

  export type ImportJobSumAggregateInputType = {
    rowCount?: true
  }

  export type ImportJobMinAggregateInputType = {
    id?: true
    kind?: true
    status?: true
    fileName?: true
    fileHash?: true
    rowCount?: true
    startedAt?: true
    completedAt?: true
    errorText?: true
    createdAt?: true
  }

  export type ImportJobMaxAggregateInputType = {
    id?: true
    kind?: true
    status?: true
    fileName?: true
    fileHash?: true
    rowCount?: true
    startedAt?: true
    completedAt?: true
    errorText?: true
    createdAt?: true
  }

  export type ImportJobCountAggregateInputType = {
    id?: true
    kind?: true
    status?: true
    fileName?: true
    fileHash?: true
    rowCount?: true
    startedAt?: true
    completedAt?: true
    errorText?: true
    createdAt?: true
    _all?: true
  }

  export type ImportJobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImportJob to aggregate.
     */
    where?: ImportJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportJobs to fetch.
     */
    orderBy?: ImportJobOrderByWithRelationInput | ImportJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImportJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ImportJobs
    **/
    _count?: true | ImportJobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ImportJobAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ImportJobSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImportJobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImportJobMaxAggregateInputType
  }

  export type GetImportJobAggregateType<T extends ImportJobAggregateArgs> = {
        [P in keyof T & keyof AggregateImportJob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImportJob[P]>
      : GetScalarType<T[P], AggregateImportJob[P]>
  }




  export type ImportJobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImportJobWhereInput
    orderBy?: ImportJobOrderByWithAggregationInput | ImportJobOrderByWithAggregationInput[]
    by: ImportJobScalarFieldEnum[] | ImportJobScalarFieldEnum
    having?: ImportJobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImportJobCountAggregateInputType | true
    _avg?: ImportJobAvgAggregateInputType
    _sum?: ImportJobSumAggregateInputType
    _min?: ImportJobMinAggregateInputType
    _max?: ImportJobMaxAggregateInputType
  }

  export type ImportJobGroupByOutputType = {
    id: string
    kind: $Enums.ImportJobKind
    status: $Enums.ImportJobStatus
    fileName: string | null
    fileHash: string | null
    rowCount: number | null
    startedAt: Date | null
    completedAt: Date | null
    errorText: string | null
    createdAt: Date
    _count: ImportJobCountAggregateOutputType | null
    _avg: ImportJobAvgAggregateOutputType | null
    _sum: ImportJobSumAggregateOutputType | null
    _min: ImportJobMinAggregateOutputType | null
    _max: ImportJobMaxAggregateOutputType | null
  }

  type GetImportJobGroupByPayload<T extends ImportJobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImportJobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImportJobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImportJobGroupByOutputType[P]>
            : GetScalarType<T[P], ImportJobGroupByOutputType[P]>
        }
      >
    >


  export type ImportJobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kind?: boolean
    status?: boolean
    fileName?: boolean
    fileHash?: boolean
    rowCount?: boolean
    startedAt?: boolean
    completedAt?: boolean
    errorText?: boolean
    createdAt?: boolean
    auditLogs?: boolean | ImportJob$auditLogsArgs<ExtArgs>
    _count?: boolean | ImportJobCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["importJob"]>

  export type ImportJobSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kind?: boolean
    status?: boolean
    fileName?: boolean
    fileHash?: boolean
    rowCount?: boolean
    startedAt?: boolean
    completedAt?: boolean
    errorText?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["importJob"]>

  export type ImportJobSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kind?: boolean
    status?: boolean
    fileName?: boolean
    fileHash?: boolean
    rowCount?: boolean
    startedAt?: boolean
    completedAt?: boolean
    errorText?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["importJob"]>

  export type ImportJobSelectScalar = {
    id?: boolean
    kind?: boolean
    status?: boolean
    fileName?: boolean
    fileHash?: boolean
    rowCount?: boolean
    startedAt?: boolean
    completedAt?: boolean
    errorText?: boolean
    createdAt?: boolean
  }

  export type ImportJobOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "kind" | "status" | "fileName" | "fileHash" | "rowCount" | "startedAt" | "completedAt" | "errorText" | "createdAt", ExtArgs["result"]["importJob"]>
  export type ImportJobInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditLogs?: boolean | ImportJob$auditLogsArgs<ExtArgs>
    _count?: boolean | ImportJobCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ImportJobIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ImportJobIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ImportJobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ImportJob"
    objects: {
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      kind: $Enums.ImportJobKind
      status: $Enums.ImportJobStatus
      fileName: string | null
      fileHash: string | null
      rowCount: number | null
      startedAt: Date | null
      completedAt: Date | null
      errorText: string | null
      createdAt: Date
    }, ExtArgs["result"]["importJob"]>
    composites: {}
  }

  type ImportJobGetPayload<S extends boolean | null | undefined | ImportJobDefaultArgs> = $Result.GetResult<Prisma.$ImportJobPayload, S>

  type ImportJobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ImportJobFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ImportJobCountAggregateInputType | true
    }

  export interface ImportJobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ImportJob'], meta: { name: 'ImportJob' } }
    /**
     * Find zero or one ImportJob that matches the filter.
     * @param {ImportJobFindUniqueArgs} args - Arguments to find a ImportJob
     * @example
     * // Get one ImportJob
     * const importJob = await prisma.importJob.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ImportJobFindUniqueArgs>(args: SelectSubset<T, ImportJobFindUniqueArgs<ExtArgs>>): Prisma__ImportJobClient<$Result.GetResult<Prisma.$ImportJobPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ImportJob that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ImportJobFindUniqueOrThrowArgs} args - Arguments to find a ImportJob
     * @example
     * // Get one ImportJob
     * const importJob = await prisma.importJob.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ImportJobFindUniqueOrThrowArgs>(args: SelectSubset<T, ImportJobFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ImportJobClient<$Result.GetResult<Prisma.$ImportJobPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ImportJob that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportJobFindFirstArgs} args - Arguments to find a ImportJob
     * @example
     * // Get one ImportJob
     * const importJob = await prisma.importJob.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ImportJobFindFirstArgs>(args?: SelectSubset<T, ImportJobFindFirstArgs<ExtArgs>>): Prisma__ImportJobClient<$Result.GetResult<Prisma.$ImportJobPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ImportJob that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportJobFindFirstOrThrowArgs} args - Arguments to find a ImportJob
     * @example
     * // Get one ImportJob
     * const importJob = await prisma.importJob.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ImportJobFindFirstOrThrowArgs>(args?: SelectSubset<T, ImportJobFindFirstOrThrowArgs<ExtArgs>>): Prisma__ImportJobClient<$Result.GetResult<Prisma.$ImportJobPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ImportJobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportJobFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ImportJobs
     * const importJobs = await prisma.importJob.findMany()
     * 
     * // Get first 10 ImportJobs
     * const importJobs = await prisma.importJob.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const importJobWithIdOnly = await prisma.importJob.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ImportJobFindManyArgs>(args?: SelectSubset<T, ImportJobFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImportJobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ImportJob.
     * @param {ImportJobCreateArgs} args - Arguments to create a ImportJob.
     * @example
     * // Create one ImportJob
     * const ImportJob = await prisma.importJob.create({
     *   data: {
     *     // ... data to create a ImportJob
     *   }
     * })
     * 
     */
    create<T extends ImportJobCreateArgs>(args: SelectSubset<T, ImportJobCreateArgs<ExtArgs>>): Prisma__ImportJobClient<$Result.GetResult<Prisma.$ImportJobPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ImportJobs.
     * @param {ImportJobCreateManyArgs} args - Arguments to create many ImportJobs.
     * @example
     * // Create many ImportJobs
     * const importJob = await prisma.importJob.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ImportJobCreateManyArgs>(args?: SelectSubset<T, ImportJobCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ImportJobs and returns the data saved in the database.
     * @param {ImportJobCreateManyAndReturnArgs} args - Arguments to create many ImportJobs.
     * @example
     * // Create many ImportJobs
     * const importJob = await prisma.importJob.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ImportJobs and only return the `id`
     * const importJobWithIdOnly = await prisma.importJob.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ImportJobCreateManyAndReturnArgs>(args?: SelectSubset<T, ImportJobCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImportJobPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ImportJob.
     * @param {ImportJobDeleteArgs} args - Arguments to delete one ImportJob.
     * @example
     * // Delete one ImportJob
     * const ImportJob = await prisma.importJob.delete({
     *   where: {
     *     // ... filter to delete one ImportJob
     *   }
     * })
     * 
     */
    delete<T extends ImportJobDeleteArgs>(args: SelectSubset<T, ImportJobDeleteArgs<ExtArgs>>): Prisma__ImportJobClient<$Result.GetResult<Prisma.$ImportJobPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ImportJob.
     * @param {ImportJobUpdateArgs} args - Arguments to update one ImportJob.
     * @example
     * // Update one ImportJob
     * const importJob = await prisma.importJob.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ImportJobUpdateArgs>(args: SelectSubset<T, ImportJobUpdateArgs<ExtArgs>>): Prisma__ImportJobClient<$Result.GetResult<Prisma.$ImportJobPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ImportJobs.
     * @param {ImportJobDeleteManyArgs} args - Arguments to filter ImportJobs to delete.
     * @example
     * // Delete a few ImportJobs
     * const { count } = await prisma.importJob.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ImportJobDeleteManyArgs>(args?: SelectSubset<T, ImportJobDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ImportJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportJobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ImportJobs
     * const importJob = await prisma.importJob.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ImportJobUpdateManyArgs>(args: SelectSubset<T, ImportJobUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ImportJobs and returns the data updated in the database.
     * @param {ImportJobUpdateManyAndReturnArgs} args - Arguments to update many ImportJobs.
     * @example
     * // Update many ImportJobs
     * const importJob = await prisma.importJob.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ImportJobs and only return the `id`
     * const importJobWithIdOnly = await prisma.importJob.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ImportJobUpdateManyAndReturnArgs>(args: SelectSubset<T, ImportJobUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImportJobPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ImportJob.
     * @param {ImportJobUpsertArgs} args - Arguments to update or create a ImportJob.
     * @example
     * // Update or create a ImportJob
     * const importJob = await prisma.importJob.upsert({
     *   create: {
     *     // ... data to create a ImportJob
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ImportJob we want to update
     *   }
     * })
     */
    upsert<T extends ImportJobUpsertArgs>(args: SelectSubset<T, ImportJobUpsertArgs<ExtArgs>>): Prisma__ImportJobClient<$Result.GetResult<Prisma.$ImportJobPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ImportJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportJobCountArgs} args - Arguments to filter ImportJobs to count.
     * @example
     * // Count the number of ImportJobs
     * const count = await prisma.importJob.count({
     *   where: {
     *     // ... the filter for the ImportJobs we want to count
     *   }
     * })
    **/
    count<T extends ImportJobCountArgs>(
      args?: Subset<T, ImportJobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImportJobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ImportJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportJobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImportJobAggregateArgs>(args: Subset<T, ImportJobAggregateArgs>): Prisma.PrismaPromise<GetImportJobAggregateType<T>>

    /**
     * Group by ImportJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportJobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImportJobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImportJobGroupByArgs['orderBy'] }
        : { orderBy?: ImportJobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImportJobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImportJobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ImportJob model
   */
  readonly fields: ImportJobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ImportJob.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ImportJobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    auditLogs<T extends ImportJob$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, ImportJob$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ImportJob model
   */
  interface ImportJobFieldRefs {
    readonly id: FieldRef<"ImportJob", 'String'>
    readonly kind: FieldRef<"ImportJob", 'ImportJobKind'>
    readonly status: FieldRef<"ImportJob", 'ImportJobStatus'>
    readonly fileName: FieldRef<"ImportJob", 'String'>
    readonly fileHash: FieldRef<"ImportJob", 'String'>
    readonly rowCount: FieldRef<"ImportJob", 'Int'>
    readonly startedAt: FieldRef<"ImportJob", 'DateTime'>
    readonly completedAt: FieldRef<"ImportJob", 'DateTime'>
    readonly errorText: FieldRef<"ImportJob", 'String'>
    readonly createdAt: FieldRef<"ImportJob", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ImportJob findUnique
   */
  export type ImportJobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportJob
     */
    select?: ImportJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportJob
     */
    omit?: ImportJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportJobInclude<ExtArgs> | null
    /**
     * Filter, which ImportJob to fetch.
     */
    where: ImportJobWhereUniqueInput
  }

  /**
   * ImportJob findUniqueOrThrow
   */
  export type ImportJobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportJob
     */
    select?: ImportJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportJob
     */
    omit?: ImportJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportJobInclude<ExtArgs> | null
    /**
     * Filter, which ImportJob to fetch.
     */
    where: ImportJobWhereUniqueInput
  }

  /**
   * ImportJob findFirst
   */
  export type ImportJobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportJob
     */
    select?: ImportJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportJob
     */
    omit?: ImportJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportJobInclude<ExtArgs> | null
    /**
     * Filter, which ImportJob to fetch.
     */
    where?: ImportJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportJobs to fetch.
     */
    orderBy?: ImportJobOrderByWithRelationInput | ImportJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImportJobs.
     */
    cursor?: ImportJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImportJobs.
     */
    distinct?: ImportJobScalarFieldEnum | ImportJobScalarFieldEnum[]
  }

  /**
   * ImportJob findFirstOrThrow
   */
  export type ImportJobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportJob
     */
    select?: ImportJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportJob
     */
    omit?: ImportJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportJobInclude<ExtArgs> | null
    /**
     * Filter, which ImportJob to fetch.
     */
    where?: ImportJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportJobs to fetch.
     */
    orderBy?: ImportJobOrderByWithRelationInput | ImportJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImportJobs.
     */
    cursor?: ImportJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImportJobs.
     */
    distinct?: ImportJobScalarFieldEnum | ImportJobScalarFieldEnum[]
  }

  /**
   * ImportJob findMany
   */
  export type ImportJobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportJob
     */
    select?: ImportJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportJob
     */
    omit?: ImportJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportJobInclude<ExtArgs> | null
    /**
     * Filter, which ImportJobs to fetch.
     */
    where?: ImportJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportJobs to fetch.
     */
    orderBy?: ImportJobOrderByWithRelationInput | ImportJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ImportJobs.
     */
    cursor?: ImportJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportJobs.
     */
    skip?: number
    distinct?: ImportJobScalarFieldEnum | ImportJobScalarFieldEnum[]
  }

  /**
   * ImportJob create
   */
  export type ImportJobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportJob
     */
    select?: ImportJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportJob
     */
    omit?: ImportJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportJobInclude<ExtArgs> | null
    /**
     * The data needed to create a ImportJob.
     */
    data?: XOR<ImportJobCreateInput, ImportJobUncheckedCreateInput>
  }

  /**
   * ImportJob createMany
   */
  export type ImportJobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ImportJobs.
     */
    data: ImportJobCreateManyInput | ImportJobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ImportJob createManyAndReturn
   */
  export type ImportJobCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportJob
     */
    select?: ImportJobSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ImportJob
     */
    omit?: ImportJobOmit<ExtArgs> | null
    /**
     * The data used to create many ImportJobs.
     */
    data: ImportJobCreateManyInput | ImportJobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ImportJob update
   */
  export type ImportJobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportJob
     */
    select?: ImportJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportJob
     */
    omit?: ImportJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportJobInclude<ExtArgs> | null
    /**
     * The data needed to update a ImportJob.
     */
    data: XOR<ImportJobUpdateInput, ImportJobUncheckedUpdateInput>
    /**
     * Choose, which ImportJob to update.
     */
    where: ImportJobWhereUniqueInput
  }

  /**
   * ImportJob updateMany
   */
  export type ImportJobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ImportJobs.
     */
    data: XOR<ImportJobUpdateManyMutationInput, ImportJobUncheckedUpdateManyInput>
    /**
     * Filter which ImportJobs to update
     */
    where?: ImportJobWhereInput
    /**
     * Limit how many ImportJobs to update.
     */
    limit?: number
  }

  /**
   * ImportJob updateManyAndReturn
   */
  export type ImportJobUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportJob
     */
    select?: ImportJobSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ImportJob
     */
    omit?: ImportJobOmit<ExtArgs> | null
    /**
     * The data used to update ImportJobs.
     */
    data: XOR<ImportJobUpdateManyMutationInput, ImportJobUncheckedUpdateManyInput>
    /**
     * Filter which ImportJobs to update
     */
    where?: ImportJobWhereInput
    /**
     * Limit how many ImportJobs to update.
     */
    limit?: number
  }

  /**
   * ImportJob upsert
   */
  export type ImportJobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportJob
     */
    select?: ImportJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportJob
     */
    omit?: ImportJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportJobInclude<ExtArgs> | null
    /**
     * The filter to search for the ImportJob to update in case it exists.
     */
    where: ImportJobWhereUniqueInput
    /**
     * In case the ImportJob found by the `where` argument doesn't exist, create a new ImportJob with this data.
     */
    create: XOR<ImportJobCreateInput, ImportJobUncheckedCreateInput>
    /**
     * In case the ImportJob was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImportJobUpdateInput, ImportJobUncheckedUpdateInput>
  }

  /**
   * ImportJob delete
   */
  export type ImportJobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportJob
     */
    select?: ImportJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportJob
     */
    omit?: ImportJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportJobInclude<ExtArgs> | null
    /**
     * Filter which ImportJob to delete.
     */
    where: ImportJobWhereUniqueInput
  }

  /**
   * ImportJob deleteMany
   */
  export type ImportJobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImportJobs to delete
     */
    where?: ImportJobWhereInput
    /**
     * Limit how many ImportJobs to delete.
     */
    limit?: number
  }

  /**
   * ImportJob.auditLogs
   */
  export type ImportJob$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * ImportJob without action
   */
  export type ImportJobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportJob
     */
    select?: ImportJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportJob
     */
    omit?: ImportJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportJobInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    actorLabel: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    importJobId: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    actorLabel: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    importJobId: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    actorLabel: number
    action: number
    entityType: number
    entityId: number
    metadataJson: number
    importJobId: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    actorLabel?: true
    action?: true
    entityType?: true
    entityId?: true
    importJobId?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    actorLabel?: true
    action?: true
    entityType?: true
    entityId?: true
    importJobId?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    actorLabel?: true
    action?: true
    entityType?: true
    entityId?: true
    metadataJson?: true
    importJobId?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    actorLabel: string | null
    action: string
    entityType: string | null
    entityId: string | null
    metadataJson: JsonValue | null
    importJobId: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actorLabel?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    metadataJson?: boolean
    importJobId?: boolean
    createdAt?: boolean
    importJob?: boolean | AuditLog$importJobArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actorLabel?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    metadataJson?: boolean
    importJobId?: boolean
    createdAt?: boolean
    importJob?: boolean | AuditLog$importJobArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actorLabel?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    metadataJson?: boolean
    importJobId?: boolean
    createdAt?: boolean
    importJob?: boolean | AuditLog$importJobArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    actorLabel?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    metadataJson?: boolean
    importJobId?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "actorLabel" | "action" | "entityType" | "entityId" | "metadataJson" | "importJobId" | "createdAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    importJob?: boolean | AuditLog$importJobArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    importJob?: boolean | AuditLog$importJobArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    importJob?: boolean | AuditLog$importJobArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      importJob: Prisma.$ImportJobPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      actorLabel: string | null
      action: string
      entityType: string | null
      entityId: string | null
      metadataJson: Prisma.JsonValue | null
      importJobId: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    importJob<T extends AuditLog$importJobArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$importJobArgs<ExtArgs>>): Prisma__ImportJobClient<$Result.GetResult<Prisma.$ImportJobPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly actorLabel: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly entityType: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly metadataJson: FieldRef<"AuditLog", 'Json'>
    readonly importJobId: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog.importJob
   */
  export type AuditLog$importJobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportJob
     */
    select?: ImportJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportJob
     */
    omit?: ImportJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportJobInclude<ExtArgs> | null
    where?: ImportJobWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CountyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    fipsCode: 'fipsCode',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CountyScalarFieldEnum = (typeof CountyScalarFieldEnum)[keyof typeof CountyScalarFieldEnum]


  export const IssueScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    summary: 'summary',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IssueScalarFieldEnum = (typeof IssueScalarFieldEnum)[keyof typeof IssueScalarFieldEnum]


  export const CountyIssueScalarFieldEnum: {
    id: 'id',
    countyId: 'countyId',
    issueId: 'issueId',
    featured: 'featured',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt'
  };

  export type CountyIssueScalarFieldEnum = (typeof CountyIssueScalarFieldEnum)[keyof typeof CountyIssueScalarFieldEnum]


  export const BlueprintSectionScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    title: 'title',
    bodyMd: 'bodyMd',
    countyId: 'countyId',
    issueId: 'issueId',
    sortOrder: 'sortOrder',
    isPinned: 'isPinned',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BlueprintSectionScalarFieldEnum = (typeof BlueprintSectionScalarFieldEnum)[keyof typeof BlueprintSectionScalarFieldEnum]


  export const QuoteScalarFieldEnum: {
    id: 'id',
    text: 'text',
    attributionLabel: 'attributionLabel',
    countyId: 'countyId',
    issueId: 'issueId',
    sourceNote: 'sourceNote',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuoteScalarFieldEnum = (typeof QuoteScalarFieldEnum)[keyof typeof QuoteScalarFieldEnum]


  export const AssetScalarFieldEnum: {
    id: 'id',
    assetType: 'assetType',
    title: 'title',
    caption: 'caption',
    credit: 'credit',
    license: 'license',
    url: 'url',
    storageKey: 'storageKey',
    countyId: 'countyId',
    issueId: 'issueId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AssetScalarFieldEnum = (typeof AssetScalarFieldEnum)[keyof typeof AssetScalarFieldEnum]


  export const GlossaryTermScalarFieldEnum: {
    id: 'id',
    term: 'term',
    slug: 'slug',
    definitionMd: 'definitionMd',
    examplesMd: 'examplesMd',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GlossaryTermScalarFieldEnum = (typeof GlossaryTermScalarFieldEnum)[keyof typeof GlossaryTermScalarFieldEnum]


  export const SourceDocumentScalarFieldEnum: {
    id: 'id',
    title: 'title',
    url: 'url',
    storageKey: 'storageKey',
    publisher: 'publisher',
    publishedAt: 'publishedAt',
    capturedAt: 'capturedAt',
    methodNote: 'methodNote',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SourceDocumentScalarFieldEnum = (typeof SourceDocumentScalarFieldEnum)[keyof typeof SourceDocumentScalarFieldEnum]


  export const SourceChunkScalarFieldEnum: {
    id: 'id',
    sourceDocumentId: 'sourceDocumentId',
    chunkIndex: 'chunkIndex',
    content: 'content',
    contentHash: 'contentHash',
    locatorJson: 'locatorJson',
    createdAt: 'createdAt'
  };

  export type SourceChunkScalarFieldEnum = (typeof SourceChunkScalarFieldEnum)[keyof typeof SourceChunkScalarFieldEnum]


  export const SourceDocumentLinkScalarFieldEnum: {
    id: 'id',
    sourceDocumentId: 'sourceDocumentId',
    countyId: 'countyId',
    issueId: 'issueId',
    blueprintSectionId: 'blueprintSectionId',
    quoteId: 'quoteId',
    assetId: 'assetId',
    surveyFormId: 'surveyFormId',
    note: 'note',
    createdAt: 'createdAt'
  };

  export type SourceDocumentLinkScalarFieldEnum = (typeof SourceDocumentLinkScalarFieldEnum)[keyof typeof SourceDocumentLinkScalarFieldEnum]


  export const GeoCountyScalarFieldEnum: {
    id: 'id',
    fipsCode: 'fipsCode',
    name: 'name',
    createdAt: 'createdAt'
  };

  export type GeoCountyScalarFieldEnum = (typeof GeoCountyScalarFieldEnum)[keyof typeof GeoCountyScalarFieldEnum]


  export const GeoZipScalarFieldEnum: {
    id: 'id',
    zipCode: 'zipCode',
    createdAt: 'createdAt'
  };

  export type GeoZipScalarFieldEnum = (typeof GeoZipScalarFieldEnum)[keyof typeof GeoZipScalarFieldEnum]


  export const GeoPrecinctScalarFieldEnum: {
    id: 'id',
    name: 'name',
    precinctCode: 'precinctCode',
    createdAt: 'createdAt'
  };

  export type GeoPrecinctScalarFieldEnum = (typeof GeoPrecinctScalarFieldEnum)[keyof typeof GeoPrecinctScalarFieldEnum]


  export const GeoDistrictScalarFieldEnum: {
    id: 'id',
    districtCode: 'districtCode',
    districtType: 'districtType',
    createdAt: 'createdAt'
  };

  export type GeoDistrictScalarFieldEnum = (typeof GeoDistrictScalarFieldEnum)[keyof typeof GeoDistrictScalarFieldEnum]


  export const GeoCrosswalkScalarFieldEnum: {
    id: 'id',
    crosswalkType: 'crosswalkType',
    fromGeoZipId: 'fromGeoZipId',
    fromGeoPrecinctId: 'fromGeoPrecinctId',
    fromGeoDistrictId: 'fromGeoDistrictId',
    fromGeoCountyFips: 'fromGeoCountyFips',
    toGeoZipId: 'toGeoZipId',
    toGeoPrecinctId: 'toGeoPrecinctId',
    toGeoDistrictId: 'toGeoDistrictId',
    toGeoCountyFips: 'toGeoCountyFips',
    weight: 'weight',
    createdAt: 'createdAt'
  };

  export type GeoCrosswalkScalarFieldEnum = (typeof GeoCrosswalkScalarFieldEnum)[keyof typeof GeoCrosswalkScalarFieldEnum]


  export const CensusMetricScalarFieldEnum: {
    id: 'id',
    countyId: 'countyId',
    geoZipId: 'geoZipId',
    metricKey: 'metricKey',
    metricLabel: 'metricLabel',
    value: 'value',
    valueText: 'valueText',
    asOfDate: 'asOfDate',
    sourceNote: 'sourceNote',
    createdAt: 'createdAt'
  };

  export type CensusMetricScalarFieldEnum = (typeof CensusMetricScalarFieldEnum)[keyof typeof CensusMetricScalarFieldEnum]


  export const BLSMetricScalarFieldEnum: {
    id: 'id',
    countyId: 'countyId',
    seriesKey: 'seriesKey',
    seriesLabel: 'seriesLabel',
    value: 'value',
    asOfDate: 'asOfDate',
    sourceNote: 'sourceNote',
    createdAt: 'createdAt'
  };

  export type BLSMetricScalarFieldEnum = (typeof BLSMetricScalarFieldEnum)[keyof typeof BLSMetricScalarFieldEnum]


  export const CivicsOfficialScalarFieldEnum: {
    id: 'id',
    name: 'name',
    officeName: 'officeName',
    party: 'party',
    phone: 'phone',
    website: 'website',
    photoUrl: 'photoUrl',
    countyId: 'countyId',
    districtId: 'districtId',
    sourceNote: 'sourceNote',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CivicsOfficialScalarFieldEnum = (typeof CivicsOfficialScalarFieldEnum)[keyof typeof CivicsOfficialScalarFieldEnum]


  export const ElectionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    electionDate: 'electionDate',
    electionType: 'electionType',
    notes: 'notes',
    createdAt: 'createdAt'
  };

  export type ElectionScalarFieldEnum = (typeof ElectionScalarFieldEnum)[keyof typeof ElectionScalarFieldEnum]


  export const ElectionResultScalarFieldEnum: {
    id: 'id',
    electionId: 'electionId',
    countyId: 'countyId',
    geoZipId: 'geoZipId',
    precinctId: 'precinctId',
    choiceLabel: 'choiceLabel',
    votes: 'votes',
    voteShare: 'voteShare',
    createdAt: 'createdAt'
  };

  export type ElectionResultScalarFieldEnum = (typeof ElectionResultScalarFieldEnum)[keyof typeof ElectionResultScalarFieldEnum]


  export const AIPromptScalarFieldEnum: {
    id: 'id',
    promptKey: 'promptKey',
    version: 'version',
    name: 'name',
    description: 'description',
    template: 'template',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AIPromptScalarFieldEnum = (typeof AIPromptScalarFieldEnum)[keyof typeof AIPromptScalarFieldEnum]


  export const AIRunScalarFieldEnum: {
    id: 'id',
    promptId: 'promptId',
    model: 'model',
    paramsJson: 'paramsJson',
    status: 'status',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    errorText: 'errorText',
    inputSummary: 'inputSummary',
    createdAt: 'createdAt'
  };

  export type AIRunScalarFieldEnum = (typeof AIRunScalarFieldEnum)[keyof typeof AIRunScalarFieldEnum]


  export const AIRunInputSourceScalarFieldEnum: {
    id: 'id',
    runId: 'runId',
    kind: 'kind',
    sourceDocumentId: 'sourceDocumentId',
    externalKey: 'externalKey',
    notes: 'notes',
    createdAt: 'createdAt'
  };

  export type AIRunInputSourceScalarFieldEnum = (typeof AIRunInputSourceScalarFieldEnum)[keyof typeof AIRunInputSourceScalarFieldEnum]


  export const AIOutputScalarFieldEnum: {
    id: 'id',
    runId: 'runId',
    outputType: 'outputType',
    status: 'status',
    title: 'title',
    summary: 'summary',
    contentMd: 'contentMd',
    reviewedAt: 'reviewedAt',
    publishedAt: 'publishedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AIOutputScalarFieldEnum = (typeof AIOutputScalarFieldEnum)[keyof typeof AIOutputScalarFieldEnum]


  export const AIOutputSectionScalarFieldEnum: {
    id: 'id',
    outputId: 'outputId',
    sectionKey: 'sectionKey',
    heading: 'heading',
    order: 'order',
    contentMd: 'contentMd',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AIOutputSectionScalarFieldEnum = (typeof AIOutputSectionScalarFieldEnum)[keyof typeof AIOutputSectionScalarFieldEnum]


  export const AIOutputScopeScalarFieldEnum: {
    id: 'id',
    outputId: 'outputId',
    scopeType: 'scopeType',
    countyId: 'countyId',
    issueId: 'issueId',
    geoZipId: 'geoZipId',
    districtId: 'districtId',
    customKey: 'customKey',
    createdAt: 'createdAt'
  };

  export type AIOutputScopeScalarFieldEnum = (typeof AIOutputScopeScalarFieldEnum)[keyof typeof AIOutputScopeScalarFieldEnum]


  export const CitationScalarFieldEnum: {
    id: 'id',
    outputSectionId: 'outputSectionId',
    sourceChunkId: 'sourceChunkId',
    sourceDocumentId: 'sourceDocumentId',
    label: 'label',
    locatorJson: 'locatorJson',
    createdAt: 'createdAt'
  };

  export type CitationScalarFieldEnum = (typeof CitationScalarFieldEnum)[keyof typeof CitationScalarFieldEnum]


  export const SurveyFormScalarFieldEnum: {
    id: 'id',
    title: 'title',
    descriptionMd: 'descriptionMd',
    slug: 'slug',
    status: 'status',
    startAt: 'startAt',
    endAt: 'endAt',
    countyId: 'countyId',
    contextLabel: 'contextLabel',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SurveyFormScalarFieldEnum = (typeof SurveyFormScalarFieldEnum)[keyof typeof SurveyFormScalarFieldEnum]


  export const SurveyQuestionScalarFieldEnum: {
    id: 'id',
    formId: 'formId',
    questionKey: 'questionKey',
    prompt: 'prompt',
    helpText: 'helpText',
    questionType: 'questionType',
    required: 'required',
    sortOrder: 'sortOrder',
    isActive: 'isActive',
    allowVoice: 'allowVoice',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SurveyQuestionScalarFieldEnum = (typeof SurveyQuestionScalarFieldEnum)[keyof typeof SurveyQuestionScalarFieldEnum]


  export const SurveyQuestionOptionScalarFieldEnum: {
    id: 'id',
    questionId: 'questionId',
    valueKey: 'valueKey',
    label: 'label',
    sortOrder: 'sortOrder',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type SurveyQuestionOptionScalarFieldEnum = (typeof SurveyQuestionOptionScalarFieldEnum)[keyof typeof SurveyQuestionOptionScalarFieldEnum]


  export const SurveyResponseScalarFieldEnum: {
    id: 'id',
    formId: 'formId',
    countyId: 'countyId',
    sourceLabel: 'sourceLabel',
    submittedAt: 'submittedAt',
    ipHash: 'ipHash',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type SurveyResponseScalarFieldEnum = (typeof SurveyResponseScalarFieldEnum)[keyof typeof SurveyResponseScalarFieldEnum]


  export const SurveyResponseItemScalarFieldEnum: {
    id: 'id',
    responseId: 'responseId',
    questionId: 'questionId',
    valueText: 'valueText',
    valueNumber: 'valueNumber',
    valueBoolean: 'valueBoolean',
    selectedOptionId: 'selectedOptionId',
    mediaAssetId: 'mediaAssetId',
    createdAt: 'createdAt'
  };

  export type SurveyResponseItemScalarFieldEnum = (typeof SurveyResponseItemScalarFieldEnum)[keyof typeof SurveyResponseItemScalarFieldEnum]


  export const SurveyResponseItemOptionScalarFieldEnum: {
    id: 'id',
    responseItemId: 'responseItemId',
    optionId: 'optionId',
    createdAt: 'createdAt'
  };

  export type SurveyResponseItemOptionScalarFieldEnum = (typeof SurveyResponseItemOptionScalarFieldEnum)[keyof typeof SurveyResponseItemOptionScalarFieldEnum]


  export const MediaAssetScalarFieldEnum: {
    id: 'id',
    assetType: 'assetType',
    storageProvider: 'storageProvider',
    storageKey: 'storageKey',
    url: 'url',
    mimeType: 'mimeType',
    sizeBytes: 'sizeBytes',
    durationMs: 'durationMs',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MediaAssetScalarFieldEnum = (typeof MediaAssetScalarFieldEnum)[keyof typeof MediaAssetScalarFieldEnum]


  export const TranscriptScalarFieldEnum: {
    id: 'id',
    mediaAssetId: 'mediaAssetId',
    provider: 'provider',
    providerVersion: 'providerVersion',
    language: 'language',
    transcriptText: 'transcriptText',
    segmentsJson: 'segmentsJson',
    createdAt: 'createdAt'
  };

  export type TranscriptScalarFieldEnum = (typeof TranscriptScalarFieldEnum)[keyof typeof TranscriptScalarFieldEnum]


  export const AIAnalysisScalarFieldEnum: {
    id: 'id',
    transcriptId: 'transcriptId',
    mediaAssetId: 'mediaAssetId',
    aiRunId: 'aiRunId',
    analysisType: 'analysisType',
    contentJson: 'contentJson',
    notes: 'notes',
    createdAt: 'createdAt'
  };

  export type AIAnalysisScalarFieldEnum = (typeof AIAnalysisScalarFieldEnum)[keyof typeof AIAnalysisScalarFieldEnum]


  export const VoterRegistrationScalarFieldEnum: {
    id: 'id',
    stateVoterId: 'stateVoterId',
    firstName: 'firstName',
    middleName: 'middleName',
    lastName: 'lastName',
    suffix: 'suffix',
    dateOfBirth: 'dateOfBirth',
    addressLine1: 'addressLine1',
    addressLine2: 'addressLine2',
    city: 'city',
    state: 'state',
    zip: 'zip',
    party: 'party',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VoterRegistrationScalarFieldEnum = (typeof VoterRegistrationScalarFieldEnum)[keyof typeof VoterRegistrationScalarFieldEnum]


  export const VoteHistoryScalarFieldEnum: {
    id: 'id',
    voterId: 'voterId',
    electionDate: 'electionDate',
    electionName: 'electionName',
    voteType: 'voteType',
    createdAt: 'createdAt'
  };

  export type VoteHistoryScalarFieldEnum = (typeof VoteHistoryScalarFieldEnum)[keyof typeof VoteHistoryScalarFieldEnum]


  export const SegmentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SegmentScalarFieldEnum = (typeof SegmentScalarFieldEnum)[keyof typeof SegmentScalarFieldEnum]


  export const SegmentMemberScalarFieldEnum: {
    id: 'id',
    segmentId: 'segmentId',
    voterId: 'voterId',
    createdAt: 'createdAt'
  };

  export type SegmentMemberScalarFieldEnum = (typeof SegmentMemberScalarFieldEnum)[keyof typeof SegmentMemberScalarFieldEnum]


  export const ImportJobScalarFieldEnum: {
    id: 'id',
    kind: 'kind',
    status: 'status',
    fileName: 'fileName',
    fileHash: 'fileHash',
    rowCount: 'rowCount',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    errorText: 'errorText',
    createdAt: 'createdAt'
  };

  export type ImportJobScalarFieldEnum = (typeof ImportJobScalarFieldEnum)[keyof typeof ImportJobScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    actorLabel: 'actorLabel',
    action: 'action',
    entityType: 'entityType',
    entityId: 'entityId',
    metadataJson: 'metadataJson',
    importJobId: 'importJobId',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'AssetType'
   */
  export type EnumAssetTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssetType'>
    


  /**
   * Reference to a field of type 'AssetType[]'
   */
  export type ListEnumAssetTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssetType[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'CrosswalkType'
   */
  export type EnumCrosswalkTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CrosswalkType'>
    


  /**
   * Reference to a field of type 'CrosswalkType[]'
   */
  export type ListEnumCrosswalkTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CrosswalkType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'AIRunStatus'
   */
  export type EnumAIRunStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AIRunStatus'>
    


  /**
   * Reference to a field of type 'AIRunStatus[]'
   */
  export type ListEnumAIRunStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AIRunStatus[]'>
    


  /**
   * Reference to a field of type 'AIRunInputKind'
   */
  export type EnumAIRunInputKindFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AIRunInputKind'>
    


  /**
   * Reference to a field of type 'AIRunInputKind[]'
   */
  export type ListEnumAIRunInputKindFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AIRunInputKind[]'>
    


  /**
   * Reference to a field of type 'AIOutputType'
   */
  export type EnumAIOutputTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AIOutputType'>
    


  /**
   * Reference to a field of type 'AIOutputType[]'
   */
  export type ListEnumAIOutputTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AIOutputType[]'>
    


  /**
   * Reference to a field of type 'PublishStatus'
   */
  export type EnumPublishStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PublishStatus'>
    


  /**
   * Reference to a field of type 'PublishStatus[]'
   */
  export type ListEnumPublishStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PublishStatus[]'>
    


  /**
   * Reference to a field of type 'AIScopeType'
   */
  export type EnumAIScopeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AIScopeType'>
    


  /**
   * Reference to a field of type 'AIScopeType[]'
   */
  export type ListEnumAIScopeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AIScopeType[]'>
    


  /**
   * Reference to a field of type 'SurveyFormStatus'
   */
  export type EnumSurveyFormStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SurveyFormStatus'>
    


  /**
   * Reference to a field of type 'SurveyFormStatus[]'
   */
  export type ListEnumSurveyFormStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SurveyFormStatus[]'>
    


  /**
   * Reference to a field of type 'SurveyQuestionType'
   */
  export type EnumSurveyQuestionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SurveyQuestionType'>
    


  /**
   * Reference to a field of type 'SurveyQuestionType[]'
   */
  export type ListEnumSurveyQuestionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SurveyQuestionType[]'>
    


  /**
   * Reference to a field of type 'AnalysisType'
   */
  export type EnumAnalysisTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AnalysisType'>
    


  /**
   * Reference to a field of type 'AnalysisType[]'
   */
  export type ListEnumAnalysisTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AnalysisType[]'>
    


  /**
   * Reference to a field of type 'ImportJobKind'
   */
  export type EnumImportJobKindFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ImportJobKind'>
    


  /**
   * Reference to a field of type 'ImportJobKind[]'
   */
  export type ListEnumImportJobKindFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ImportJobKind[]'>
    


  /**
   * Reference to a field of type 'ImportJobStatus'
   */
  export type EnumImportJobStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ImportJobStatus'>
    


  /**
   * Reference to a field of type 'ImportJobStatus[]'
   */
  export type ListEnumImportJobStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ImportJobStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type CountyWhereInput = {
    AND?: CountyWhereInput | CountyWhereInput[]
    OR?: CountyWhereInput[]
    NOT?: CountyWhereInput | CountyWhereInput[]
    id?: UuidFilter<"County"> | string
    name?: StringFilter<"County"> | string
    slug?: StringFilter<"County"> | string
    fipsCode?: StringNullableFilter<"County"> | string | null
    isActive?: BoolFilter<"County"> | boolean
    createdAt?: DateTimeFilter<"County"> | Date | string
    updatedAt?: DateTimeFilter<"County"> | Date | string
    blueprintSections?: BlueprintSectionListRelationFilter
    quotes?: QuoteListRelationFilter
    assets?: AssetListRelationFilter
    countyIssues?: CountyIssueListRelationFilter
    censusMetrics?: CensusMetricListRelationFilter
    blsMetrics?: BLSMetricListRelationFilter
    civicsOfficials?: CivicsOfficialListRelationFilter
    electionResults?: ElectionResultListRelationFilter
    surveyForms?: SurveyFormListRelationFilter
    surveyResponses?: SurveyResponseListRelationFilter
    aiOutputScopes?: AIOutputScopeListRelationFilter
    sourceLinks?: SourceDocumentLinkListRelationFilter
  }

  export type CountyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    fipsCode?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    blueprintSections?: BlueprintSectionOrderByRelationAggregateInput
    quotes?: QuoteOrderByRelationAggregateInput
    assets?: AssetOrderByRelationAggregateInput
    countyIssues?: CountyIssueOrderByRelationAggregateInput
    censusMetrics?: CensusMetricOrderByRelationAggregateInput
    blsMetrics?: BLSMetricOrderByRelationAggregateInput
    civicsOfficials?: CivicsOfficialOrderByRelationAggregateInput
    electionResults?: ElectionResultOrderByRelationAggregateInput
    surveyForms?: SurveyFormOrderByRelationAggregateInput
    surveyResponses?: SurveyResponseOrderByRelationAggregateInput
    aiOutputScopes?: AIOutputScopeOrderByRelationAggregateInput
    sourceLinks?: SourceDocumentLinkOrderByRelationAggregateInput
  }

  export type CountyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    fipsCode?: string
    AND?: CountyWhereInput | CountyWhereInput[]
    OR?: CountyWhereInput[]
    NOT?: CountyWhereInput | CountyWhereInput[]
    name?: StringFilter<"County"> | string
    isActive?: BoolFilter<"County"> | boolean
    createdAt?: DateTimeFilter<"County"> | Date | string
    updatedAt?: DateTimeFilter<"County"> | Date | string
    blueprintSections?: BlueprintSectionListRelationFilter
    quotes?: QuoteListRelationFilter
    assets?: AssetListRelationFilter
    countyIssues?: CountyIssueListRelationFilter
    censusMetrics?: CensusMetricListRelationFilter
    blsMetrics?: BLSMetricListRelationFilter
    civicsOfficials?: CivicsOfficialListRelationFilter
    electionResults?: ElectionResultListRelationFilter
    surveyForms?: SurveyFormListRelationFilter
    surveyResponses?: SurveyResponseListRelationFilter
    aiOutputScopes?: AIOutputScopeListRelationFilter
    sourceLinks?: SourceDocumentLinkListRelationFilter
  }, "id" | "slug" | "fipsCode">

  export type CountyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    fipsCode?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CountyCountOrderByAggregateInput
    _max?: CountyMaxOrderByAggregateInput
    _min?: CountyMinOrderByAggregateInput
  }

  export type CountyScalarWhereWithAggregatesInput = {
    AND?: CountyScalarWhereWithAggregatesInput | CountyScalarWhereWithAggregatesInput[]
    OR?: CountyScalarWhereWithAggregatesInput[]
    NOT?: CountyScalarWhereWithAggregatesInput | CountyScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"County"> | string
    name?: StringWithAggregatesFilter<"County"> | string
    slug?: StringWithAggregatesFilter<"County"> | string
    fipsCode?: StringNullableWithAggregatesFilter<"County"> | string | null
    isActive?: BoolWithAggregatesFilter<"County"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"County"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"County"> | Date | string
  }

  export type IssueWhereInput = {
    AND?: IssueWhereInput | IssueWhereInput[]
    OR?: IssueWhereInput[]
    NOT?: IssueWhereInput | IssueWhereInput[]
    id?: UuidFilter<"Issue"> | string
    name?: StringFilter<"Issue"> | string
    slug?: StringFilter<"Issue"> | string
    summary?: StringNullableFilter<"Issue"> | string | null
    isActive?: BoolFilter<"Issue"> | boolean
    createdAt?: DateTimeFilter<"Issue"> | Date | string
    updatedAt?: DateTimeFilter<"Issue"> | Date | string
    countyIssues?: CountyIssueListRelationFilter
    blueprintSections?: BlueprintSectionListRelationFilter
    quotes?: QuoteListRelationFilter
    assets?: AssetListRelationFilter
    aiOutputScopes?: AIOutputScopeListRelationFilter
    sourceLinks?: SourceDocumentLinkListRelationFilter
  }

  export type IssueOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    summary?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    countyIssues?: CountyIssueOrderByRelationAggregateInput
    blueprintSections?: BlueprintSectionOrderByRelationAggregateInput
    quotes?: QuoteOrderByRelationAggregateInput
    assets?: AssetOrderByRelationAggregateInput
    aiOutputScopes?: AIOutputScopeOrderByRelationAggregateInput
    sourceLinks?: SourceDocumentLinkOrderByRelationAggregateInput
  }

  export type IssueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: IssueWhereInput | IssueWhereInput[]
    OR?: IssueWhereInput[]
    NOT?: IssueWhereInput | IssueWhereInput[]
    name?: StringFilter<"Issue"> | string
    summary?: StringNullableFilter<"Issue"> | string | null
    isActive?: BoolFilter<"Issue"> | boolean
    createdAt?: DateTimeFilter<"Issue"> | Date | string
    updatedAt?: DateTimeFilter<"Issue"> | Date | string
    countyIssues?: CountyIssueListRelationFilter
    blueprintSections?: BlueprintSectionListRelationFilter
    quotes?: QuoteListRelationFilter
    assets?: AssetListRelationFilter
    aiOutputScopes?: AIOutputScopeListRelationFilter
    sourceLinks?: SourceDocumentLinkListRelationFilter
  }, "id" | "slug">

  export type IssueOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    summary?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IssueCountOrderByAggregateInput
    _max?: IssueMaxOrderByAggregateInput
    _min?: IssueMinOrderByAggregateInput
  }

  export type IssueScalarWhereWithAggregatesInput = {
    AND?: IssueScalarWhereWithAggregatesInput | IssueScalarWhereWithAggregatesInput[]
    OR?: IssueScalarWhereWithAggregatesInput[]
    NOT?: IssueScalarWhereWithAggregatesInput | IssueScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Issue"> | string
    name?: StringWithAggregatesFilter<"Issue"> | string
    slug?: StringWithAggregatesFilter<"Issue"> | string
    summary?: StringNullableWithAggregatesFilter<"Issue"> | string | null
    isActive?: BoolWithAggregatesFilter<"Issue"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Issue"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Issue"> | Date | string
  }

  export type CountyIssueWhereInput = {
    AND?: CountyIssueWhereInput | CountyIssueWhereInput[]
    OR?: CountyIssueWhereInput[]
    NOT?: CountyIssueWhereInput | CountyIssueWhereInput[]
    id?: UuidFilter<"CountyIssue"> | string
    countyId?: UuidFilter<"CountyIssue"> | string
    issueId?: UuidFilter<"CountyIssue"> | string
    featured?: BoolFilter<"CountyIssue"> | boolean
    sortOrder?: IntNullableFilter<"CountyIssue"> | number | null
    createdAt?: DateTimeFilter<"CountyIssue"> | Date | string
    county?: XOR<CountyScalarRelationFilter, CountyWhereInput>
    issue?: XOR<IssueScalarRelationFilter, IssueWhereInput>
  }

  export type CountyIssueOrderByWithRelationInput = {
    id?: SortOrder
    countyId?: SortOrder
    issueId?: SortOrder
    featured?: SortOrder
    sortOrder?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    county?: CountyOrderByWithRelationInput
    issue?: IssueOrderByWithRelationInput
  }

  export type CountyIssueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    countyId_issueId?: CountyIssueCountyIdIssueIdCompoundUniqueInput
    AND?: CountyIssueWhereInput | CountyIssueWhereInput[]
    OR?: CountyIssueWhereInput[]
    NOT?: CountyIssueWhereInput | CountyIssueWhereInput[]
    countyId?: UuidFilter<"CountyIssue"> | string
    issueId?: UuidFilter<"CountyIssue"> | string
    featured?: BoolFilter<"CountyIssue"> | boolean
    sortOrder?: IntNullableFilter<"CountyIssue"> | number | null
    createdAt?: DateTimeFilter<"CountyIssue"> | Date | string
    county?: XOR<CountyScalarRelationFilter, CountyWhereInput>
    issue?: XOR<IssueScalarRelationFilter, IssueWhereInput>
  }, "id" | "countyId_issueId">

  export type CountyIssueOrderByWithAggregationInput = {
    id?: SortOrder
    countyId?: SortOrder
    issueId?: SortOrder
    featured?: SortOrder
    sortOrder?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CountyIssueCountOrderByAggregateInput
    _avg?: CountyIssueAvgOrderByAggregateInput
    _max?: CountyIssueMaxOrderByAggregateInput
    _min?: CountyIssueMinOrderByAggregateInput
    _sum?: CountyIssueSumOrderByAggregateInput
  }

  export type CountyIssueScalarWhereWithAggregatesInput = {
    AND?: CountyIssueScalarWhereWithAggregatesInput | CountyIssueScalarWhereWithAggregatesInput[]
    OR?: CountyIssueScalarWhereWithAggregatesInput[]
    NOT?: CountyIssueScalarWhereWithAggregatesInput | CountyIssueScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"CountyIssue"> | string
    countyId?: UuidWithAggregatesFilter<"CountyIssue"> | string
    issueId?: UuidWithAggregatesFilter<"CountyIssue"> | string
    featured?: BoolWithAggregatesFilter<"CountyIssue"> | boolean
    sortOrder?: IntNullableWithAggregatesFilter<"CountyIssue"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"CountyIssue"> | Date | string
  }

  export type BlueprintSectionWhereInput = {
    AND?: BlueprintSectionWhereInput | BlueprintSectionWhereInput[]
    OR?: BlueprintSectionWhereInput[]
    NOT?: BlueprintSectionWhereInput | BlueprintSectionWhereInput[]
    id?: UuidFilter<"BlueprintSection"> | string
    slug?: StringFilter<"BlueprintSection"> | string
    title?: StringFilter<"BlueprintSection"> | string
    bodyMd?: StringFilter<"BlueprintSection"> | string
    countyId?: UuidNullableFilter<"BlueprintSection"> | string | null
    issueId?: UuidNullableFilter<"BlueprintSection"> | string | null
    sortOrder?: IntNullableFilter<"BlueprintSection"> | number | null
    isPinned?: BoolFilter<"BlueprintSection"> | boolean
    createdAt?: DateTimeFilter<"BlueprintSection"> | Date | string
    updatedAt?: DateTimeFilter<"BlueprintSection"> | Date | string
    county?: XOR<CountyNullableScalarRelationFilter, CountyWhereInput> | null
    issue?: XOR<IssueNullableScalarRelationFilter, IssueWhereInput> | null
    sourceLinks?: SourceDocumentLinkListRelationFilter
  }

  export type BlueprintSectionOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    bodyMd?: SortOrder
    countyId?: SortOrderInput | SortOrder
    issueId?: SortOrderInput | SortOrder
    sortOrder?: SortOrderInput | SortOrder
    isPinned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    county?: CountyOrderByWithRelationInput
    issue?: IssueOrderByWithRelationInput
    sourceLinks?: SourceDocumentLinkOrderByRelationAggregateInput
  }

  export type BlueprintSectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: BlueprintSectionWhereInput | BlueprintSectionWhereInput[]
    OR?: BlueprintSectionWhereInput[]
    NOT?: BlueprintSectionWhereInput | BlueprintSectionWhereInput[]
    title?: StringFilter<"BlueprintSection"> | string
    bodyMd?: StringFilter<"BlueprintSection"> | string
    countyId?: UuidNullableFilter<"BlueprintSection"> | string | null
    issueId?: UuidNullableFilter<"BlueprintSection"> | string | null
    sortOrder?: IntNullableFilter<"BlueprintSection"> | number | null
    isPinned?: BoolFilter<"BlueprintSection"> | boolean
    createdAt?: DateTimeFilter<"BlueprintSection"> | Date | string
    updatedAt?: DateTimeFilter<"BlueprintSection"> | Date | string
    county?: XOR<CountyNullableScalarRelationFilter, CountyWhereInput> | null
    issue?: XOR<IssueNullableScalarRelationFilter, IssueWhereInput> | null
    sourceLinks?: SourceDocumentLinkListRelationFilter
  }, "id" | "slug">

  export type BlueprintSectionOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    bodyMd?: SortOrder
    countyId?: SortOrderInput | SortOrder
    issueId?: SortOrderInput | SortOrder
    sortOrder?: SortOrderInput | SortOrder
    isPinned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BlueprintSectionCountOrderByAggregateInput
    _avg?: BlueprintSectionAvgOrderByAggregateInput
    _max?: BlueprintSectionMaxOrderByAggregateInput
    _min?: BlueprintSectionMinOrderByAggregateInput
    _sum?: BlueprintSectionSumOrderByAggregateInput
  }

  export type BlueprintSectionScalarWhereWithAggregatesInput = {
    AND?: BlueprintSectionScalarWhereWithAggregatesInput | BlueprintSectionScalarWhereWithAggregatesInput[]
    OR?: BlueprintSectionScalarWhereWithAggregatesInput[]
    NOT?: BlueprintSectionScalarWhereWithAggregatesInput | BlueprintSectionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"BlueprintSection"> | string
    slug?: StringWithAggregatesFilter<"BlueprintSection"> | string
    title?: StringWithAggregatesFilter<"BlueprintSection"> | string
    bodyMd?: StringWithAggregatesFilter<"BlueprintSection"> | string
    countyId?: UuidNullableWithAggregatesFilter<"BlueprintSection"> | string | null
    issueId?: UuidNullableWithAggregatesFilter<"BlueprintSection"> | string | null
    sortOrder?: IntNullableWithAggregatesFilter<"BlueprintSection"> | number | null
    isPinned?: BoolWithAggregatesFilter<"BlueprintSection"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"BlueprintSection"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BlueprintSection"> | Date | string
  }

  export type QuoteWhereInput = {
    AND?: QuoteWhereInput | QuoteWhereInput[]
    OR?: QuoteWhereInput[]
    NOT?: QuoteWhereInput | QuoteWhereInput[]
    id?: UuidFilter<"Quote"> | string
    text?: StringFilter<"Quote"> | string
    attributionLabel?: StringNullableFilter<"Quote"> | string | null
    countyId?: UuidFilter<"Quote"> | string
    issueId?: UuidNullableFilter<"Quote"> | string | null
    sourceNote?: StringNullableFilter<"Quote"> | string | null
    createdAt?: DateTimeFilter<"Quote"> | Date | string
    updatedAt?: DateTimeFilter<"Quote"> | Date | string
    county?: XOR<CountyScalarRelationFilter, CountyWhereInput>
    issue?: XOR<IssueNullableScalarRelationFilter, IssueWhereInput> | null
    sourceLinks?: SourceDocumentLinkListRelationFilter
  }

  export type QuoteOrderByWithRelationInput = {
    id?: SortOrder
    text?: SortOrder
    attributionLabel?: SortOrderInput | SortOrder
    countyId?: SortOrder
    issueId?: SortOrderInput | SortOrder
    sourceNote?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    county?: CountyOrderByWithRelationInput
    issue?: IssueOrderByWithRelationInput
    sourceLinks?: SourceDocumentLinkOrderByRelationAggregateInput
  }

  export type QuoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuoteWhereInput | QuoteWhereInput[]
    OR?: QuoteWhereInput[]
    NOT?: QuoteWhereInput | QuoteWhereInput[]
    text?: StringFilter<"Quote"> | string
    attributionLabel?: StringNullableFilter<"Quote"> | string | null
    countyId?: UuidFilter<"Quote"> | string
    issueId?: UuidNullableFilter<"Quote"> | string | null
    sourceNote?: StringNullableFilter<"Quote"> | string | null
    createdAt?: DateTimeFilter<"Quote"> | Date | string
    updatedAt?: DateTimeFilter<"Quote"> | Date | string
    county?: XOR<CountyScalarRelationFilter, CountyWhereInput>
    issue?: XOR<IssueNullableScalarRelationFilter, IssueWhereInput> | null
    sourceLinks?: SourceDocumentLinkListRelationFilter
  }, "id">

  export type QuoteOrderByWithAggregationInput = {
    id?: SortOrder
    text?: SortOrder
    attributionLabel?: SortOrderInput | SortOrder
    countyId?: SortOrder
    issueId?: SortOrderInput | SortOrder
    sourceNote?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuoteCountOrderByAggregateInput
    _max?: QuoteMaxOrderByAggregateInput
    _min?: QuoteMinOrderByAggregateInput
  }

  export type QuoteScalarWhereWithAggregatesInput = {
    AND?: QuoteScalarWhereWithAggregatesInput | QuoteScalarWhereWithAggregatesInput[]
    OR?: QuoteScalarWhereWithAggregatesInput[]
    NOT?: QuoteScalarWhereWithAggregatesInput | QuoteScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Quote"> | string
    text?: StringWithAggregatesFilter<"Quote"> | string
    attributionLabel?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    countyId?: UuidWithAggregatesFilter<"Quote"> | string
    issueId?: UuidNullableWithAggregatesFilter<"Quote"> | string | null
    sourceNote?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Quote"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Quote"> | Date | string
  }

  export type AssetWhereInput = {
    AND?: AssetWhereInput | AssetWhereInput[]
    OR?: AssetWhereInput[]
    NOT?: AssetWhereInput | AssetWhereInput[]
    id?: UuidFilter<"Asset"> | string
    assetType?: EnumAssetTypeFilter<"Asset"> | $Enums.AssetType
    title?: StringNullableFilter<"Asset"> | string | null
    caption?: StringNullableFilter<"Asset"> | string | null
    credit?: StringNullableFilter<"Asset"> | string | null
    license?: StringNullableFilter<"Asset"> | string | null
    url?: StringNullableFilter<"Asset"> | string | null
    storageKey?: StringNullableFilter<"Asset"> | string | null
    countyId?: UuidNullableFilter<"Asset"> | string | null
    issueId?: UuidNullableFilter<"Asset"> | string | null
    createdAt?: DateTimeFilter<"Asset"> | Date | string
    updatedAt?: DateTimeFilter<"Asset"> | Date | string
    county?: XOR<CountyNullableScalarRelationFilter, CountyWhereInput> | null
    issue?: XOR<IssueNullableScalarRelationFilter, IssueWhereInput> | null
    sourceLinks?: SourceDocumentLinkListRelationFilter
  }

  export type AssetOrderByWithRelationInput = {
    id?: SortOrder
    assetType?: SortOrder
    title?: SortOrderInput | SortOrder
    caption?: SortOrderInput | SortOrder
    credit?: SortOrderInput | SortOrder
    license?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    storageKey?: SortOrderInput | SortOrder
    countyId?: SortOrderInput | SortOrder
    issueId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    county?: CountyOrderByWithRelationInput
    issue?: IssueOrderByWithRelationInput
    sourceLinks?: SourceDocumentLinkOrderByRelationAggregateInput
  }

  export type AssetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AssetWhereInput | AssetWhereInput[]
    OR?: AssetWhereInput[]
    NOT?: AssetWhereInput | AssetWhereInput[]
    assetType?: EnumAssetTypeFilter<"Asset"> | $Enums.AssetType
    title?: StringNullableFilter<"Asset"> | string | null
    caption?: StringNullableFilter<"Asset"> | string | null
    credit?: StringNullableFilter<"Asset"> | string | null
    license?: StringNullableFilter<"Asset"> | string | null
    url?: StringNullableFilter<"Asset"> | string | null
    storageKey?: StringNullableFilter<"Asset"> | string | null
    countyId?: UuidNullableFilter<"Asset"> | string | null
    issueId?: UuidNullableFilter<"Asset"> | string | null
    createdAt?: DateTimeFilter<"Asset"> | Date | string
    updatedAt?: DateTimeFilter<"Asset"> | Date | string
    county?: XOR<CountyNullableScalarRelationFilter, CountyWhereInput> | null
    issue?: XOR<IssueNullableScalarRelationFilter, IssueWhereInput> | null
    sourceLinks?: SourceDocumentLinkListRelationFilter
  }, "id">

  export type AssetOrderByWithAggregationInput = {
    id?: SortOrder
    assetType?: SortOrder
    title?: SortOrderInput | SortOrder
    caption?: SortOrderInput | SortOrder
    credit?: SortOrderInput | SortOrder
    license?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    storageKey?: SortOrderInput | SortOrder
    countyId?: SortOrderInput | SortOrder
    issueId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AssetCountOrderByAggregateInput
    _max?: AssetMaxOrderByAggregateInput
    _min?: AssetMinOrderByAggregateInput
  }

  export type AssetScalarWhereWithAggregatesInput = {
    AND?: AssetScalarWhereWithAggregatesInput | AssetScalarWhereWithAggregatesInput[]
    OR?: AssetScalarWhereWithAggregatesInput[]
    NOT?: AssetScalarWhereWithAggregatesInput | AssetScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Asset"> | string
    assetType?: EnumAssetTypeWithAggregatesFilter<"Asset"> | $Enums.AssetType
    title?: StringNullableWithAggregatesFilter<"Asset"> | string | null
    caption?: StringNullableWithAggregatesFilter<"Asset"> | string | null
    credit?: StringNullableWithAggregatesFilter<"Asset"> | string | null
    license?: StringNullableWithAggregatesFilter<"Asset"> | string | null
    url?: StringNullableWithAggregatesFilter<"Asset"> | string | null
    storageKey?: StringNullableWithAggregatesFilter<"Asset"> | string | null
    countyId?: UuidNullableWithAggregatesFilter<"Asset"> | string | null
    issueId?: UuidNullableWithAggregatesFilter<"Asset"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Asset"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Asset"> | Date | string
  }

  export type GlossaryTermWhereInput = {
    AND?: GlossaryTermWhereInput | GlossaryTermWhereInput[]
    OR?: GlossaryTermWhereInput[]
    NOT?: GlossaryTermWhereInput | GlossaryTermWhereInput[]
    id?: UuidFilter<"GlossaryTerm"> | string
    term?: StringFilter<"GlossaryTerm"> | string
    slug?: StringFilter<"GlossaryTerm"> | string
    definitionMd?: StringFilter<"GlossaryTerm"> | string
    examplesMd?: StringNullableFilter<"GlossaryTerm"> | string | null
    createdAt?: DateTimeFilter<"GlossaryTerm"> | Date | string
    updatedAt?: DateTimeFilter<"GlossaryTerm"> | Date | string
  }

  export type GlossaryTermOrderByWithRelationInput = {
    id?: SortOrder
    term?: SortOrder
    slug?: SortOrder
    definitionMd?: SortOrder
    examplesMd?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GlossaryTermWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    term?: string
    slug?: string
    AND?: GlossaryTermWhereInput | GlossaryTermWhereInput[]
    OR?: GlossaryTermWhereInput[]
    NOT?: GlossaryTermWhereInput | GlossaryTermWhereInput[]
    definitionMd?: StringFilter<"GlossaryTerm"> | string
    examplesMd?: StringNullableFilter<"GlossaryTerm"> | string | null
    createdAt?: DateTimeFilter<"GlossaryTerm"> | Date | string
    updatedAt?: DateTimeFilter<"GlossaryTerm"> | Date | string
  }, "id" | "term" | "slug">

  export type GlossaryTermOrderByWithAggregationInput = {
    id?: SortOrder
    term?: SortOrder
    slug?: SortOrder
    definitionMd?: SortOrder
    examplesMd?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GlossaryTermCountOrderByAggregateInput
    _max?: GlossaryTermMaxOrderByAggregateInput
    _min?: GlossaryTermMinOrderByAggregateInput
  }

  export type GlossaryTermScalarWhereWithAggregatesInput = {
    AND?: GlossaryTermScalarWhereWithAggregatesInput | GlossaryTermScalarWhereWithAggregatesInput[]
    OR?: GlossaryTermScalarWhereWithAggregatesInput[]
    NOT?: GlossaryTermScalarWhereWithAggregatesInput | GlossaryTermScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"GlossaryTerm"> | string
    term?: StringWithAggregatesFilter<"GlossaryTerm"> | string
    slug?: StringWithAggregatesFilter<"GlossaryTerm"> | string
    definitionMd?: StringWithAggregatesFilter<"GlossaryTerm"> | string
    examplesMd?: StringNullableWithAggregatesFilter<"GlossaryTerm"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"GlossaryTerm"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GlossaryTerm"> | Date | string
  }

  export type SourceDocumentWhereInput = {
    AND?: SourceDocumentWhereInput | SourceDocumentWhereInput[]
    OR?: SourceDocumentWhereInput[]
    NOT?: SourceDocumentWhereInput | SourceDocumentWhereInput[]
    id?: UuidFilter<"SourceDocument"> | string
    title?: StringFilter<"SourceDocument"> | string
    url?: StringNullableFilter<"SourceDocument"> | string | null
    storageKey?: StringNullableFilter<"SourceDocument"> | string | null
    publisher?: StringNullableFilter<"SourceDocument"> | string | null
    publishedAt?: DateTimeNullableFilter<"SourceDocument"> | Date | string | null
    capturedAt?: DateTimeNullableFilter<"SourceDocument"> | Date | string | null
    methodNote?: StringNullableFilter<"SourceDocument"> | string | null
    createdAt?: DateTimeFilter<"SourceDocument"> | Date | string
    updatedAt?: DateTimeFilter<"SourceDocument"> | Date | string
    chunks?: SourceChunkListRelationFilter
    citations?: CitationListRelationFilter
    runInputs?: AIRunInputSourceListRelationFilter
    sourceLinks?: SourceDocumentLinkListRelationFilter
  }

  export type SourceDocumentOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    url?: SortOrderInput | SortOrder
    storageKey?: SortOrderInput | SortOrder
    publisher?: SortOrderInput | SortOrder
    publishedAt?: SortOrderInput | SortOrder
    capturedAt?: SortOrderInput | SortOrder
    methodNote?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    chunks?: SourceChunkOrderByRelationAggregateInput
    citations?: CitationOrderByRelationAggregateInput
    runInputs?: AIRunInputSourceOrderByRelationAggregateInput
    sourceLinks?: SourceDocumentLinkOrderByRelationAggregateInput
  }

  export type SourceDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SourceDocumentWhereInput | SourceDocumentWhereInput[]
    OR?: SourceDocumentWhereInput[]
    NOT?: SourceDocumentWhereInput | SourceDocumentWhereInput[]
    title?: StringFilter<"SourceDocument"> | string
    url?: StringNullableFilter<"SourceDocument"> | string | null
    storageKey?: StringNullableFilter<"SourceDocument"> | string | null
    publisher?: StringNullableFilter<"SourceDocument"> | string | null
    publishedAt?: DateTimeNullableFilter<"SourceDocument"> | Date | string | null
    capturedAt?: DateTimeNullableFilter<"SourceDocument"> | Date | string | null
    methodNote?: StringNullableFilter<"SourceDocument"> | string | null
    createdAt?: DateTimeFilter<"SourceDocument"> | Date | string
    updatedAt?: DateTimeFilter<"SourceDocument"> | Date | string
    chunks?: SourceChunkListRelationFilter
    citations?: CitationListRelationFilter
    runInputs?: AIRunInputSourceListRelationFilter
    sourceLinks?: SourceDocumentLinkListRelationFilter
  }, "id">

  export type SourceDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    url?: SortOrderInput | SortOrder
    storageKey?: SortOrderInput | SortOrder
    publisher?: SortOrderInput | SortOrder
    publishedAt?: SortOrderInput | SortOrder
    capturedAt?: SortOrderInput | SortOrder
    methodNote?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SourceDocumentCountOrderByAggregateInput
    _max?: SourceDocumentMaxOrderByAggregateInput
    _min?: SourceDocumentMinOrderByAggregateInput
  }

  export type SourceDocumentScalarWhereWithAggregatesInput = {
    AND?: SourceDocumentScalarWhereWithAggregatesInput | SourceDocumentScalarWhereWithAggregatesInput[]
    OR?: SourceDocumentScalarWhereWithAggregatesInput[]
    NOT?: SourceDocumentScalarWhereWithAggregatesInput | SourceDocumentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"SourceDocument"> | string
    title?: StringWithAggregatesFilter<"SourceDocument"> | string
    url?: StringNullableWithAggregatesFilter<"SourceDocument"> | string | null
    storageKey?: StringNullableWithAggregatesFilter<"SourceDocument"> | string | null
    publisher?: StringNullableWithAggregatesFilter<"SourceDocument"> | string | null
    publishedAt?: DateTimeNullableWithAggregatesFilter<"SourceDocument"> | Date | string | null
    capturedAt?: DateTimeNullableWithAggregatesFilter<"SourceDocument"> | Date | string | null
    methodNote?: StringNullableWithAggregatesFilter<"SourceDocument"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SourceDocument"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SourceDocument"> | Date | string
  }

  export type SourceChunkWhereInput = {
    AND?: SourceChunkWhereInput | SourceChunkWhereInput[]
    OR?: SourceChunkWhereInput[]
    NOT?: SourceChunkWhereInput | SourceChunkWhereInput[]
    id?: UuidFilter<"SourceChunk"> | string
    sourceDocumentId?: UuidFilter<"SourceChunk"> | string
    chunkIndex?: IntFilter<"SourceChunk"> | number
    content?: StringFilter<"SourceChunk"> | string
    contentHash?: StringFilter<"SourceChunk"> | string
    locatorJson?: JsonNullableFilter<"SourceChunk">
    createdAt?: DateTimeFilter<"SourceChunk"> | Date | string
    sourceDocument?: XOR<SourceDocumentScalarRelationFilter, SourceDocumentWhereInput>
    citations?: CitationListRelationFilter
  }

  export type SourceChunkOrderByWithRelationInput = {
    id?: SortOrder
    sourceDocumentId?: SortOrder
    chunkIndex?: SortOrder
    content?: SortOrder
    contentHash?: SortOrder
    locatorJson?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    sourceDocument?: SourceDocumentOrderByWithRelationInput
    citations?: CitationOrderByRelationAggregateInput
  }

  export type SourceChunkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sourceDocumentId_chunkIndex?: SourceChunkSourceDocumentIdChunkIndexCompoundUniqueInput
    AND?: SourceChunkWhereInput | SourceChunkWhereInput[]
    OR?: SourceChunkWhereInput[]
    NOT?: SourceChunkWhereInput | SourceChunkWhereInput[]
    sourceDocumentId?: UuidFilter<"SourceChunk"> | string
    chunkIndex?: IntFilter<"SourceChunk"> | number
    content?: StringFilter<"SourceChunk"> | string
    contentHash?: StringFilter<"SourceChunk"> | string
    locatorJson?: JsonNullableFilter<"SourceChunk">
    createdAt?: DateTimeFilter<"SourceChunk"> | Date | string
    sourceDocument?: XOR<SourceDocumentScalarRelationFilter, SourceDocumentWhereInput>
    citations?: CitationListRelationFilter
  }, "id" | "sourceDocumentId_chunkIndex">

  export type SourceChunkOrderByWithAggregationInput = {
    id?: SortOrder
    sourceDocumentId?: SortOrder
    chunkIndex?: SortOrder
    content?: SortOrder
    contentHash?: SortOrder
    locatorJson?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SourceChunkCountOrderByAggregateInput
    _avg?: SourceChunkAvgOrderByAggregateInput
    _max?: SourceChunkMaxOrderByAggregateInput
    _min?: SourceChunkMinOrderByAggregateInput
    _sum?: SourceChunkSumOrderByAggregateInput
  }

  export type SourceChunkScalarWhereWithAggregatesInput = {
    AND?: SourceChunkScalarWhereWithAggregatesInput | SourceChunkScalarWhereWithAggregatesInput[]
    OR?: SourceChunkScalarWhereWithAggregatesInput[]
    NOT?: SourceChunkScalarWhereWithAggregatesInput | SourceChunkScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"SourceChunk"> | string
    sourceDocumentId?: UuidWithAggregatesFilter<"SourceChunk"> | string
    chunkIndex?: IntWithAggregatesFilter<"SourceChunk"> | number
    content?: StringWithAggregatesFilter<"SourceChunk"> | string
    contentHash?: StringWithAggregatesFilter<"SourceChunk"> | string
    locatorJson?: JsonNullableWithAggregatesFilter<"SourceChunk">
    createdAt?: DateTimeWithAggregatesFilter<"SourceChunk"> | Date | string
  }

  export type SourceDocumentLinkWhereInput = {
    AND?: SourceDocumentLinkWhereInput | SourceDocumentLinkWhereInput[]
    OR?: SourceDocumentLinkWhereInput[]
    NOT?: SourceDocumentLinkWhereInput | SourceDocumentLinkWhereInput[]
    id?: UuidFilter<"SourceDocumentLink"> | string
    sourceDocumentId?: UuidFilter<"SourceDocumentLink"> | string
    countyId?: UuidNullableFilter<"SourceDocumentLink"> | string | null
    issueId?: UuidNullableFilter<"SourceDocumentLink"> | string | null
    blueprintSectionId?: UuidNullableFilter<"SourceDocumentLink"> | string | null
    quoteId?: UuidNullableFilter<"SourceDocumentLink"> | string | null
    assetId?: UuidNullableFilter<"SourceDocumentLink"> | string | null
    surveyFormId?: UuidNullableFilter<"SourceDocumentLink"> | string | null
    note?: StringNullableFilter<"SourceDocumentLink"> | string | null
    createdAt?: DateTimeFilter<"SourceDocumentLink"> | Date | string
    sourceDocument?: XOR<SourceDocumentScalarRelationFilter, SourceDocumentWhereInput>
    county?: XOR<CountyNullableScalarRelationFilter, CountyWhereInput> | null
    issue?: XOR<IssueNullableScalarRelationFilter, IssueWhereInput> | null
    blueprintSection?: XOR<BlueprintSectionNullableScalarRelationFilter, BlueprintSectionWhereInput> | null
    quote?: XOR<QuoteNullableScalarRelationFilter, QuoteWhereInput> | null
    asset?: XOR<AssetNullableScalarRelationFilter, AssetWhereInput> | null
    surveyForm?: XOR<SurveyFormNullableScalarRelationFilter, SurveyFormWhereInput> | null
  }

  export type SourceDocumentLinkOrderByWithRelationInput = {
    id?: SortOrder
    sourceDocumentId?: SortOrder
    countyId?: SortOrderInput | SortOrder
    issueId?: SortOrderInput | SortOrder
    blueprintSectionId?: SortOrderInput | SortOrder
    quoteId?: SortOrderInput | SortOrder
    assetId?: SortOrderInput | SortOrder
    surveyFormId?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    sourceDocument?: SourceDocumentOrderByWithRelationInput
    county?: CountyOrderByWithRelationInput
    issue?: IssueOrderByWithRelationInput
    blueprintSection?: BlueprintSectionOrderByWithRelationInput
    quote?: QuoteOrderByWithRelationInput
    asset?: AssetOrderByWithRelationInput
    surveyForm?: SurveyFormOrderByWithRelationInput
  }

  export type SourceDocumentLinkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SourceDocumentLinkWhereInput | SourceDocumentLinkWhereInput[]
    OR?: SourceDocumentLinkWhereInput[]
    NOT?: SourceDocumentLinkWhereInput | SourceDocumentLinkWhereInput[]
    sourceDocumentId?: UuidFilter<"SourceDocumentLink"> | string
    countyId?: UuidNullableFilter<"SourceDocumentLink"> | string | null
    issueId?: UuidNullableFilter<"SourceDocumentLink"> | string | null
    blueprintSectionId?: UuidNullableFilter<"SourceDocumentLink"> | string | null
    quoteId?: UuidNullableFilter<"SourceDocumentLink"> | string | null
    assetId?: UuidNullableFilter<"SourceDocumentLink"> | string | null
    surveyFormId?: UuidNullableFilter<"SourceDocumentLink"> | string | null
    note?: StringNullableFilter<"SourceDocumentLink"> | string | null
    createdAt?: DateTimeFilter<"SourceDocumentLink"> | Date | string
    sourceDocument?: XOR<SourceDocumentScalarRelationFilter, SourceDocumentWhereInput>
    county?: XOR<CountyNullableScalarRelationFilter, CountyWhereInput> | null
    issue?: XOR<IssueNullableScalarRelationFilter, IssueWhereInput> | null
    blueprintSection?: XOR<BlueprintSectionNullableScalarRelationFilter, BlueprintSectionWhereInput> | null
    quote?: XOR<QuoteNullableScalarRelationFilter, QuoteWhereInput> | null
    asset?: XOR<AssetNullableScalarRelationFilter, AssetWhereInput> | null
    surveyForm?: XOR<SurveyFormNullableScalarRelationFilter, SurveyFormWhereInput> | null
  }, "id">

  export type SourceDocumentLinkOrderByWithAggregationInput = {
    id?: SortOrder
    sourceDocumentId?: SortOrder
    countyId?: SortOrderInput | SortOrder
    issueId?: SortOrderInput | SortOrder
    blueprintSectionId?: SortOrderInput | SortOrder
    quoteId?: SortOrderInput | SortOrder
    assetId?: SortOrderInput | SortOrder
    surveyFormId?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SourceDocumentLinkCountOrderByAggregateInput
    _max?: SourceDocumentLinkMaxOrderByAggregateInput
    _min?: SourceDocumentLinkMinOrderByAggregateInput
  }

  export type SourceDocumentLinkScalarWhereWithAggregatesInput = {
    AND?: SourceDocumentLinkScalarWhereWithAggregatesInput | SourceDocumentLinkScalarWhereWithAggregatesInput[]
    OR?: SourceDocumentLinkScalarWhereWithAggregatesInput[]
    NOT?: SourceDocumentLinkScalarWhereWithAggregatesInput | SourceDocumentLinkScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"SourceDocumentLink"> | string
    sourceDocumentId?: UuidWithAggregatesFilter<"SourceDocumentLink"> | string
    countyId?: UuidNullableWithAggregatesFilter<"SourceDocumentLink"> | string | null
    issueId?: UuidNullableWithAggregatesFilter<"SourceDocumentLink"> | string | null
    blueprintSectionId?: UuidNullableWithAggregatesFilter<"SourceDocumentLink"> | string | null
    quoteId?: UuidNullableWithAggregatesFilter<"SourceDocumentLink"> | string | null
    assetId?: UuidNullableWithAggregatesFilter<"SourceDocumentLink"> | string | null
    surveyFormId?: UuidNullableWithAggregatesFilter<"SourceDocumentLink"> | string | null
    note?: StringNullableWithAggregatesFilter<"SourceDocumentLink"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SourceDocumentLink"> | Date | string
  }

  export type GeoCountyWhereInput = {
    AND?: GeoCountyWhereInput | GeoCountyWhereInput[]
    OR?: GeoCountyWhereInput[]
    NOT?: GeoCountyWhereInput | GeoCountyWhereInput[]
    id?: UuidFilter<"GeoCounty"> | string
    fipsCode?: StringNullableFilter<"GeoCounty"> | string | null
    name?: StringFilter<"GeoCounty"> | string
    createdAt?: DateTimeFilter<"GeoCounty"> | Date | string
  }

  export type GeoCountyOrderByWithRelationInput = {
    id?: SortOrder
    fipsCode?: SortOrderInput | SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type GeoCountyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    fipsCode?: string
    AND?: GeoCountyWhereInput | GeoCountyWhereInput[]
    OR?: GeoCountyWhereInput[]
    NOT?: GeoCountyWhereInput | GeoCountyWhereInput[]
    name?: StringFilter<"GeoCounty"> | string
    createdAt?: DateTimeFilter<"GeoCounty"> | Date | string
  }, "id" | "fipsCode">

  export type GeoCountyOrderByWithAggregationInput = {
    id?: SortOrder
    fipsCode?: SortOrderInput | SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    _count?: GeoCountyCountOrderByAggregateInput
    _max?: GeoCountyMaxOrderByAggregateInput
    _min?: GeoCountyMinOrderByAggregateInput
  }

  export type GeoCountyScalarWhereWithAggregatesInput = {
    AND?: GeoCountyScalarWhereWithAggregatesInput | GeoCountyScalarWhereWithAggregatesInput[]
    OR?: GeoCountyScalarWhereWithAggregatesInput[]
    NOT?: GeoCountyScalarWhereWithAggregatesInput | GeoCountyScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"GeoCounty"> | string
    fipsCode?: StringNullableWithAggregatesFilter<"GeoCounty"> | string | null
    name?: StringWithAggregatesFilter<"GeoCounty"> | string
    createdAt?: DateTimeWithAggregatesFilter<"GeoCounty"> | Date | string
  }

  export type GeoZipWhereInput = {
    AND?: GeoZipWhereInput | GeoZipWhereInput[]
    OR?: GeoZipWhereInput[]
    NOT?: GeoZipWhereInput | GeoZipWhereInput[]
    id?: UuidFilter<"GeoZip"> | string
    zipCode?: StringFilter<"GeoZip"> | string
    createdAt?: DateTimeFilter<"GeoZip"> | Date | string
    censusMetrics?: CensusMetricListRelationFilter
    aiOutputScopes?: AIOutputScopeListRelationFilter
    electionResults?: ElectionResultListRelationFilter
  }

  export type GeoZipOrderByWithRelationInput = {
    id?: SortOrder
    zipCode?: SortOrder
    createdAt?: SortOrder
    censusMetrics?: CensusMetricOrderByRelationAggregateInput
    aiOutputScopes?: AIOutputScopeOrderByRelationAggregateInput
    electionResults?: ElectionResultOrderByRelationAggregateInput
  }

  export type GeoZipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    zipCode?: string
    AND?: GeoZipWhereInput | GeoZipWhereInput[]
    OR?: GeoZipWhereInput[]
    NOT?: GeoZipWhereInput | GeoZipWhereInput[]
    createdAt?: DateTimeFilter<"GeoZip"> | Date | string
    censusMetrics?: CensusMetricListRelationFilter
    aiOutputScopes?: AIOutputScopeListRelationFilter
    electionResults?: ElectionResultListRelationFilter
  }, "id" | "zipCode">

  export type GeoZipOrderByWithAggregationInput = {
    id?: SortOrder
    zipCode?: SortOrder
    createdAt?: SortOrder
    _count?: GeoZipCountOrderByAggregateInput
    _max?: GeoZipMaxOrderByAggregateInput
    _min?: GeoZipMinOrderByAggregateInput
  }

  export type GeoZipScalarWhereWithAggregatesInput = {
    AND?: GeoZipScalarWhereWithAggregatesInput | GeoZipScalarWhereWithAggregatesInput[]
    OR?: GeoZipScalarWhereWithAggregatesInput[]
    NOT?: GeoZipScalarWhereWithAggregatesInput | GeoZipScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"GeoZip"> | string
    zipCode?: StringWithAggregatesFilter<"GeoZip"> | string
    createdAt?: DateTimeWithAggregatesFilter<"GeoZip"> | Date | string
  }

  export type GeoPrecinctWhereInput = {
    AND?: GeoPrecinctWhereInput | GeoPrecinctWhereInput[]
    OR?: GeoPrecinctWhereInput[]
    NOT?: GeoPrecinctWhereInput | GeoPrecinctWhereInput[]
    id?: UuidFilter<"GeoPrecinct"> | string
    name?: StringNullableFilter<"GeoPrecinct"> | string | null
    precinctCode?: StringNullableFilter<"GeoPrecinct"> | string | null
    createdAt?: DateTimeFilter<"GeoPrecinct"> | Date | string
    electionResults?: ElectionResultListRelationFilter
  }

  export type GeoPrecinctOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    precinctCode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    electionResults?: ElectionResultOrderByRelationAggregateInput
  }

  export type GeoPrecinctWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GeoPrecinctWhereInput | GeoPrecinctWhereInput[]
    OR?: GeoPrecinctWhereInput[]
    NOT?: GeoPrecinctWhereInput | GeoPrecinctWhereInput[]
    name?: StringNullableFilter<"GeoPrecinct"> | string | null
    precinctCode?: StringNullableFilter<"GeoPrecinct"> | string | null
    createdAt?: DateTimeFilter<"GeoPrecinct"> | Date | string
    electionResults?: ElectionResultListRelationFilter
  }, "id">

  export type GeoPrecinctOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    precinctCode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: GeoPrecinctCountOrderByAggregateInput
    _max?: GeoPrecinctMaxOrderByAggregateInput
    _min?: GeoPrecinctMinOrderByAggregateInput
  }

  export type GeoPrecinctScalarWhereWithAggregatesInput = {
    AND?: GeoPrecinctScalarWhereWithAggregatesInput | GeoPrecinctScalarWhereWithAggregatesInput[]
    OR?: GeoPrecinctScalarWhereWithAggregatesInput[]
    NOT?: GeoPrecinctScalarWhereWithAggregatesInput | GeoPrecinctScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"GeoPrecinct"> | string
    name?: StringNullableWithAggregatesFilter<"GeoPrecinct"> | string | null
    precinctCode?: StringNullableWithAggregatesFilter<"GeoPrecinct"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"GeoPrecinct"> | Date | string
  }

  export type GeoDistrictWhereInput = {
    AND?: GeoDistrictWhereInput | GeoDistrictWhereInput[]
    OR?: GeoDistrictWhereInput[]
    NOT?: GeoDistrictWhereInput | GeoDistrictWhereInput[]
    id?: UuidFilter<"GeoDistrict"> | string
    districtCode?: StringFilter<"GeoDistrict"> | string
    districtType?: StringNullableFilter<"GeoDistrict"> | string | null
    createdAt?: DateTimeFilter<"GeoDistrict"> | Date | string
    civicsOfficials?: CivicsOfficialListRelationFilter
    aiOutputScopes?: AIOutputScopeListRelationFilter
  }

  export type GeoDistrictOrderByWithRelationInput = {
    id?: SortOrder
    districtCode?: SortOrder
    districtType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    civicsOfficials?: CivicsOfficialOrderByRelationAggregateInput
    aiOutputScopes?: AIOutputScopeOrderByRelationAggregateInput
  }

  export type GeoDistrictWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    districtCode?: string
    AND?: GeoDistrictWhereInput | GeoDistrictWhereInput[]
    OR?: GeoDistrictWhereInput[]
    NOT?: GeoDistrictWhereInput | GeoDistrictWhereInput[]
    districtType?: StringNullableFilter<"GeoDistrict"> | string | null
    createdAt?: DateTimeFilter<"GeoDistrict"> | Date | string
    civicsOfficials?: CivicsOfficialListRelationFilter
    aiOutputScopes?: AIOutputScopeListRelationFilter
  }, "id" | "districtCode">

  export type GeoDistrictOrderByWithAggregationInput = {
    id?: SortOrder
    districtCode?: SortOrder
    districtType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: GeoDistrictCountOrderByAggregateInput
    _max?: GeoDistrictMaxOrderByAggregateInput
    _min?: GeoDistrictMinOrderByAggregateInput
  }

  export type GeoDistrictScalarWhereWithAggregatesInput = {
    AND?: GeoDistrictScalarWhereWithAggregatesInput | GeoDistrictScalarWhereWithAggregatesInput[]
    OR?: GeoDistrictScalarWhereWithAggregatesInput[]
    NOT?: GeoDistrictScalarWhereWithAggregatesInput | GeoDistrictScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"GeoDistrict"> | string
    districtCode?: StringWithAggregatesFilter<"GeoDistrict"> | string
    districtType?: StringNullableWithAggregatesFilter<"GeoDistrict"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"GeoDistrict"> | Date | string
  }

  export type GeoCrosswalkWhereInput = {
    AND?: GeoCrosswalkWhereInput | GeoCrosswalkWhereInput[]
    OR?: GeoCrosswalkWhereInput[]
    NOT?: GeoCrosswalkWhereInput | GeoCrosswalkWhereInput[]
    id?: UuidFilter<"GeoCrosswalk"> | string
    crosswalkType?: EnumCrosswalkTypeFilter<"GeoCrosswalk"> | $Enums.CrosswalkType
    fromGeoZipId?: UuidNullableFilter<"GeoCrosswalk"> | string | null
    fromGeoPrecinctId?: UuidNullableFilter<"GeoCrosswalk"> | string | null
    fromGeoDistrictId?: UuidNullableFilter<"GeoCrosswalk"> | string | null
    fromGeoCountyFips?: StringNullableFilter<"GeoCrosswalk"> | string | null
    toGeoZipId?: UuidNullableFilter<"GeoCrosswalk"> | string | null
    toGeoPrecinctId?: UuidNullableFilter<"GeoCrosswalk"> | string | null
    toGeoDistrictId?: UuidNullableFilter<"GeoCrosswalk"> | string | null
    toGeoCountyFips?: StringNullableFilter<"GeoCrosswalk"> | string | null
    weight?: FloatNullableFilter<"GeoCrosswalk"> | number | null
    createdAt?: DateTimeFilter<"GeoCrosswalk"> | Date | string
  }

  export type GeoCrosswalkOrderByWithRelationInput = {
    id?: SortOrder
    crosswalkType?: SortOrder
    fromGeoZipId?: SortOrderInput | SortOrder
    fromGeoPrecinctId?: SortOrderInput | SortOrder
    fromGeoDistrictId?: SortOrderInput | SortOrder
    fromGeoCountyFips?: SortOrderInput | SortOrder
    toGeoZipId?: SortOrderInput | SortOrder
    toGeoPrecinctId?: SortOrderInput | SortOrder
    toGeoDistrictId?: SortOrderInput | SortOrder
    toGeoCountyFips?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type GeoCrosswalkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GeoCrosswalkWhereInput | GeoCrosswalkWhereInput[]
    OR?: GeoCrosswalkWhereInput[]
    NOT?: GeoCrosswalkWhereInput | GeoCrosswalkWhereInput[]
    crosswalkType?: EnumCrosswalkTypeFilter<"GeoCrosswalk"> | $Enums.CrosswalkType
    fromGeoZipId?: UuidNullableFilter<"GeoCrosswalk"> | string | null
    fromGeoPrecinctId?: UuidNullableFilter<"GeoCrosswalk"> | string | null
    fromGeoDistrictId?: UuidNullableFilter<"GeoCrosswalk"> | string | null
    fromGeoCountyFips?: StringNullableFilter<"GeoCrosswalk"> | string | null
    toGeoZipId?: UuidNullableFilter<"GeoCrosswalk"> | string | null
    toGeoPrecinctId?: UuidNullableFilter<"GeoCrosswalk"> | string | null
    toGeoDistrictId?: UuidNullableFilter<"GeoCrosswalk"> | string | null
    toGeoCountyFips?: StringNullableFilter<"GeoCrosswalk"> | string | null
    weight?: FloatNullableFilter<"GeoCrosswalk"> | number | null
    createdAt?: DateTimeFilter<"GeoCrosswalk"> | Date | string
  }, "id">

  export type GeoCrosswalkOrderByWithAggregationInput = {
    id?: SortOrder
    crosswalkType?: SortOrder
    fromGeoZipId?: SortOrderInput | SortOrder
    fromGeoPrecinctId?: SortOrderInput | SortOrder
    fromGeoDistrictId?: SortOrderInput | SortOrder
    fromGeoCountyFips?: SortOrderInput | SortOrder
    toGeoZipId?: SortOrderInput | SortOrder
    toGeoPrecinctId?: SortOrderInput | SortOrder
    toGeoDistrictId?: SortOrderInput | SortOrder
    toGeoCountyFips?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: GeoCrosswalkCountOrderByAggregateInput
    _avg?: GeoCrosswalkAvgOrderByAggregateInput
    _max?: GeoCrosswalkMaxOrderByAggregateInput
    _min?: GeoCrosswalkMinOrderByAggregateInput
    _sum?: GeoCrosswalkSumOrderByAggregateInput
  }

  export type GeoCrosswalkScalarWhereWithAggregatesInput = {
    AND?: GeoCrosswalkScalarWhereWithAggregatesInput | GeoCrosswalkScalarWhereWithAggregatesInput[]
    OR?: GeoCrosswalkScalarWhereWithAggregatesInput[]
    NOT?: GeoCrosswalkScalarWhereWithAggregatesInput | GeoCrosswalkScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"GeoCrosswalk"> | string
    crosswalkType?: EnumCrosswalkTypeWithAggregatesFilter<"GeoCrosswalk"> | $Enums.CrosswalkType
    fromGeoZipId?: UuidNullableWithAggregatesFilter<"GeoCrosswalk"> | string | null
    fromGeoPrecinctId?: UuidNullableWithAggregatesFilter<"GeoCrosswalk"> | string | null
    fromGeoDistrictId?: UuidNullableWithAggregatesFilter<"GeoCrosswalk"> | string | null
    fromGeoCountyFips?: StringNullableWithAggregatesFilter<"GeoCrosswalk"> | string | null
    toGeoZipId?: UuidNullableWithAggregatesFilter<"GeoCrosswalk"> | string | null
    toGeoPrecinctId?: UuidNullableWithAggregatesFilter<"GeoCrosswalk"> | string | null
    toGeoDistrictId?: UuidNullableWithAggregatesFilter<"GeoCrosswalk"> | string | null
    toGeoCountyFips?: StringNullableWithAggregatesFilter<"GeoCrosswalk"> | string | null
    weight?: FloatNullableWithAggregatesFilter<"GeoCrosswalk"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"GeoCrosswalk"> | Date | string
  }

  export type CensusMetricWhereInput = {
    AND?: CensusMetricWhereInput | CensusMetricWhereInput[]
    OR?: CensusMetricWhereInput[]
    NOT?: CensusMetricWhereInput | CensusMetricWhereInput[]
    id?: UuidFilter<"CensusMetric"> | string
    countyId?: UuidNullableFilter<"CensusMetric"> | string | null
    geoZipId?: UuidNullableFilter<"CensusMetric"> | string | null
    metricKey?: StringFilter<"CensusMetric"> | string
    metricLabel?: StringNullableFilter<"CensusMetric"> | string | null
    value?: FloatNullableFilter<"CensusMetric"> | number | null
    valueText?: StringNullableFilter<"CensusMetric"> | string | null
    asOfDate?: DateTimeNullableFilter<"CensusMetric"> | Date | string | null
    sourceNote?: StringNullableFilter<"CensusMetric"> | string | null
    createdAt?: DateTimeFilter<"CensusMetric"> | Date | string
    county?: XOR<CountyNullableScalarRelationFilter, CountyWhereInput> | null
    geoZip?: XOR<GeoZipNullableScalarRelationFilter, GeoZipWhereInput> | null
  }

  export type CensusMetricOrderByWithRelationInput = {
    id?: SortOrder
    countyId?: SortOrderInput | SortOrder
    geoZipId?: SortOrderInput | SortOrder
    metricKey?: SortOrder
    metricLabel?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    valueText?: SortOrderInput | SortOrder
    asOfDate?: SortOrderInput | SortOrder
    sourceNote?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    county?: CountyOrderByWithRelationInput
    geoZip?: GeoZipOrderByWithRelationInput
  }

  export type CensusMetricWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CensusMetricWhereInput | CensusMetricWhereInput[]
    OR?: CensusMetricWhereInput[]
    NOT?: CensusMetricWhereInput | CensusMetricWhereInput[]
    countyId?: UuidNullableFilter<"CensusMetric"> | string | null
    geoZipId?: UuidNullableFilter<"CensusMetric"> | string | null
    metricKey?: StringFilter<"CensusMetric"> | string
    metricLabel?: StringNullableFilter<"CensusMetric"> | string | null
    value?: FloatNullableFilter<"CensusMetric"> | number | null
    valueText?: StringNullableFilter<"CensusMetric"> | string | null
    asOfDate?: DateTimeNullableFilter<"CensusMetric"> | Date | string | null
    sourceNote?: StringNullableFilter<"CensusMetric"> | string | null
    createdAt?: DateTimeFilter<"CensusMetric"> | Date | string
    county?: XOR<CountyNullableScalarRelationFilter, CountyWhereInput> | null
    geoZip?: XOR<GeoZipNullableScalarRelationFilter, GeoZipWhereInput> | null
  }, "id">

  export type CensusMetricOrderByWithAggregationInput = {
    id?: SortOrder
    countyId?: SortOrderInput | SortOrder
    geoZipId?: SortOrderInput | SortOrder
    metricKey?: SortOrder
    metricLabel?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    valueText?: SortOrderInput | SortOrder
    asOfDate?: SortOrderInput | SortOrder
    sourceNote?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CensusMetricCountOrderByAggregateInput
    _avg?: CensusMetricAvgOrderByAggregateInput
    _max?: CensusMetricMaxOrderByAggregateInput
    _min?: CensusMetricMinOrderByAggregateInput
    _sum?: CensusMetricSumOrderByAggregateInput
  }

  export type CensusMetricScalarWhereWithAggregatesInput = {
    AND?: CensusMetricScalarWhereWithAggregatesInput | CensusMetricScalarWhereWithAggregatesInput[]
    OR?: CensusMetricScalarWhereWithAggregatesInput[]
    NOT?: CensusMetricScalarWhereWithAggregatesInput | CensusMetricScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"CensusMetric"> | string
    countyId?: UuidNullableWithAggregatesFilter<"CensusMetric"> | string | null
    geoZipId?: UuidNullableWithAggregatesFilter<"CensusMetric"> | string | null
    metricKey?: StringWithAggregatesFilter<"CensusMetric"> | string
    metricLabel?: StringNullableWithAggregatesFilter<"CensusMetric"> | string | null
    value?: FloatNullableWithAggregatesFilter<"CensusMetric"> | number | null
    valueText?: StringNullableWithAggregatesFilter<"CensusMetric"> | string | null
    asOfDate?: DateTimeNullableWithAggregatesFilter<"CensusMetric"> | Date | string | null
    sourceNote?: StringNullableWithAggregatesFilter<"CensusMetric"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CensusMetric"> | Date | string
  }

  export type BLSMetricWhereInput = {
    AND?: BLSMetricWhereInput | BLSMetricWhereInput[]
    OR?: BLSMetricWhereInput[]
    NOT?: BLSMetricWhereInput | BLSMetricWhereInput[]
    id?: UuidFilter<"BLSMetric"> | string
    countyId?: UuidFilter<"BLSMetric"> | string
    seriesKey?: StringFilter<"BLSMetric"> | string
    seriesLabel?: StringNullableFilter<"BLSMetric"> | string | null
    value?: FloatNullableFilter<"BLSMetric"> | number | null
    asOfDate?: DateTimeNullableFilter<"BLSMetric"> | Date | string | null
    sourceNote?: StringNullableFilter<"BLSMetric"> | string | null
    createdAt?: DateTimeFilter<"BLSMetric"> | Date | string
    county?: XOR<CountyScalarRelationFilter, CountyWhereInput>
  }

  export type BLSMetricOrderByWithRelationInput = {
    id?: SortOrder
    countyId?: SortOrder
    seriesKey?: SortOrder
    seriesLabel?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    asOfDate?: SortOrderInput | SortOrder
    sourceNote?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    county?: CountyOrderByWithRelationInput
  }

  export type BLSMetricWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BLSMetricWhereInput | BLSMetricWhereInput[]
    OR?: BLSMetricWhereInput[]
    NOT?: BLSMetricWhereInput | BLSMetricWhereInput[]
    countyId?: UuidFilter<"BLSMetric"> | string
    seriesKey?: StringFilter<"BLSMetric"> | string
    seriesLabel?: StringNullableFilter<"BLSMetric"> | string | null
    value?: FloatNullableFilter<"BLSMetric"> | number | null
    asOfDate?: DateTimeNullableFilter<"BLSMetric"> | Date | string | null
    sourceNote?: StringNullableFilter<"BLSMetric"> | string | null
    createdAt?: DateTimeFilter<"BLSMetric"> | Date | string
    county?: XOR<CountyScalarRelationFilter, CountyWhereInput>
  }, "id">

  export type BLSMetricOrderByWithAggregationInput = {
    id?: SortOrder
    countyId?: SortOrder
    seriesKey?: SortOrder
    seriesLabel?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    asOfDate?: SortOrderInput | SortOrder
    sourceNote?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: BLSMetricCountOrderByAggregateInput
    _avg?: BLSMetricAvgOrderByAggregateInput
    _max?: BLSMetricMaxOrderByAggregateInput
    _min?: BLSMetricMinOrderByAggregateInput
    _sum?: BLSMetricSumOrderByAggregateInput
  }

  export type BLSMetricScalarWhereWithAggregatesInput = {
    AND?: BLSMetricScalarWhereWithAggregatesInput | BLSMetricScalarWhereWithAggregatesInput[]
    OR?: BLSMetricScalarWhereWithAggregatesInput[]
    NOT?: BLSMetricScalarWhereWithAggregatesInput | BLSMetricScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"BLSMetric"> | string
    countyId?: UuidWithAggregatesFilter<"BLSMetric"> | string
    seriesKey?: StringWithAggregatesFilter<"BLSMetric"> | string
    seriesLabel?: StringNullableWithAggregatesFilter<"BLSMetric"> | string | null
    value?: FloatNullableWithAggregatesFilter<"BLSMetric"> | number | null
    asOfDate?: DateTimeNullableWithAggregatesFilter<"BLSMetric"> | Date | string | null
    sourceNote?: StringNullableWithAggregatesFilter<"BLSMetric"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BLSMetric"> | Date | string
  }

  export type CivicsOfficialWhereInput = {
    AND?: CivicsOfficialWhereInput | CivicsOfficialWhereInput[]
    OR?: CivicsOfficialWhereInput[]
    NOT?: CivicsOfficialWhereInput | CivicsOfficialWhereInput[]
    id?: UuidFilter<"CivicsOfficial"> | string
    name?: StringFilter<"CivicsOfficial"> | string
    officeName?: StringFilter<"CivicsOfficial"> | string
    party?: StringNullableFilter<"CivicsOfficial"> | string | null
    phone?: StringNullableFilter<"CivicsOfficial"> | string | null
    website?: StringNullableFilter<"CivicsOfficial"> | string | null
    photoUrl?: StringNullableFilter<"CivicsOfficial"> | string | null
    countyId?: UuidNullableFilter<"CivicsOfficial"> | string | null
    districtId?: UuidNullableFilter<"CivicsOfficial"> | string | null
    sourceNote?: StringNullableFilter<"CivicsOfficial"> | string | null
    createdAt?: DateTimeFilter<"CivicsOfficial"> | Date | string
    updatedAt?: DateTimeFilter<"CivicsOfficial"> | Date | string
    county?: XOR<CountyNullableScalarRelationFilter, CountyWhereInput> | null
    district?: XOR<GeoDistrictNullableScalarRelationFilter, GeoDistrictWhereInput> | null
  }

  export type CivicsOfficialOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    officeName?: SortOrder
    party?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    photoUrl?: SortOrderInput | SortOrder
    countyId?: SortOrderInput | SortOrder
    districtId?: SortOrderInput | SortOrder
    sourceNote?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    county?: CountyOrderByWithRelationInput
    district?: GeoDistrictOrderByWithRelationInput
  }

  export type CivicsOfficialWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CivicsOfficialWhereInput | CivicsOfficialWhereInput[]
    OR?: CivicsOfficialWhereInput[]
    NOT?: CivicsOfficialWhereInput | CivicsOfficialWhereInput[]
    name?: StringFilter<"CivicsOfficial"> | string
    officeName?: StringFilter<"CivicsOfficial"> | string
    party?: StringNullableFilter<"CivicsOfficial"> | string | null
    phone?: StringNullableFilter<"CivicsOfficial"> | string | null
    website?: StringNullableFilter<"CivicsOfficial"> | string | null
    photoUrl?: StringNullableFilter<"CivicsOfficial"> | string | null
    countyId?: UuidNullableFilter<"CivicsOfficial"> | string | null
    districtId?: UuidNullableFilter<"CivicsOfficial"> | string | null
    sourceNote?: StringNullableFilter<"CivicsOfficial"> | string | null
    createdAt?: DateTimeFilter<"CivicsOfficial"> | Date | string
    updatedAt?: DateTimeFilter<"CivicsOfficial"> | Date | string
    county?: XOR<CountyNullableScalarRelationFilter, CountyWhereInput> | null
    district?: XOR<GeoDistrictNullableScalarRelationFilter, GeoDistrictWhereInput> | null
  }, "id">

  export type CivicsOfficialOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    officeName?: SortOrder
    party?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    photoUrl?: SortOrderInput | SortOrder
    countyId?: SortOrderInput | SortOrder
    districtId?: SortOrderInput | SortOrder
    sourceNote?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CivicsOfficialCountOrderByAggregateInput
    _max?: CivicsOfficialMaxOrderByAggregateInput
    _min?: CivicsOfficialMinOrderByAggregateInput
  }

  export type CivicsOfficialScalarWhereWithAggregatesInput = {
    AND?: CivicsOfficialScalarWhereWithAggregatesInput | CivicsOfficialScalarWhereWithAggregatesInput[]
    OR?: CivicsOfficialScalarWhereWithAggregatesInput[]
    NOT?: CivicsOfficialScalarWhereWithAggregatesInput | CivicsOfficialScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"CivicsOfficial"> | string
    name?: StringWithAggregatesFilter<"CivicsOfficial"> | string
    officeName?: StringWithAggregatesFilter<"CivicsOfficial"> | string
    party?: StringNullableWithAggregatesFilter<"CivicsOfficial"> | string | null
    phone?: StringNullableWithAggregatesFilter<"CivicsOfficial"> | string | null
    website?: StringNullableWithAggregatesFilter<"CivicsOfficial"> | string | null
    photoUrl?: StringNullableWithAggregatesFilter<"CivicsOfficial"> | string | null
    countyId?: UuidNullableWithAggregatesFilter<"CivicsOfficial"> | string | null
    districtId?: UuidNullableWithAggregatesFilter<"CivicsOfficial"> | string | null
    sourceNote?: StringNullableWithAggregatesFilter<"CivicsOfficial"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CivicsOfficial"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CivicsOfficial"> | Date | string
  }

  export type ElectionWhereInput = {
    AND?: ElectionWhereInput | ElectionWhereInput[]
    OR?: ElectionWhereInput[]
    NOT?: ElectionWhereInput | ElectionWhereInput[]
    id?: UuidFilter<"Election"> | string
    name?: StringFilter<"Election"> | string
    electionDate?: DateTimeFilter<"Election"> | Date | string
    electionType?: StringNullableFilter<"Election"> | string | null
    notes?: StringNullableFilter<"Election"> | string | null
    createdAt?: DateTimeFilter<"Election"> | Date | string
    results?: ElectionResultListRelationFilter
  }

  export type ElectionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    electionDate?: SortOrder
    electionType?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    results?: ElectionResultOrderByRelationAggregateInput
  }

  export type ElectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ElectionWhereInput | ElectionWhereInput[]
    OR?: ElectionWhereInput[]
    NOT?: ElectionWhereInput | ElectionWhereInput[]
    name?: StringFilter<"Election"> | string
    electionDate?: DateTimeFilter<"Election"> | Date | string
    electionType?: StringNullableFilter<"Election"> | string | null
    notes?: StringNullableFilter<"Election"> | string | null
    createdAt?: DateTimeFilter<"Election"> | Date | string
    results?: ElectionResultListRelationFilter
  }, "id">

  export type ElectionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    electionDate?: SortOrder
    electionType?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ElectionCountOrderByAggregateInput
    _max?: ElectionMaxOrderByAggregateInput
    _min?: ElectionMinOrderByAggregateInput
  }

  export type ElectionScalarWhereWithAggregatesInput = {
    AND?: ElectionScalarWhereWithAggregatesInput | ElectionScalarWhereWithAggregatesInput[]
    OR?: ElectionScalarWhereWithAggregatesInput[]
    NOT?: ElectionScalarWhereWithAggregatesInput | ElectionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Election"> | string
    name?: StringWithAggregatesFilter<"Election"> | string
    electionDate?: DateTimeWithAggregatesFilter<"Election"> | Date | string
    electionType?: StringNullableWithAggregatesFilter<"Election"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Election"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Election"> | Date | string
  }

  export type ElectionResultWhereInput = {
    AND?: ElectionResultWhereInput | ElectionResultWhereInput[]
    OR?: ElectionResultWhereInput[]
    NOT?: ElectionResultWhereInput | ElectionResultWhereInput[]
    id?: UuidFilter<"ElectionResult"> | string
    electionId?: UuidFilter<"ElectionResult"> | string
    countyId?: UuidNullableFilter<"ElectionResult"> | string | null
    geoZipId?: UuidNullableFilter<"ElectionResult"> | string | null
    precinctId?: UuidNullableFilter<"ElectionResult"> | string | null
    choiceLabel?: StringFilter<"ElectionResult"> | string
    votes?: IntNullableFilter<"ElectionResult"> | number | null
    voteShare?: FloatNullableFilter<"ElectionResult"> | number | null
    createdAt?: DateTimeFilter<"ElectionResult"> | Date | string
    election?: XOR<ElectionScalarRelationFilter, ElectionWhereInput>
    county?: XOR<CountyNullableScalarRelationFilter, CountyWhereInput> | null
    geoZip?: XOR<GeoZipNullableScalarRelationFilter, GeoZipWhereInput> | null
    precinct?: XOR<GeoPrecinctNullableScalarRelationFilter, GeoPrecinctWhereInput> | null
  }

  export type ElectionResultOrderByWithRelationInput = {
    id?: SortOrder
    electionId?: SortOrder
    countyId?: SortOrderInput | SortOrder
    geoZipId?: SortOrderInput | SortOrder
    precinctId?: SortOrderInput | SortOrder
    choiceLabel?: SortOrder
    votes?: SortOrderInput | SortOrder
    voteShare?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    election?: ElectionOrderByWithRelationInput
    county?: CountyOrderByWithRelationInput
    geoZip?: GeoZipOrderByWithRelationInput
    precinct?: GeoPrecinctOrderByWithRelationInput
  }

  export type ElectionResultWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ElectionResultWhereInput | ElectionResultWhereInput[]
    OR?: ElectionResultWhereInput[]
    NOT?: ElectionResultWhereInput | ElectionResultWhereInput[]
    electionId?: UuidFilter<"ElectionResult"> | string
    countyId?: UuidNullableFilter<"ElectionResult"> | string | null
    geoZipId?: UuidNullableFilter<"ElectionResult"> | string | null
    precinctId?: UuidNullableFilter<"ElectionResult"> | string | null
    choiceLabel?: StringFilter<"ElectionResult"> | string
    votes?: IntNullableFilter<"ElectionResult"> | number | null
    voteShare?: FloatNullableFilter<"ElectionResult"> | number | null
    createdAt?: DateTimeFilter<"ElectionResult"> | Date | string
    election?: XOR<ElectionScalarRelationFilter, ElectionWhereInput>
    county?: XOR<CountyNullableScalarRelationFilter, CountyWhereInput> | null
    geoZip?: XOR<GeoZipNullableScalarRelationFilter, GeoZipWhereInput> | null
    precinct?: XOR<GeoPrecinctNullableScalarRelationFilter, GeoPrecinctWhereInput> | null
  }, "id">

  export type ElectionResultOrderByWithAggregationInput = {
    id?: SortOrder
    electionId?: SortOrder
    countyId?: SortOrderInput | SortOrder
    geoZipId?: SortOrderInput | SortOrder
    precinctId?: SortOrderInput | SortOrder
    choiceLabel?: SortOrder
    votes?: SortOrderInput | SortOrder
    voteShare?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ElectionResultCountOrderByAggregateInput
    _avg?: ElectionResultAvgOrderByAggregateInput
    _max?: ElectionResultMaxOrderByAggregateInput
    _min?: ElectionResultMinOrderByAggregateInput
    _sum?: ElectionResultSumOrderByAggregateInput
  }

  export type ElectionResultScalarWhereWithAggregatesInput = {
    AND?: ElectionResultScalarWhereWithAggregatesInput | ElectionResultScalarWhereWithAggregatesInput[]
    OR?: ElectionResultScalarWhereWithAggregatesInput[]
    NOT?: ElectionResultScalarWhereWithAggregatesInput | ElectionResultScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ElectionResult"> | string
    electionId?: UuidWithAggregatesFilter<"ElectionResult"> | string
    countyId?: UuidNullableWithAggregatesFilter<"ElectionResult"> | string | null
    geoZipId?: UuidNullableWithAggregatesFilter<"ElectionResult"> | string | null
    precinctId?: UuidNullableWithAggregatesFilter<"ElectionResult"> | string | null
    choiceLabel?: StringWithAggregatesFilter<"ElectionResult"> | string
    votes?: IntNullableWithAggregatesFilter<"ElectionResult"> | number | null
    voteShare?: FloatNullableWithAggregatesFilter<"ElectionResult"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"ElectionResult"> | Date | string
  }

  export type AIPromptWhereInput = {
    AND?: AIPromptWhereInput | AIPromptWhereInput[]
    OR?: AIPromptWhereInput[]
    NOT?: AIPromptWhereInput | AIPromptWhereInput[]
    id?: UuidFilter<"AIPrompt"> | string
    promptKey?: StringFilter<"AIPrompt"> | string
    version?: IntFilter<"AIPrompt"> | number
    name?: StringFilter<"AIPrompt"> | string
    description?: StringNullableFilter<"AIPrompt"> | string | null
    template?: StringFilter<"AIPrompt"> | string
    createdAt?: DateTimeFilter<"AIPrompt"> | Date | string
    updatedAt?: DateTimeFilter<"AIPrompt"> | Date | string
    runs?: AIRunListRelationFilter
  }

  export type AIPromptOrderByWithRelationInput = {
    id?: SortOrder
    promptKey?: SortOrder
    version?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    template?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    runs?: AIRunOrderByRelationAggregateInput
  }

  export type AIPromptWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    promptKey_version?: AIPromptPromptKeyVersionCompoundUniqueInput
    AND?: AIPromptWhereInput | AIPromptWhereInput[]
    OR?: AIPromptWhereInput[]
    NOT?: AIPromptWhereInput | AIPromptWhereInput[]
    promptKey?: StringFilter<"AIPrompt"> | string
    version?: IntFilter<"AIPrompt"> | number
    name?: StringFilter<"AIPrompt"> | string
    description?: StringNullableFilter<"AIPrompt"> | string | null
    template?: StringFilter<"AIPrompt"> | string
    createdAt?: DateTimeFilter<"AIPrompt"> | Date | string
    updatedAt?: DateTimeFilter<"AIPrompt"> | Date | string
    runs?: AIRunListRelationFilter
  }, "id" | "promptKey_version">

  export type AIPromptOrderByWithAggregationInput = {
    id?: SortOrder
    promptKey?: SortOrder
    version?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    template?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AIPromptCountOrderByAggregateInput
    _avg?: AIPromptAvgOrderByAggregateInput
    _max?: AIPromptMaxOrderByAggregateInput
    _min?: AIPromptMinOrderByAggregateInput
    _sum?: AIPromptSumOrderByAggregateInput
  }

  export type AIPromptScalarWhereWithAggregatesInput = {
    AND?: AIPromptScalarWhereWithAggregatesInput | AIPromptScalarWhereWithAggregatesInput[]
    OR?: AIPromptScalarWhereWithAggregatesInput[]
    NOT?: AIPromptScalarWhereWithAggregatesInput | AIPromptScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"AIPrompt"> | string
    promptKey?: StringWithAggregatesFilter<"AIPrompt"> | string
    version?: IntWithAggregatesFilter<"AIPrompt"> | number
    name?: StringWithAggregatesFilter<"AIPrompt"> | string
    description?: StringNullableWithAggregatesFilter<"AIPrompt"> | string | null
    template?: StringWithAggregatesFilter<"AIPrompt"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AIPrompt"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AIPrompt"> | Date | string
  }

  export type AIRunWhereInput = {
    AND?: AIRunWhereInput | AIRunWhereInput[]
    OR?: AIRunWhereInput[]
    NOT?: AIRunWhereInput | AIRunWhereInput[]
    id?: UuidFilter<"AIRun"> | string
    promptId?: UuidFilter<"AIRun"> | string
    model?: StringFilter<"AIRun"> | string
    paramsJson?: JsonNullableFilter<"AIRun">
    status?: EnumAIRunStatusFilter<"AIRun"> | $Enums.AIRunStatus
    startedAt?: DateTimeNullableFilter<"AIRun"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"AIRun"> | Date | string | null
    errorText?: StringNullableFilter<"AIRun"> | string | null
    inputSummary?: StringNullableFilter<"AIRun"> | string | null
    createdAt?: DateTimeFilter<"AIRun"> | Date | string
    prompt?: XOR<AIPromptScalarRelationFilter, AIPromptWhereInput>
    outputs?: AIOutputListRelationFilter
    inputSources?: AIRunInputSourceListRelationFilter
    analyses?: AIAnalysisListRelationFilter
  }

  export type AIRunOrderByWithRelationInput = {
    id?: SortOrder
    promptId?: SortOrder
    model?: SortOrder
    paramsJson?: SortOrderInput | SortOrder
    status?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    errorText?: SortOrderInput | SortOrder
    inputSummary?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    prompt?: AIPromptOrderByWithRelationInput
    outputs?: AIOutputOrderByRelationAggregateInput
    inputSources?: AIRunInputSourceOrderByRelationAggregateInput
    analyses?: AIAnalysisOrderByRelationAggregateInput
  }

  export type AIRunWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AIRunWhereInput | AIRunWhereInput[]
    OR?: AIRunWhereInput[]
    NOT?: AIRunWhereInput | AIRunWhereInput[]
    promptId?: UuidFilter<"AIRun"> | string
    model?: StringFilter<"AIRun"> | string
    paramsJson?: JsonNullableFilter<"AIRun">
    status?: EnumAIRunStatusFilter<"AIRun"> | $Enums.AIRunStatus
    startedAt?: DateTimeNullableFilter<"AIRun"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"AIRun"> | Date | string | null
    errorText?: StringNullableFilter<"AIRun"> | string | null
    inputSummary?: StringNullableFilter<"AIRun"> | string | null
    createdAt?: DateTimeFilter<"AIRun"> | Date | string
    prompt?: XOR<AIPromptScalarRelationFilter, AIPromptWhereInput>
    outputs?: AIOutputListRelationFilter
    inputSources?: AIRunInputSourceListRelationFilter
    analyses?: AIAnalysisListRelationFilter
  }, "id">

  export type AIRunOrderByWithAggregationInput = {
    id?: SortOrder
    promptId?: SortOrder
    model?: SortOrder
    paramsJson?: SortOrderInput | SortOrder
    status?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    errorText?: SortOrderInput | SortOrder
    inputSummary?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AIRunCountOrderByAggregateInput
    _max?: AIRunMaxOrderByAggregateInput
    _min?: AIRunMinOrderByAggregateInput
  }

  export type AIRunScalarWhereWithAggregatesInput = {
    AND?: AIRunScalarWhereWithAggregatesInput | AIRunScalarWhereWithAggregatesInput[]
    OR?: AIRunScalarWhereWithAggregatesInput[]
    NOT?: AIRunScalarWhereWithAggregatesInput | AIRunScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"AIRun"> | string
    promptId?: UuidWithAggregatesFilter<"AIRun"> | string
    model?: StringWithAggregatesFilter<"AIRun"> | string
    paramsJson?: JsonNullableWithAggregatesFilter<"AIRun">
    status?: EnumAIRunStatusWithAggregatesFilter<"AIRun"> | $Enums.AIRunStatus
    startedAt?: DateTimeNullableWithAggregatesFilter<"AIRun"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"AIRun"> | Date | string | null
    errorText?: StringNullableWithAggregatesFilter<"AIRun"> | string | null
    inputSummary?: StringNullableWithAggregatesFilter<"AIRun"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AIRun"> | Date | string
  }

  export type AIRunInputSourceWhereInput = {
    AND?: AIRunInputSourceWhereInput | AIRunInputSourceWhereInput[]
    OR?: AIRunInputSourceWhereInput[]
    NOT?: AIRunInputSourceWhereInput | AIRunInputSourceWhereInput[]
    id?: UuidFilter<"AIRunInputSource"> | string
    runId?: UuidFilter<"AIRunInputSource"> | string
    kind?: EnumAIRunInputKindFilter<"AIRunInputSource"> | $Enums.AIRunInputKind
    sourceDocumentId?: UuidNullableFilter<"AIRunInputSource"> | string | null
    externalKey?: StringNullableFilter<"AIRunInputSource"> | string | null
    notes?: StringNullableFilter<"AIRunInputSource"> | string | null
    createdAt?: DateTimeFilter<"AIRunInputSource"> | Date | string
    run?: XOR<AIRunScalarRelationFilter, AIRunWhereInput>
    sourceDocument?: XOR<SourceDocumentNullableScalarRelationFilter, SourceDocumentWhereInput> | null
  }

  export type AIRunInputSourceOrderByWithRelationInput = {
    id?: SortOrder
    runId?: SortOrder
    kind?: SortOrder
    sourceDocumentId?: SortOrderInput | SortOrder
    externalKey?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    run?: AIRunOrderByWithRelationInput
    sourceDocument?: SourceDocumentOrderByWithRelationInput
  }

  export type AIRunInputSourceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AIRunInputSourceWhereInput | AIRunInputSourceWhereInput[]
    OR?: AIRunInputSourceWhereInput[]
    NOT?: AIRunInputSourceWhereInput | AIRunInputSourceWhereInput[]
    runId?: UuidFilter<"AIRunInputSource"> | string
    kind?: EnumAIRunInputKindFilter<"AIRunInputSource"> | $Enums.AIRunInputKind
    sourceDocumentId?: UuidNullableFilter<"AIRunInputSource"> | string | null
    externalKey?: StringNullableFilter<"AIRunInputSource"> | string | null
    notes?: StringNullableFilter<"AIRunInputSource"> | string | null
    createdAt?: DateTimeFilter<"AIRunInputSource"> | Date | string
    run?: XOR<AIRunScalarRelationFilter, AIRunWhereInput>
    sourceDocument?: XOR<SourceDocumentNullableScalarRelationFilter, SourceDocumentWhereInput> | null
  }, "id">

  export type AIRunInputSourceOrderByWithAggregationInput = {
    id?: SortOrder
    runId?: SortOrder
    kind?: SortOrder
    sourceDocumentId?: SortOrderInput | SortOrder
    externalKey?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AIRunInputSourceCountOrderByAggregateInput
    _max?: AIRunInputSourceMaxOrderByAggregateInput
    _min?: AIRunInputSourceMinOrderByAggregateInput
  }

  export type AIRunInputSourceScalarWhereWithAggregatesInput = {
    AND?: AIRunInputSourceScalarWhereWithAggregatesInput | AIRunInputSourceScalarWhereWithAggregatesInput[]
    OR?: AIRunInputSourceScalarWhereWithAggregatesInput[]
    NOT?: AIRunInputSourceScalarWhereWithAggregatesInput | AIRunInputSourceScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"AIRunInputSource"> | string
    runId?: UuidWithAggregatesFilter<"AIRunInputSource"> | string
    kind?: EnumAIRunInputKindWithAggregatesFilter<"AIRunInputSource"> | $Enums.AIRunInputKind
    sourceDocumentId?: UuidNullableWithAggregatesFilter<"AIRunInputSource"> | string | null
    externalKey?: StringNullableWithAggregatesFilter<"AIRunInputSource"> | string | null
    notes?: StringNullableWithAggregatesFilter<"AIRunInputSource"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AIRunInputSource"> | Date | string
  }

  export type AIOutputWhereInput = {
    AND?: AIOutputWhereInput | AIOutputWhereInput[]
    OR?: AIOutputWhereInput[]
    NOT?: AIOutputWhereInput | AIOutputWhereInput[]
    id?: UuidFilter<"AIOutput"> | string
    runId?: UuidFilter<"AIOutput"> | string
    outputType?: EnumAIOutputTypeFilter<"AIOutput"> | $Enums.AIOutputType
    status?: EnumPublishStatusFilter<"AIOutput"> | $Enums.PublishStatus
    title?: StringNullableFilter<"AIOutput"> | string | null
    summary?: StringNullableFilter<"AIOutput"> | string | null
    contentMd?: StringFilter<"AIOutput"> | string
    reviewedAt?: DateTimeNullableFilter<"AIOutput"> | Date | string | null
    publishedAt?: DateTimeNullableFilter<"AIOutput"> | Date | string | null
    createdAt?: DateTimeFilter<"AIOutput"> | Date | string
    updatedAt?: DateTimeFilter<"AIOutput"> | Date | string
    run?: XOR<AIRunScalarRelationFilter, AIRunWhereInput>
    sections?: AIOutputSectionListRelationFilter
    scopes?: AIOutputScopeListRelationFilter
  }

  export type AIOutputOrderByWithRelationInput = {
    id?: SortOrder
    runId?: SortOrder
    outputType?: SortOrder
    status?: SortOrder
    title?: SortOrderInput | SortOrder
    summary?: SortOrderInput | SortOrder
    contentMd?: SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    run?: AIRunOrderByWithRelationInput
    sections?: AIOutputSectionOrderByRelationAggregateInput
    scopes?: AIOutputScopeOrderByRelationAggregateInput
  }

  export type AIOutputWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AIOutputWhereInput | AIOutputWhereInput[]
    OR?: AIOutputWhereInput[]
    NOT?: AIOutputWhereInput | AIOutputWhereInput[]
    runId?: UuidFilter<"AIOutput"> | string
    outputType?: EnumAIOutputTypeFilter<"AIOutput"> | $Enums.AIOutputType
    status?: EnumPublishStatusFilter<"AIOutput"> | $Enums.PublishStatus
    title?: StringNullableFilter<"AIOutput"> | string | null
    summary?: StringNullableFilter<"AIOutput"> | string | null
    contentMd?: StringFilter<"AIOutput"> | string
    reviewedAt?: DateTimeNullableFilter<"AIOutput"> | Date | string | null
    publishedAt?: DateTimeNullableFilter<"AIOutput"> | Date | string | null
    createdAt?: DateTimeFilter<"AIOutput"> | Date | string
    updatedAt?: DateTimeFilter<"AIOutput"> | Date | string
    run?: XOR<AIRunScalarRelationFilter, AIRunWhereInput>
    sections?: AIOutputSectionListRelationFilter
    scopes?: AIOutputScopeListRelationFilter
  }, "id">

  export type AIOutputOrderByWithAggregationInput = {
    id?: SortOrder
    runId?: SortOrder
    outputType?: SortOrder
    status?: SortOrder
    title?: SortOrderInput | SortOrder
    summary?: SortOrderInput | SortOrder
    contentMd?: SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AIOutputCountOrderByAggregateInput
    _max?: AIOutputMaxOrderByAggregateInput
    _min?: AIOutputMinOrderByAggregateInput
  }

  export type AIOutputScalarWhereWithAggregatesInput = {
    AND?: AIOutputScalarWhereWithAggregatesInput | AIOutputScalarWhereWithAggregatesInput[]
    OR?: AIOutputScalarWhereWithAggregatesInput[]
    NOT?: AIOutputScalarWhereWithAggregatesInput | AIOutputScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"AIOutput"> | string
    runId?: UuidWithAggregatesFilter<"AIOutput"> | string
    outputType?: EnumAIOutputTypeWithAggregatesFilter<"AIOutput"> | $Enums.AIOutputType
    status?: EnumPublishStatusWithAggregatesFilter<"AIOutput"> | $Enums.PublishStatus
    title?: StringNullableWithAggregatesFilter<"AIOutput"> | string | null
    summary?: StringNullableWithAggregatesFilter<"AIOutput"> | string | null
    contentMd?: StringWithAggregatesFilter<"AIOutput"> | string
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"AIOutput"> | Date | string | null
    publishedAt?: DateTimeNullableWithAggregatesFilter<"AIOutput"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AIOutput"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AIOutput"> | Date | string
  }

  export type AIOutputSectionWhereInput = {
    AND?: AIOutputSectionWhereInput | AIOutputSectionWhereInput[]
    OR?: AIOutputSectionWhereInput[]
    NOT?: AIOutputSectionWhereInput | AIOutputSectionWhereInput[]
    id?: UuidFilter<"AIOutputSection"> | string
    outputId?: UuidFilter<"AIOutputSection"> | string
    sectionKey?: StringFilter<"AIOutputSection"> | string
    heading?: StringNullableFilter<"AIOutputSection"> | string | null
    order?: IntFilter<"AIOutputSection"> | number
    contentMd?: StringFilter<"AIOutputSection"> | string
    createdAt?: DateTimeFilter<"AIOutputSection"> | Date | string
    updatedAt?: DateTimeFilter<"AIOutputSection"> | Date | string
    output?: XOR<AIOutputScalarRelationFilter, AIOutputWhereInput>
    citations?: CitationListRelationFilter
  }

  export type AIOutputSectionOrderByWithRelationInput = {
    id?: SortOrder
    outputId?: SortOrder
    sectionKey?: SortOrder
    heading?: SortOrderInput | SortOrder
    order?: SortOrder
    contentMd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    output?: AIOutputOrderByWithRelationInput
    citations?: CitationOrderByRelationAggregateInput
  }

  export type AIOutputSectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    outputId_sectionKey?: AIOutputSectionOutputIdSectionKeyCompoundUniqueInput
    AND?: AIOutputSectionWhereInput | AIOutputSectionWhereInput[]
    OR?: AIOutputSectionWhereInput[]
    NOT?: AIOutputSectionWhereInput | AIOutputSectionWhereInput[]
    outputId?: UuidFilter<"AIOutputSection"> | string
    sectionKey?: StringFilter<"AIOutputSection"> | string
    heading?: StringNullableFilter<"AIOutputSection"> | string | null
    order?: IntFilter<"AIOutputSection"> | number
    contentMd?: StringFilter<"AIOutputSection"> | string
    createdAt?: DateTimeFilter<"AIOutputSection"> | Date | string
    updatedAt?: DateTimeFilter<"AIOutputSection"> | Date | string
    output?: XOR<AIOutputScalarRelationFilter, AIOutputWhereInput>
    citations?: CitationListRelationFilter
  }, "id" | "outputId_sectionKey">

  export type AIOutputSectionOrderByWithAggregationInput = {
    id?: SortOrder
    outputId?: SortOrder
    sectionKey?: SortOrder
    heading?: SortOrderInput | SortOrder
    order?: SortOrder
    contentMd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AIOutputSectionCountOrderByAggregateInput
    _avg?: AIOutputSectionAvgOrderByAggregateInput
    _max?: AIOutputSectionMaxOrderByAggregateInput
    _min?: AIOutputSectionMinOrderByAggregateInput
    _sum?: AIOutputSectionSumOrderByAggregateInput
  }

  export type AIOutputSectionScalarWhereWithAggregatesInput = {
    AND?: AIOutputSectionScalarWhereWithAggregatesInput | AIOutputSectionScalarWhereWithAggregatesInput[]
    OR?: AIOutputSectionScalarWhereWithAggregatesInput[]
    NOT?: AIOutputSectionScalarWhereWithAggregatesInput | AIOutputSectionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"AIOutputSection"> | string
    outputId?: UuidWithAggregatesFilter<"AIOutputSection"> | string
    sectionKey?: StringWithAggregatesFilter<"AIOutputSection"> | string
    heading?: StringNullableWithAggregatesFilter<"AIOutputSection"> | string | null
    order?: IntWithAggregatesFilter<"AIOutputSection"> | number
    contentMd?: StringWithAggregatesFilter<"AIOutputSection"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AIOutputSection"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AIOutputSection"> | Date | string
  }

  export type AIOutputScopeWhereInput = {
    AND?: AIOutputScopeWhereInput | AIOutputScopeWhereInput[]
    OR?: AIOutputScopeWhereInput[]
    NOT?: AIOutputScopeWhereInput | AIOutputScopeWhereInput[]
    id?: UuidFilter<"AIOutputScope"> | string
    outputId?: UuidFilter<"AIOutputScope"> | string
    scopeType?: EnumAIScopeTypeFilter<"AIOutputScope"> | $Enums.AIScopeType
    countyId?: UuidNullableFilter<"AIOutputScope"> | string | null
    issueId?: UuidNullableFilter<"AIOutputScope"> | string | null
    geoZipId?: UuidNullableFilter<"AIOutputScope"> | string | null
    districtId?: UuidNullableFilter<"AIOutputScope"> | string | null
    customKey?: StringNullableFilter<"AIOutputScope"> | string | null
    createdAt?: DateTimeFilter<"AIOutputScope"> | Date | string
    output?: XOR<AIOutputScalarRelationFilter, AIOutputWhereInput>
    county?: XOR<CountyNullableScalarRelationFilter, CountyWhereInput> | null
    issue?: XOR<IssueNullableScalarRelationFilter, IssueWhereInput> | null
    geoZip?: XOR<GeoZipNullableScalarRelationFilter, GeoZipWhereInput> | null
    district?: XOR<GeoDistrictNullableScalarRelationFilter, GeoDistrictWhereInput> | null
  }

  export type AIOutputScopeOrderByWithRelationInput = {
    id?: SortOrder
    outputId?: SortOrder
    scopeType?: SortOrder
    countyId?: SortOrderInput | SortOrder
    issueId?: SortOrderInput | SortOrder
    geoZipId?: SortOrderInput | SortOrder
    districtId?: SortOrderInput | SortOrder
    customKey?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    output?: AIOutputOrderByWithRelationInput
    county?: CountyOrderByWithRelationInput
    issue?: IssueOrderByWithRelationInput
    geoZip?: GeoZipOrderByWithRelationInput
    district?: GeoDistrictOrderByWithRelationInput
  }

  export type AIOutputScopeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AIOutputScopeWhereInput | AIOutputScopeWhereInput[]
    OR?: AIOutputScopeWhereInput[]
    NOT?: AIOutputScopeWhereInput | AIOutputScopeWhereInput[]
    outputId?: UuidFilter<"AIOutputScope"> | string
    scopeType?: EnumAIScopeTypeFilter<"AIOutputScope"> | $Enums.AIScopeType
    countyId?: UuidNullableFilter<"AIOutputScope"> | string | null
    issueId?: UuidNullableFilter<"AIOutputScope"> | string | null
    geoZipId?: UuidNullableFilter<"AIOutputScope"> | string | null
    districtId?: UuidNullableFilter<"AIOutputScope"> | string | null
    customKey?: StringNullableFilter<"AIOutputScope"> | string | null
    createdAt?: DateTimeFilter<"AIOutputScope"> | Date | string
    output?: XOR<AIOutputScalarRelationFilter, AIOutputWhereInput>
    county?: XOR<CountyNullableScalarRelationFilter, CountyWhereInput> | null
    issue?: XOR<IssueNullableScalarRelationFilter, IssueWhereInput> | null
    geoZip?: XOR<GeoZipNullableScalarRelationFilter, GeoZipWhereInput> | null
    district?: XOR<GeoDistrictNullableScalarRelationFilter, GeoDistrictWhereInput> | null
  }, "id">

  export type AIOutputScopeOrderByWithAggregationInput = {
    id?: SortOrder
    outputId?: SortOrder
    scopeType?: SortOrder
    countyId?: SortOrderInput | SortOrder
    issueId?: SortOrderInput | SortOrder
    geoZipId?: SortOrderInput | SortOrder
    districtId?: SortOrderInput | SortOrder
    customKey?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AIOutputScopeCountOrderByAggregateInput
    _max?: AIOutputScopeMaxOrderByAggregateInput
    _min?: AIOutputScopeMinOrderByAggregateInput
  }

  export type AIOutputScopeScalarWhereWithAggregatesInput = {
    AND?: AIOutputScopeScalarWhereWithAggregatesInput | AIOutputScopeScalarWhereWithAggregatesInput[]
    OR?: AIOutputScopeScalarWhereWithAggregatesInput[]
    NOT?: AIOutputScopeScalarWhereWithAggregatesInput | AIOutputScopeScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"AIOutputScope"> | string
    outputId?: UuidWithAggregatesFilter<"AIOutputScope"> | string
    scopeType?: EnumAIScopeTypeWithAggregatesFilter<"AIOutputScope"> | $Enums.AIScopeType
    countyId?: UuidNullableWithAggregatesFilter<"AIOutputScope"> | string | null
    issueId?: UuidNullableWithAggregatesFilter<"AIOutputScope"> | string | null
    geoZipId?: UuidNullableWithAggregatesFilter<"AIOutputScope"> | string | null
    districtId?: UuidNullableWithAggregatesFilter<"AIOutputScope"> | string | null
    customKey?: StringNullableWithAggregatesFilter<"AIOutputScope"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AIOutputScope"> | Date | string
  }

  export type CitationWhereInput = {
    AND?: CitationWhereInput | CitationWhereInput[]
    OR?: CitationWhereInput[]
    NOT?: CitationWhereInput | CitationWhereInput[]
    id?: UuidFilter<"Citation"> | string
    outputSectionId?: UuidFilter<"Citation"> | string
    sourceChunkId?: UuidNullableFilter<"Citation"> | string | null
    sourceDocumentId?: UuidNullableFilter<"Citation"> | string | null
    label?: StringNullableFilter<"Citation"> | string | null
    locatorJson?: JsonNullableFilter<"Citation">
    createdAt?: DateTimeFilter<"Citation"> | Date | string
    outputSection?: XOR<AIOutputSectionScalarRelationFilter, AIOutputSectionWhereInput>
    sourceChunk?: XOR<SourceChunkNullableScalarRelationFilter, SourceChunkWhereInput> | null
    sourceDocument?: XOR<SourceDocumentNullableScalarRelationFilter, SourceDocumentWhereInput> | null
  }

  export type CitationOrderByWithRelationInput = {
    id?: SortOrder
    outputSectionId?: SortOrder
    sourceChunkId?: SortOrderInput | SortOrder
    sourceDocumentId?: SortOrderInput | SortOrder
    label?: SortOrderInput | SortOrder
    locatorJson?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    outputSection?: AIOutputSectionOrderByWithRelationInput
    sourceChunk?: SourceChunkOrderByWithRelationInput
    sourceDocument?: SourceDocumentOrderByWithRelationInput
  }

  export type CitationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CitationWhereInput | CitationWhereInput[]
    OR?: CitationWhereInput[]
    NOT?: CitationWhereInput | CitationWhereInput[]
    outputSectionId?: UuidFilter<"Citation"> | string
    sourceChunkId?: UuidNullableFilter<"Citation"> | string | null
    sourceDocumentId?: UuidNullableFilter<"Citation"> | string | null
    label?: StringNullableFilter<"Citation"> | string | null
    locatorJson?: JsonNullableFilter<"Citation">
    createdAt?: DateTimeFilter<"Citation"> | Date | string
    outputSection?: XOR<AIOutputSectionScalarRelationFilter, AIOutputSectionWhereInput>
    sourceChunk?: XOR<SourceChunkNullableScalarRelationFilter, SourceChunkWhereInput> | null
    sourceDocument?: XOR<SourceDocumentNullableScalarRelationFilter, SourceDocumentWhereInput> | null
  }, "id">

  export type CitationOrderByWithAggregationInput = {
    id?: SortOrder
    outputSectionId?: SortOrder
    sourceChunkId?: SortOrderInput | SortOrder
    sourceDocumentId?: SortOrderInput | SortOrder
    label?: SortOrderInput | SortOrder
    locatorJson?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CitationCountOrderByAggregateInput
    _max?: CitationMaxOrderByAggregateInput
    _min?: CitationMinOrderByAggregateInput
  }

  export type CitationScalarWhereWithAggregatesInput = {
    AND?: CitationScalarWhereWithAggregatesInput | CitationScalarWhereWithAggregatesInput[]
    OR?: CitationScalarWhereWithAggregatesInput[]
    NOT?: CitationScalarWhereWithAggregatesInput | CitationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Citation"> | string
    outputSectionId?: UuidWithAggregatesFilter<"Citation"> | string
    sourceChunkId?: UuidNullableWithAggregatesFilter<"Citation"> | string | null
    sourceDocumentId?: UuidNullableWithAggregatesFilter<"Citation"> | string | null
    label?: StringNullableWithAggregatesFilter<"Citation"> | string | null
    locatorJson?: JsonNullableWithAggregatesFilter<"Citation">
    createdAt?: DateTimeWithAggregatesFilter<"Citation"> | Date | string
  }

  export type SurveyFormWhereInput = {
    AND?: SurveyFormWhereInput | SurveyFormWhereInput[]
    OR?: SurveyFormWhereInput[]
    NOT?: SurveyFormWhereInput | SurveyFormWhereInput[]
    id?: UuidFilter<"SurveyForm"> | string
    title?: StringFilter<"SurveyForm"> | string
    descriptionMd?: StringNullableFilter<"SurveyForm"> | string | null
    slug?: StringFilter<"SurveyForm"> | string
    status?: EnumSurveyFormStatusFilter<"SurveyForm"> | $Enums.SurveyFormStatus
    startAt?: DateTimeNullableFilter<"SurveyForm"> | Date | string | null
    endAt?: DateTimeNullableFilter<"SurveyForm"> | Date | string | null
    countyId?: UuidNullableFilter<"SurveyForm"> | string | null
    contextLabel?: StringNullableFilter<"SurveyForm"> | string | null
    createdAt?: DateTimeFilter<"SurveyForm"> | Date | string
    updatedAt?: DateTimeFilter<"SurveyForm"> | Date | string
    county?: XOR<CountyNullableScalarRelationFilter, CountyWhereInput> | null
    questions?: SurveyQuestionListRelationFilter
    responses?: SurveyResponseListRelationFilter
    sourceLinks?: SourceDocumentLinkListRelationFilter
  }

  export type SurveyFormOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    descriptionMd?: SortOrderInput | SortOrder
    slug?: SortOrder
    status?: SortOrder
    startAt?: SortOrderInput | SortOrder
    endAt?: SortOrderInput | SortOrder
    countyId?: SortOrderInput | SortOrder
    contextLabel?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    county?: CountyOrderByWithRelationInput
    questions?: SurveyQuestionOrderByRelationAggregateInput
    responses?: SurveyResponseOrderByRelationAggregateInput
    sourceLinks?: SourceDocumentLinkOrderByRelationAggregateInput
  }

  export type SurveyFormWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: SurveyFormWhereInput | SurveyFormWhereInput[]
    OR?: SurveyFormWhereInput[]
    NOT?: SurveyFormWhereInput | SurveyFormWhereInput[]
    title?: StringFilter<"SurveyForm"> | string
    descriptionMd?: StringNullableFilter<"SurveyForm"> | string | null
    status?: EnumSurveyFormStatusFilter<"SurveyForm"> | $Enums.SurveyFormStatus
    startAt?: DateTimeNullableFilter<"SurveyForm"> | Date | string | null
    endAt?: DateTimeNullableFilter<"SurveyForm"> | Date | string | null
    countyId?: UuidNullableFilter<"SurveyForm"> | string | null
    contextLabel?: StringNullableFilter<"SurveyForm"> | string | null
    createdAt?: DateTimeFilter<"SurveyForm"> | Date | string
    updatedAt?: DateTimeFilter<"SurveyForm"> | Date | string
    county?: XOR<CountyNullableScalarRelationFilter, CountyWhereInput> | null
    questions?: SurveyQuestionListRelationFilter
    responses?: SurveyResponseListRelationFilter
    sourceLinks?: SourceDocumentLinkListRelationFilter
  }, "id" | "slug">

  export type SurveyFormOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    descriptionMd?: SortOrderInput | SortOrder
    slug?: SortOrder
    status?: SortOrder
    startAt?: SortOrderInput | SortOrder
    endAt?: SortOrderInput | SortOrder
    countyId?: SortOrderInput | SortOrder
    contextLabel?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SurveyFormCountOrderByAggregateInput
    _max?: SurveyFormMaxOrderByAggregateInput
    _min?: SurveyFormMinOrderByAggregateInput
  }

  export type SurveyFormScalarWhereWithAggregatesInput = {
    AND?: SurveyFormScalarWhereWithAggregatesInput | SurveyFormScalarWhereWithAggregatesInput[]
    OR?: SurveyFormScalarWhereWithAggregatesInput[]
    NOT?: SurveyFormScalarWhereWithAggregatesInput | SurveyFormScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"SurveyForm"> | string
    title?: StringWithAggregatesFilter<"SurveyForm"> | string
    descriptionMd?: StringNullableWithAggregatesFilter<"SurveyForm"> | string | null
    slug?: StringWithAggregatesFilter<"SurveyForm"> | string
    status?: EnumSurveyFormStatusWithAggregatesFilter<"SurveyForm"> | $Enums.SurveyFormStatus
    startAt?: DateTimeNullableWithAggregatesFilter<"SurveyForm"> | Date | string | null
    endAt?: DateTimeNullableWithAggregatesFilter<"SurveyForm"> | Date | string | null
    countyId?: UuidNullableWithAggregatesFilter<"SurveyForm"> | string | null
    contextLabel?: StringNullableWithAggregatesFilter<"SurveyForm"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SurveyForm"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SurveyForm"> | Date | string
  }

  export type SurveyQuestionWhereInput = {
    AND?: SurveyQuestionWhereInput | SurveyQuestionWhereInput[]
    OR?: SurveyQuestionWhereInput[]
    NOT?: SurveyQuestionWhereInput | SurveyQuestionWhereInput[]
    id?: UuidFilter<"SurveyQuestion"> | string
    formId?: UuidFilter<"SurveyQuestion"> | string
    questionKey?: StringFilter<"SurveyQuestion"> | string
    prompt?: StringFilter<"SurveyQuestion"> | string
    helpText?: StringNullableFilter<"SurveyQuestion"> | string | null
    questionType?: EnumSurveyQuestionTypeFilter<"SurveyQuestion"> | $Enums.SurveyQuestionType
    required?: BoolFilter<"SurveyQuestion"> | boolean
    sortOrder?: IntFilter<"SurveyQuestion"> | number
    isActive?: BoolFilter<"SurveyQuestion"> | boolean
    allowVoice?: BoolFilter<"SurveyQuestion"> | boolean
    createdAt?: DateTimeFilter<"SurveyQuestion"> | Date | string
    updatedAt?: DateTimeFilter<"SurveyQuestion"> | Date | string
    form?: XOR<SurveyFormScalarRelationFilter, SurveyFormWhereInput>
    options?: SurveyQuestionOptionListRelationFilter
    responseItems?: SurveyResponseItemListRelationFilter
  }

  export type SurveyQuestionOrderByWithRelationInput = {
    id?: SortOrder
    formId?: SortOrder
    questionKey?: SortOrder
    prompt?: SortOrder
    helpText?: SortOrderInput | SortOrder
    questionType?: SortOrder
    required?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    allowVoice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    form?: SurveyFormOrderByWithRelationInput
    options?: SurveyQuestionOptionOrderByRelationAggregateInput
    responseItems?: SurveyResponseItemOrderByRelationAggregateInput
  }

  export type SurveyQuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    formId_questionKey?: SurveyQuestionFormIdQuestionKeyCompoundUniqueInput
    AND?: SurveyQuestionWhereInput | SurveyQuestionWhereInput[]
    OR?: SurveyQuestionWhereInput[]
    NOT?: SurveyQuestionWhereInput | SurveyQuestionWhereInput[]
    formId?: UuidFilter<"SurveyQuestion"> | string
    questionKey?: StringFilter<"SurveyQuestion"> | string
    prompt?: StringFilter<"SurveyQuestion"> | string
    helpText?: StringNullableFilter<"SurveyQuestion"> | string | null
    questionType?: EnumSurveyQuestionTypeFilter<"SurveyQuestion"> | $Enums.SurveyQuestionType
    required?: BoolFilter<"SurveyQuestion"> | boolean
    sortOrder?: IntFilter<"SurveyQuestion"> | number
    isActive?: BoolFilter<"SurveyQuestion"> | boolean
    allowVoice?: BoolFilter<"SurveyQuestion"> | boolean
    createdAt?: DateTimeFilter<"SurveyQuestion"> | Date | string
    updatedAt?: DateTimeFilter<"SurveyQuestion"> | Date | string
    form?: XOR<SurveyFormScalarRelationFilter, SurveyFormWhereInput>
    options?: SurveyQuestionOptionListRelationFilter
    responseItems?: SurveyResponseItemListRelationFilter
  }, "id" | "formId_questionKey">

  export type SurveyQuestionOrderByWithAggregationInput = {
    id?: SortOrder
    formId?: SortOrder
    questionKey?: SortOrder
    prompt?: SortOrder
    helpText?: SortOrderInput | SortOrder
    questionType?: SortOrder
    required?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    allowVoice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SurveyQuestionCountOrderByAggregateInput
    _avg?: SurveyQuestionAvgOrderByAggregateInput
    _max?: SurveyQuestionMaxOrderByAggregateInput
    _min?: SurveyQuestionMinOrderByAggregateInput
    _sum?: SurveyQuestionSumOrderByAggregateInput
  }

  export type SurveyQuestionScalarWhereWithAggregatesInput = {
    AND?: SurveyQuestionScalarWhereWithAggregatesInput | SurveyQuestionScalarWhereWithAggregatesInput[]
    OR?: SurveyQuestionScalarWhereWithAggregatesInput[]
    NOT?: SurveyQuestionScalarWhereWithAggregatesInput | SurveyQuestionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"SurveyQuestion"> | string
    formId?: UuidWithAggregatesFilter<"SurveyQuestion"> | string
    questionKey?: StringWithAggregatesFilter<"SurveyQuestion"> | string
    prompt?: StringWithAggregatesFilter<"SurveyQuestion"> | string
    helpText?: StringNullableWithAggregatesFilter<"SurveyQuestion"> | string | null
    questionType?: EnumSurveyQuestionTypeWithAggregatesFilter<"SurveyQuestion"> | $Enums.SurveyQuestionType
    required?: BoolWithAggregatesFilter<"SurveyQuestion"> | boolean
    sortOrder?: IntWithAggregatesFilter<"SurveyQuestion"> | number
    isActive?: BoolWithAggregatesFilter<"SurveyQuestion"> | boolean
    allowVoice?: BoolWithAggregatesFilter<"SurveyQuestion"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SurveyQuestion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SurveyQuestion"> | Date | string
  }

  export type SurveyQuestionOptionWhereInput = {
    AND?: SurveyQuestionOptionWhereInput | SurveyQuestionOptionWhereInput[]
    OR?: SurveyQuestionOptionWhereInput[]
    NOT?: SurveyQuestionOptionWhereInput | SurveyQuestionOptionWhereInput[]
    id?: UuidFilter<"SurveyQuestionOption"> | string
    questionId?: UuidFilter<"SurveyQuestionOption"> | string
    valueKey?: StringFilter<"SurveyQuestionOption"> | string
    label?: StringFilter<"SurveyQuestionOption"> | string
    sortOrder?: IntFilter<"SurveyQuestionOption"> | number
    isActive?: BoolFilter<"SurveyQuestionOption"> | boolean
    createdAt?: DateTimeFilter<"SurveyQuestionOption"> | Date | string
    question?: XOR<SurveyQuestionScalarRelationFilter, SurveyQuestionWhereInput>
    responseItemOptions?: SurveyResponseItemOptionListRelationFilter
    selectedByResponseItems?: SurveyResponseItemListRelationFilter
  }

  export type SurveyQuestionOptionOrderByWithRelationInput = {
    id?: SortOrder
    questionId?: SortOrder
    valueKey?: SortOrder
    label?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    question?: SurveyQuestionOrderByWithRelationInput
    responseItemOptions?: SurveyResponseItemOptionOrderByRelationAggregateInput
    selectedByResponseItems?: SurveyResponseItemOrderByRelationAggregateInput
  }

  export type SurveyQuestionOptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    questionId_valueKey?: SurveyQuestionOptionQuestionIdValueKeyCompoundUniqueInput
    AND?: SurveyQuestionOptionWhereInput | SurveyQuestionOptionWhereInput[]
    OR?: SurveyQuestionOptionWhereInput[]
    NOT?: SurveyQuestionOptionWhereInput | SurveyQuestionOptionWhereInput[]
    questionId?: UuidFilter<"SurveyQuestionOption"> | string
    valueKey?: StringFilter<"SurveyQuestionOption"> | string
    label?: StringFilter<"SurveyQuestionOption"> | string
    sortOrder?: IntFilter<"SurveyQuestionOption"> | number
    isActive?: BoolFilter<"SurveyQuestionOption"> | boolean
    createdAt?: DateTimeFilter<"SurveyQuestionOption"> | Date | string
    question?: XOR<SurveyQuestionScalarRelationFilter, SurveyQuestionWhereInput>
    responseItemOptions?: SurveyResponseItemOptionListRelationFilter
    selectedByResponseItems?: SurveyResponseItemListRelationFilter
  }, "id" | "questionId_valueKey">

  export type SurveyQuestionOptionOrderByWithAggregationInput = {
    id?: SortOrder
    questionId?: SortOrder
    valueKey?: SortOrder
    label?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: SurveyQuestionOptionCountOrderByAggregateInput
    _avg?: SurveyQuestionOptionAvgOrderByAggregateInput
    _max?: SurveyQuestionOptionMaxOrderByAggregateInput
    _min?: SurveyQuestionOptionMinOrderByAggregateInput
    _sum?: SurveyQuestionOptionSumOrderByAggregateInput
  }

  export type SurveyQuestionOptionScalarWhereWithAggregatesInput = {
    AND?: SurveyQuestionOptionScalarWhereWithAggregatesInput | SurveyQuestionOptionScalarWhereWithAggregatesInput[]
    OR?: SurveyQuestionOptionScalarWhereWithAggregatesInput[]
    NOT?: SurveyQuestionOptionScalarWhereWithAggregatesInput | SurveyQuestionOptionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"SurveyQuestionOption"> | string
    questionId?: UuidWithAggregatesFilter<"SurveyQuestionOption"> | string
    valueKey?: StringWithAggregatesFilter<"SurveyQuestionOption"> | string
    label?: StringWithAggregatesFilter<"SurveyQuestionOption"> | string
    sortOrder?: IntWithAggregatesFilter<"SurveyQuestionOption"> | number
    isActive?: BoolWithAggregatesFilter<"SurveyQuestionOption"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SurveyQuestionOption"> | Date | string
  }

  export type SurveyResponseWhereInput = {
    AND?: SurveyResponseWhereInput | SurveyResponseWhereInput[]
    OR?: SurveyResponseWhereInput[]
    NOT?: SurveyResponseWhereInput | SurveyResponseWhereInput[]
    id?: UuidFilter<"SurveyResponse"> | string
    formId?: UuidFilter<"SurveyResponse"> | string
    countyId?: UuidNullableFilter<"SurveyResponse"> | string | null
    sourceLabel?: StringNullableFilter<"SurveyResponse"> | string | null
    submittedAt?: DateTimeFilter<"SurveyResponse"> | Date | string
    ipHash?: StringNullableFilter<"SurveyResponse"> | string | null
    userAgent?: StringNullableFilter<"SurveyResponse"> | string | null
    createdAt?: DateTimeFilter<"SurveyResponse"> | Date | string
    form?: XOR<SurveyFormScalarRelationFilter, SurveyFormWhereInput>
    county?: XOR<CountyNullableScalarRelationFilter, CountyWhereInput> | null
    items?: SurveyResponseItemListRelationFilter
  }

  export type SurveyResponseOrderByWithRelationInput = {
    id?: SortOrder
    formId?: SortOrder
    countyId?: SortOrderInput | SortOrder
    sourceLabel?: SortOrderInput | SortOrder
    submittedAt?: SortOrder
    ipHash?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    form?: SurveyFormOrderByWithRelationInput
    county?: CountyOrderByWithRelationInput
    items?: SurveyResponseItemOrderByRelationAggregateInput
  }

  export type SurveyResponseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SurveyResponseWhereInput | SurveyResponseWhereInput[]
    OR?: SurveyResponseWhereInput[]
    NOT?: SurveyResponseWhereInput | SurveyResponseWhereInput[]
    formId?: UuidFilter<"SurveyResponse"> | string
    countyId?: UuidNullableFilter<"SurveyResponse"> | string | null
    sourceLabel?: StringNullableFilter<"SurveyResponse"> | string | null
    submittedAt?: DateTimeFilter<"SurveyResponse"> | Date | string
    ipHash?: StringNullableFilter<"SurveyResponse"> | string | null
    userAgent?: StringNullableFilter<"SurveyResponse"> | string | null
    createdAt?: DateTimeFilter<"SurveyResponse"> | Date | string
    form?: XOR<SurveyFormScalarRelationFilter, SurveyFormWhereInput>
    county?: XOR<CountyNullableScalarRelationFilter, CountyWhereInput> | null
    items?: SurveyResponseItemListRelationFilter
  }, "id">

  export type SurveyResponseOrderByWithAggregationInput = {
    id?: SortOrder
    formId?: SortOrder
    countyId?: SortOrderInput | SortOrder
    sourceLabel?: SortOrderInput | SortOrder
    submittedAt?: SortOrder
    ipHash?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SurveyResponseCountOrderByAggregateInput
    _max?: SurveyResponseMaxOrderByAggregateInput
    _min?: SurveyResponseMinOrderByAggregateInput
  }

  export type SurveyResponseScalarWhereWithAggregatesInput = {
    AND?: SurveyResponseScalarWhereWithAggregatesInput | SurveyResponseScalarWhereWithAggregatesInput[]
    OR?: SurveyResponseScalarWhereWithAggregatesInput[]
    NOT?: SurveyResponseScalarWhereWithAggregatesInput | SurveyResponseScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"SurveyResponse"> | string
    formId?: UuidWithAggregatesFilter<"SurveyResponse"> | string
    countyId?: UuidNullableWithAggregatesFilter<"SurveyResponse"> | string | null
    sourceLabel?: StringNullableWithAggregatesFilter<"SurveyResponse"> | string | null
    submittedAt?: DateTimeWithAggregatesFilter<"SurveyResponse"> | Date | string
    ipHash?: StringNullableWithAggregatesFilter<"SurveyResponse"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"SurveyResponse"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SurveyResponse"> | Date | string
  }

  export type SurveyResponseItemWhereInput = {
    AND?: SurveyResponseItemWhereInput | SurveyResponseItemWhereInput[]
    OR?: SurveyResponseItemWhereInput[]
    NOT?: SurveyResponseItemWhereInput | SurveyResponseItemWhereInput[]
    id?: UuidFilter<"SurveyResponseItem"> | string
    responseId?: UuidFilter<"SurveyResponseItem"> | string
    questionId?: UuidFilter<"SurveyResponseItem"> | string
    valueText?: StringNullableFilter<"SurveyResponseItem"> | string | null
    valueNumber?: FloatNullableFilter<"SurveyResponseItem"> | number | null
    valueBoolean?: BoolNullableFilter<"SurveyResponseItem"> | boolean | null
    selectedOptionId?: UuidNullableFilter<"SurveyResponseItem"> | string | null
    mediaAssetId?: UuidNullableFilter<"SurveyResponseItem"> | string | null
    createdAt?: DateTimeFilter<"SurveyResponseItem"> | Date | string
    response?: XOR<SurveyResponseScalarRelationFilter, SurveyResponseWhereInput>
    question?: XOR<SurveyQuestionScalarRelationFilter, SurveyQuestionWhereInput>
    selectedOption?: XOR<SurveyQuestionOptionNullableScalarRelationFilter, SurveyQuestionOptionWhereInput> | null
    mediaAsset?: XOR<MediaAssetNullableScalarRelationFilter, MediaAssetWhereInput> | null
    multiSelectedOptions?: SurveyResponseItemOptionListRelationFilter
  }

  export type SurveyResponseItemOrderByWithRelationInput = {
    id?: SortOrder
    responseId?: SortOrder
    questionId?: SortOrder
    valueText?: SortOrderInput | SortOrder
    valueNumber?: SortOrderInput | SortOrder
    valueBoolean?: SortOrderInput | SortOrder
    selectedOptionId?: SortOrderInput | SortOrder
    mediaAssetId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    response?: SurveyResponseOrderByWithRelationInput
    question?: SurveyQuestionOrderByWithRelationInput
    selectedOption?: SurveyQuestionOptionOrderByWithRelationInput
    mediaAsset?: MediaAssetOrderByWithRelationInput
    multiSelectedOptions?: SurveyResponseItemOptionOrderByRelationAggregateInput
  }

  export type SurveyResponseItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SurveyResponseItemWhereInput | SurveyResponseItemWhereInput[]
    OR?: SurveyResponseItemWhereInput[]
    NOT?: SurveyResponseItemWhereInput | SurveyResponseItemWhereInput[]
    responseId?: UuidFilter<"SurveyResponseItem"> | string
    questionId?: UuidFilter<"SurveyResponseItem"> | string
    valueText?: StringNullableFilter<"SurveyResponseItem"> | string | null
    valueNumber?: FloatNullableFilter<"SurveyResponseItem"> | number | null
    valueBoolean?: BoolNullableFilter<"SurveyResponseItem"> | boolean | null
    selectedOptionId?: UuidNullableFilter<"SurveyResponseItem"> | string | null
    mediaAssetId?: UuidNullableFilter<"SurveyResponseItem"> | string | null
    createdAt?: DateTimeFilter<"SurveyResponseItem"> | Date | string
    response?: XOR<SurveyResponseScalarRelationFilter, SurveyResponseWhereInput>
    question?: XOR<SurveyQuestionScalarRelationFilter, SurveyQuestionWhereInput>
    selectedOption?: XOR<SurveyQuestionOptionNullableScalarRelationFilter, SurveyQuestionOptionWhereInput> | null
    mediaAsset?: XOR<MediaAssetNullableScalarRelationFilter, MediaAssetWhereInput> | null
    multiSelectedOptions?: SurveyResponseItemOptionListRelationFilter
  }, "id">

  export type SurveyResponseItemOrderByWithAggregationInput = {
    id?: SortOrder
    responseId?: SortOrder
    questionId?: SortOrder
    valueText?: SortOrderInput | SortOrder
    valueNumber?: SortOrderInput | SortOrder
    valueBoolean?: SortOrderInput | SortOrder
    selectedOptionId?: SortOrderInput | SortOrder
    mediaAssetId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SurveyResponseItemCountOrderByAggregateInput
    _avg?: SurveyResponseItemAvgOrderByAggregateInput
    _max?: SurveyResponseItemMaxOrderByAggregateInput
    _min?: SurveyResponseItemMinOrderByAggregateInput
    _sum?: SurveyResponseItemSumOrderByAggregateInput
  }

  export type SurveyResponseItemScalarWhereWithAggregatesInput = {
    AND?: SurveyResponseItemScalarWhereWithAggregatesInput | SurveyResponseItemScalarWhereWithAggregatesInput[]
    OR?: SurveyResponseItemScalarWhereWithAggregatesInput[]
    NOT?: SurveyResponseItemScalarWhereWithAggregatesInput | SurveyResponseItemScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"SurveyResponseItem"> | string
    responseId?: UuidWithAggregatesFilter<"SurveyResponseItem"> | string
    questionId?: UuidWithAggregatesFilter<"SurveyResponseItem"> | string
    valueText?: StringNullableWithAggregatesFilter<"SurveyResponseItem"> | string | null
    valueNumber?: FloatNullableWithAggregatesFilter<"SurveyResponseItem"> | number | null
    valueBoolean?: BoolNullableWithAggregatesFilter<"SurveyResponseItem"> | boolean | null
    selectedOptionId?: UuidNullableWithAggregatesFilter<"SurveyResponseItem"> | string | null
    mediaAssetId?: UuidNullableWithAggregatesFilter<"SurveyResponseItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SurveyResponseItem"> | Date | string
  }

  export type SurveyResponseItemOptionWhereInput = {
    AND?: SurveyResponseItemOptionWhereInput | SurveyResponseItemOptionWhereInput[]
    OR?: SurveyResponseItemOptionWhereInput[]
    NOT?: SurveyResponseItemOptionWhereInput | SurveyResponseItemOptionWhereInput[]
    id?: UuidFilter<"SurveyResponseItemOption"> | string
    responseItemId?: UuidFilter<"SurveyResponseItemOption"> | string
    optionId?: UuidFilter<"SurveyResponseItemOption"> | string
    createdAt?: DateTimeFilter<"SurveyResponseItemOption"> | Date | string
    responseItem?: XOR<SurveyResponseItemScalarRelationFilter, SurveyResponseItemWhereInput>
    option?: XOR<SurveyQuestionOptionScalarRelationFilter, SurveyQuestionOptionWhereInput>
  }

  export type SurveyResponseItemOptionOrderByWithRelationInput = {
    id?: SortOrder
    responseItemId?: SortOrder
    optionId?: SortOrder
    createdAt?: SortOrder
    responseItem?: SurveyResponseItemOrderByWithRelationInput
    option?: SurveyQuestionOptionOrderByWithRelationInput
  }

  export type SurveyResponseItemOptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    responseItemId_optionId?: SurveyResponseItemOptionResponseItemIdOptionIdCompoundUniqueInput
    AND?: SurveyResponseItemOptionWhereInput | SurveyResponseItemOptionWhereInput[]
    OR?: SurveyResponseItemOptionWhereInput[]
    NOT?: SurveyResponseItemOptionWhereInput | SurveyResponseItemOptionWhereInput[]
    responseItemId?: UuidFilter<"SurveyResponseItemOption"> | string
    optionId?: UuidFilter<"SurveyResponseItemOption"> | string
    createdAt?: DateTimeFilter<"SurveyResponseItemOption"> | Date | string
    responseItem?: XOR<SurveyResponseItemScalarRelationFilter, SurveyResponseItemWhereInput>
    option?: XOR<SurveyQuestionOptionScalarRelationFilter, SurveyQuestionOptionWhereInput>
  }, "id" | "responseItemId_optionId">

  export type SurveyResponseItemOptionOrderByWithAggregationInput = {
    id?: SortOrder
    responseItemId?: SortOrder
    optionId?: SortOrder
    createdAt?: SortOrder
    _count?: SurveyResponseItemOptionCountOrderByAggregateInput
    _max?: SurveyResponseItemOptionMaxOrderByAggregateInput
    _min?: SurveyResponseItemOptionMinOrderByAggregateInput
  }

  export type SurveyResponseItemOptionScalarWhereWithAggregatesInput = {
    AND?: SurveyResponseItemOptionScalarWhereWithAggregatesInput | SurveyResponseItemOptionScalarWhereWithAggregatesInput[]
    OR?: SurveyResponseItemOptionScalarWhereWithAggregatesInput[]
    NOT?: SurveyResponseItemOptionScalarWhereWithAggregatesInput | SurveyResponseItemOptionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"SurveyResponseItemOption"> | string
    responseItemId?: UuidWithAggregatesFilter<"SurveyResponseItemOption"> | string
    optionId?: UuidWithAggregatesFilter<"SurveyResponseItemOption"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SurveyResponseItemOption"> | Date | string
  }

  export type MediaAssetWhereInput = {
    AND?: MediaAssetWhereInput | MediaAssetWhereInput[]
    OR?: MediaAssetWhereInput[]
    NOT?: MediaAssetWhereInput | MediaAssetWhereInput[]
    id?: UuidFilter<"MediaAsset"> | string
    assetType?: EnumAssetTypeFilter<"MediaAsset"> | $Enums.AssetType
    storageProvider?: StringNullableFilter<"MediaAsset"> | string | null
    storageKey?: StringNullableFilter<"MediaAsset"> | string | null
    url?: StringNullableFilter<"MediaAsset"> | string | null
    mimeType?: StringNullableFilter<"MediaAsset"> | string | null
    sizeBytes?: IntNullableFilter<"MediaAsset"> | number | null
    durationMs?: IntNullableFilter<"MediaAsset"> | number | null
    createdAt?: DateTimeFilter<"MediaAsset"> | Date | string
    updatedAt?: DateTimeFilter<"MediaAsset"> | Date | string
    surveyResponseItems?: SurveyResponseItemListRelationFilter
    transcripts?: TranscriptListRelationFilter
    analyses?: AIAnalysisListRelationFilter
  }

  export type MediaAssetOrderByWithRelationInput = {
    id?: SortOrder
    assetType?: SortOrder
    storageProvider?: SortOrderInput | SortOrder
    storageKey?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    mimeType?: SortOrderInput | SortOrder
    sizeBytes?: SortOrderInput | SortOrder
    durationMs?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    surveyResponseItems?: SurveyResponseItemOrderByRelationAggregateInput
    transcripts?: TranscriptOrderByRelationAggregateInput
    analyses?: AIAnalysisOrderByRelationAggregateInput
  }

  export type MediaAssetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MediaAssetWhereInput | MediaAssetWhereInput[]
    OR?: MediaAssetWhereInput[]
    NOT?: MediaAssetWhereInput | MediaAssetWhereInput[]
    assetType?: EnumAssetTypeFilter<"MediaAsset"> | $Enums.AssetType
    storageProvider?: StringNullableFilter<"MediaAsset"> | string | null
    storageKey?: StringNullableFilter<"MediaAsset"> | string | null
    url?: StringNullableFilter<"MediaAsset"> | string | null
    mimeType?: StringNullableFilter<"MediaAsset"> | string | null
    sizeBytes?: IntNullableFilter<"MediaAsset"> | number | null
    durationMs?: IntNullableFilter<"MediaAsset"> | number | null
    createdAt?: DateTimeFilter<"MediaAsset"> | Date | string
    updatedAt?: DateTimeFilter<"MediaAsset"> | Date | string
    surveyResponseItems?: SurveyResponseItemListRelationFilter
    transcripts?: TranscriptListRelationFilter
    analyses?: AIAnalysisListRelationFilter
  }, "id">

  export type MediaAssetOrderByWithAggregationInput = {
    id?: SortOrder
    assetType?: SortOrder
    storageProvider?: SortOrderInput | SortOrder
    storageKey?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    mimeType?: SortOrderInput | SortOrder
    sizeBytes?: SortOrderInput | SortOrder
    durationMs?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MediaAssetCountOrderByAggregateInput
    _avg?: MediaAssetAvgOrderByAggregateInput
    _max?: MediaAssetMaxOrderByAggregateInput
    _min?: MediaAssetMinOrderByAggregateInput
    _sum?: MediaAssetSumOrderByAggregateInput
  }

  export type MediaAssetScalarWhereWithAggregatesInput = {
    AND?: MediaAssetScalarWhereWithAggregatesInput | MediaAssetScalarWhereWithAggregatesInput[]
    OR?: MediaAssetScalarWhereWithAggregatesInput[]
    NOT?: MediaAssetScalarWhereWithAggregatesInput | MediaAssetScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"MediaAsset"> | string
    assetType?: EnumAssetTypeWithAggregatesFilter<"MediaAsset"> | $Enums.AssetType
    storageProvider?: StringNullableWithAggregatesFilter<"MediaAsset"> | string | null
    storageKey?: StringNullableWithAggregatesFilter<"MediaAsset"> | string | null
    url?: StringNullableWithAggregatesFilter<"MediaAsset"> | string | null
    mimeType?: StringNullableWithAggregatesFilter<"MediaAsset"> | string | null
    sizeBytes?: IntNullableWithAggregatesFilter<"MediaAsset"> | number | null
    durationMs?: IntNullableWithAggregatesFilter<"MediaAsset"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"MediaAsset"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MediaAsset"> | Date | string
  }

  export type TranscriptWhereInput = {
    AND?: TranscriptWhereInput | TranscriptWhereInput[]
    OR?: TranscriptWhereInput[]
    NOT?: TranscriptWhereInput | TranscriptWhereInput[]
    id?: UuidFilter<"Transcript"> | string
    mediaAssetId?: UuidFilter<"Transcript"> | string
    provider?: StringNullableFilter<"Transcript"> | string | null
    providerVersion?: StringNullableFilter<"Transcript"> | string | null
    language?: StringNullableFilter<"Transcript"> | string | null
    transcriptText?: StringFilter<"Transcript"> | string
    segmentsJson?: JsonNullableFilter<"Transcript">
    createdAt?: DateTimeFilter<"Transcript"> | Date | string
    mediaAsset?: XOR<MediaAssetScalarRelationFilter, MediaAssetWhereInput>
    analyses?: AIAnalysisListRelationFilter
  }

  export type TranscriptOrderByWithRelationInput = {
    id?: SortOrder
    mediaAssetId?: SortOrder
    provider?: SortOrderInput | SortOrder
    providerVersion?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    transcriptText?: SortOrder
    segmentsJson?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    mediaAsset?: MediaAssetOrderByWithRelationInput
    analyses?: AIAnalysisOrderByRelationAggregateInput
  }

  export type TranscriptWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TranscriptWhereInput | TranscriptWhereInput[]
    OR?: TranscriptWhereInput[]
    NOT?: TranscriptWhereInput | TranscriptWhereInput[]
    mediaAssetId?: UuidFilter<"Transcript"> | string
    provider?: StringNullableFilter<"Transcript"> | string | null
    providerVersion?: StringNullableFilter<"Transcript"> | string | null
    language?: StringNullableFilter<"Transcript"> | string | null
    transcriptText?: StringFilter<"Transcript"> | string
    segmentsJson?: JsonNullableFilter<"Transcript">
    createdAt?: DateTimeFilter<"Transcript"> | Date | string
    mediaAsset?: XOR<MediaAssetScalarRelationFilter, MediaAssetWhereInput>
    analyses?: AIAnalysisListRelationFilter
  }, "id">

  export type TranscriptOrderByWithAggregationInput = {
    id?: SortOrder
    mediaAssetId?: SortOrder
    provider?: SortOrderInput | SortOrder
    providerVersion?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    transcriptText?: SortOrder
    segmentsJson?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TranscriptCountOrderByAggregateInput
    _max?: TranscriptMaxOrderByAggregateInput
    _min?: TranscriptMinOrderByAggregateInput
  }

  export type TranscriptScalarWhereWithAggregatesInput = {
    AND?: TranscriptScalarWhereWithAggregatesInput | TranscriptScalarWhereWithAggregatesInput[]
    OR?: TranscriptScalarWhereWithAggregatesInput[]
    NOT?: TranscriptScalarWhereWithAggregatesInput | TranscriptScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Transcript"> | string
    mediaAssetId?: UuidWithAggregatesFilter<"Transcript"> | string
    provider?: StringNullableWithAggregatesFilter<"Transcript"> | string | null
    providerVersion?: StringNullableWithAggregatesFilter<"Transcript"> | string | null
    language?: StringNullableWithAggregatesFilter<"Transcript"> | string | null
    transcriptText?: StringWithAggregatesFilter<"Transcript"> | string
    segmentsJson?: JsonNullableWithAggregatesFilter<"Transcript">
    createdAt?: DateTimeWithAggregatesFilter<"Transcript"> | Date | string
  }

  export type AIAnalysisWhereInput = {
    AND?: AIAnalysisWhereInput | AIAnalysisWhereInput[]
    OR?: AIAnalysisWhereInput[]
    NOT?: AIAnalysisWhereInput | AIAnalysisWhereInput[]
    id?: UuidFilter<"AIAnalysis"> | string
    transcriptId?: UuidNullableFilter<"AIAnalysis"> | string | null
    mediaAssetId?: UuidNullableFilter<"AIAnalysis"> | string | null
    aiRunId?: UuidNullableFilter<"AIAnalysis"> | string | null
    analysisType?: EnumAnalysisTypeFilter<"AIAnalysis"> | $Enums.AnalysisType
    contentJson?: JsonFilter<"AIAnalysis">
    notes?: StringNullableFilter<"AIAnalysis"> | string | null
    createdAt?: DateTimeFilter<"AIAnalysis"> | Date | string
    transcript?: XOR<TranscriptNullableScalarRelationFilter, TranscriptWhereInput> | null
    mediaAsset?: XOR<MediaAssetNullableScalarRelationFilter, MediaAssetWhereInput> | null
    aiRun?: XOR<AIRunNullableScalarRelationFilter, AIRunWhereInput> | null
  }

  export type AIAnalysisOrderByWithRelationInput = {
    id?: SortOrder
    transcriptId?: SortOrderInput | SortOrder
    mediaAssetId?: SortOrderInput | SortOrder
    aiRunId?: SortOrderInput | SortOrder
    analysisType?: SortOrder
    contentJson?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    transcript?: TranscriptOrderByWithRelationInput
    mediaAsset?: MediaAssetOrderByWithRelationInput
    aiRun?: AIRunOrderByWithRelationInput
  }

  export type AIAnalysisWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AIAnalysisWhereInput | AIAnalysisWhereInput[]
    OR?: AIAnalysisWhereInput[]
    NOT?: AIAnalysisWhereInput | AIAnalysisWhereInput[]
    transcriptId?: UuidNullableFilter<"AIAnalysis"> | string | null
    mediaAssetId?: UuidNullableFilter<"AIAnalysis"> | string | null
    aiRunId?: UuidNullableFilter<"AIAnalysis"> | string | null
    analysisType?: EnumAnalysisTypeFilter<"AIAnalysis"> | $Enums.AnalysisType
    contentJson?: JsonFilter<"AIAnalysis">
    notes?: StringNullableFilter<"AIAnalysis"> | string | null
    createdAt?: DateTimeFilter<"AIAnalysis"> | Date | string
    transcript?: XOR<TranscriptNullableScalarRelationFilter, TranscriptWhereInput> | null
    mediaAsset?: XOR<MediaAssetNullableScalarRelationFilter, MediaAssetWhereInput> | null
    aiRun?: XOR<AIRunNullableScalarRelationFilter, AIRunWhereInput> | null
  }, "id">

  export type AIAnalysisOrderByWithAggregationInput = {
    id?: SortOrder
    transcriptId?: SortOrderInput | SortOrder
    mediaAssetId?: SortOrderInput | SortOrder
    aiRunId?: SortOrderInput | SortOrder
    analysisType?: SortOrder
    contentJson?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AIAnalysisCountOrderByAggregateInput
    _max?: AIAnalysisMaxOrderByAggregateInput
    _min?: AIAnalysisMinOrderByAggregateInput
  }

  export type AIAnalysisScalarWhereWithAggregatesInput = {
    AND?: AIAnalysisScalarWhereWithAggregatesInput | AIAnalysisScalarWhereWithAggregatesInput[]
    OR?: AIAnalysisScalarWhereWithAggregatesInput[]
    NOT?: AIAnalysisScalarWhereWithAggregatesInput | AIAnalysisScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"AIAnalysis"> | string
    transcriptId?: UuidNullableWithAggregatesFilter<"AIAnalysis"> | string | null
    mediaAssetId?: UuidNullableWithAggregatesFilter<"AIAnalysis"> | string | null
    aiRunId?: UuidNullableWithAggregatesFilter<"AIAnalysis"> | string | null
    analysisType?: EnumAnalysisTypeWithAggregatesFilter<"AIAnalysis"> | $Enums.AnalysisType
    contentJson?: JsonWithAggregatesFilter<"AIAnalysis">
    notes?: StringNullableWithAggregatesFilter<"AIAnalysis"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AIAnalysis"> | Date | string
  }

  export type VoterRegistrationWhereInput = {
    AND?: VoterRegistrationWhereInput | VoterRegistrationWhereInput[]
    OR?: VoterRegistrationWhereInput[]
    NOT?: VoterRegistrationWhereInput | VoterRegistrationWhereInput[]
    id?: UuidFilter<"VoterRegistration"> | string
    stateVoterId?: StringFilter<"VoterRegistration"> | string
    firstName?: StringNullableFilter<"VoterRegistration"> | string | null
    middleName?: StringNullableFilter<"VoterRegistration"> | string | null
    lastName?: StringNullableFilter<"VoterRegistration"> | string | null
    suffix?: StringNullableFilter<"VoterRegistration"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"VoterRegistration"> | Date | string | null
    addressLine1?: StringNullableFilter<"VoterRegistration"> | string | null
    addressLine2?: StringNullableFilter<"VoterRegistration"> | string | null
    city?: StringNullableFilter<"VoterRegistration"> | string | null
    state?: StringNullableFilter<"VoterRegistration"> | string | null
    zip?: StringNullableFilter<"VoterRegistration"> | string | null
    party?: StringNullableFilter<"VoterRegistration"> | string | null
    status?: StringNullableFilter<"VoterRegistration"> | string | null
    createdAt?: DateTimeFilter<"VoterRegistration"> | Date | string
    updatedAt?: DateTimeFilter<"VoterRegistration"> | Date | string
    voteHistory?: VoteHistoryListRelationFilter
    segmentMemberships?: SegmentMemberListRelationFilter
  }

  export type VoterRegistrationOrderByWithRelationInput = {
    id?: SortOrder
    stateVoterId?: SortOrder
    firstName?: SortOrderInput | SortOrder
    middleName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    suffix?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    addressLine1?: SortOrderInput | SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    zip?: SortOrderInput | SortOrder
    party?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    voteHistory?: VoteHistoryOrderByRelationAggregateInput
    segmentMemberships?: SegmentMemberOrderByRelationAggregateInput
  }

  export type VoterRegistrationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    stateVoterId?: string
    AND?: VoterRegistrationWhereInput | VoterRegistrationWhereInput[]
    OR?: VoterRegistrationWhereInput[]
    NOT?: VoterRegistrationWhereInput | VoterRegistrationWhereInput[]
    firstName?: StringNullableFilter<"VoterRegistration"> | string | null
    middleName?: StringNullableFilter<"VoterRegistration"> | string | null
    lastName?: StringNullableFilter<"VoterRegistration"> | string | null
    suffix?: StringNullableFilter<"VoterRegistration"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"VoterRegistration"> | Date | string | null
    addressLine1?: StringNullableFilter<"VoterRegistration"> | string | null
    addressLine2?: StringNullableFilter<"VoterRegistration"> | string | null
    city?: StringNullableFilter<"VoterRegistration"> | string | null
    state?: StringNullableFilter<"VoterRegistration"> | string | null
    zip?: StringNullableFilter<"VoterRegistration"> | string | null
    party?: StringNullableFilter<"VoterRegistration"> | string | null
    status?: StringNullableFilter<"VoterRegistration"> | string | null
    createdAt?: DateTimeFilter<"VoterRegistration"> | Date | string
    updatedAt?: DateTimeFilter<"VoterRegistration"> | Date | string
    voteHistory?: VoteHistoryListRelationFilter
    segmentMemberships?: SegmentMemberListRelationFilter
  }, "id" | "stateVoterId">

  export type VoterRegistrationOrderByWithAggregationInput = {
    id?: SortOrder
    stateVoterId?: SortOrder
    firstName?: SortOrderInput | SortOrder
    middleName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    suffix?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    addressLine1?: SortOrderInput | SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    zip?: SortOrderInput | SortOrder
    party?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VoterRegistrationCountOrderByAggregateInput
    _max?: VoterRegistrationMaxOrderByAggregateInput
    _min?: VoterRegistrationMinOrderByAggregateInput
  }

  export type VoterRegistrationScalarWhereWithAggregatesInput = {
    AND?: VoterRegistrationScalarWhereWithAggregatesInput | VoterRegistrationScalarWhereWithAggregatesInput[]
    OR?: VoterRegistrationScalarWhereWithAggregatesInput[]
    NOT?: VoterRegistrationScalarWhereWithAggregatesInput | VoterRegistrationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"VoterRegistration"> | string
    stateVoterId?: StringWithAggregatesFilter<"VoterRegistration"> | string
    firstName?: StringNullableWithAggregatesFilter<"VoterRegistration"> | string | null
    middleName?: StringNullableWithAggregatesFilter<"VoterRegistration"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"VoterRegistration"> | string | null
    suffix?: StringNullableWithAggregatesFilter<"VoterRegistration"> | string | null
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"VoterRegistration"> | Date | string | null
    addressLine1?: StringNullableWithAggregatesFilter<"VoterRegistration"> | string | null
    addressLine2?: StringNullableWithAggregatesFilter<"VoterRegistration"> | string | null
    city?: StringNullableWithAggregatesFilter<"VoterRegistration"> | string | null
    state?: StringNullableWithAggregatesFilter<"VoterRegistration"> | string | null
    zip?: StringNullableWithAggregatesFilter<"VoterRegistration"> | string | null
    party?: StringNullableWithAggregatesFilter<"VoterRegistration"> | string | null
    status?: StringNullableWithAggregatesFilter<"VoterRegistration"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"VoterRegistration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VoterRegistration"> | Date | string
  }

  export type VoteHistoryWhereInput = {
    AND?: VoteHistoryWhereInput | VoteHistoryWhereInput[]
    OR?: VoteHistoryWhereInput[]
    NOT?: VoteHistoryWhereInput | VoteHistoryWhereInput[]
    id?: UuidFilter<"VoteHistory"> | string
    voterId?: UuidFilter<"VoteHistory"> | string
    electionDate?: DateTimeNullableFilter<"VoteHistory"> | Date | string | null
    electionName?: StringNullableFilter<"VoteHistory"> | string | null
    voteType?: StringNullableFilter<"VoteHistory"> | string | null
    createdAt?: DateTimeFilter<"VoteHistory"> | Date | string
    voter?: XOR<VoterRegistrationScalarRelationFilter, VoterRegistrationWhereInput>
  }

  export type VoteHistoryOrderByWithRelationInput = {
    id?: SortOrder
    voterId?: SortOrder
    electionDate?: SortOrderInput | SortOrder
    electionName?: SortOrderInput | SortOrder
    voteType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    voter?: VoterRegistrationOrderByWithRelationInput
  }

  export type VoteHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VoteHistoryWhereInput | VoteHistoryWhereInput[]
    OR?: VoteHistoryWhereInput[]
    NOT?: VoteHistoryWhereInput | VoteHistoryWhereInput[]
    voterId?: UuidFilter<"VoteHistory"> | string
    electionDate?: DateTimeNullableFilter<"VoteHistory"> | Date | string | null
    electionName?: StringNullableFilter<"VoteHistory"> | string | null
    voteType?: StringNullableFilter<"VoteHistory"> | string | null
    createdAt?: DateTimeFilter<"VoteHistory"> | Date | string
    voter?: XOR<VoterRegistrationScalarRelationFilter, VoterRegistrationWhereInput>
  }, "id">

  export type VoteHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    voterId?: SortOrder
    electionDate?: SortOrderInput | SortOrder
    electionName?: SortOrderInput | SortOrder
    voteType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: VoteHistoryCountOrderByAggregateInput
    _max?: VoteHistoryMaxOrderByAggregateInput
    _min?: VoteHistoryMinOrderByAggregateInput
  }

  export type VoteHistoryScalarWhereWithAggregatesInput = {
    AND?: VoteHistoryScalarWhereWithAggregatesInput | VoteHistoryScalarWhereWithAggregatesInput[]
    OR?: VoteHistoryScalarWhereWithAggregatesInput[]
    NOT?: VoteHistoryScalarWhereWithAggregatesInput | VoteHistoryScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"VoteHistory"> | string
    voterId?: UuidWithAggregatesFilter<"VoteHistory"> | string
    electionDate?: DateTimeNullableWithAggregatesFilter<"VoteHistory"> | Date | string | null
    electionName?: StringNullableWithAggregatesFilter<"VoteHistory"> | string | null
    voteType?: StringNullableWithAggregatesFilter<"VoteHistory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"VoteHistory"> | Date | string
  }

  export type SegmentWhereInput = {
    AND?: SegmentWhereInput | SegmentWhereInput[]
    OR?: SegmentWhereInput[]
    NOT?: SegmentWhereInput | SegmentWhereInput[]
    id?: UuidFilter<"Segment"> | string
    name?: StringFilter<"Segment"> | string
    slug?: StringFilter<"Segment"> | string
    description?: StringNullableFilter<"Segment"> | string | null
    createdAt?: DateTimeFilter<"Segment"> | Date | string
    updatedAt?: DateTimeFilter<"Segment"> | Date | string
    members?: SegmentMemberListRelationFilter
  }

  export type SegmentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    members?: SegmentMemberOrderByRelationAggregateInput
  }

  export type SegmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: SegmentWhereInput | SegmentWhereInput[]
    OR?: SegmentWhereInput[]
    NOT?: SegmentWhereInput | SegmentWhereInput[]
    name?: StringFilter<"Segment"> | string
    description?: StringNullableFilter<"Segment"> | string | null
    createdAt?: DateTimeFilter<"Segment"> | Date | string
    updatedAt?: DateTimeFilter<"Segment"> | Date | string
    members?: SegmentMemberListRelationFilter
  }, "id" | "slug">

  export type SegmentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SegmentCountOrderByAggregateInput
    _max?: SegmentMaxOrderByAggregateInput
    _min?: SegmentMinOrderByAggregateInput
  }

  export type SegmentScalarWhereWithAggregatesInput = {
    AND?: SegmentScalarWhereWithAggregatesInput | SegmentScalarWhereWithAggregatesInput[]
    OR?: SegmentScalarWhereWithAggregatesInput[]
    NOT?: SegmentScalarWhereWithAggregatesInput | SegmentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Segment"> | string
    name?: StringWithAggregatesFilter<"Segment"> | string
    slug?: StringWithAggregatesFilter<"Segment"> | string
    description?: StringNullableWithAggregatesFilter<"Segment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Segment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Segment"> | Date | string
  }

  export type SegmentMemberWhereInput = {
    AND?: SegmentMemberWhereInput | SegmentMemberWhereInput[]
    OR?: SegmentMemberWhereInput[]
    NOT?: SegmentMemberWhereInput | SegmentMemberWhereInput[]
    id?: UuidFilter<"SegmentMember"> | string
    segmentId?: UuidFilter<"SegmentMember"> | string
    voterId?: UuidFilter<"SegmentMember"> | string
    createdAt?: DateTimeFilter<"SegmentMember"> | Date | string
    segment?: XOR<SegmentScalarRelationFilter, SegmentWhereInput>
    voter?: XOR<VoterRegistrationScalarRelationFilter, VoterRegistrationWhereInput>
  }

  export type SegmentMemberOrderByWithRelationInput = {
    id?: SortOrder
    segmentId?: SortOrder
    voterId?: SortOrder
    createdAt?: SortOrder
    segment?: SegmentOrderByWithRelationInput
    voter?: VoterRegistrationOrderByWithRelationInput
  }

  export type SegmentMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    segmentId_voterId?: SegmentMemberSegmentIdVoterIdCompoundUniqueInput
    AND?: SegmentMemberWhereInput | SegmentMemberWhereInput[]
    OR?: SegmentMemberWhereInput[]
    NOT?: SegmentMemberWhereInput | SegmentMemberWhereInput[]
    segmentId?: UuidFilter<"SegmentMember"> | string
    voterId?: UuidFilter<"SegmentMember"> | string
    createdAt?: DateTimeFilter<"SegmentMember"> | Date | string
    segment?: XOR<SegmentScalarRelationFilter, SegmentWhereInput>
    voter?: XOR<VoterRegistrationScalarRelationFilter, VoterRegistrationWhereInput>
  }, "id" | "segmentId_voterId">

  export type SegmentMemberOrderByWithAggregationInput = {
    id?: SortOrder
    segmentId?: SortOrder
    voterId?: SortOrder
    createdAt?: SortOrder
    _count?: SegmentMemberCountOrderByAggregateInput
    _max?: SegmentMemberMaxOrderByAggregateInput
    _min?: SegmentMemberMinOrderByAggregateInput
  }

  export type SegmentMemberScalarWhereWithAggregatesInput = {
    AND?: SegmentMemberScalarWhereWithAggregatesInput | SegmentMemberScalarWhereWithAggregatesInput[]
    OR?: SegmentMemberScalarWhereWithAggregatesInput[]
    NOT?: SegmentMemberScalarWhereWithAggregatesInput | SegmentMemberScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"SegmentMember"> | string
    segmentId?: UuidWithAggregatesFilter<"SegmentMember"> | string
    voterId?: UuidWithAggregatesFilter<"SegmentMember"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SegmentMember"> | Date | string
  }

  export type ImportJobWhereInput = {
    AND?: ImportJobWhereInput | ImportJobWhereInput[]
    OR?: ImportJobWhereInput[]
    NOT?: ImportJobWhereInput | ImportJobWhereInput[]
    id?: UuidFilter<"ImportJob"> | string
    kind?: EnumImportJobKindFilter<"ImportJob"> | $Enums.ImportJobKind
    status?: EnumImportJobStatusFilter<"ImportJob"> | $Enums.ImportJobStatus
    fileName?: StringNullableFilter<"ImportJob"> | string | null
    fileHash?: StringNullableFilter<"ImportJob"> | string | null
    rowCount?: IntNullableFilter<"ImportJob"> | number | null
    startedAt?: DateTimeNullableFilter<"ImportJob"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"ImportJob"> | Date | string | null
    errorText?: StringNullableFilter<"ImportJob"> | string | null
    createdAt?: DateTimeFilter<"ImportJob"> | Date | string
    auditLogs?: AuditLogListRelationFilter
  }

  export type ImportJobOrderByWithRelationInput = {
    id?: SortOrder
    kind?: SortOrder
    status?: SortOrder
    fileName?: SortOrderInput | SortOrder
    fileHash?: SortOrderInput | SortOrder
    rowCount?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    errorText?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    auditLogs?: AuditLogOrderByRelationAggregateInput
  }

  export type ImportJobWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ImportJobWhereInput | ImportJobWhereInput[]
    OR?: ImportJobWhereInput[]
    NOT?: ImportJobWhereInput | ImportJobWhereInput[]
    kind?: EnumImportJobKindFilter<"ImportJob"> | $Enums.ImportJobKind
    status?: EnumImportJobStatusFilter<"ImportJob"> | $Enums.ImportJobStatus
    fileName?: StringNullableFilter<"ImportJob"> | string | null
    fileHash?: StringNullableFilter<"ImportJob"> | string | null
    rowCount?: IntNullableFilter<"ImportJob"> | number | null
    startedAt?: DateTimeNullableFilter<"ImportJob"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"ImportJob"> | Date | string | null
    errorText?: StringNullableFilter<"ImportJob"> | string | null
    createdAt?: DateTimeFilter<"ImportJob"> | Date | string
    auditLogs?: AuditLogListRelationFilter
  }, "id">

  export type ImportJobOrderByWithAggregationInput = {
    id?: SortOrder
    kind?: SortOrder
    status?: SortOrder
    fileName?: SortOrderInput | SortOrder
    fileHash?: SortOrderInput | SortOrder
    rowCount?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    errorText?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ImportJobCountOrderByAggregateInput
    _avg?: ImportJobAvgOrderByAggregateInput
    _max?: ImportJobMaxOrderByAggregateInput
    _min?: ImportJobMinOrderByAggregateInput
    _sum?: ImportJobSumOrderByAggregateInput
  }

  export type ImportJobScalarWhereWithAggregatesInput = {
    AND?: ImportJobScalarWhereWithAggregatesInput | ImportJobScalarWhereWithAggregatesInput[]
    OR?: ImportJobScalarWhereWithAggregatesInput[]
    NOT?: ImportJobScalarWhereWithAggregatesInput | ImportJobScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ImportJob"> | string
    kind?: EnumImportJobKindWithAggregatesFilter<"ImportJob"> | $Enums.ImportJobKind
    status?: EnumImportJobStatusWithAggregatesFilter<"ImportJob"> | $Enums.ImportJobStatus
    fileName?: StringNullableWithAggregatesFilter<"ImportJob"> | string | null
    fileHash?: StringNullableWithAggregatesFilter<"ImportJob"> | string | null
    rowCount?: IntNullableWithAggregatesFilter<"ImportJob"> | number | null
    startedAt?: DateTimeNullableWithAggregatesFilter<"ImportJob"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"ImportJob"> | Date | string | null
    errorText?: StringNullableWithAggregatesFilter<"ImportJob"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ImportJob"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: UuidFilter<"AuditLog"> | string
    actorLabel?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringNullableFilter<"AuditLog"> | string | null
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    metadataJson?: JsonNullableFilter<"AuditLog">
    importJobId?: UuidNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    importJob?: XOR<ImportJobNullableScalarRelationFilter, ImportJobWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    actorLabel?: SortOrderInput | SortOrder
    action?: SortOrder
    entityType?: SortOrderInput | SortOrder
    entityId?: SortOrderInput | SortOrder
    metadataJson?: SortOrderInput | SortOrder
    importJobId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    importJob?: ImportJobOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    actorLabel?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringNullableFilter<"AuditLog"> | string | null
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    metadataJson?: JsonNullableFilter<"AuditLog">
    importJobId?: UuidNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    importJob?: XOR<ImportJobNullableScalarRelationFilter, ImportJobWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    actorLabel?: SortOrderInput | SortOrder
    action?: SortOrder
    entityType?: SortOrderInput | SortOrder
    entityId?: SortOrderInput | SortOrder
    metadataJson?: SortOrderInput | SortOrder
    importJobId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"AuditLog"> | string
    actorLabel?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    entityType?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    entityId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    metadataJson?: JsonNullableWithAggregatesFilter<"AuditLog">
    importJobId?: UuidNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type CountyCreateInput = {
    id?: string
    name: string
    slug: string
    fipsCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blueprintSections?: BlueprintSectionCreateNestedManyWithoutCountyInput
    quotes?: QuoteCreateNestedManyWithoutCountyInput
    assets?: AssetCreateNestedManyWithoutCountyInput
    countyIssues?: CountyIssueCreateNestedManyWithoutCountyInput
    censusMetrics?: CensusMetricCreateNestedManyWithoutCountyInput
    blsMetrics?: BLSMetricCreateNestedManyWithoutCountyInput
    civicsOfficials?: CivicsOfficialCreateNestedManyWithoutCountyInput
    electionResults?: ElectionResultCreateNestedManyWithoutCountyInput
    surveyForms?: SurveyFormCreateNestedManyWithoutCountyInput
    surveyResponses?: SurveyResponseCreateNestedManyWithoutCountyInput
    aiOutputScopes?: AIOutputScopeCreateNestedManyWithoutCountyInput
    sourceLinks?: SourceDocumentLinkCreateNestedManyWithoutCountyInput
  }

  export type CountyUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    fipsCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blueprintSections?: BlueprintSectionUncheckedCreateNestedManyWithoutCountyInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutCountyInput
    assets?: AssetUncheckedCreateNestedManyWithoutCountyInput
    countyIssues?: CountyIssueUncheckedCreateNestedManyWithoutCountyInput
    censusMetrics?: CensusMetricUncheckedCreateNestedManyWithoutCountyInput
    blsMetrics?: BLSMetricUncheckedCreateNestedManyWithoutCountyInput
    civicsOfficials?: CivicsOfficialUncheckedCreateNestedManyWithoutCountyInput
    electionResults?: ElectionResultUncheckedCreateNestedManyWithoutCountyInput
    surveyForms?: SurveyFormUncheckedCreateNestedManyWithoutCountyInput
    surveyResponses?: SurveyResponseUncheckedCreateNestedManyWithoutCountyInput
    aiOutputScopes?: AIOutputScopeUncheckedCreateNestedManyWithoutCountyInput
    sourceLinks?: SourceDocumentLinkUncheckedCreateNestedManyWithoutCountyInput
  }

  export type CountyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fipsCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blueprintSections?: BlueprintSectionUpdateManyWithoutCountyNestedInput
    quotes?: QuoteUpdateManyWithoutCountyNestedInput
    assets?: AssetUpdateManyWithoutCountyNestedInput
    countyIssues?: CountyIssueUpdateManyWithoutCountyNestedInput
    censusMetrics?: CensusMetricUpdateManyWithoutCountyNestedInput
    blsMetrics?: BLSMetricUpdateManyWithoutCountyNestedInput
    civicsOfficials?: CivicsOfficialUpdateManyWithoutCountyNestedInput
    electionResults?: ElectionResultUpdateManyWithoutCountyNestedInput
    surveyForms?: SurveyFormUpdateManyWithoutCountyNestedInput
    surveyResponses?: SurveyResponseUpdateManyWithoutCountyNestedInput
    aiOutputScopes?: AIOutputScopeUpdateManyWithoutCountyNestedInput
    sourceLinks?: SourceDocumentLinkUpdateManyWithoutCountyNestedInput
  }

  export type CountyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fipsCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blueprintSections?: BlueprintSectionUncheckedUpdateManyWithoutCountyNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutCountyNestedInput
    assets?: AssetUncheckedUpdateManyWithoutCountyNestedInput
    countyIssues?: CountyIssueUncheckedUpdateManyWithoutCountyNestedInput
    censusMetrics?: CensusMetricUncheckedUpdateManyWithoutCountyNestedInput
    blsMetrics?: BLSMetricUncheckedUpdateManyWithoutCountyNestedInput
    civicsOfficials?: CivicsOfficialUncheckedUpdateManyWithoutCountyNestedInput
    electionResults?: ElectionResultUncheckedUpdateManyWithoutCountyNestedInput
    surveyForms?: SurveyFormUncheckedUpdateManyWithoutCountyNestedInput
    surveyResponses?: SurveyResponseUncheckedUpdateManyWithoutCountyNestedInput
    aiOutputScopes?: AIOutputScopeUncheckedUpdateManyWithoutCountyNestedInput
    sourceLinks?: SourceDocumentLinkUncheckedUpdateManyWithoutCountyNestedInput
  }

  export type CountyCreateManyInput = {
    id?: string
    name: string
    slug: string
    fipsCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CountyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fipsCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fipsCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IssueCreateInput = {
    id?: string
    name: string
    slug: string
    summary?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    countyIssues?: CountyIssueCreateNestedManyWithoutIssueInput
    blueprintSections?: BlueprintSectionCreateNestedManyWithoutIssueInput
    quotes?: QuoteCreateNestedManyWithoutIssueInput
    assets?: AssetCreateNestedManyWithoutIssueInput
    aiOutputScopes?: AIOutputScopeCreateNestedManyWithoutIssueInput
    sourceLinks?: SourceDocumentLinkCreateNestedManyWithoutIssueInput
  }

  export type IssueUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    summary?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    countyIssues?: CountyIssueUncheckedCreateNestedManyWithoutIssueInput
    blueprintSections?: BlueprintSectionUncheckedCreateNestedManyWithoutIssueInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutIssueInput
    assets?: AssetUncheckedCreateNestedManyWithoutIssueInput
    aiOutputScopes?: AIOutputScopeUncheckedCreateNestedManyWithoutIssueInput
    sourceLinks?: SourceDocumentLinkUncheckedCreateNestedManyWithoutIssueInput
  }

  export type IssueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    countyIssues?: CountyIssueUpdateManyWithoutIssueNestedInput
    blueprintSections?: BlueprintSectionUpdateManyWithoutIssueNestedInput
    quotes?: QuoteUpdateManyWithoutIssueNestedInput
    assets?: AssetUpdateManyWithoutIssueNestedInput
    aiOutputScopes?: AIOutputScopeUpdateManyWithoutIssueNestedInput
    sourceLinks?: SourceDocumentLinkUpdateManyWithoutIssueNestedInput
  }

  export type IssueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    countyIssues?: CountyIssueUncheckedUpdateManyWithoutIssueNestedInput
    blueprintSections?: BlueprintSectionUncheckedUpdateManyWithoutIssueNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutIssueNestedInput
    assets?: AssetUncheckedUpdateManyWithoutIssueNestedInput
    aiOutputScopes?: AIOutputScopeUncheckedUpdateManyWithoutIssueNestedInput
    sourceLinks?: SourceDocumentLinkUncheckedUpdateManyWithoutIssueNestedInput
  }

  export type IssueCreateManyInput = {
    id?: string
    name: string
    slug: string
    summary?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IssueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IssueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountyIssueCreateInput = {
    id?: string
    featured?: boolean
    sortOrder?: number | null
    createdAt?: Date | string
    county: CountyCreateNestedOneWithoutCountyIssuesInput
    issue: IssueCreateNestedOneWithoutCountyIssuesInput
  }

  export type CountyIssueUncheckedCreateInput = {
    id?: string
    countyId: string
    issueId: string
    featured?: boolean
    sortOrder?: number | null
    createdAt?: Date | string
  }

  export type CountyIssueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    county?: CountyUpdateOneRequiredWithoutCountyIssuesNestedInput
    issue?: IssueUpdateOneRequiredWithoutCountyIssuesNestedInput
  }

  export type CountyIssueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    countyId?: StringFieldUpdateOperationsInput | string
    issueId?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountyIssueCreateManyInput = {
    id?: string
    countyId: string
    issueId: string
    featured?: boolean
    sortOrder?: number | null
    createdAt?: Date | string
  }

  export type CountyIssueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountyIssueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    countyId?: StringFieldUpdateOperationsInput | string
    issueId?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlueprintSectionCreateInput = {
    id?: string
    slug: string
    title: string
    bodyMd: string
    sortOrder?: number | null
    isPinned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    county?: CountyCreateNestedOneWithoutBlueprintSectionsInput
    issue?: IssueCreateNestedOneWithoutBlueprintSectionsInput
    sourceLinks?: SourceDocumentLinkCreateNestedManyWithoutBlueprintSectionInput
  }

  export type BlueprintSectionUncheckedCreateInput = {
    id?: string
    slug: string
    title: string
    bodyMd: string
    countyId?: string | null
    issueId?: string | null
    sortOrder?: number | null
    isPinned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceLinks?: SourceDocumentLinkUncheckedCreateNestedManyWithoutBlueprintSectionInput
  }

  export type BlueprintSectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    bodyMd?: StringFieldUpdateOperationsInput | string
    sortOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    county?: CountyUpdateOneWithoutBlueprintSectionsNestedInput
    issue?: IssueUpdateOneWithoutBlueprintSectionsNestedInput
    sourceLinks?: SourceDocumentLinkUpdateManyWithoutBlueprintSectionNestedInput
  }

  export type BlueprintSectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    bodyMd?: StringFieldUpdateOperationsInput | string
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    issueId?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceLinks?: SourceDocumentLinkUncheckedUpdateManyWithoutBlueprintSectionNestedInput
  }

  export type BlueprintSectionCreateManyInput = {
    id?: string
    slug: string
    title: string
    bodyMd: string
    countyId?: string | null
    issueId?: string | null
    sortOrder?: number | null
    isPinned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlueprintSectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    bodyMd?: StringFieldUpdateOperationsInput | string
    sortOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlueprintSectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    bodyMd?: StringFieldUpdateOperationsInput | string
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    issueId?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteCreateInput = {
    id?: string
    text: string
    attributionLabel?: string | null
    sourceNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    county: CountyCreateNestedOneWithoutQuotesInput
    issue?: IssueCreateNestedOneWithoutQuotesInput
    sourceLinks?: SourceDocumentLinkCreateNestedManyWithoutQuoteInput
  }

  export type QuoteUncheckedCreateInput = {
    id?: string
    text: string
    attributionLabel?: string | null
    countyId: string
    issueId?: string | null
    sourceNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceLinks?: SourceDocumentLinkUncheckedCreateNestedManyWithoutQuoteInput
  }

  export type QuoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    attributionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    sourceNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    county?: CountyUpdateOneRequiredWithoutQuotesNestedInput
    issue?: IssueUpdateOneWithoutQuotesNestedInput
    sourceLinks?: SourceDocumentLinkUpdateManyWithoutQuoteNestedInput
  }

  export type QuoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    attributionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    countyId?: StringFieldUpdateOperationsInput | string
    issueId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceLinks?: SourceDocumentLinkUncheckedUpdateManyWithoutQuoteNestedInput
  }

  export type QuoteCreateManyInput = {
    id?: string
    text: string
    attributionLabel?: string | null
    countyId: string
    issueId?: string | null
    sourceNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    attributionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    sourceNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    attributionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    countyId?: StringFieldUpdateOperationsInput | string
    issueId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetCreateInput = {
    id?: string
    assetType?: $Enums.AssetType
    title?: string | null
    caption?: string | null
    credit?: string | null
    license?: string | null
    url?: string | null
    storageKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    county?: CountyCreateNestedOneWithoutAssetsInput
    issue?: IssueCreateNestedOneWithoutAssetsInput
    sourceLinks?: SourceDocumentLinkCreateNestedManyWithoutAssetInput
  }

  export type AssetUncheckedCreateInput = {
    id?: string
    assetType?: $Enums.AssetType
    title?: string | null
    caption?: string | null
    credit?: string | null
    license?: string | null
    url?: string | null
    storageKey?: string | null
    countyId?: string | null
    issueId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceLinks?: SourceDocumentLinkUncheckedCreateNestedManyWithoutAssetInput
  }

  export type AssetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetType?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    credit?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    county?: CountyUpdateOneWithoutAssetsNestedInput
    issue?: IssueUpdateOneWithoutAssetsNestedInput
    sourceLinks?: SourceDocumentLinkUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetType?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    credit?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    issueId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceLinks?: SourceDocumentLinkUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type AssetCreateManyInput = {
    id?: string
    assetType?: $Enums.AssetType
    title?: string | null
    caption?: string | null
    credit?: string | null
    license?: string | null
    url?: string | null
    storageKey?: string | null
    countyId?: string | null
    issueId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetType?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    credit?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetType?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    credit?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    issueId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GlossaryTermCreateInput = {
    id?: string
    term: string
    slug: string
    definitionMd: string
    examplesMd?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GlossaryTermUncheckedCreateInput = {
    id?: string
    term: string
    slug: string
    definitionMd: string
    examplesMd?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GlossaryTermUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    term?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    definitionMd?: StringFieldUpdateOperationsInput | string
    examplesMd?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GlossaryTermUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    term?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    definitionMd?: StringFieldUpdateOperationsInput | string
    examplesMd?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GlossaryTermCreateManyInput = {
    id?: string
    term: string
    slug: string
    definitionMd: string
    examplesMd?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GlossaryTermUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    term?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    definitionMd?: StringFieldUpdateOperationsInput | string
    examplesMd?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GlossaryTermUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    term?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    definitionMd?: StringFieldUpdateOperationsInput | string
    examplesMd?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SourceDocumentCreateInput = {
    id?: string
    title: string
    url?: string | null
    storageKey?: string | null
    publisher?: string | null
    publishedAt?: Date | string | null
    capturedAt?: Date | string | null
    methodNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    chunks?: SourceChunkCreateNestedManyWithoutSourceDocumentInput
    citations?: CitationCreateNestedManyWithoutSourceDocumentInput
    runInputs?: AIRunInputSourceCreateNestedManyWithoutSourceDocumentInput
    sourceLinks?: SourceDocumentLinkCreateNestedManyWithoutSourceDocumentInput
  }

  export type SourceDocumentUncheckedCreateInput = {
    id?: string
    title: string
    url?: string | null
    storageKey?: string | null
    publisher?: string | null
    publishedAt?: Date | string | null
    capturedAt?: Date | string | null
    methodNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    chunks?: SourceChunkUncheckedCreateNestedManyWithoutSourceDocumentInput
    citations?: CitationUncheckedCreateNestedManyWithoutSourceDocumentInput
    runInputs?: AIRunInputSourceUncheckedCreateNestedManyWithoutSourceDocumentInput
    sourceLinks?: SourceDocumentLinkUncheckedCreateNestedManyWithoutSourceDocumentInput
  }

  export type SourceDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    methodNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chunks?: SourceChunkUpdateManyWithoutSourceDocumentNestedInput
    citations?: CitationUpdateManyWithoutSourceDocumentNestedInput
    runInputs?: AIRunInputSourceUpdateManyWithoutSourceDocumentNestedInput
    sourceLinks?: SourceDocumentLinkUpdateManyWithoutSourceDocumentNestedInput
  }

  export type SourceDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    methodNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chunks?: SourceChunkUncheckedUpdateManyWithoutSourceDocumentNestedInput
    citations?: CitationUncheckedUpdateManyWithoutSourceDocumentNestedInput
    runInputs?: AIRunInputSourceUncheckedUpdateManyWithoutSourceDocumentNestedInput
    sourceLinks?: SourceDocumentLinkUncheckedUpdateManyWithoutSourceDocumentNestedInput
  }

  export type SourceDocumentCreateManyInput = {
    id?: string
    title: string
    url?: string | null
    storageKey?: string | null
    publisher?: string | null
    publishedAt?: Date | string | null
    capturedAt?: Date | string | null
    methodNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SourceDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    methodNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SourceDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    methodNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SourceChunkCreateInput = {
    id?: string
    chunkIndex: number
    content: string
    contentHash: string
    locatorJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    sourceDocument: SourceDocumentCreateNestedOneWithoutChunksInput
    citations?: CitationCreateNestedManyWithoutSourceChunkInput
  }

  export type SourceChunkUncheckedCreateInput = {
    id?: string
    sourceDocumentId: string
    chunkIndex: number
    content: string
    contentHash: string
    locatorJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    citations?: CitationUncheckedCreateNestedManyWithoutSourceChunkInput
  }

  export type SourceChunkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    locatorJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceDocument?: SourceDocumentUpdateOneRequiredWithoutChunksNestedInput
    citations?: CitationUpdateManyWithoutSourceChunkNestedInput
  }

  export type SourceChunkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceDocumentId?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    locatorJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    citations?: CitationUncheckedUpdateManyWithoutSourceChunkNestedInput
  }

  export type SourceChunkCreateManyInput = {
    id?: string
    sourceDocumentId: string
    chunkIndex: number
    content: string
    contentHash: string
    locatorJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SourceChunkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    locatorJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SourceChunkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceDocumentId?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    locatorJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SourceDocumentLinkCreateInput = {
    id?: string
    note?: string | null
    createdAt?: Date | string
    sourceDocument: SourceDocumentCreateNestedOneWithoutSourceLinksInput
    county?: CountyCreateNestedOneWithoutSourceLinksInput
    issue?: IssueCreateNestedOneWithoutSourceLinksInput
    blueprintSection?: BlueprintSectionCreateNestedOneWithoutSourceLinksInput
    quote?: QuoteCreateNestedOneWithoutSourceLinksInput
    asset?: AssetCreateNestedOneWithoutSourceLinksInput
    surveyForm?: SurveyFormCreateNestedOneWithoutSourceLinksInput
  }

  export type SourceDocumentLinkUncheckedCreateInput = {
    id?: string
    sourceDocumentId: string
    countyId?: string | null
    issueId?: string | null
    blueprintSectionId?: string | null
    quoteId?: string | null
    assetId?: string | null
    surveyFormId?: string | null
    note?: string | null
    createdAt?: Date | string
  }

  export type SourceDocumentLinkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceDocument?: SourceDocumentUpdateOneRequiredWithoutSourceLinksNestedInput
    county?: CountyUpdateOneWithoutSourceLinksNestedInput
    issue?: IssueUpdateOneWithoutSourceLinksNestedInput
    blueprintSection?: BlueprintSectionUpdateOneWithoutSourceLinksNestedInput
    quote?: QuoteUpdateOneWithoutSourceLinksNestedInput
    asset?: AssetUpdateOneWithoutSourceLinksNestedInput
    surveyForm?: SurveyFormUpdateOneWithoutSourceLinksNestedInput
  }

  export type SourceDocumentLinkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceDocumentId?: StringFieldUpdateOperationsInput | string
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    issueId?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintSectionId?: NullableStringFieldUpdateOperationsInput | string | null
    quoteId?: NullableStringFieldUpdateOperationsInput | string | null
    assetId?: NullableStringFieldUpdateOperationsInput | string | null
    surveyFormId?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SourceDocumentLinkCreateManyInput = {
    id?: string
    sourceDocumentId: string
    countyId?: string | null
    issueId?: string | null
    blueprintSectionId?: string | null
    quoteId?: string | null
    assetId?: string | null
    surveyFormId?: string | null
    note?: string | null
    createdAt?: Date | string
  }

  export type SourceDocumentLinkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SourceDocumentLinkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceDocumentId?: StringFieldUpdateOperationsInput | string
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    issueId?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintSectionId?: NullableStringFieldUpdateOperationsInput | string | null
    quoteId?: NullableStringFieldUpdateOperationsInput | string | null
    assetId?: NullableStringFieldUpdateOperationsInput | string | null
    surveyFormId?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeoCountyCreateInput = {
    id?: string
    fipsCode?: string | null
    name: string
    createdAt?: Date | string
  }

  export type GeoCountyUncheckedCreateInput = {
    id?: string
    fipsCode?: string | null
    name: string
    createdAt?: Date | string
  }

  export type GeoCountyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fipsCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeoCountyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fipsCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeoCountyCreateManyInput = {
    id?: string
    fipsCode?: string | null
    name: string
    createdAt?: Date | string
  }

  export type GeoCountyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fipsCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeoCountyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fipsCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeoZipCreateInput = {
    id?: string
    zipCode: string
    createdAt?: Date | string
    censusMetrics?: CensusMetricCreateNestedManyWithoutGeoZipInput
    aiOutputScopes?: AIOutputScopeCreateNestedManyWithoutGeoZipInput
    electionResults?: ElectionResultCreateNestedManyWithoutGeoZipInput
  }

  export type GeoZipUncheckedCreateInput = {
    id?: string
    zipCode: string
    createdAt?: Date | string
    censusMetrics?: CensusMetricUncheckedCreateNestedManyWithoutGeoZipInput
    aiOutputScopes?: AIOutputScopeUncheckedCreateNestedManyWithoutGeoZipInput
    electionResults?: ElectionResultUncheckedCreateNestedManyWithoutGeoZipInput
  }

  export type GeoZipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    censusMetrics?: CensusMetricUpdateManyWithoutGeoZipNestedInput
    aiOutputScopes?: AIOutputScopeUpdateManyWithoutGeoZipNestedInput
    electionResults?: ElectionResultUpdateManyWithoutGeoZipNestedInput
  }

  export type GeoZipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    censusMetrics?: CensusMetricUncheckedUpdateManyWithoutGeoZipNestedInput
    aiOutputScopes?: AIOutputScopeUncheckedUpdateManyWithoutGeoZipNestedInput
    electionResults?: ElectionResultUncheckedUpdateManyWithoutGeoZipNestedInput
  }

  export type GeoZipCreateManyInput = {
    id?: string
    zipCode: string
    createdAt?: Date | string
  }

  export type GeoZipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeoZipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeoPrecinctCreateInput = {
    id?: string
    name?: string | null
    precinctCode?: string | null
    createdAt?: Date | string
    electionResults?: ElectionResultCreateNestedManyWithoutPrecinctInput
  }

  export type GeoPrecinctUncheckedCreateInput = {
    id?: string
    name?: string | null
    precinctCode?: string | null
    createdAt?: Date | string
    electionResults?: ElectionResultUncheckedCreateNestedManyWithoutPrecinctInput
  }

  export type GeoPrecinctUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    precinctCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    electionResults?: ElectionResultUpdateManyWithoutPrecinctNestedInput
  }

  export type GeoPrecinctUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    precinctCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    electionResults?: ElectionResultUncheckedUpdateManyWithoutPrecinctNestedInput
  }

  export type GeoPrecinctCreateManyInput = {
    id?: string
    name?: string | null
    precinctCode?: string | null
    createdAt?: Date | string
  }

  export type GeoPrecinctUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    precinctCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeoPrecinctUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    precinctCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeoDistrictCreateInput = {
    id?: string
    districtCode: string
    districtType?: string | null
    createdAt?: Date | string
    civicsOfficials?: CivicsOfficialCreateNestedManyWithoutDistrictInput
    aiOutputScopes?: AIOutputScopeCreateNestedManyWithoutDistrictInput
  }

  export type GeoDistrictUncheckedCreateInput = {
    id?: string
    districtCode: string
    districtType?: string | null
    createdAt?: Date | string
    civicsOfficials?: CivicsOfficialUncheckedCreateNestedManyWithoutDistrictInput
    aiOutputScopes?: AIOutputScopeUncheckedCreateNestedManyWithoutDistrictInput
  }

  export type GeoDistrictUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    districtCode?: StringFieldUpdateOperationsInput | string
    districtType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    civicsOfficials?: CivicsOfficialUpdateManyWithoutDistrictNestedInput
    aiOutputScopes?: AIOutputScopeUpdateManyWithoutDistrictNestedInput
  }

  export type GeoDistrictUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    districtCode?: StringFieldUpdateOperationsInput | string
    districtType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    civicsOfficials?: CivicsOfficialUncheckedUpdateManyWithoutDistrictNestedInput
    aiOutputScopes?: AIOutputScopeUncheckedUpdateManyWithoutDistrictNestedInput
  }

  export type GeoDistrictCreateManyInput = {
    id?: string
    districtCode: string
    districtType?: string | null
    createdAt?: Date | string
  }

  export type GeoDistrictUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    districtCode?: StringFieldUpdateOperationsInput | string
    districtType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeoDistrictUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    districtCode?: StringFieldUpdateOperationsInput | string
    districtType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeoCrosswalkCreateInput = {
    id?: string
    crosswalkType: $Enums.CrosswalkType
    fromGeoZipId?: string | null
    fromGeoPrecinctId?: string | null
    fromGeoDistrictId?: string | null
    fromGeoCountyFips?: string | null
    toGeoZipId?: string | null
    toGeoPrecinctId?: string | null
    toGeoDistrictId?: string | null
    toGeoCountyFips?: string | null
    weight?: number | null
    createdAt?: Date | string
  }

  export type GeoCrosswalkUncheckedCreateInput = {
    id?: string
    crosswalkType: $Enums.CrosswalkType
    fromGeoZipId?: string | null
    fromGeoPrecinctId?: string | null
    fromGeoDistrictId?: string | null
    fromGeoCountyFips?: string | null
    toGeoZipId?: string | null
    toGeoPrecinctId?: string | null
    toGeoDistrictId?: string | null
    toGeoCountyFips?: string | null
    weight?: number | null
    createdAt?: Date | string
  }

  export type GeoCrosswalkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    crosswalkType?: EnumCrosswalkTypeFieldUpdateOperationsInput | $Enums.CrosswalkType
    fromGeoZipId?: NullableStringFieldUpdateOperationsInput | string | null
    fromGeoPrecinctId?: NullableStringFieldUpdateOperationsInput | string | null
    fromGeoDistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    fromGeoCountyFips?: NullableStringFieldUpdateOperationsInput | string | null
    toGeoZipId?: NullableStringFieldUpdateOperationsInput | string | null
    toGeoPrecinctId?: NullableStringFieldUpdateOperationsInput | string | null
    toGeoDistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    toGeoCountyFips?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeoCrosswalkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    crosswalkType?: EnumCrosswalkTypeFieldUpdateOperationsInput | $Enums.CrosswalkType
    fromGeoZipId?: NullableStringFieldUpdateOperationsInput | string | null
    fromGeoPrecinctId?: NullableStringFieldUpdateOperationsInput | string | null
    fromGeoDistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    fromGeoCountyFips?: NullableStringFieldUpdateOperationsInput | string | null
    toGeoZipId?: NullableStringFieldUpdateOperationsInput | string | null
    toGeoPrecinctId?: NullableStringFieldUpdateOperationsInput | string | null
    toGeoDistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    toGeoCountyFips?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeoCrosswalkCreateManyInput = {
    id?: string
    crosswalkType: $Enums.CrosswalkType
    fromGeoZipId?: string | null
    fromGeoPrecinctId?: string | null
    fromGeoDistrictId?: string | null
    fromGeoCountyFips?: string | null
    toGeoZipId?: string | null
    toGeoPrecinctId?: string | null
    toGeoDistrictId?: string | null
    toGeoCountyFips?: string | null
    weight?: number | null
    createdAt?: Date | string
  }

  export type GeoCrosswalkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    crosswalkType?: EnumCrosswalkTypeFieldUpdateOperationsInput | $Enums.CrosswalkType
    fromGeoZipId?: NullableStringFieldUpdateOperationsInput | string | null
    fromGeoPrecinctId?: NullableStringFieldUpdateOperationsInput | string | null
    fromGeoDistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    fromGeoCountyFips?: NullableStringFieldUpdateOperationsInput | string | null
    toGeoZipId?: NullableStringFieldUpdateOperationsInput | string | null
    toGeoPrecinctId?: NullableStringFieldUpdateOperationsInput | string | null
    toGeoDistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    toGeoCountyFips?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeoCrosswalkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    crosswalkType?: EnumCrosswalkTypeFieldUpdateOperationsInput | $Enums.CrosswalkType
    fromGeoZipId?: NullableStringFieldUpdateOperationsInput | string | null
    fromGeoPrecinctId?: NullableStringFieldUpdateOperationsInput | string | null
    fromGeoDistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    fromGeoCountyFips?: NullableStringFieldUpdateOperationsInput | string | null
    toGeoZipId?: NullableStringFieldUpdateOperationsInput | string | null
    toGeoPrecinctId?: NullableStringFieldUpdateOperationsInput | string | null
    toGeoDistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    toGeoCountyFips?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CensusMetricCreateInput = {
    id?: string
    metricKey: string
    metricLabel?: string | null
    value?: number | null
    valueText?: string | null
    asOfDate?: Date | string | null
    sourceNote?: string | null
    createdAt?: Date | string
    county?: CountyCreateNestedOneWithoutCensusMetricsInput
    geoZip?: GeoZipCreateNestedOneWithoutCensusMetricsInput
  }

  export type CensusMetricUncheckedCreateInput = {
    id?: string
    countyId?: string | null
    geoZipId?: string | null
    metricKey: string
    metricLabel?: string | null
    value?: number | null
    valueText?: string | null
    asOfDate?: Date | string | null
    sourceNote?: string | null
    createdAt?: Date | string
  }

  export type CensusMetricUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricKey?: StringFieldUpdateOperationsInput | string
    metricLabel?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    valueText?: NullableStringFieldUpdateOperationsInput | string | null
    asOfDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    county?: CountyUpdateOneWithoutCensusMetricsNestedInput
    geoZip?: GeoZipUpdateOneWithoutCensusMetricsNestedInput
  }

  export type CensusMetricUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    geoZipId?: NullableStringFieldUpdateOperationsInput | string | null
    metricKey?: StringFieldUpdateOperationsInput | string
    metricLabel?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    valueText?: NullableStringFieldUpdateOperationsInput | string | null
    asOfDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CensusMetricCreateManyInput = {
    id?: string
    countyId?: string | null
    geoZipId?: string | null
    metricKey: string
    metricLabel?: string | null
    value?: number | null
    valueText?: string | null
    asOfDate?: Date | string | null
    sourceNote?: string | null
    createdAt?: Date | string
  }

  export type CensusMetricUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricKey?: StringFieldUpdateOperationsInput | string
    metricLabel?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    valueText?: NullableStringFieldUpdateOperationsInput | string | null
    asOfDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CensusMetricUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    geoZipId?: NullableStringFieldUpdateOperationsInput | string | null
    metricKey?: StringFieldUpdateOperationsInput | string
    metricLabel?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    valueText?: NullableStringFieldUpdateOperationsInput | string | null
    asOfDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BLSMetricCreateInput = {
    id?: string
    seriesKey: string
    seriesLabel?: string | null
    value?: number | null
    asOfDate?: Date | string | null
    sourceNote?: string | null
    createdAt?: Date | string
    county: CountyCreateNestedOneWithoutBlsMetricsInput
  }

  export type BLSMetricUncheckedCreateInput = {
    id?: string
    countyId: string
    seriesKey: string
    seriesLabel?: string | null
    value?: number | null
    asOfDate?: Date | string | null
    sourceNote?: string | null
    createdAt?: Date | string
  }

  export type BLSMetricUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seriesKey?: StringFieldUpdateOperationsInput | string
    seriesLabel?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    asOfDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    county?: CountyUpdateOneRequiredWithoutBlsMetricsNestedInput
  }

  export type BLSMetricUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    countyId?: StringFieldUpdateOperationsInput | string
    seriesKey?: StringFieldUpdateOperationsInput | string
    seriesLabel?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    asOfDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BLSMetricCreateManyInput = {
    id?: string
    countyId: string
    seriesKey: string
    seriesLabel?: string | null
    value?: number | null
    asOfDate?: Date | string | null
    sourceNote?: string | null
    createdAt?: Date | string
  }

  export type BLSMetricUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    seriesKey?: StringFieldUpdateOperationsInput | string
    seriesLabel?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    asOfDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BLSMetricUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    countyId?: StringFieldUpdateOperationsInput | string
    seriesKey?: StringFieldUpdateOperationsInput | string
    seriesLabel?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    asOfDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CivicsOfficialCreateInput = {
    id?: string
    name: string
    officeName: string
    party?: string | null
    phone?: string | null
    website?: string | null
    photoUrl?: string | null
    sourceNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    county?: CountyCreateNestedOneWithoutCivicsOfficialsInput
    district?: GeoDistrictCreateNestedOneWithoutCivicsOfficialsInput
  }

  export type CivicsOfficialUncheckedCreateInput = {
    id?: string
    name: string
    officeName: string
    party?: string | null
    phone?: string | null
    website?: string | null
    photoUrl?: string | null
    countyId?: string | null
    districtId?: string | null
    sourceNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CivicsOfficialUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    officeName?: StringFieldUpdateOperationsInput | string
    party?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    sourceNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    county?: CountyUpdateOneWithoutCivicsOfficialsNestedInput
    district?: GeoDistrictUpdateOneWithoutCivicsOfficialsNestedInput
  }

  export type CivicsOfficialUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    officeName?: StringFieldUpdateOperationsInput | string
    party?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    districtId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CivicsOfficialCreateManyInput = {
    id?: string
    name: string
    officeName: string
    party?: string | null
    phone?: string | null
    website?: string | null
    photoUrl?: string | null
    countyId?: string | null
    districtId?: string | null
    sourceNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CivicsOfficialUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    officeName?: StringFieldUpdateOperationsInput | string
    party?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    sourceNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CivicsOfficialUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    officeName?: StringFieldUpdateOperationsInput | string
    party?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    districtId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElectionCreateInput = {
    id?: string
    name: string
    electionDate: Date | string
    electionType?: string | null
    notes?: string | null
    createdAt?: Date | string
    results?: ElectionResultCreateNestedManyWithoutElectionInput
  }

  export type ElectionUncheckedCreateInput = {
    id?: string
    name: string
    electionDate: Date | string
    electionType?: string | null
    notes?: string | null
    createdAt?: Date | string
    results?: ElectionResultUncheckedCreateNestedManyWithoutElectionInput
  }

  export type ElectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    electionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    electionType?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    results?: ElectionResultUpdateManyWithoutElectionNestedInput
  }

  export type ElectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    electionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    electionType?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    results?: ElectionResultUncheckedUpdateManyWithoutElectionNestedInput
  }

  export type ElectionCreateManyInput = {
    id?: string
    name: string
    electionDate: Date | string
    electionType?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type ElectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    electionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    electionType?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    electionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    electionType?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElectionResultCreateInput = {
    id?: string
    choiceLabel: string
    votes?: number | null
    voteShare?: number | null
    createdAt?: Date | string
    election: ElectionCreateNestedOneWithoutResultsInput
    county?: CountyCreateNestedOneWithoutElectionResultsInput
    geoZip?: GeoZipCreateNestedOneWithoutElectionResultsInput
    precinct?: GeoPrecinctCreateNestedOneWithoutElectionResultsInput
  }

  export type ElectionResultUncheckedCreateInput = {
    id?: string
    electionId: string
    countyId?: string | null
    geoZipId?: string | null
    precinctId?: string | null
    choiceLabel: string
    votes?: number | null
    voteShare?: number | null
    createdAt?: Date | string
  }

  export type ElectionResultUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    choiceLabel?: StringFieldUpdateOperationsInput | string
    votes?: NullableIntFieldUpdateOperationsInput | number | null
    voteShare?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    election?: ElectionUpdateOneRequiredWithoutResultsNestedInput
    county?: CountyUpdateOneWithoutElectionResultsNestedInput
    geoZip?: GeoZipUpdateOneWithoutElectionResultsNestedInput
    precinct?: GeoPrecinctUpdateOneWithoutElectionResultsNestedInput
  }

  export type ElectionResultUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    electionId?: StringFieldUpdateOperationsInput | string
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    geoZipId?: NullableStringFieldUpdateOperationsInput | string | null
    precinctId?: NullableStringFieldUpdateOperationsInput | string | null
    choiceLabel?: StringFieldUpdateOperationsInput | string
    votes?: NullableIntFieldUpdateOperationsInput | number | null
    voteShare?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElectionResultCreateManyInput = {
    id?: string
    electionId: string
    countyId?: string | null
    geoZipId?: string | null
    precinctId?: string | null
    choiceLabel: string
    votes?: number | null
    voteShare?: number | null
    createdAt?: Date | string
  }

  export type ElectionResultUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    choiceLabel?: StringFieldUpdateOperationsInput | string
    votes?: NullableIntFieldUpdateOperationsInput | number | null
    voteShare?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElectionResultUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    electionId?: StringFieldUpdateOperationsInput | string
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    geoZipId?: NullableStringFieldUpdateOperationsInput | string | null
    precinctId?: NullableStringFieldUpdateOperationsInput | string | null
    choiceLabel?: StringFieldUpdateOperationsInput | string
    votes?: NullableIntFieldUpdateOperationsInput | number | null
    voteShare?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIPromptCreateInput = {
    id?: string
    promptKey: string
    version: number
    name: string
    description?: string | null
    template: string
    createdAt?: Date | string
    updatedAt?: Date | string
    runs?: AIRunCreateNestedManyWithoutPromptInput
  }

  export type AIPromptUncheckedCreateInput = {
    id?: string
    promptKey: string
    version: number
    name: string
    description?: string | null
    template: string
    createdAt?: Date | string
    updatedAt?: Date | string
    runs?: AIRunUncheckedCreateNestedManyWithoutPromptInput
  }

  export type AIPromptUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    promptKey?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    template?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    runs?: AIRunUpdateManyWithoutPromptNestedInput
  }

  export type AIPromptUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    promptKey?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    template?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    runs?: AIRunUncheckedUpdateManyWithoutPromptNestedInput
  }

  export type AIPromptCreateManyInput = {
    id?: string
    promptKey: string
    version: number
    name: string
    description?: string | null
    template: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIPromptUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    promptKey?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    template?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIPromptUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    promptKey?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    template?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIRunCreateInput = {
    id?: string
    model: string
    paramsJson?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.AIRunStatus
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorText?: string | null
    inputSummary?: string | null
    createdAt?: Date | string
    prompt: AIPromptCreateNestedOneWithoutRunsInput
    outputs?: AIOutputCreateNestedManyWithoutRunInput
    inputSources?: AIRunInputSourceCreateNestedManyWithoutRunInput
    analyses?: AIAnalysisCreateNestedManyWithoutAiRunInput
  }

  export type AIRunUncheckedCreateInput = {
    id?: string
    promptId: string
    model: string
    paramsJson?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.AIRunStatus
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorText?: string | null
    inputSummary?: string | null
    createdAt?: Date | string
    outputs?: AIOutputUncheckedCreateNestedManyWithoutRunInput
    inputSources?: AIRunInputSourceUncheckedCreateNestedManyWithoutRunInput
    analyses?: AIAnalysisUncheckedCreateNestedManyWithoutAiRunInput
  }

  export type AIRunUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    paramsJson?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAIRunStatusFieldUpdateOperationsInput | $Enums.AIRunStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorText?: NullableStringFieldUpdateOperationsInput | string | null
    inputSummary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prompt?: AIPromptUpdateOneRequiredWithoutRunsNestedInput
    outputs?: AIOutputUpdateManyWithoutRunNestedInput
    inputSources?: AIRunInputSourceUpdateManyWithoutRunNestedInput
    analyses?: AIAnalysisUpdateManyWithoutAiRunNestedInput
  }

  export type AIRunUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    promptId?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    paramsJson?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAIRunStatusFieldUpdateOperationsInput | $Enums.AIRunStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorText?: NullableStringFieldUpdateOperationsInput | string | null
    inputSummary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    outputs?: AIOutputUncheckedUpdateManyWithoutRunNestedInput
    inputSources?: AIRunInputSourceUncheckedUpdateManyWithoutRunNestedInput
    analyses?: AIAnalysisUncheckedUpdateManyWithoutAiRunNestedInput
  }

  export type AIRunCreateManyInput = {
    id?: string
    promptId: string
    model: string
    paramsJson?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.AIRunStatus
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorText?: string | null
    inputSummary?: string | null
    createdAt?: Date | string
  }

  export type AIRunUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    paramsJson?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAIRunStatusFieldUpdateOperationsInput | $Enums.AIRunStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorText?: NullableStringFieldUpdateOperationsInput | string | null
    inputSummary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIRunUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    promptId?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    paramsJson?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAIRunStatusFieldUpdateOperationsInput | $Enums.AIRunStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorText?: NullableStringFieldUpdateOperationsInput | string | null
    inputSummary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIRunInputSourceCreateInput = {
    id?: string
    kind?: $Enums.AIRunInputKind
    externalKey?: string | null
    notes?: string | null
    createdAt?: Date | string
    run: AIRunCreateNestedOneWithoutInputSourcesInput
    sourceDocument?: SourceDocumentCreateNestedOneWithoutRunInputsInput
  }

  export type AIRunInputSourceUncheckedCreateInput = {
    id?: string
    runId: string
    kind?: $Enums.AIRunInputKind
    sourceDocumentId?: string | null
    externalKey?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type AIRunInputSourceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumAIRunInputKindFieldUpdateOperationsInput | $Enums.AIRunInputKind
    externalKey?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    run?: AIRunUpdateOneRequiredWithoutInputSourcesNestedInput
    sourceDocument?: SourceDocumentUpdateOneWithoutRunInputsNestedInput
  }

  export type AIRunInputSourceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    runId?: StringFieldUpdateOperationsInput | string
    kind?: EnumAIRunInputKindFieldUpdateOperationsInput | $Enums.AIRunInputKind
    sourceDocumentId?: NullableStringFieldUpdateOperationsInput | string | null
    externalKey?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIRunInputSourceCreateManyInput = {
    id?: string
    runId: string
    kind?: $Enums.AIRunInputKind
    sourceDocumentId?: string | null
    externalKey?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type AIRunInputSourceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumAIRunInputKindFieldUpdateOperationsInput | $Enums.AIRunInputKind
    externalKey?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIRunInputSourceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    runId?: StringFieldUpdateOperationsInput | string
    kind?: EnumAIRunInputKindFieldUpdateOperationsInput | $Enums.AIRunInputKind
    sourceDocumentId?: NullableStringFieldUpdateOperationsInput | string | null
    externalKey?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIOutputCreateInput = {
    id?: string
    outputType?: $Enums.AIOutputType
    status?: $Enums.PublishStatus
    title?: string | null
    summary?: string | null
    contentMd: string
    reviewedAt?: Date | string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    run: AIRunCreateNestedOneWithoutOutputsInput
    sections?: AIOutputSectionCreateNestedManyWithoutOutputInput
    scopes?: AIOutputScopeCreateNestedManyWithoutOutputInput
  }

  export type AIOutputUncheckedCreateInput = {
    id?: string
    runId: string
    outputType?: $Enums.AIOutputType
    status?: $Enums.PublishStatus
    title?: string | null
    summary?: string | null
    contentMd: string
    reviewedAt?: Date | string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sections?: AIOutputSectionUncheckedCreateNestedManyWithoutOutputInput
    scopes?: AIOutputScopeUncheckedCreateNestedManyWithoutOutputInput
  }

  export type AIOutputUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    outputType?: EnumAIOutputTypeFieldUpdateOperationsInput | $Enums.AIOutputType
    status?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    title?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    contentMd?: StringFieldUpdateOperationsInput | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    run?: AIRunUpdateOneRequiredWithoutOutputsNestedInput
    sections?: AIOutputSectionUpdateManyWithoutOutputNestedInput
    scopes?: AIOutputScopeUpdateManyWithoutOutputNestedInput
  }

  export type AIOutputUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    runId?: StringFieldUpdateOperationsInput | string
    outputType?: EnumAIOutputTypeFieldUpdateOperationsInput | $Enums.AIOutputType
    status?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    title?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    contentMd?: StringFieldUpdateOperationsInput | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sections?: AIOutputSectionUncheckedUpdateManyWithoutOutputNestedInput
    scopes?: AIOutputScopeUncheckedUpdateManyWithoutOutputNestedInput
  }

  export type AIOutputCreateManyInput = {
    id?: string
    runId: string
    outputType?: $Enums.AIOutputType
    status?: $Enums.PublishStatus
    title?: string | null
    summary?: string | null
    contentMd: string
    reviewedAt?: Date | string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIOutputUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    outputType?: EnumAIOutputTypeFieldUpdateOperationsInput | $Enums.AIOutputType
    status?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    title?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    contentMd?: StringFieldUpdateOperationsInput | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIOutputUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    runId?: StringFieldUpdateOperationsInput | string
    outputType?: EnumAIOutputTypeFieldUpdateOperationsInput | $Enums.AIOutputType
    status?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    title?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    contentMd?: StringFieldUpdateOperationsInput | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIOutputSectionCreateInput = {
    id?: string
    sectionKey: string
    heading?: string | null
    order?: number
    contentMd: string
    createdAt?: Date | string
    updatedAt?: Date | string
    output: AIOutputCreateNestedOneWithoutSectionsInput
    citations?: CitationCreateNestedManyWithoutOutputSectionInput
  }

  export type AIOutputSectionUncheckedCreateInput = {
    id?: string
    outputId: string
    sectionKey: string
    heading?: string | null
    order?: number
    contentMd: string
    createdAt?: Date | string
    updatedAt?: Date | string
    citations?: CitationUncheckedCreateNestedManyWithoutOutputSectionInput
  }

  export type AIOutputSectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionKey?: StringFieldUpdateOperationsInput | string
    heading?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    contentMd?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    output?: AIOutputUpdateOneRequiredWithoutSectionsNestedInput
    citations?: CitationUpdateManyWithoutOutputSectionNestedInput
  }

  export type AIOutputSectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    outputId?: StringFieldUpdateOperationsInput | string
    sectionKey?: StringFieldUpdateOperationsInput | string
    heading?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    contentMd?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    citations?: CitationUncheckedUpdateManyWithoutOutputSectionNestedInput
  }

  export type AIOutputSectionCreateManyInput = {
    id?: string
    outputId: string
    sectionKey: string
    heading?: string | null
    order?: number
    contentMd: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIOutputSectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionKey?: StringFieldUpdateOperationsInput | string
    heading?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    contentMd?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIOutputSectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    outputId?: StringFieldUpdateOperationsInput | string
    sectionKey?: StringFieldUpdateOperationsInput | string
    heading?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    contentMd?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIOutputScopeCreateInput = {
    id?: string
    scopeType: $Enums.AIScopeType
    customKey?: string | null
    createdAt?: Date | string
    output: AIOutputCreateNestedOneWithoutScopesInput
    county?: CountyCreateNestedOneWithoutAiOutputScopesInput
    issue?: IssueCreateNestedOneWithoutAiOutputScopesInput
    geoZip?: GeoZipCreateNestedOneWithoutAiOutputScopesInput
    district?: GeoDistrictCreateNestedOneWithoutAiOutputScopesInput
  }

  export type AIOutputScopeUncheckedCreateInput = {
    id?: string
    outputId: string
    scopeType: $Enums.AIScopeType
    countyId?: string | null
    issueId?: string | null
    geoZipId?: string | null
    districtId?: string | null
    customKey?: string | null
    createdAt?: Date | string
  }

  export type AIOutputScopeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scopeType?: EnumAIScopeTypeFieldUpdateOperationsInput | $Enums.AIScopeType
    customKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    output?: AIOutputUpdateOneRequiredWithoutScopesNestedInput
    county?: CountyUpdateOneWithoutAiOutputScopesNestedInput
    issue?: IssueUpdateOneWithoutAiOutputScopesNestedInput
    geoZip?: GeoZipUpdateOneWithoutAiOutputScopesNestedInput
    district?: GeoDistrictUpdateOneWithoutAiOutputScopesNestedInput
  }

  export type AIOutputScopeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    outputId?: StringFieldUpdateOperationsInput | string
    scopeType?: EnumAIScopeTypeFieldUpdateOperationsInput | $Enums.AIScopeType
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    issueId?: NullableStringFieldUpdateOperationsInput | string | null
    geoZipId?: NullableStringFieldUpdateOperationsInput | string | null
    districtId?: NullableStringFieldUpdateOperationsInput | string | null
    customKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIOutputScopeCreateManyInput = {
    id?: string
    outputId: string
    scopeType: $Enums.AIScopeType
    countyId?: string | null
    issueId?: string | null
    geoZipId?: string | null
    districtId?: string | null
    customKey?: string | null
    createdAt?: Date | string
  }

  export type AIOutputScopeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    scopeType?: EnumAIScopeTypeFieldUpdateOperationsInput | $Enums.AIScopeType
    customKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIOutputScopeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    outputId?: StringFieldUpdateOperationsInput | string
    scopeType?: EnumAIScopeTypeFieldUpdateOperationsInput | $Enums.AIScopeType
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    issueId?: NullableStringFieldUpdateOperationsInput | string | null
    geoZipId?: NullableStringFieldUpdateOperationsInput | string | null
    districtId?: NullableStringFieldUpdateOperationsInput | string | null
    customKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CitationCreateInput = {
    id?: string
    label?: string | null
    locatorJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    outputSection: AIOutputSectionCreateNestedOneWithoutCitationsInput
    sourceChunk?: SourceChunkCreateNestedOneWithoutCitationsInput
    sourceDocument?: SourceDocumentCreateNestedOneWithoutCitationsInput
  }

  export type CitationUncheckedCreateInput = {
    id?: string
    outputSectionId: string
    sourceChunkId?: string | null
    sourceDocumentId?: string | null
    label?: string | null
    locatorJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type CitationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    locatorJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    outputSection?: AIOutputSectionUpdateOneRequiredWithoutCitationsNestedInput
    sourceChunk?: SourceChunkUpdateOneWithoutCitationsNestedInput
    sourceDocument?: SourceDocumentUpdateOneWithoutCitationsNestedInput
  }

  export type CitationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    outputSectionId?: StringFieldUpdateOperationsInput | string
    sourceChunkId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceDocumentId?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    locatorJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CitationCreateManyInput = {
    id?: string
    outputSectionId: string
    sourceChunkId?: string | null
    sourceDocumentId?: string | null
    label?: string | null
    locatorJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type CitationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    locatorJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CitationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    outputSectionId?: StringFieldUpdateOperationsInput | string
    sourceChunkId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceDocumentId?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    locatorJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyFormCreateInput = {
    id?: string
    title: string
    descriptionMd?: string | null
    slug: string
    status?: $Enums.SurveyFormStatus
    startAt?: Date | string | null
    endAt?: Date | string | null
    contextLabel?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    county?: CountyCreateNestedOneWithoutSurveyFormsInput
    questions?: SurveyQuestionCreateNestedManyWithoutFormInput
    responses?: SurveyResponseCreateNestedManyWithoutFormInput
    sourceLinks?: SourceDocumentLinkCreateNestedManyWithoutSurveyFormInput
  }

  export type SurveyFormUncheckedCreateInput = {
    id?: string
    title: string
    descriptionMd?: string | null
    slug: string
    status?: $Enums.SurveyFormStatus
    startAt?: Date | string | null
    endAt?: Date | string | null
    countyId?: string | null
    contextLabel?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: SurveyQuestionUncheckedCreateNestedManyWithoutFormInput
    responses?: SurveyResponseUncheckedCreateNestedManyWithoutFormInput
    sourceLinks?: SourceDocumentLinkUncheckedCreateNestedManyWithoutSurveyFormInput
  }

  export type SurveyFormUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    descriptionMd?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumSurveyFormStatusFieldUpdateOperationsInput | $Enums.SurveyFormStatus
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contextLabel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    county?: CountyUpdateOneWithoutSurveyFormsNestedInput
    questions?: SurveyQuestionUpdateManyWithoutFormNestedInput
    responses?: SurveyResponseUpdateManyWithoutFormNestedInput
    sourceLinks?: SourceDocumentLinkUpdateManyWithoutSurveyFormNestedInput
  }

  export type SurveyFormUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    descriptionMd?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumSurveyFormStatusFieldUpdateOperationsInput | $Enums.SurveyFormStatus
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    contextLabel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: SurveyQuestionUncheckedUpdateManyWithoutFormNestedInput
    responses?: SurveyResponseUncheckedUpdateManyWithoutFormNestedInput
    sourceLinks?: SourceDocumentLinkUncheckedUpdateManyWithoutSurveyFormNestedInput
  }

  export type SurveyFormCreateManyInput = {
    id?: string
    title: string
    descriptionMd?: string | null
    slug: string
    status?: $Enums.SurveyFormStatus
    startAt?: Date | string | null
    endAt?: Date | string | null
    countyId?: string | null
    contextLabel?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SurveyFormUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    descriptionMd?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumSurveyFormStatusFieldUpdateOperationsInput | $Enums.SurveyFormStatus
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contextLabel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyFormUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    descriptionMd?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumSurveyFormStatusFieldUpdateOperationsInput | $Enums.SurveyFormStatus
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    contextLabel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyQuestionCreateInput = {
    id?: string
    questionKey: string
    prompt: string
    helpText?: string | null
    questionType: $Enums.SurveyQuestionType
    required?: boolean
    sortOrder?: number
    isActive?: boolean
    allowVoice?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    form: SurveyFormCreateNestedOneWithoutQuestionsInput
    options?: SurveyQuestionOptionCreateNestedManyWithoutQuestionInput
    responseItems?: SurveyResponseItemCreateNestedManyWithoutQuestionInput
  }

  export type SurveyQuestionUncheckedCreateInput = {
    id?: string
    formId: string
    questionKey: string
    prompt: string
    helpText?: string | null
    questionType: $Enums.SurveyQuestionType
    required?: boolean
    sortOrder?: number
    isActive?: boolean
    allowVoice?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    options?: SurveyQuestionOptionUncheckedCreateNestedManyWithoutQuestionInput
    responseItems?: SurveyResponseItemUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type SurveyQuestionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionKey?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    helpText?: NullableStringFieldUpdateOperationsInput | string | null
    questionType?: EnumSurveyQuestionTypeFieldUpdateOperationsInput | $Enums.SurveyQuestionType
    required?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    allowVoice?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    form?: SurveyFormUpdateOneRequiredWithoutQuestionsNestedInput
    options?: SurveyQuestionOptionUpdateManyWithoutQuestionNestedInput
    responseItems?: SurveyResponseItemUpdateManyWithoutQuestionNestedInput
  }

  export type SurveyQuestionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    questionKey?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    helpText?: NullableStringFieldUpdateOperationsInput | string | null
    questionType?: EnumSurveyQuestionTypeFieldUpdateOperationsInput | $Enums.SurveyQuestionType
    required?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    allowVoice?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: SurveyQuestionOptionUncheckedUpdateManyWithoutQuestionNestedInput
    responseItems?: SurveyResponseItemUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type SurveyQuestionCreateManyInput = {
    id?: string
    formId: string
    questionKey: string
    prompt: string
    helpText?: string | null
    questionType: $Enums.SurveyQuestionType
    required?: boolean
    sortOrder?: number
    isActive?: boolean
    allowVoice?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SurveyQuestionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionKey?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    helpText?: NullableStringFieldUpdateOperationsInput | string | null
    questionType?: EnumSurveyQuestionTypeFieldUpdateOperationsInput | $Enums.SurveyQuestionType
    required?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    allowVoice?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyQuestionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    questionKey?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    helpText?: NullableStringFieldUpdateOperationsInput | string | null
    questionType?: EnumSurveyQuestionTypeFieldUpdateOperationsInput | $Enums.SurveyQuestionType
    required?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    allowVoice?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyQuestionOptionCreateInput = {
    id?: string
    valueKey: string
    label: string
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    question: SurveyQuestionCreateNestedOneWithoutOptionsInput
    responseItemOptions?: SurveyResponseItemOptionCreateNestedManyWithoutOptionInput
    selectedByResponseItems?: SurveyResponseItemCreateNestedManyWithoutSelectedOptionInput
  }

  export type SurveyQuestionOptionUncheckedCreateInput = {
    id?: string
    questionId: string
    valueKey: string
    label: string
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    responseItemOptions?: SurveyResponseItemOptionUncheckedCreateNestedManyWithoutOptionInput
    selectedByResponseItems?: SurveyResponseItemUncheckedCreateNestedManyWithoutSelectedOptionInput
  }

  export type SurveyQuestionOptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    valueKey?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: SurveyQuestionUpdateOneRequiredWithoutOptionsNestedInput
    responseItemOptions?: SurveyResponseItemOptionUpdateManyWithoutOptionNestedInput
    selectedByResponseItems?: SurveyResponseItemUpdateManyWithoutSelectedOptionNestedInput
  }

  export type SurveyQuestionOptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    valueKey?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responseItemOptions?: SurveyResponseItemOptionUncheckedUpdateManyWithoutOptionNestedInput
    selectedByResponseItems?: SurveyResponseItemUncheckedUpdateManyWithoutSelectedOptionNestedInput
  }

  export type SurveyQuestionOptionCreateManyInput = {
    id?: string
    questionId: string
    valueKey: string
    label: string
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type SurveyQuestionOptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    valueKey?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyQuestionOptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    valueKey?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyResponseCreateInput = {
    id?: string
    sourceLabel?: string | null
    submittedAt?: Date | string
    ipHash?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    form: SurveyFormCreateNestedOneWithoutResponsesInput
    county?: CountyCreateNestedOneWithoutSurveyResponsesInput
    items?: SurveyResponseItemCreateNestedManyWithoutResponseInput
  }

  export type SurveyResponseUncheckedCreateInput = {
    id?: string
    formId: string
    countyId?: string | null
    sourceLabel?: string | null
    submittedAt?: Date | string
    ipHash?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    items?: SurveyResponseItemUncheckedCreateNestedManyWithoutResponseInput
  }

  export type SurveyResponseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceLabel?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipHash?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    form?: SurveyFormUpdateOneRequiredWithoutResponsesNestedInput
    county?: CountyUpdateOneWithoutSurveyResponsesNestedInput
    items?: SurveyResponseItemUpdateManyWithoutResponseNestedInput
  }

  export type SurveyResponseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLabel?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipHash?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: SurveyResponseItemUncheckedUpdateManyWithoutResponseNestedInput
  }

  export type SurveyResponseCreateManyInput = {
    id?: string
    formId: string
    countyId?: string | null
    sourceLabel?: string | null
    submittedAt?: Date | string
    ipHash?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type SurveyResponseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceLabel?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipHash?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyResponseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLabel?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipHash?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyResponseItemCreateInput = {
    id?: string
    valueText?: string | null
    valueNumber?: number | null
    valueBoolean?: boolean | null
    createdAt?: Date | string
    response: SurveyResponseCreateNestedOneWithoutItemsInput
    question: SurveyQuestionCreateNestedOneWithoutResponseItemsInput
    selectedOption?: SurveyQuestionOptionCreateNestedOneWithoutSelectedByResponseItemsInput
    mediaAsset?: MediaAssetCreateNestedOneWithoutSurveyResponseItemsInput
    multiSelectedOptions?: SurveyResponseItemOptionCreateNestedManyWithoutResponseItemInput
  }

  export type SurveyResponseItemUncheckedCreateInput = {
    id?: string
    responseId: string
    questionId: string
    valueText?: string | null
    valueNumber?: number | null
    valueBoolean?: boolean | null
    selectedOptionId?: string | null
    mediaAssetId?: string | null
    createdAt?: Date | string
    multiSelectedOptions?: SurveyResponseItemOptionUncheckedCreateNestedManyWithoutResponseItemInput
  }

  export type SurveyResponseItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    valueText?: NullableStringFieldUpdateOperationsInput | string | null
    valueNumber?: NullableFloatFieldUpdateOperationsInput | number | null
    valueBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    response?: SurveyResponseUpdateOneRequiredWithoutItemsNestedInput
    question?: SurveyQuestionUpdateOneRequiredWithoutResponseItemsNestedInput
    selectedOption?: SurveyQuestionOptionUpdateOneWithoutSelectedByResponseItemsNestedInput
    mediaAsset?: MediaAssetUpdateOneWithoutSurveyResponseItemsNestedInput
    multiSelectedOptions?: SurveyResponseItemOptionUpdateManyWithoutResponseItemNestedInput
  }

  export type SurveyResponseItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    responseId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    valueText?: NullableStringFieldUpdateOperationsInput | string | null
    valueNumber?: NullableFloatFieldUpdateOperationsInput | number | null
    valueBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
    selectedOptionId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaAssetId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    multiSelectedOptions?: SurveyResponseItemOptionUncheckedUpdateManyWithoutResponseItemNestedInput
  }

  export type SurveyResponseItemCreateManyInput = {
    id?: string
    responseId: string
    questionId: string
    valueText?: string | null
    valueNumber?: number | null
    valueBoolean?: boolean | null
    selectedOptionId?: string | null
    mediaAssetId?: string | null
    createdAt?: Date | string
  }

  export type SurveyResponseItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    valueText?: NullableStringFieldUpdateOperationsInput | string | null
    valueNumber?: NullableFloatFieldUpdateOperationsInput | number | null
    valueBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyResponseItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    responseId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    valueText?: NullableStringFieldUpdateOperationsInput | string | null
    valueNumber?: NullableFloatFieldUpdateOperationsInput | number | null
    valueBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
    selectedOptionId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaAssetId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyResponseItemOptionCreateInput = {
    id?: string
    createdAt?: Date | string
    responseItem: SurveyResponseItemCreateNestedOneWithoutMultiSelectedOptionsInput
    option: SurveyQuestionOptionCreateNestedOneWithoutResponseItemOptionsInput
  }

  export type SurveyResponseItemOptionUncheckedCreateInput = {
    id?: string
    responseItemId: string
    optionId: string
    createdAt?: Date | string
  }

  export type SurveyResponseItemOptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responseItem?: SurveyResponseItemUpdateOneRequiredWithoutMultiSelectedOptionsNestedInput
    option?: SurveyQuestionOptionUpdateOneRequiredWithoutResponseItemOptionsNestedInput
  }

  export type SurveyResponseItemOptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    responseItemId?: StringFieldUpdateOperationsInput | string
    optionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyResponseItemOptionCreateManyInput = {
    id?: string
    responseItemId: string
    optionId: string
    createdAt?: Date | string
  }

  export type SurveyResponseItemOptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyResponseItemOptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    responseItemId?: StringFieldUpdateOperationsInput | string
    optionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaAssetCreateInput = {
    id?: string
    assetType?: $Enums.AssetType
    storageProvider?: string | null
    storageKey?: string | null
    url?: string | null
    mimeType?: string | null
    sizeBytes?: number | null
    durationMs?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    surveyResponseItems?: SurveyResponseItemCreateNestedManyWithoutMediaAssetInput
    transcripts?: TranscriptCreateNestedManyWithoutMediaAssetInput
    analyses?: AIAnalysisCreateNestedManyWithoutMediaAssetInput
  }

  export type MediaAssetUncheckedCreateInput = {
    id?: string
    assetType?: $Enums.AssetType
    storageProvider?: string | null
    storageKey?: string | null
    url?: string | null
    mimeType?: string | null
    sizeBytes?: number | null
    durationMs?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    surveyResponseItems?: SurveyResponseItemUncheckedCreateNestedManyWithoutMediaAssetInput
    transcripts?: TranscriptUncheckedCreateNestedManyWithoutMediaAssetInput
    analyses?: AIAnalysisUncheckedCreateNestedManyWithoutMediaAssetInput
  }

  export type MediaAssetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetType?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    storageProvider?: NullableStringFieldUpdateOperationsInput | string | null
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surveyResponseItems?: SurveyResponseItemUpdateManyWithoutMediaAssetNestedInput
    transcripts?: TranscriptUpdateManyWithoutMediaAssetNestedInput
    analyses?: AIAnalysisUpdateManyWithoutMediaAssetNestedInput
  }

  export type MediaAssetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetType?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    storageProvider?: NullableStringFieldUpdateOperationsInput | string | null
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surveyResponseItems?: SurveyResponseItemUncheckedUpdateManyWithoutMediaAssetNestedInput
    transcripts?: TranscriptUncheckedUpdateManyWithoutMediaAssetNestedInput
    analyses?: AIAnalysisUncheckedUpdateManyWithoutMediaAssetNestedInput
  }

  export type MediaAssetCreateManyInput = {
    id?: string
    assetType?: $Enums.AssetType
    storageProvider?: string | null
    storageKey?: string | null
    url?: string | null
    mimeType?: string | null
    sizeBytes?: number | null
    durationMs?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MediaAssetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetType?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    storageProvider?: NullableStringFieldUpdateOperationsInput | string | null
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaAssetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetType?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    storageProvider?: NullableStringFieldUpdateOperationsInput | string | null
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranscriptCreateInput = {
    id?: string
    provider?: string | null
    providerVersion?: string | null
    language?: string | null
    transcriptText: string
    segmentsJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    mediaAsset: MediaAssetCreateNestedOneWithoutTranscriptsInput
    analyses?: AIAnalysisCreateNestedManyWithoutTranscriptInput
  }

  export type TranscriptUncheckedCreateInput = {
    id?: string
    mediaAssetId: string
    provider?: string | null
    providerVersion?: string | null
    language?: string | null
    transcriptText: string
    segmentsJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    analyses?: AIAnalysisUncheckedCreateNestedManyWithoutTranscriptInput
  }

  export type TranscriptUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerVersion?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptText?: StringFieldUpdateOperationsInput | string
    segmentsJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaAsset?: MediaAssetUpdateOneRequiredWithoutTranscriptsNestedInput
    analyses?: AIAnalysisUpdateManyWithoutTranscriptNestedInput
  }

  export type TranscriptUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaAssetId?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerVersion?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptText?: StringFieldUpdateOperationsInput | string
    segmentsJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: AIAnalysisUncheckedUpdateManyWithoutTranscriptNestedInput
  }

  export type TranscriptCreateManyInput = {
    id?: string
    mediaAssetId: string
    provider?: string | null
    providerVersion?: string | null
    language?: string | null
    transcriptText: string
    segmentsJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type TranscriptUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerVersion?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptText?: StringFieldUpdateOperationsInput | string
    segmentsJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranscriptUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaAssetId?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerVersion?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptText?: StringFieldUpdateOperationsInput | string
    segmentsJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIAnalysisCreateInput = {
    id?: string
    analysisType?: $Enums.AnalysisType
    contentJson: JsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
    transcript?: TranscriptCreateNestedOneWithoutAnalysesInput
    mediaAsset?: MediaAssetCreateNestedOneWithoutAnalysesInput
    aiRun?: AIRunCreateNestedOneWithoutAnalysesInput
  }

  export type AIAnalysisUncheckedCreateInput = {
    id?: string
    transcriptId?: string | null
    mediaAssetId?: string | null
    aiRunId?: string | null
    analysisType?: $Enums.AnalysisType
    contentJson: JsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
  }

  export type AIAnalysisUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    analysisType?: EnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType
    contentJson?: JsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transcript?: TranscriptUpdateOneWithoutAnalysesNestedInput
    mediaAsset?: MediaAssetUpdateOneWithoutAnalysesNestedInput
    aiRun?: AIRunUpdateOneWithoutAnalysesNestedInput
  }

  export type AIAnalysisUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transcriptId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaAssetId?: NullableStringFieldUpdateOperationsInput | string | null
    aiRunId?: NullableStringFieldUpdateOperationsInput | string | null
    analysisType?: EnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType
    contentJson?: JsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIAnalysisCreateManyInput = {
    id?: string
    transcriptId?: string | null
    mediaAssetId?: string | null
    aiRunId?: string | null
    analysisType?: $Enums.AnalysisType
    contentJson: JsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
  }

  export type AIAnalysisUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    analysisType?: EnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType
    contentJson?: JsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIAnalysisUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    transcriptId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaAssetId?: NullableStringFieldUpdateOperationsInput | string | null
    aiRunId?: NullableStringFieldUpdateOperationsInput | string | null
    analysisType?: EnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType
    contentJson?: JsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoterRegistrationCreateInput = {
    id?: string
    stateVoterId: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    suffix?: string | null
    dateOfBirth?: Date | string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    party?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    voteHistory?: VoteHistoryCreateNestedManyWithoutVoterInput
    segmentMemberships?: SegmentMemberCreateNestedManyWithoutVoterInput
  }

  export type VoterRegistrationUncheckedCreateInput = {
    id?: string
    stateVoterId: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    suffix?: string | null
    dateOfBirth?: Date | string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    party?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    voteHistory?: VoteHistoryUncheckedCreateNestedManyWithoutVoterInput
    segmentMemberships?: SegmentMemberUncheckedCreateNestedManyWithoutVoterInput
  }

  export type VoterRegistrationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stateVoterId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    suffix?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    party?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    voteHistory?: VoteHistoryUpdateManyWithoutVoterNestedInput
    segmentMemberships?: SegmentMemberUpdateManyWithoutVoterNestedInput
  }

  export type VoterRegistrationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stateVoterId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    suffix?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    party?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    voteHistory?: VoteHistoryUncheckedUpdateManyWithoutVoterNestedInput
    segmentMemberships?: SegmentMemberUncheckedUpdateManyWithoutVoterNestedInput
  }

  export type VoterRegistrationCreateManyInput = {
    id?: string
    stateVoterId: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    suffix?: string | null
    dateOfBirth?: Date | string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    party?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VoterRegistrationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stateVoterId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    suffix?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    party?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoterRegistrationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    stateVoterId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    suffix?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    party?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoteHistoryCreateInput = {
    id?: string
    electionDate?: Date | string | null
    electionName?: string | null
    voteType?: string | null
    createdAt?: Date | string
    voter: VoterRegistrationCreateNestedOneWithoutVoteHistoryInput
  }

  export type VoteHistoryUncheckedCreateInput = {
    id?: string
    voterId: string
    electionDate?: Date | string | null
    electionName?: string | null
    voteType?: string | null
    createdAt?: Date | string
  }

  export type VoteHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    electionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    electionName?: NullableStringFieldUpdateOperationsInput | string | null
    voteType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    voter?: VoterRegistrationUpdateOneRequiredWithoutVoteHistoryNestedInput
  }

  export type VoteHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    voterId?: StringFieldUpdateOperationsInput | string
    electionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    electionName?: NullableStringFieldUpdateOperationsInput | string | null
    voteType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoteHistoryCreateManyInput = {
    id?: string
    voterId: string
    electionDate?: Date | string | null
    electionName?: string | null
    voteType?: string | null
    createdAt?: Date | string
  }

  export type VoteHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    electionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    electionName?: NullableStringFieldUpdateOperationsInput | string | null
    voteType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoteHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    voterId?: StringFieldUpdateOperationsInput | string
    electionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    electionName?: NullableStringFieldUpdateOperationsInput | string | null
    voteType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SegmentCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: SegmentMemberCreateNestedManyWithoutSegmentInput
  }

  export type SegmentUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: SegmentMemberUncheckedCreateNestedManyWithoutSegmentInput
  }

  export type SegmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: SegmentMemberUpdateManyWithoutSegmentNestedInput
  }

  export type SegmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: SegmentMemberUncheckedUpdateManyWithoutSegmentNestedInput
  }

  export type SegmentCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SegmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SegmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SegmentMemberCreateInput = {
    id?: string
    createdAt?: Date | string
    segment: SegmentCreateNestedOneWithoutMembersInput
    voter: VoterRegistrationCreateNestedOneWithoutSegmentMembershipsInput
  }

  export type SegmentMemberUncheckedCreateInput = {
    id?: string
    segmentId: string
    voterId: string
    createdAt?: Date | string
  }

  export type SegmentMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    segment?: SegmentUpdateOneRequiredWithoutMembersNestedInput
    voter?: VoterRegistrationUpdateOneRequiredWithoutSegmentMembershipsNestedInput
  }

  export type SegmentMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    segmentId?: StringFieldUpdateOperationsInput | string
    voterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SegmentMemberCreateManyInput = {
    id?: string
    segmentId: string
    voterId: string
    createdAt?: Date | string
  }

  export type SegmentMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SegmentMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    segmentId?: StringFieldUpdateOperationsInput | string
    voterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImportJobCreateInput = {
    id?: string
    kind?: $Enums.ImportJobKind
    status?: $Enums.ImportJobStatus
    fileName?: string | null
    fileHash?: string | null
    rowCount?: number | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorText?: string | null
    createdAt?: Date | string
    auditLogs?: AuditLogCreateNestedManyWithoutImportJobInput
  }

  export type ImportJobUncheckedCreateInput = {
    id?: string
    kind?: $Enums.ImportJobKind
    status?: $Enums.ImportJobStatus
    fileName?: string | null
    fileHash?: string | null
    rowCount?: number | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorText?: string | null
    createdAt?: Date | string
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutImportJobInput
  }

  export type ImportJobUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumImportJobKindFieldUpdateOperationsInput | $Enums.ImportJobKind
    status?: EnumImportJobStatusFieldUpdateOperationsInput | $Enums.ImportJobStatus
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileHash?: NullableStringFieldUpdateOperationsInput | string | null
    rowCount?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUpdateManyWithoutImportJobNestedInput
  }

  export type ImportJobUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumImportJobKindFieldUpdateOperationsInput | $Enums.ImportJobKind
    status?: EnumImportJobStatusFieldUpdateOperationsInput | $Enums.ImportJobStatus
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileHash?: NullableStringFieldUpdateOperationsInput | string | null
    rowCount?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUncheckedUpdateManyWithoutImportJobNestedInput
  }

  export type ImportJobCreateManyInput = {
    id?: string
    kind?: $Enums.ImportJobKind
    status?: $Enums.ImportJobStatus
    fileName?: string | null
    fileHash?: string | null
    rowCount?: number | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorText?: string | null
    createdAt?: Date | string
  }

  export type ImportJobUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumImportJobKindFieldUpdateOperationsInput | $Enums.ImportJobKind
    status?: EnumImportJobStatusFieldUpdateOperationsInput | $Enums.ImportJobStatus
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileHash?: NullableStringFieldUpdateOperationsInput | string | null
    rowCount?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImportJobUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumImportJobKindFieldUpdateOperationsInput | $Enums.ImportJobKind
    status?: EnumImportJobStatusFieldUpdateOperationsInput | $Enums.ImportJobStatus
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileHash?: NullableStringFieldUpdateOperationsInput | string | null
    rowCount?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    actorLabel?: string | null
    action: string
    entityType?: string | null
    entityId?: string | null
    metadataJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    importJob?: ImportJobCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    actorLabel?: string | null
    action: string
    entityType?: string | null
    entityId?: string | null
    metadataJson?: NullableJsonNullValueInput | InputJsonValue
    importJobId?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorLabel?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadataJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    importJob?: ImportJobUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorLabel?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadataJson?: NullableJsonNullValueInput | InputJsonValue
    importJobId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    actorLabel?: string | null
    action: string
    entityType?: string | null
    entityId?: string | null
    metadataJson?: NullableJsonNullValueInput | InputJsonValue
    importJobId?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorLabel?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadataJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorLabel?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadataJson?: NullableJsonNullValueInput | InputJsonValue
    importJobId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BlueprintSectionListRelationFilter = {
    every?: BlueprintSectionWhereInput
    some?: BlueprintSectionWhereInput
    none?: BlueprintSectionWhereInput
  }

  export type QuoteListRelationFilter = {
    every?: QuoteWhereInput
    some?: QuoteWhereInput
    none?: QuoteWhereInput
  }

  export type AssetListRelationFilter = {
    every?: AssetWhereInput
    some?: AssetWhereInput
    none?: AssetWhereInput
  }

  export type CountyIssueListRelationFilter = {
    every?: CountyIssueWhereInput
    some?: CountyIssueWhereInput
    none?: CountyIssueWhereInput
  }

  export type CensusMetricListRelationFilter = {
    every?: CensusMetricWhereInput
    some?: CensusMetricWhereInput
    none?: CensusMetricWhereInput
  }

  export type BLSMetricListRelationFilter = {
    every?: BLSMetricWhereInput
    some?: BLSMetricWhereInput
    none?: BLSMetricWhereInput
  }

  export type CivicsOfficialListRelationFilter = {
    every?: CivicsOfficialWhereInput
    some?: CivicsOfficialWhereInput
    none?: CivicsOfficialWhereInput
  }

  export type ElectionResultListRelationFilter = {
    every?: ElectionResultWhereInput
    some?: ElectionResultWhereInput
    none?: ElectionResultWhereInput
  }

  export type SurveyFormListRelationFilter = {
    every?: SurveyFormWhereInput
    some?: SurveyFormWhereInput
    none?: SurveyFormWhereInput
  }

  export type SurveyResponseListRelationFilter = {
    every?: SurveyResponseWhereInput
    some?: SurveyResponseWhereInput
    none?: SurveyResponseWhereInput
  }

  export type AIOutputScopeListRelationFilter = {
    every?: AIOutputScopeWhereInput
    some?: AIOutputScopeWhereInput
    none?: AIOutputScopeWhereInput
  }

  export type SourceDocumentLinkListRelationFilter = {
    every?: SourceDocumentLinkWhereInput
    some?: SourceDocumentLinkWhereInput
    none?: SourceDocumentLinkWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type BlueprintSectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CountyIssueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CensusMetricOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BLSMetricOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CivicsOfficialOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ElectionResultOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SurveyFormOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SurveyResponseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AIOutputScopeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SourceDocumentLinkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CountyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    fipsCode?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CountyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    fipsCode?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CountyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    fipsCode?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IssueCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    summary?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IssueMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    summary?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IssueMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    summary?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type CountyScalarRelationFilter = {
    is?: CountyWhereInput
    isNot?: CountyWhereInput
  }

  export type IssueScalarRelationFilter = {
    is?: IssueWhereInput
    isNot?: IssueWhereInput
  }

  export type CountyIssueCountyIdIssueIdCompoundUniqueInput = {
    countyId: string
    issueId: string
  }

  export type CountyIssueCountOrderByAggregateInput = {
    id?: SortOrder
    countyId?: SortOrder
    issueId?: SortOrder
    featured?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
  }

  export type CountyIssueAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type CountyIssueMaxOrderByAggregateInput = {
    id?: SortOrder
    countyId?: SortOrder
    issueId?: SortOrder
    featured?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
  }

  export type CountyIssueMinOrderByAggregateInput = {
    id?: SortOrder
    countyId?: SortOrder
    issueId?: SortOrder
    featured?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
  }

  export type CountyIssueSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type CountyNullableScalarRelationFilter = {
    is?: CountyWhereInput | null
    isNot?: CountyWhereInput | null
  }

  export type IssueNullableScalarRelationFilter = {
    is?: IssueWhereInput | null
    isNot?: IssueWhereInput | null
  }

  export type BlueprintSectionCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    bodyMd?: SortOrder
    countyId?: SortOrder
    issueId?: SortOrder
    sortOrder?: SortOrder
    isPinned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlueprintSectionAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type BlueprintSectionMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    bodyMd?: SortOrder
    countyId?: SortOrder
    issueId?: SortOrder
    sortOrder?: SortOrder
    isPinned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlueprintSectionMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    bodyMd?: SortOrder
    countyId?: SortOrder
    issueId?: SortOrder
    sortOrder?: SortOrder
    isPinned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlueprintSectionSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type QuoteCountOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    attributionLabel?: SortOrder
    countyId?: SortOrder
    issueId?: SortOrder
    sourceNote?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuoteMaxOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    attributionLabel?: SortOrder
    countyId?: SortOrder
    issueId?: SortOrder
    sourceNote?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuoteMinOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    attributionLabel?: SortOrder
    countyId?: SortOrder
    issueId?: SortOrder
    sourceNote?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAssetTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetType | EnumAssetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AssetType[] | ListEnumAssetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssetType[] | ListEnumAssetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAssetTypeFilter<$PrismaModel> | $Enums.AssetType
  }

  export type AssetCountOrderByAggregateInput = {
    id?: SortOrder
    assetType?: SortOrder
    title?: SortOrder
    caption?: SortOrder
    credit?: SortOrder
    license?: SortOrder
    url?: SortOrder
    storageKey?: SortOrder
    countyId?: SortOrder
    issueId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssetMaxOrderByAggregateInput = {
    id?: SortOrder
    assetType?: SortOrder
    title?: SortOrder
    caption?: SortOrder
    credit?: SortOrder
    license?: SortOrder
    url?: SortOrder
    storageKey?: SortOrder
    countyId?: SortOrder
    issueId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssetMinOrderByAggregateInput = {
    id?: SortOrder
    assetType?: SortOrder
    title?: SortOrder
    caption?: SortOrder
    credit?: SortOrder
    license?: SortOrder
    url?: SortOrder
    storageKey?: SortOrder
    countyId?: SortOrder
    issueId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAssetTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetType | EnumAssetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AssetType[] | ListEnumAssetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssetType[] | ListEnumAssetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAssetTypeWithAggregatesFilter<$PrismaModel> | $Enums.AssetType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAssetTypeFilter<$PrismaModel>
    _max?: NestedEnumAssetTypeFilter<$PrismaModel>
  }

  export type GlossaryTermCountOrderByAggregateInput = {
    id?: SortOrder
    term?: SortOrder
    slug?: SortOrder
    definitionMd?: SortOrder
    examplesMd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GlossaryTermMaxOrderByAggregateInput = {
    id?: SortOrder
    term?: SortOrder
    slug?: SortOrder
    definitionMd?: SortOrder
    examplesMd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GlossaryTermMinOrderByAggregateInput = {
    id?: SortOrder
    term?: SortOrder
    slug?: SortOrder
    definitionMd?: SortOrder
    examplesMd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type SourceChunkListRelationFilter = {
    every?: SourceChunkWhereInput
    some?: SourceChunkWhereInput
    none?: SourceChunkWhereInput
  }

  export type CitationListRelationFilter = {
    every?: CitationWhereInput
    some?: CitationWhereInput
    none?: CitationWhereInput
  }

  export type AIRunInputSourceListRelationFilter = {
    every?: AIRunInputSourceWhereInput
    some?: AIRunInputSourceWhereInput
    none?: AIRunInputSourceWhereInput
  }

  export type SourceChunkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CitationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AIRunInputSourceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SourceDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    url?: SortOrder
    storageKey?: SortOrder
    publisher?: SortOrder
    publishedAt?: SortOrder
    capturedAt?: SortOrder
    methodNote?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SourceDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    url?: SortOrder
    storageKey?: SortOrder
    publisher?: SortOrder
    publishedAt?: SortOrder
    capturedAt?: SortOrder
    methodNote?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SourceDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    url?: SortOrder
    storageKey?: SortOrder
    publisher?: SortOrder
    publishedAt?: SortOrder
    capturedAt?: SortOrder
    methodNote?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type SourceDocumentScalarRelationFilter = {
    is?: SourceDocumentWhereInput
    isNot?: SourceDocumentWhereInput
  }

  export type SourceChunkSourceDocumentIdChunkIndexCompoundUniqueInput = {
    sourceDocumentId: string
    chunkIndex: number
  }

  export type SourceChunkCountOrderByAggregateInput = {
    id?: SortOrder
    sourceDocumentId?: SortOrder
    chunkIndex?: SortOrder
    content?: SortOrder
    contentHash?: SortOrder
    locatorJson?: SortOrder
    createdAt?: SortOrder
  }

  export type SourceChunkAvgOrderByAggregateInput = {
    chunkIndex?: SortOrder
  }

  export type SourceChunkMaxOrderByAggregateInput = {
    id?: SortOrder
    sourceDocumentId?: SortOrder
    chunkIndex?: SortOrder
    content?: SortOrder
    contentHash?: SortOrder
    createdAt?: SortOrder
  }

  export type SourceChunkMinOrderByAggregateInput = {
    id?: SortOrder
    sourceDocumentId?: SortOrder
    chunkIndex?: SortOrder
    content?: SortOrder
    contentHash?: SortOrder
    createdAt?: SortOrder
  }

  export type SourceChunkSumOrderByAggregateInput = {
    chunkIndex?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type BlueprintSectionNullableScalarRelationFilter = {
    is?: BlueprintSectionWhereInput | null
    isNot?: BlueprintSectionWhereInput | null
  }

  export type QuoteNullableScalarRelationFilter = {
    is?: QuoteWhereInput | null
    isNot?: QuoteWhereInput | null
  }

  export type AssetNullableScalarRelationFilter = {
    is?: AssetWhereInput | null
    isNot?: AssetWhereInput | null
  }

  export type SurveyFormNullableScalarRelationFilter = {
    is?: SurveyFormWhereInput | null
    isNot?: SurveyFormWhereInput | null
  }

  export type SourceDocumentLinkCountOrderByAggregateInput = {
    id?: SortOrder
    sourceDocumentId?: SortOrder
    countyId?: SortOrder
    issueId?: SortOrder
    blueprintSectionId?: SortOrder
    quoteId?: SortOrder
    assetId?: SortOrder
    surveyFormId?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type SourceDocumentLinkMaxOrderByAggregateInput = {
    id?: SortOrder
    sourceDocumentId?: SortOrder
    countyId?: SortOrder
    issueId?: SortOrder
    blueprintSectionId?: SortOrder
    quoteId?: SortOrder
    assetId?: SortOrder
    surveyFormId?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type SourceDocumentLinkMinOrderByAggregateInput = {
    id?: SortOrder
    sourceDocumentId?: SortOrder
    countyId?: SortOrder
    issueId?: SortOrder
    blueprintSectionId?: SortOrder
    quoteId?: SortOrder
    assetId?: SortOrder
    surveyFormId?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type GeoCountyCountOrderByAggregateInput = {
    id?: SortOrder
    fipsCode?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type GeoCountyMaxOrderByAggregateInput = {
    id?: SortOrder
    fipsCode?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type GeoCountyMinOrderByAggregateInput = {
    id?: SortOrder
    fipsCode?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type GeoZipCountOrderByAggregateInput = {
    id?: SortOrder
    zipCode?: SortOrder
    createdAt?: SortOrder
  }

  export type GeoZipMaxOrderByAggregateInput = {
    id?: SortOrder
    zipCode?: SortOrder
    createdAt?: SortOrder
  }

  export type GeoZipMinOrderByAggregateInput = {
    id?: SortOrder
    zipCode?: SortOrder
    createdAt?: SortOrder
  }

  export type GeoPrecinctCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    precinctCode?: SortOrder
    createdAt?: SortOrder
  }

  export type GeoPrecinctMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    precinctCode?: SortOrder
    createdAt?: SortOrder
  }

  export type GeoPrecinctMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    precinctCode?: SortOrder
    createdAt?: SortOrder
  }

  export type GeoDistrictCountOrderByAggregateInput = {
    id?: SortOrder
    districtCode?: SortOrder
    districtType?: SortOrder
    createdAt?: SortOrder
  }

  export type GeoDistrictMaxOrderByAggregateInput = {
    id?: SortOrder
    districtCode?: SortOrder
    districtType?: SortOrder
    createdAt?: SortOrder
  }

  export type GeoDistrictMinOrderByAggregateInput = {
    id?: SortOrder
    districtCode?: SortOrder
    districtType?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumCrosswalkTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CrosswalkType | EnumCrosswalkTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CrosswalkType[] | ListEnumCrosswalkTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CrosswalkType[] | ListEnumCrosswalkTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCrosswalkTypeFilter<$PrismaModel> | $Enums.CrosswalkType
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type GeoCrosswalkCountOrderByAggregateInput = {
    id?: SortOrder
    crosswalkType?: SortOrder
    fromGeoZipId?: SortOrder
    fromGeoPrecinctId?: SortOrder
    fromGeoDistrictId?: SortOrder
    fromGeoCountyFips?: SortOrder
    toGeoZipId?: SortOrder
    toGeoPrecinctId?: SortOrder
    toGeoDistrictId?: SortOrder
    toGeoCountyFips?: SortOrder
    weight?: SortOrder
    createdAt?: SortOrder
  }

  export type GeoCrosswalkAvgOrderByAggregateInput = {
    weight?: SortOrder
  }

  export type GeoCrosswalkMaxOrderByAggregateInput = {
    id?: SortOrder
    crosswalkType?: SortOrder
    fromGeoZipId?: SortOrder
    fromGeoPrecinctId?: SortOrder
    fromGeoDistrictId?: SortOrder
    fromGeoCountyFips?: SortOrder
    toGeoZipId?: SortOrder
    toGeoPrecinctId?: SortOrder
    toGeoDistrictId?: SortOrder
    toGeoCountyFips?: SortOrder
    weight?: SortOrder
    createdAt?: SortOrder
  }

  export type GeoCrosswalkMinOrderByAggregateInput = {
    id?: SortOrder
    crosswalkType?: SortOrder
    fromGeoZipId?: SortOrder
    fromGeoPrecinctId?: SortOrder
    fromGeoDistrictId?: SortOrder
    fromGeoCountyFips?: SortOrder
    toGeoZipId?: SortOrder
    toGeoPrecinctId?: SortOrder
    toGeoDistrictId?: SortOrder
    toGeoCountyFips?: SortOrder
    weight?: SortOrder
    createdAt?: SortOrder
  }

  export type GeoCrosswalkSumOrderByAggregateInput = {
    weight?: SortOrder
  }

  export type EnumCrosswalkTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CrosswalkType | EnumCrosswalkTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CrosswalkType[] | ListEnumCrosswalkTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CrosswalkType[] | ListEnumCrosswalkTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCrosswalkTypeWithAggregatesFilter<$PrismaModel> | $Enums.CrosswalkType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCrosswalkTypeFilter<$PrismaModel>
    _max?: NestedEnumCrosswalkTypeFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type GeoZipNullableScalarRelationFilter = {
    is?: GeoZipWhereInput | null
    isNot?: GeoZipWhereInput | null
  }

  export type CensusMetricCountOrderByAggregateInput = {
    id?: SortOrder
    countyId?: SortOrder
    geoZipId?: SortOrder
    metricKey?: SortOrder
    metricLabel?: SortOrder
    value?: SortOrder
    valueText?: SortOrder
    asOfDate?: SortOrder
    sourceNote?: SortOrder
    createdAt?: SortOrder
  }

  export type CensusMetricAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type CensusMetricMaxOrderByAggregateInput = {
    id?: SortOrder
    countyId?: SortOrder
    geoZipId?: SortOrder
    metricKey?: SortOrder
    metricLabel?: SortOrder
    value?: SortOrder
    valueText?: SortOrder
    asOfDate?: SortOrder
    sourceNote?: SortOrder
    createdAt?: SortOrder
  }

  export type CensusMetricMinOrderByAggregateInput = {
    id?: SortOrder
    countyId?: SortOrder
    geoZipId?: SortOrder
    metricKey?: SortOrder
    metricLabel?: SortOrder
    value?: SortOrder
    valueText?: SortOrder
    asOfDate?: SortOrder
    sourceNote?: SortOrder
    createdAt?: SortOrder
  }

  export type CensusMetricSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type BLSMetricCountOrderByAggregateInput = {
    id?: SortOrder
    countyId?: SortOrder
    seriesKey?: SortOrder
    seriesLabel?: SortOrder
    value?: SortOrder
    asOfDate?: SortOrder
    sourceNote?: SortOrder
    createdAt?: SortOrder
  }

  export type BLSMetricAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type BLSMetricMaxOrderByAggregateInput = {
    id?: SortOrder
    countyId?: SortOrder
    seriesKey?: SortOrder
    seriesLabel?: SortOrder
    value?: SortOrder
    asOfDate?: SortOrder
    sourceNote?: SortOrder
    createdAt?: SortOrder
  }

  export type BLSMetricMinOrderByAggregateInput = {
    id?: SortOrder
    countyId?: SortOrder
    seriesKey?: SortOrder
    seriesLabel?: SortOrder
    value?: SortOrder
    asOfDate?: SortOrder
    sourceNote?: SortOrder
    createdAt?: SortOrder
  }

  export type BLSMetricSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type GeoDistrictNullableScalarRelationFilter = {
    is?: GeoDistrictWhereInput | null
    isNot?: GeoDistrictWhereInput | null
  }

  export type CivicsOfficialCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    officeName?: SortOrder
    party?: SortOrder
    phone?: SortOrder
    website?: SortOrder
    photoUrl?: SortOrder
    countyId?: SortOrder
    districtId?: SortOrder
    sourceNote?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CivicsOfficialMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    officeName?: SortOrder
    party?: SortOrder
    phone?: SortOrder
    website?: SortOrder
    photoUrl?: SortOrder
    countyId?: SortOrder
    districtId?: SortOrder
    sourceNote?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CivicsOfficialMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    officeName?: SortOrder
    party?: SortOrder
    phone?: SortOrder
    website?: SortOrder
    photoUrl?: SortOrder
    countyId?: SortOrder
    districtId?: SortOrder
    sourceNote?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ElectionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    electionDate?: SortOrder
    electionType?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type ElectionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    electionDate?: SortOrder
    electionType?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type ElectionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    electionDate?: SortOrder
    electionType?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type ElectionScalarRelationFilter = {
    is?: ElectionWhereInput
    isNot?: ElectionWhereInput
  }

  export type GeoPrecinctNullableScalarRelationFilter = {
    is?: GeoPrecinctWhereInput | null
    isNot?: GeoPrecinctWhereInput | null
  }

  export type ElectionResultCountOrderByAggregateInput = {
    id?: SortOrder
    electionId?: SortOrder
    countyId?: SortOrder
    geoZipId?: SortOrder
    precinctId?: SortOrder
    choiceLabel?: SortOrder
    votes?: SortOrder
    voteShare?: SortOrder
    createdAt?: SortOrder
  }

  export type ElectionResultAvgOrderByAggregateInput = {
    votes?: SortOrder
    voteShare?: SortOrder
  }

  export type ElectionResultMaxOrderByAggregateInput = {
    id?: SortOrder
    electionId?: SortOrder
    countyId?: SortOrder
    geoZipId?: SortOrder
    precinctId?: SortOrder
    choiceLabel?: SortOrder
    votes?: SortOrder
    voteShare?: SortOrder
    createdAt?: SortOrder
  }

  export type ElectionResultMinOrderByAggregateInput = {
    id?: SortOrder
    electionId?: SortOrder
    countyId?: SortOrder
    geoZipId?: SortOrder
    precinctId?: SortOrder
    choiceLabel?: SortOrder
    votes?: SortOrder
    voteShare?: SortOrder
    createdAt?: SortOrder
  }

  export type ElectionResultSumOrderByAggregateInput = {
    votes?: SortOrder
    voteShare?: SortOrder
  }

  export type AIRunListRelationFilter = {
    every?: AIRunWhereInput
    some?: AIRunWhereInput
    none?: AIRunWhereInput
  }

  export type AIRunOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AIPromptPromptKeyVersionCompoundUniqueInput = {
    promptKey: string
    version: number
  }

  export type AIPromptCountOrderByAggregateInput = {
    id?: SortOrder
    promptKey?: SortOrder
    version?: SortOrder
    name?: SortOrder
    description?: SortOrder
    template?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIPromptAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type AIPromptMaxOrderByAggregateInput = {
    id?: SortOrder
    promptKey?: SortOrder
    version?: SortOrder
    name?: SortOrder
    description?: SortOrder
    template?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIPromptMinOrderByAggregateInput = {
    id?: SortOrder
    promptKey?: SortOrder
    version?: SortOrder
    name?: SortOrder
    description?: SortOrder
    template?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIPromptSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type EnumAIRunStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AIRunStatus | EnumAIRunStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AIRunStatus[] | ListEnumAIRunStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AIRunStatus[] | ListEnumAIRunStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAIRunStatusFilter<$PrismaModel> | $Enums.AIRunStatus
  }

  export type AIPromptScalarRelationFilter = {
    is?: AIPromptWhereInput
    isNot?: AIPromptWhereInput
  }

  export type AIOutputListRelationFilter = {
    every?: AIOutputWhereInput
    some?: AIOutputWhereInput
    none?: AIOutputWhereInput
  }

  export type AIAnalysisListRelationFilter = {
    every?: AIAnalysisWhereInput
    some?: AIAnalysisWhereInput
    none?: AIAnalysisWhereInput
  }

  export type AIOutputOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AIAnalysisOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AIRunCountOrderByAggregateInput = {
    id?: SortOrder
    promptId?: SortOrder
    model?: SortOrder
    paramsJson?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    errorText?: SortOrder
    inputSummary?: SortOrder
    createdAt?: SortOrder
  }

  export type AIRunMaxOrderByAggregateInput = {
    id?: SortOrder
    promptId?: SortOrder
    model?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    errorText?: SortOrder
    inputSummary?: SortOrder
    createdAt?: SortOrder
  }

  export type AIRunMinOrderByAggregateInput = {
    id?: SortOrder
    promptId?: SortOrder
    model?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    errorText?: SortOrder
    inputSummary?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumAIRunStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AIRunStatus | EnumAIRunStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AIRunStatus[] | ListEnumAIRunStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AIRunStatus[] | ListEnumAIRunStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAIRunStatusWithAggregatesFilter<$PrismaModel> | $Enums.AIRunStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAIRunStatusFilter<$PrismaModel>
    _max?: NestedEnumAIRunStatusFilter<$PrismaModel>
  }

  export type EnumAIRunInputKindFilter<$PrismaModel = never> = {
    equals?: $Enums.AIRunInputKind | EnumAIRunInputKindFieldRefInput<$PrismaModel>
    in?: $Enums.AIRunInputKind[] | ListEnumAIRunInputKindFieldRefInput<$PrismaModel>
    notIn?: $Enums.AIRunInputKind[] | ListEnumAIRunInputKindFieldRefInput<$PrismaModel>
    not?: NestedEnumAIRunInputKindFilter<$PrismaModel> | $Enums.AIRunInputKind
  }

  export type AIRunScalarRelationFilter = {
    is?: AIRunWhereInput
    isNot?: AIRunWhereInput
  }

  export type SourceDocumentNullableScalarRelationFilter = {
    is?: SourceDocumentWhereInput | null
    isNot?: SourceDocumentWhereInput | null
  }

  export type AIRunInputSourceCountOrderByAggregateInput = {
    id?: SortOrder
    runId?: SortOrder
    kind?: SortOrder
    sourceDocumentId?: SortOrder
    externalKey?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type AIRunInputSourceMaxOrderByAggregateInput = {
    id?: SortOrder
    runId?: SortOrder
    kind?: SortOrder
    sourceDocumentId?: SortOrder
    externalKey?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type AIRunInputSourceMinOrderByAggregateInput = {
    id?: SortOrder
    runId?: SortOrder
    kind?: SortOrder
    sourceDocumentId?: SortOrder
    externalKey?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumAIRunInputKindWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AIRunInputKind | EnumAIRunInputKindFieldRefInput<$PrismaModel>
    in?: $Enums.AIRunInputKind[] | ListEnumAIRunInputKindFieldRefInput<$PrismaModel>
    notIn?: $Enums.AIRunInputKind[] | ListEnumAIRunInputKindFieldRefInput<$PrismaModel>
    not?: NestedEnumAIRunInputKindWithAggregatesFilter<$PrismaModel> | $Enums.AIRunInputKind
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAIRunInputKindFilter<$PrismaModel>
    _max?: NestedEnumAIRunInputKindFilter<$PrismaModel>
  }

  export type EnumAIOutputTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AIOutputType | EnumAIOutputTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AIOutputType[] | ListEnumAIOutputTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AIOutputType[] | ListEnumAIOutputTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAIOutputTypeFilter<$PrismaModel> | $Enums.AIOutputType
  }

  export type EnumPublishStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PublishStatus | EnumPublishStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PublishStatus[] | ListEnumPublishStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PublishStatus[] | ListEnumPublishStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPublishStatusFilter<$PrismaModel> | $Enums.PublishStatus
  }

  export type AIOutputSectionListRelationFilter = {
    every?: AIOutputSectionWhereInput
    some?: AIOutputSectionWhereInput
    none?: AIOutputSectionWhereInput
  }

  export type AIOutputSectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AIOutputCountOrderByAggregateInput = {
    id?: SortOrder
    runId?: SortOrder
    outputType?: SortOrder
    status?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    contentMd?: SortOrder
    reviewedAt?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIOutputMaxOrderByAggregateInput = {
    id?: SortOrder
    runId?: SortOrder
    outputType?: SortOrder
    status?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    contentMd?: SortOrder
    reviewedAt?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIOutputMinOrderByAggregateInput = {
    id?: SortOrder
    runId?: SortOrder
    outputType?: SortOrder
    status?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    contentMd?: SortOrder
    reviewedAt?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAIOutputTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AIOutputType | EnumAIOutputTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AIOutputType[] | ListEnumAIOutputTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AIOutputType[] | ListEnumAIOutputTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAIOutputTypeWithAggregatesFilter<$PrismaModel> | $Enums.AIOutputType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAIOutputTypeFilter<$PrismaModel>
    _max?: NestedEnumAIOutputTypeFilter<$PrismaModel>
  }

  export type EnumPublishStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PublishStatus | EnumPublishStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PublishStatus[] | ListEnumPublishStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PublishStatus[] | ListEnumPublishStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPublishStatusWithAggregatesFilter<$PrismaModel> | $Enums.PublishStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPublishStatusFilter<$PrismaModel>
    _max?: NestedEnumPublishStatusFilter<$PrismaModel>
  }

  export type AIOutputScalarRelationFilter = {
    is?: AIOutputWhereInput
    isNot?: AIOutputWhereInput
  }

  export type AIOutputSectionOutputIdSectionKeyCompoundUniqueInput = {
    outputId: string
    sectionKey: string
  }

  export type AIOutputSectionCountOrderByAggregateInput = {
    id?: SortOrder
    outputId?: SortOrder
    sectionKey?: SortOrder
    heading?: SortOrder
    order?: SortOrder
    contentMd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIOutputSectionAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type AIOutputSectionMaxOrderByAggregateInput = {
    id?: SortOrder
    outputId?: SortOrder
    sectionKey?: SortOrder
    heading?: SortOrder
    order?: SortOrder
    contentMd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIOutputSectionMinOrderByAggregateInput = {
    id?: SortOrder
    outputId?: SortOrder
    sectionKey?: SortOrder
    heading?: SortOrder
    order?: SortOrder
    contentMd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIOutputSectionSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EnumAIScopeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AIScopeType | EnumAIScopeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AIScopeType[] | ListEnumAIScopeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AIScopeType[] | ListEnumAIScopeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAIScopeTypeFilter<$PrismaModel> | $Enums.AIScopeType
  }

  export type AIOutputScopeCountOrderByAggregateInput = {
    id?: SortOrder
    outputId?: SortOrder
    scopeType?: SortOrder
    countyId?: SortOrder
    issueId?: SortOrder
    geoZipId?: SortOrder
    districtId?: SortOrder
    customKey?: SortOrder
    createdAt?: SortOrder
  }

  export type AIOutputScopeMaxOrderByAggregateInput = {
    id?: SortOrder
    outputId?: SortOrder
    scopeType?: SortOrder
    countyId?: SortOrder
    issueId?: SortOrder
    geoZipId?: SortOrder
    districtId?: SortOrder
    customKey?: SortOrder
    createdAt?: SortOrder
  }

  export type AIOutputScopeMinOrderByAggregateInput = {
    id?: SortOrder
    outputId?: SortOrder
    scopeType?: SortOrder
    countyId?: SortOrder
    issueId?: SortOrder
    geoZipId?: SortOrder
    districtId?: SortOrder
    customKey?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumAIScopeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AIScopeType | EnumAIScopeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AIScopeType[] | ListEnumAIScopeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AIScopeType[] | ListEnumAIScopeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAIScopeTypeWithAggregatesFilter<$PrismaModel> | $Enums.AIScopeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAIScopeTypeFilter<$PrismaModel>
    _max?: NestedEnumAIScopeTypeFilter<$PrismaModel>
  }

  export type AIOutputSectionScalarRelationFilter = {
    is?: AIOutputSectionWhereInput
    isNot?: AIOutputSectionWhereInput
  }

  export type SourceChunkNullableScalarRelationFilter = {
    is?: SourceChunkWhereInput | null
    isNot?: SourceChunkWhereInput | null
  }

  export type CitationCountOrderByAggregateInput = {
    id?: SortOrder
    outputSectionId?: SortOrder
    sourceChunkId?: SortOrder
    sourceDocumentId?: SortOrder
    label?: SortOrder
    locatorJson?: SortOrder
    createdAt?: SortOrder
  }

  export type CitationMaxOrderByAggregateInput = {
    id?: SortOrder
    outputSectionId?: SortOrder
    sourceChunkId?: SortOrder
    sourceDocumentId?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
  }

  export type CitationMinOrderByAggregateInput = {
    id?: SortOrder
    outputSectionId?: SortOrder
    sourceChunkId?: SortOrder
    sourceDocumentId?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumSurveyFormStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SurveyFormStatus | EnumSurveyFormStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SurveyFormStatus[] | ListEnumSurveyFormStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SurveyFormStatus[] | ListEnumSurveyFormStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSurveyFormStatusFilter<$PrismaModel> | $Enums.SurveyFormStatus
  }

  export type SurveyQuestionListRelationFilter = {
    every?: SurveyQuestionWhereInput
    some?: SurveyQuestionWhereInput
    none?: SurveyQuestionWhereInput
  }

  export type SurveyQuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SurveyFormCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    descriptionMd?: SortOrder
    slug?: SortOrder
    status?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    countyId?: SortOrder
    contextLabel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SurveyFormMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    descriptionMd?: SortOrder
    slug?: SortOrder
    status?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    countyId?: SortOrder
    contextLabel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SurveyFormMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    descriptionMd?: SortOrder
    slug?: SortOrder
    status?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    countyId?: SortOrder
    contextLabel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSurveyFormStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SurveyFormStatus | EnumSurveyFormStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SurveyFormStatus[] | ListEnumSurveyFormStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SurveyFormStatus[] | ListEnumSurveyFormStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSurveyFormStatusWithAggregatesFilter<$PrismaModel> | $Enums.SurveyFormStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSurveyFormStatusFilter<$PrismaModel>
    _max?: NestedEnumSurveyFormStatusFilter<$PrismaModel>
  }

  export type EnumSurveyQuestionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SurveyQuestionType | EnumSurveyQuestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SurveyQuestionType[] | ListEnumSurveyQuestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SurveyQuestionType[] | ListEnumSurveyQuestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSurveyQuestionTypeFilter<$PrismaModel> | $Enums.SurveyQuestionType
  }

  export type SurveyFormScalarRelationFilter = {
    is?: SurveyFormWhereInput
    isNot?: SurveyFormWhereInput
  }

  export type SurveyQuestionOptionListRelationFilter = {
    every?: SurveyQuestionOptionWhereInput
    some?: SurveyQuestionOptionWhereInput
    none?: SurveyQuestionOptionWhereInput
  }

  export type SurveyResponseItemListRelationFilter = {
    every?: SurveyResponseItemWhereInput
    some?: SurveyResponseItemWhereInput
    none?: SurveyResponseItemWhereInput
  }

  export type SurveyQuestionOptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SurveyResponseItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SurveyQuestionFormIdQuestionKeyCompoundUniqueInput = {
    formId: string
    questionKey: string
  }

  export type SurveyQuestionCountOrderByAggregateInput = {
    id?: SortOrder
    formId?: SortOrder
    questionKey?: SortOrder
    prompt?: SortOrder
    helpText?: SortOrder
    questionType?: SortOrder
    required?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    allowVoice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SurveyQuestionAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type SurveyQuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    formId?: SortOrder
    questionKey?: SortOrder
    prompt?: SortOrder
    helpText?: SortOrder
    questionType?: SortOrder
    required?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    allowVoice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SurveyQuestionMinOrderByAggregateInput = {
    id?: SortOrder
    formId?: SortOrder
    questionKey?: SortOrder
    prompt?: SortOrder
    helpText?: SortOrder
    questionType?: SortOrder
    required?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    allowVoice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SurveyQuestionSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type EnumSurveyQuestionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SurveyQuestionType | EnumSurveyQuestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SurveyQuestionType[] | ListEnumSurveyQuestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SurveyQuestionType[] | ListEnumSurveyQuestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSurveyQuestionTypeWithAggregatesFilter<$PrismaModel> | $Enums.SurveyQuestionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSurveyQuestionTypeFilter<$PrismaModel>
    _max?: NestedEnumSurveyQuestionTypeFilter<$PrismaModel>
  }

  export type SurveyQuestionScalarRelationFilter = {
    is?: SurveyQuestionWhereInput
    isNot?: SurveyQuestionWhereInput
  }

  export type SurveyResponseItemOptionListRelationFilter = {
    every?: SurveyResponseItemOptionWhereInput
    some?: SurveyResponseItemOptionWhereInput
    none?: SurveyResponseItemOptionWhereInput
  }

  export type SurveyResponseItemOptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SurveyQuestionOptionQuestionIdValueKeyCompoundUniqueInput = {
    questionId: string
    valueKey: string
  }

  export type SurveyQuestionOptionCountOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    valueKey?: SortOrder
    label?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type SurveyQuestionOptionAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type SurveyQuestionOptionMaxOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    valueKey?: SortOrder
    label?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type SurveyQuestionOptionMinOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    valueKey?: SortOrder
    label?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type SurveyQuestionOptionSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type SurveyResponseCountOrderByAggregateInput = {
    id?: SortOrder
    formId?: SortOrder
    countyId?: SortOrder
    sourceLabel?: SortOrder
    submittedAt?: SortOrder
    ipHash?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type SurveyResponseMaxOrderByAggregateInput = {
    id?: SortOrder
    formId?: SortOrder
    countyId?: SortOrder
    sourceLabel?: SortOrder
    submittedAt?: SortOrder
    ipHash?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type SurveyResponseMinOrderByAggregateInput = {
    id?: SortOrder
    formId?: SortOrder
    countyId?: SortOrder
    sourceLabel?: SortOrder
    submittedAt?: SortOrder
    ipHash?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type SurveyResponseScalarRelationFilter = {
    is?: SurveyResponseWhereInput
    isNot?: SurveyResponseWhereInput
  }

  export type SurveyQuestionOptionNullableScalarRelationFilter = {
    is?: SurveyQuestionOptionWhereInput | null
    isNot?: SurveyQuestionOptionWhereInput | null
  }

  export type MediaAssetNullableScalarRelationFilter = {
    is?: MediaAssetWhereInput | null
    isNot?: MediaAssetWhereInput | null
  }

  export type SurveyResponseItemCountOrderByAggregateInput = {
    id?: SortOrder
    responseId?: SortOrder
    questionId?: SortOrder
    valueText?: SortOrder
    valueNumber?: SortOrder
    valueBoolean?: SortOrder
    selectedOptionId?: SortOrder
    mediaAssetId?: SortOrder
    createdAt?: SortOrder
  }

  export type SurveyResponseItemAvgOrderByAggregateInput = {
    valueNumber?: SortOrder
  }

  export type SurveyResponseItemMaxOrderByAggregateInput = {
    id?: SortOrder
    responseId?: SortOrder
    questionId?: SortOrder
    valueText?: SortOrder
    valueNumber?: SortOrder
    valueBoolean?: SortOrder
    selectedOptionId?: SortOrder
    mediaAssetId?: SortOrder
    createdAt?: SortOrder
  }

  export type SurveyResponseItemMinOrderByAggregateInput = {
    id?: SortOrder
    responseId?: SortOrder
    questionId?: SortOrder
    valueText?: SortOrder
    valueNumber?: SortOrder
    valueBoolean?: SortOrder
    selectedOptionId?: SortOrder
    mediaAssetId?: SortOrder
    createdAt?: SortOrder
  }

  export type SurveyResponseItemSumOrderByAggregateInput = {
    valueNumber?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type SurveyResponseItemScalarRelationFilter = {
    is?: SurveyResponseItemWhereInput
    isNot?: SurveyResponseItemWhereInput
  }

  export type SurveyQuestionOptionScalarRelationFilter = {
    is?: SurveyQuestionOptionWhereInput
    isNot?: SurveyQuestionOptionWhereInput
  }

  export type SurveyResponseItemOptionResponseItemIdOptionIdCompoundUniqueInput = {
    responseItemId: string
    optionId: string
  }

  export type SurveyResponseItemOptionCountOrderByAggregateInput = {
    id?: SortOrder
    responseItemId?: SortOrder
    optionId?: SortOrder
    createdAt?: SortOrder
  }

  export type SurveyResponseItemOptionMaxOrderByAggregateInput = {
    id?: SortOrder
    responseItemId?: SortOrder
    optionId?: SortOrder
    createdAt?: SortOrder
  }

  export type SurveyResponseItemOptionMinOrderByAggregateInput = {
    id?: SortOrder
    responseItemId?: SortOrder
    optionId?: SortOrder
    createdAt?: SortOrder
  }

  export type TranscriptListRelationFilter = {
    every?: TranscriptWhereInput
    some?: TranscriptWhereInput
    none?: TranscriptWhereInput
  }

  export type TranscriptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MediaAssetCountOrderByAggregateInput = {
    id?: SortOrder
    assetType?: SortOrder
    storageProvider?: SortOrder
    storageKey?: SortOrder
    url?: SortOrder
    mimeType?: SortOrder
    sizeBytes?: SortOrder
    durationMs?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MediaAssetAvgOrderByAggregateInput = {
    sizeBytes?: SortOrder
    durationMs?: SortOrder
  }

  export type MediaAssetMaxOrderByAggregateInput = {
    id?: SortOrder
    assetType?: SortOrder
    storageProvider?: SortOrder
    storageKey?: SortOrder
    url?: SortOrder
    mimeType?: SortOrder
    sizeBytes?: SortOrder
    durationMs?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MediaAssetMinOrderByAggregateInput = {
    id?: SortOrder
    assetType?: SortOrder
    storageProvider?: SortOrder
    storageKey?: SortOrder
    url?: SortOrder
    mimeType?: SortOrder
    sizeBytes?: SortOrder
    durationMs?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MediaAssetSumOrderByAggregateInput = {
    sizeBytes?: SortOrder
    durationMs?: SortOrder
  }

  export type MediaAssetScalarRelationFilter = {
    is?: MediaAssetWhereInput
    isNot?: MediaAssetWhereInput
  }

  export type TranscriptCountOrderByAggregateInput = {
    id?: SortOrder
    mediaAssetId?: SortOrder
    provider?: SortOrder
    providerVersion?: SortOrder
    language?: SortOrder
    transcriptText?: SortOrder
    segmentsJson?: SortOrder
    createdAt?: SortOrder
  }

  export type TranscriptMaxOrderByAggregateInput = {
    id?: SortOrder
    mediaAssetId?: SortOrder
    provider?: SortOrder
    providerVersion?: SortOrder
    language?: SortOrder
    transcriptText?: SortOrder
    createdAt?: SortOrder
  }

  export type TranscriptMinOrderByAggregateInput = {
    id?: SortOrder
    mediaAssetId?: SortOrder
    provider?: SortOrder
    providerVersion?: SortOrder
    language?: SortOrder
    transcriptText?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumAnalysisTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AnalysisType | EnumAnalysisTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AnalysisType[] | ListEnumAnalysisTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AnalysisType[] | ListEnumAnalysisTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAnalysisTypeFilter<$PrismaModel> | $Enums.AnalysisType
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type TranscriptNullableScalarRelationFilter = {
    is?: TranscriptWhereInput | null
    isNot?: TranscriptWhereInput | null
  }

  export type AIRunNullableScalarRelationFilter = {
    is?: AIRunWhereInput | null
    isNot?: AIRunWhereInput | null
  }

  export type AIAnalysisCountOrderByAggregateInput = {
    id?: SortOrder
    transcriptId?: SortOrder
    mediaAssetId?: SortOrder
    aiRunId?: SortOrder
    analysisType?: SortOrder
    contentJson?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type AIAnalysisMaxOrderByAggregateInput = {
    id?: SortOrder
    transcriptId?: SortOrder
    mediaAssetId?: SortOrder
    aiRunId?: SortOrder
    analysisType?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type AIAnalysisMinOrderByAggregateInput = {
    id?: SortOrder
    transcriptId?: SortOrder
    mediaAssetId?: SortOrder
    aiRunId?: SortOrder
    analysisType?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumAnalysisTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AnalysisType | EnumAnalysisTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AnalysisType[] | ListEnumAnalysisTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AnalysisType[] | ListEnumAnalysisTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAnalysisTypeWithAggregatesFilter<$PrismaModel> | $Enums.AnalysisType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAnalysisTypeFilter<$PrismaModel>
    _max?: NestedEnumAnalysisTypeFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type VoteHistoryListRelationFilter = {
    every?: VoteHistoryWhereInput
    some?: VoteHistoryWhereInput
    none?: VoteHistoryWhereInput
  }

  export type SegmentMemberListRelationFilter = {
    every?: SegmentMemberWhereInput
    some?: SegmentMemberWhereInput
    none?: SegmentMemberWhereInput
  }

  export type VoteHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SegmentMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VoterRegistrationCountOrderByAggregateInput = {
    id?: SortOrder
    stateVoterId?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    suffix?: SortOrder
    dateOfBirth?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    party?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VoterRegistrationMaxOrderByAggregateInput = {
    id?: SortOrder
    stateVoterId?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    suffix?: SortOrder
    dateOfBirth?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    party?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VoterRegistrationMinOrderByAggregateInput = {
    id?: SortOrder
    stateVoterId?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    suffix?: SortOrder
    dateOfBirth?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    party?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VoterRegistrationScalarRelationFilter = {
    is?: VoterRegistrationWhereInput
    isNot?: VoterRegistrationWhereInput
  }

  export type VoteHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    voterId?: SortOrder
    electionDate?: SortOrder
    electionName?: SortOrder
    voteType?: SortOrder
    createdAt?: SortOrder
  }

  export type VoteHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    voterId?: SortOrder
    electionDate?: SortOrder
    electionName?: SortOrder
    voteType?: SortOrder
    createdAt?: SortOrder
  }

  export type VoteHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    voterId?: SortOrder
    electionDate?: SortOrder
    electionName?: SortOrder
    voteType?: SortOrder
    createdAt?: SortOrder
  }

  export type SegmentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SegmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SegmentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SegmentScalarRelationFilter = {
    is?: SegmentWhereInput
    isNot?: SegmentWhereInput
  }

  export type SegmentMemberSegmentIdVoterIdCompoundUniqueInput = {
    segmentId: string
    voterId: string
  }

  export type SegmentMemberCountOrderByAggregateInput = {
    id?: SortOrder
    segmentId?: SortOrder
    voterId?: SortOrder
    createdAt?: SortOrder
  }

  export type SegmentMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    segmentId?: SortOrder
    voterId?: SortOrder
    createdAt?: SortOrder
  }

  export type SegmentMemberMinOrderByAggregateInput = {
    id?: SortOrder
    segmentId?: SortOrder
    voterId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumImportJobKindFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportJobKind | EnumImportJobKindFieldRefInput<$PrismaModel>
    in?: $Enums.ImportJobKind[] | ListEnumImportJobKindFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImportJobKind[] | ListEnumImportJobKindFieldRefInput<$PrismaModel>
    not?: NestedEnumImportJobKindFilter<$PrismaModel> | $Enums.ImportJobKind
  }

  export type EnumImportJobStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportJobStatus | EnumImportJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ImportJobStatus[] | ListEnumImportJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImportJobStatus[] | ListEnumImportJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumImportJobStatusFilter<$PrismaModel> | $Enums.ImportJobStatus
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ImportJobCountOrderByAggregateInput = {
    id?: SortOrder
    kind?: SortOrder
    status?: SortOrder
    fileName?: SortOrder
    fileHash?: SortOrder
    rowCount?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    errorText?: SortOrder
    createdAt?: SortOrder
  }

  export type ImportJobAvgOrderByAggregateInput = {
    rowCount?: SortOrder
  }

  export type ImportJobMaxOrderByAggregateInput = {
    id?: SortOrder
    kind?: SortOrder
    status?: SortOrder
    fileName?: SortOrder
    fileHash?: SortOrder
    rowCount?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    errorText?: SortOrder
    createdAt?: SortOrder
  }

  export type ImportJobMinOrderByAggregateInput = {
    id?: SortOrder
    kind?: SortOrder
    status?: SortOrder
    fileName?: SortOrder
    fileHash?: SortOrder
    rowCount?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    errorText?: SortOrder
    createdAt?: SortOrder
  }

  export type ImportJobSumOrderByAggregateInput = {
    rowCount?: SortOrder
  }

  export type EnumImportJobKindWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportJobKind | EnumImportJobKindFieldRefInput<$PrismaModel>
    in?: $Enums.ImportJobKind[] | ListEnumImportJobKindFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImportJobKind[] | ListEnumImportJobKindFieldRefInput<$PrismaModel>
    not?: NestedEnumImportJobKindWithAggregatesFilter<$PrismaModel> | $Enums.ImportJobKind
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumImportJobKindFilter<$PrismaModel>
    _max?: NestedEnumImportJobKindFilter<$PrismaModel>
  }

  export type EnumImportJobStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportJobStatus | EnumImportJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ImportJobStatus[] | ListEnumImportJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImportJobStatus[] | ListEnumImportJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumImportJobStatusWithAggregatesFilter<$PrismaModel> | $Enums.ImportJobStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumImportJobStatusFilter<$PrismaModel>
    _max?: NestedEnumImportJobStatusFilter<$PrismaModel>
  }

  export type ImportJobNullableScalarRelationFilter = {
    is?: ImportJobWhereInput | null
    isNot?: ImportJobWhereInput | null
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    actorLabel?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    metadataJson?: SortOrder
    importJobId?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    actorLabel?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    importJobId?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    actorLabel?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    importJobId?: SortOrder
    createdAt?: SortOrder
  }

  export type BlueprintSectionCreateNestedManyWithoutCountyInput = {
    create?: XOR<BlueprintSectionCreateWithoutCountyInput, BlueprintSectionUncheckedCreateWithoutCountyInput> | BlueprintSectionCreateWithoutCountyInput[] | BlueprintSectionUncheckedCreateWithoutCountyInput[]
    connectOrCreate?: BlueprintSectionCreateOrConnectWithoutCountyInput | BlueprintSectionCreateOrConnectWithoutCountyInput[]
    createMany?: BlueprintSectionCreateManyCountyInputEnvelope
    connect?: BlueprintSectionWhereUniqueInput | BlueprintSectionWhereUniqueInput[]
  }

  export type QuoteCreateNestedManyWithoutCountyInput = {
    create?: XOR<QuoteCreateWithoutCountyInput, QuoteUncheckedCreateWithoutCountyInput> | QuoteCreateWithoutCountyInput[] | QuoteUncheckedCreateWithoutCountyInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutCountyInput | QuoteCreateOrConnectWithoutCountyInput[]
    createMany?: QuoteCreateManyCountyInputEnvelope
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
  }

  export type AssetCreateNestedManyWithoutCountyInput = {
    create?: XOR<AssetCreateWithoutCountyInput, AssetUncheckedCreateWithoutCountyInput> | AssetCreateWithoutCountyInput[] | AssetUncheckedCreateWithoutCountyInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutCountyInput | AssetCreateOrConnectWithoutCountyInput[]
    createMany?: AssetCreateManyCountyInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type CountyIssueCreateNestedManyWithoutCountyInput = {
    create?: XOR<CountyIssueCreateWithoutCountyInput, CountyIssueUncheckedCreateWithoutCountyInput> | CountyIssueCreateWithoutCountyInput[] | CountyIssueUncheckedCreateWithoutCountyInput[]
    connectOrCreate?: CountyIssueCreateOrConnectWithoutCountyInput | CountyIssueCreateOrConnectWithoutCountyInput[]
    createMany?: CountyIssueCreateManyCountyInputEnvelope
    connect?: CountyIssueWhereUniqueInput | CountyIssueWhereUniqueInput[]
  }

  export type CensusMetricCreateNestedManyWithoutCountyInput = {
    create?: XOR<CensusMetricCreateWithoutCountyInput, CensusMetricUncheckedCreateWithoutCountyInput> | CensusMetricCreateWithoutCountyInput[] | CensusMetricUncheckedCreateWithoutCountyInput[]
    connectOrCreate?: CensusMetricCreateOrConnectWithoutCountyInput | CensusMetricCreateOrConnectWithoutCountyInput[]
    createMany?: CensusMetricCreateManyCountyInputEnvelope
    connect?: CensusMetricWhereUniqueInput | CensusMetricWhereUniqueInput[]
  }

  export type BLSMetricCreateNestedManyWithoutCountyInput = {
    create?: XOR<BLSMetricCreateWithoutCountyInput, BLSMetricUncheckedCreateWithoutCountyInput> | BLSMetricCreateWithoutCountyInput[] | BLSMetricUncheckedCreateWithoutCountyInput[]
    connectOrCreate?: BLSMetricCreateOrConnectWithoutCountyInput | BLSMetricCreateOrConnectWithoutCountyInput[]
    createMany?: BLSMetricCreateManyCountyInputEnvelope
    connect?: BLSMetricWhereUniqueInput | BLSMetricWhereUniqueInput[]
  }

  export type CivicsOfficialCreateNestedManyWithoutCountyInput = {
    create?: XOR<CivicsOfficialCreateWithoutCountyInput, CivicsOfficialUncheckedCreateWithoutCountyInput> | CivicsOfficialCreateWithoutCountyInput[] | CivicsOfficialUncheckedCreateWithoutCountyInput[]
    connectOrCreate?: CivicsOfficialCreateOrConnectWithoutCountyInput | CivicsOfficialCreateOrConnectWithoutCountyInput[]
    createMany?: CivicsOfficialCreateManyCountyInputEnvelope
    connect?: CivicsOfficialWhereUniqueInput | CivicsOfficialWhereUniqueInput[]
  }

  export type ElectionResultCreateNestedManyWithoutCountyInput = {
    create?: XOR<ElectionResultCreateWithoutCountyInput, ElectionResultUncheckedCreateWithoutCountyInput> | ElectionResultCreateWithoutCountyInput[] | ElectionResultUncheckedCreateWithoutCountyInput[]
    connectOrCreate?: ElectionResultCreateOrConnectWithoutCountyInput | ElectionResultCreateOrConnectWithoutCountyInput[]
    createMany?: ElectionResultCreateManyCountyInputEnvelope
    connect?: ElectionResultWhereUniqueInput | ElectionResultWhereUniqueInput[]
  }

  export type SurveyFormCreateNestedManyWithoutCountyInput = {
    create?: XOR<SurveyFormCreateWithoutCountyInput, SurveyFormUncheckedCreateWithoutCountyInput> | SurveyFormCreateWithoutCountyInput[] | SurveyFormUncheckedCreateWithoutCountyInput[]
    connectOrCreate?: SurveyFormCreateOrConnectWithoutCountyInput | SurveyFormCreateOrConnectWithoutCountyInput[]
    createMany?: SurveyFormCreateManyCountyInputEnvelope
    connect?: SurveyFormWhereUniqueInput | SurveyFormWhereUniqueInput[]
  }

  export type SurveyResponseCreateNestedManyWithoutCountyInput = {
    create?: XOR<SurveyResponseCreateWithoutCountyInput, SurveyResponseUncheckedCreateWithoutCountyInput> | SurveyResponseCreateWithoutCountyInput[] | SurveyResponseUncheckedCreateWithoutCountyInput[]
    connectOrCreate?: SurveyResponseCreateOrConnectWithoutCountyInput | SurveyResponseCreateOrConnectWithoutCountyInput[]
    createMany?: SurveyResponseCreateManyCountyInputEnvelope
    connect?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
  }

  export type AIOutputScopeCreateNestedManyWithoutCountyInput = {
    create?: XOR<AIOutputScopeCreateWithoutCountyInput, AIOutputScopeUncheckedCreateWithoutCountyInput> | AIOutputScopeCreateWithoutCountyInput[] | AIOutputScopeUncheckedCreateWithoutCountyInput[]
    connectOrCreate?: AIOutputScopeCreateOrConnectWithoutCountyInput | AIOutputScopeCreateOrConnectWithoutCountyInput[]
    createMany?: AIOutputScopeCreateManyCountyInputEnvelope
    connect?: AIOutputScopeWhereUniqueInput | AIOutputScopeWhereUniqueInput[]
  }

  export type SourceDocumentLinkCreateNestedManyWithoutCountyInput = {
    create?: XOR<SourceDocumentLinkCreateWithoutCountyInput, SourceDocumentLinkUncheckedCreateWithoutCountyInput> | SourceDocumentLinkCreateWithoutCountyInput[] | SourceDocumentLinkUncheckedCreateWithoutCountyInput[]
    connectOrCreate?: SourceDocumentLinkCreateOrConnectWithoutCountyInput | SourceDocumentLinkCreateOrConnectWithoutCountyInput[]
    createMany?: SourceDocumentLinkCreateManyCountyInputEnvelope
    connect?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
  }

  export type BlueprintSectionUncheckedCreateNestedManyWithoutCountyInput = {
    create?: XOR<BlueprintSectionCreateWithoutCountyInput, BlueprintSectionUncheckedCreateWithoutCountyInput> | BlueprintSectionCreateWithoutCountyInput[] | BlueprintSectionUncheckedCreateWithoutCountyInput[]
    connectOrCreate?: BlueprintSectionCreateOrConnectWithoutCountyInput | BlueprintSectionCreateOrConnectWithoutCountyInput[]
    createMany?: BlueprintSectionCreateManyCountyInputEnvelope
    connect?: BlueprintSectionWhereUniqueInput | BlueprintSectionWhereUniqueInput[]
  }

  export type QuoteUncheckedCreateNestedManyWithoutCountyInput = {
    create?: XOR<QuoteCreateWithoutCountyInput, QuoteUncheckedCreateWithoutCountyInput> | QuoteCreateWithoutCountyInput[] | QuoteUncheckedCreateWithoutCountyInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutCountyInput | QuoteCreateOrConnectWithoutCountyInput[]
    createMany?: QuoteCreateManyCountyInputEnvelope
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
  }

  export type AssetUncheckedCreateNestedManyWithoutCountyInput = {
    create?: XOR<AssetCreateWithoutCountyInput, AssetUncheckedCreateWithoutCountyInput> | AssetCreateWithoutCountyInput[] | AssetUncheckedCreateWithoutCountyInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutCountyInput | AssetCreateOrConnectWithoutCountyInput[]
    createMany?: AssetCreateManyCountyInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type CountyIssueUncheckedCreateNestedManyWithoutCountyInput = {
    create?: XOR<CountyIssueCreateWithoutCountyInput, CountyIssueUncheckedCreateWithoutCountyInput> | CountyIssueCreateWithoutCountyInput[] | CountyIssueUncheckedCreateWithoutCountyInput[]
    connectOrCreate?: CountyIssueCreateOrConnectWithoutCountyInput | CountyIssueCreateOrConnectWithoutCountyInput[]
    createMany?: CountyIssueCreateManyCountyInputEnvelope
    connect?: CountyIssueWhereUniqueInput | CountyIssueWhereUniqueInput[]
  }

  export type CensusMetricUncheckedCreateNestedManyWithoutCountyInput = {
    create?: XOR<CensusMetricCreateWithoutCountyInput, CensusMetricUncheckedCreateWithoutCountyInput> | CensusMetricCreateWithoutCountyInput[] | CensusMetricUncheckedCreateWithoutCountyInput[]
    connectOrCreate?: CensusMetricCreateOrConnectWithoutCountyInput | CensusMetricCreateOrConnectWithoutCountyInput[]
    createMany?: CensusMetricCreateManyCountyInputEnvelope
    connect?: CensusMetricWhereUniqueInput | CensusMetricWhereUniqueInput[]
  }

  export type BLSMetricUncheckedCreateNestedManyWithoutCountyInput = {
    create?: XOR<BLSMetricCreateWithoutCountyInput, BLSMetricUncheckedCreateWithoutCountyInput> | BLSMetricCreateWithoutCountyInput[] | BLSMetricUncheckedCreateWithoutCountyInput[]
    connectOrCreate?: BLSMetricCreateOrConnectWithoutCountyInput | BLSMetricCreateOrConnectWithoutCountyInput[]
    createMany?: BLSMetricCreateManyCountyInputEnvelope
    connect?: BLSMetricWhereUniqueInput | BLSMetricWhereUniqueInput[]
  }

  export type CivicsOfficialUncheckedCreateNestedManyWithoutCountyInput = {
    create?: XOR<CivicsOfficialCreateWithoutCountyInput, CivicsOfficialUncheckedCreateWithoutCountyInput> | CivicsOfficialCreateWithoutCountyInput[] | CivicsOfficialUncheckedCreateWithoutCountyInput[]
    connectOrCreate?: CivicsOfficialCreateOrConnectWithoutCountyInput | CivicsOfficialCreateOrConnectWithoutCountyInput[]
    createMany?: CivicsOfficialCreateManyCountyInputEnvelope
    connect?: CivicsOfficialWhereUniqueInput | CivicsOfficialWhereUniqueInput[]
  }

  export type ElectionResultUncheckedCreateNestedManyWithoutCountyInput = {
    create?: XOR<ElectionResultCreateWithoutCountyInput, ElectionResultUncheckedCreateWithoutCountyInput> | ElectionResultCreateWithoutCountyInput[] | ElectionResultUncheckedCreateWithoutCountyInput[]
    connectOrCreate?: ElectionResultCreateOrConnectWithoutCountyInput | ElectionResultCreateOrConnectWithoutCountyInput[]
    createMany?: ElectionResultCreateManyCountyInputEnvelope
    connect?: ElectionResultWhereUniqueInput | ElectionResultWhereUniqueInput[]
  }

  export type SurveyFormUncheckedCreateNestedManyWithoutCountyInput = {
    create?: XOR<SurveyFormCreateWithoutCountyInput, SurveyFormUncheckedCreateWithoutCountyInput> | SurveyFormCreateWithoutCountyInput[] | SurveyFormUncheckedCreateWithoutCountyInput[]
    connectOrCreate?: SurveyFormCreateOrConnectWithoutCountyInput | SurveyFormCreateOrConnectWithoutCountyInput[]
    createMany?: SurveyFormCreateManyCountyInputEnvelope
    connect?: SurveyFormWhereUniqueInput | SurveyFormWhereUniqueInput[]
  }

  export type SurveyResponseUncheckedCreateNestedManyWithoutCountyInput = {
    create?: XOR<SurveyResponseCreateWithoutCountyInput, SurveyResponseUncheckedCreateWithoutCountyInput> | SurveyResponseCreateWithoutCountyInput[] | SurveyResponseUncheckedCreateWithoutCountyInput[]
    connectOrCreate?: SurveyResponseCreateOrConnectWithoutCountyInput | SurveyResponseCreateOrConnectWithoutCountyInput[]
    createMany?: SurveyResponseCreateManyCountyInputEnvelope
    connect?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
  }

  export type AIOutputScopeUncheckedCreateNestedManyWithoutCountyInput = {
    create?: XOR<AIOutputScopeCreateWithoutCountyInput, AIOutputScopeUncheckedCreateWithoutCountyInput> | AIOutputScopeCreateWithoutCountyInput[] | AIOutputScopeUncheckedCreateWithoutCountyInput[]
    connectOrCreate?: AIOutputScopeCreateOrConnectWithoutCountyInput | AIOutputScopeCreateOrConnectWithoutCountyInput[]
    createMany?: AIOutputScopeCreateManyCountyInputEnvelope
    connect?: AIOutputScopeWhereUniqueInput | AIOutputScopeWhereUniqueInput[]
  }

  export type SourceDocumentLinkUncheckedCreateNestedManyWithoutCountyInput = {
    create?: XOR<SourceDocumentLinkCreateWithoutCountyInput, SourceDocumentLinkUncheckedCreateWithoutCountyInput> | SourceDocumentLinkCreateWithoutCountyInput[] | SourceDocumentLinkUncheckedCreateWithoutCountyInput[]
    connectOrCreate?: SourceDocumentLinkCreateOrConnectWithoutCountyInput | SourceDocumentLinkCreateOrConnectWithoutCountyInput[]
    createMany?: SourceDocumentLinkCreateManyCountyInputEnvelope
    connect?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BlueprintSectionUpdateManyWithoutCountyNestedInput = {
    create?: XOR<BlueprintSectionCreateWithoutCountyInput, BlueprintSectionUncheckedCreateWithoutCountyInput> | BlueprintSectionCreateWithoutCountyInput[] | BlueprintSectionUncheckedCreateWithoutCountyInput[]
    connectOrCreate?: BlueprintSectionCreateOrConnectWithoutCountyInput | BlueprintSectionCreateOrConnectWithoutCountyInput[]
    upsert?: BlueprintSectionUpsertWithWhereUniqueWithoutCountyInput | BlueprintSectionUpsertWithWhereUniqueWithoutCountyInput[]
    createMany?: BlueprintSectionCreateManyCountyInputEnvelope
    set?: BlueprintSectionWhereUniqueInput | BlueprintSectionWhereUniqueInput[]
    disconnect?: BlueprintSectionWhereUniqueInput | BlueprintSectionWhereUniqueInput[]
    delete?: BlueprintSectionWhereUniqueInput | BlueprintSectionWhereUniqueInput[]
    connect?: BlueprintSectionWhereUniqueInput | BlueprintSectionWhereUniqueInput[]
    update?: BlueprintSectionUpdateWithWhereUniqueWithoutCountyInput | BlueprintSectionUpdateWithWhereUniqueWithoutCountyInput[]
    updateMany?: BlueprintSectionUpdateManyWithWhereWithoutCountyInput | BlueprintSectionUpdateManyWithWhereWithoutCountyInput[]
    deleteMany?: BlueprintSectionScalarWhereInput | BlueprintSectionScalarWhereInput[]
  }

  export type QuoteUpdateManyWithoutCountyNestedInput = {
    create?: XOR<QuoteCreateWithoutCountyInput, QuoteUncheckedCreateWithoutCountyInput> | QuoteCreateWithoutCountyInput[] | QuoteUncheckedCreateWithoutCountyInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutCountyInput | QuoteCreateOrConnectWithoutCountyInput[]
    upsert?: QuoteUpsertWithWhereUniqueWithoutCountyInput | QuoteUpsertWithWhereUniqueWithoutCountyInput[]
    createMany?: QuoteCreateManyCountyInputEnvelope
    set?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    disconnect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    delete?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    update?: QuoteUpdateWithWhereUniqueWithoutCountyInput | QuoteUpdateWithWhereUniqueWithoutCountyInput[]
    updateMany?: QuoteUpdateManyWithWhereWithoutCountyInput | QuoteUpdateManyWithWhereWithoutCountyInput[]
    deleteMany?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
  }

  export type AssetUpdateManyWithoutCountyNestedInput = {
    create?: XOR<AssetCreateWithoutCountyInput, AssetUncheckedCreateWithoutCountyInput> | AssetCreateWithoutCountyInput[] | AssetUncheckedCreateWithoutCountyInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutCountyInput | AssetCreateOrConnectWithoutCountyInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutCountyInput | AssetUpsertWithWhereUniqueWithoutCountyInput[]
    createMany?: AssetCreateManyCountyInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutCountyInput | AssetUpdateWithWhereUniqueWithoutCountyInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutCountyInput | AssetUpdateManyWithWhereWithoutCountyInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type CountyIssueUpdateManyWithoutCountyNestedInput = {
    create?: XOR<CountyIssueCreateWithoutCountyInput, CountyIssueUncheckedCreateWithoutCountyInput> | CountyIssueCreateWithoutCountyInput[] | CountyIssueUncheckedCreateWithoutCountyInput[]
    connectOrCreate?: CountyIssueCreateOrConnectWithoutCountyInput | CountyIssueCreateOrConnectWithoutCountyInput[]
    upsert?: CountyIssueUpsertWithWhereUniqueWithoutCountyInput | CountyIssueUpsertWithWhereUniqueWithoutCountyInput[]
    createMany?: CountyIssueCreateManyCountyInputEnvelope
    set?: CountyIssueWhereUniqueInput | CountyIssueWhereUniqueInput[]
    disconnect?: CountyIssueWhereUniqueInput | CountyIssueWhereUniqueInput[]
    delete?: CountyIssueWhereUniqueInput | CountyIssueWhereUniqueInput[]
    connect?: CountyIssueWhereUniqueInput | CountyIssueWhereUniqueInput[]
    update?: CountyIssueUpdateWithWhereUniqueWithoutCountyInput | CountyIssueUpdateWithWhereUniqueWithoutCountyInput[]
    updateMany?: CountyIssueUpdateManyWithWhereWithoutCountyInput | CountyIssueUpdateManyWithWhereWithoutCountyInput[]
    deleteMany?: CountyIssueScalarWhereInput | CountyIssueScalarWhereInput[]
  }

  export type CensusMetricUpdateManyWithoutCountyNestedInput = {
    create?: XOR<CensusMetricCreateWithoutCountyInput, CensusMetricUncheckedCreateWithoutCountyInput> | CensusMetricCreateWithoutCountyInput[] | CensusMetricUncheckedCreateWithoutCountyInput[]
    connectOrCreate?: CensusMetricCreateOrConnectWithoutCountyInput | CensusMetricCreateOrConnectWithoutCountyInput[]
    upsert?: CensusMetricUpsertWithWhereUniqueWithoutCountyInput | CensusMetricUpsertWithWhereUniqueWithoutCountyInput[]
    createMany?: CensusMetricCreateManyCountyInputEnvelope
    set?: CensusMetricWhereUniqueInput | CensusMetricWhereUniqueInput[]
    disconnect?: CensusMetricWhereUniqueInput | CensusMetricWhereUniqueInput[]
    delete?: CensusMetricWhereUniqueInput | CensusMetricWhereUniqueInput[]
    connect?: CensusMetricWhereUniqueInput | CensusMetricWhereUniqueInput[]
    update?: CensusMetricUpdateWithWhereUniqueWithoutCountyInput | CensusMetricUpdateWithWhereUniqueWithoutCountyInput[]
    updateMany?: CensusMetricUpdateManyWithWhereWithoutCountyInput | CensusMetricUpdateManyWithWhereWithoutCountyInput[]
    deleteMany?: CensusMetricScalarWhereInput | CensusMetricScalarWhereInput[]
  }

  export type BLSMetricUpdateManyWithoutCountyNestedInput = {
    create?: XOR<BLSMetricCreateWithoutCountyInput, BLSMetricUncheckedCreateWithoutCountyInput> | BLSMetricCreateWithoutCountyInput[] | BLSMetricUncheckedCreateWithoutCountyInput[]
    connectOrCreate?: BLSMetricCreateOrConnectWithoutCountyInput | BLSMetricCreateOrConnectWithoutCountyInput[]
    upsert?: BLSMetricUpsertWithWhereUniqueWithoutCountyInput | BLSMetricUpsertWithWhereUniqueWithoutCountyInput[]
    createMany?: BLSMetricCreateManyCountyInputEnvelope
    set?: BLSMetricWhereUniqueInput | BLSMetricWhereUniqueInput[]
    disconnect?: BLSMetricWhereUniqueInput | BLSMetricWhereUniqueInput[]
    delete?: BLSMetricWhereUniqueInput | BLSMetricWhereUniqueInput[]
    connect?: BLSMetricWhereUniqueInput | BLSMetricWhereUniqueInput[]
    update?: BLSMetricUpdateWithWhereUniqueWithoutCountyInput | BLSMetricUpdateWithWhereUniqueWithoutCountyInput[]
    updateMany?: BLSMetricUpdateManyWithWhereWithoutCountyInput | BLSMetricUpdateManyWithWhereWithoutCountyInput[]
    deleteMany?: BLSMetricScalarWhereInput | BLSMetricScalarWhereInput[]
  }

  export type CivicsOfficialUpdateManyWithoutCountyNestedInput = {
    create?: XOR<CivicsOfficialCreateWithoutCountyInput, CivicsOfficialUncheckedCreateWithoutCountyInput> | CivicsOfficialCreateWithoutCountyInput[] | CivicsOfficialUncheckedCreateWithoutCountyInput[]
    connectOrCreate?: CivicsOfficialCreateOrConnectWithoutCountyInput | CivicsOfficialCreateOrConnectWithoutCountyInput[]
    upsert?: CivicsOfficialUpsertWithWhereUniqueWithoutCountyInput | CivicsOfficialUpsertWithWhereUniqueWithoutCountyInput[]
    createMany?: CivicsOfficialCreateManyCountyInputEnvelope
    set?: CivicsOfficialWhereUniqueInput | CivicsOfficialWhereUniqueInput[]
    disconnect?: CivicsOfficialWhereUniqueInput | CivicsOfficialWhereUniqueInput[]
    delete?: CivicsOfficialWhereUniqueInput | CivicsOfficialWhereUniqueInput[]
    connect?: CivicsOfficialWhereUniqueInput | CivicsOfficialWhereUniqueInput[]
    update?: CivicsOfficialUpdateWithWhereUniqueWithoutCountyInput | CivicsOfficialUpdateWithWhereUniqueWithoutCountyInput[]
    updateMany?: CivicsOfficialUpdateManyWithWhereWithoutCountyInput | CivicsOfficialUpdateManyWithWhereWithoutCountyInput[]
    deleteMany?: CivicsOfficialScalarWhereInput | CivicsOfficialScalarWhereInput[]
  }

  export type ElectionResultUpdateManyWithoutCountyNestedInput = {
    create?: XOR<ElectionResultCreateWithoutCountyInput, ElectionResultUncheckedCreateWithoutCountyInput> | ElectionResultCreateWithoutCountyInput[] | ElectionResultUncheckedCreateWithoutCountyInput[]
    connectOrCreate?: ElectionResultCreateOrConnectWithoutCountyInput | ElectionResultCreateOrConnectWithoutCountyInput[]
    upsert?: ElectionResultUpsertWithWhereUniqueWithoutCountyInput | ElectionResultUpsertWithWhereUniqueWithoutCountyInput[]
    createMany?: ElectionResultCreateManyCountyInputEnvelope
    set?: ElectionResultWhereUniqueInput | ElectionResultWhereUniqueInput[]
    disconnect?: ElectionResultWhereUniqueInput | ElectionResultWhereUniqueInput[]
    delete?: ElectionResultWhereUniqueInput | ElectionResultWhereUniqueInput[]
    connect?: ElectionResultWhereUniqueInput | ElectionResultWhereUniqueInput[]
    update?: ElectionResultUpdateWithWhereUniqueWithoutCountyInput | ElectionResultUpdateWithWhereUniqueWithoutCountyInput[]
    updateMany?: ElectionResultUpdateManyWithWhereWithoutCountyInput | ElectionResultUpdateManyWithWhereWithoutCountyInput[]
    deleteMany?: ElectionResultScalarWhereInput | ElectionResultScalarWhereInput[]
  }

  export type SurveyFormUpdateManyWithoutCountyNestedInput = {
    create?: XOR<SurveyFormCreateWithoutCountyInput, SurveyFormUncheckedCreateWithoutCountyInput> | SurveyFormCreateWithoutCountyInput[] | SurveyFormUncheckedCreateWithoutCountyInput[]
    connectOrCreate?: SurveyFormCreateOrConnectWithoutCountyInput | SurveyFormCreateOrConnectWithoutCountyInput[]
    upsert?: SurveyFormUpsertWithWhereUniqueWithoutCountyInput | SurveyFormUpsertWithWhereUniqueWithoutCountyInput[]
    createMany?: SurveyFormCreateManyCountyInputEnvelope
    set?: SurveyFormWhereUniqueInput | SurveyFormWhereUniqueInput[]
    disconnect?: SurveyFormWhereUniqueInput | SurveyFormWhereUniqueInput[]
    delete?: SurveyFormWhereUniqueInput | SurveyFormWhereUniqueInput[]
    connect?: SurveyFormWhereUniqueInput | SurveyFormWhereUniqueInput[]
    update?: SurveyFormUpdateWithWhereUniqueWithoutCountyInput | SurveyFormUpdateWithWhereUniqueWithoutCountyInput[]
    updateMany?: SurveyFormUpdateManyWithWhereWithoutCountyInput | SurveyFormUpdateManyWithWhereWithoutCountyInput[]
    deleteMany?: SurveyFormScalarWhereInput | SurveyFormScalarWhereInput[]
  }

  export type SurveyResponseUpdateManyWithoutCountyNestedInput = {
    create?: XOR<SurveyResponseCreateWithoutCountyInput, SurveyResponseUncheckedCreateWithoutCountyInput> | SurveyResponseCreateWithoutCountyInput[] | SurveyResponseUncheckedCreateWithoutCountyInput[]
    connectOrCreate?: SurveyResponseCreateOrConnectWithoutCountyInput | SurveyResponseCreateOrConnectWithoutCountyInput[]
    upsert?: SurveyResponseUpsertWithWhereUniqueWithoutCountyInput | SurveyResponseUpsertWithWhereUniqueWithoutCountyInput[]
    createMany?: SurveyResponseCreateManyCountyInputEnvelope
    set?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
    disconnect?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
    delete?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
    connect?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
    update?: SurveyResponseUpdateWithWhereUniqueWithoutCountyInput | SurveyResponseUpdateWithWhereUniqueWithoutCountyInput[]
    updateMany?: SurveyResponseUpdateManyWithWhereWithoutCountyInput | SurveyResponseUpdateManyWithWhereWithoutCountyInput[]
    deleteMany?: SurveyResponseScalarWhereInput | SurveyResponseScalarWhereInput[]
  }

  export type AIOutputScopeUpdateManyWithoutCountyNestedInput = {
    create?: XOR<AIOutputScopeCreateWithoutCountyInput, AIOutputScopeUncheckedCreateWithoutCountyInput> | AIOutputScopeCreateWithoutCountyInput[] | AIOutputScopeUncheckedCreateWithoutCountyInput[]
    connectOrCreate?: AIOutputScopeCreateOrConnectWithoutCountyInput | AIOutputScopeCreateOrConnectWithoutCountyInput[]
    upsert?: AIOutputScopeUpsertWithWhereUniqueWithoutCountyInput | AIOutputScopeUpsertWithWhereUniqueWithoutCountyInput[]
    createMany?: AIOutputScopeCreateManyCountyInputEnvelope
    set?: AIOutputScopeWhereUniqueInput | AIOutputScopeWhereUniqueInput[]
    disconnect?: AIOutputScopeWhereUniqueInput | AIOutputScopeWhereUniqueInput[]
    delete?: AIOutputScopeWhereUniqueInput | AIOutputScopeWhereUniqueInput[]
    connect?: AIOutputScopeWhereUniqueInput | AIOutputScopeWhereUniqueInput[]
    update?: AIOutputScopeUpdateWithWhereUniqueWithoutCountyInput | AIOutputScopeUpdateWithWhereUniqueWithoutCountyInput[]
    updateMany?: AIOutputScopeUpdateManyWithWhereWithoutCountyInput | AIOutputScopeUpdateManyWithWhereWithoutCountyInput[]
    deleteMany?: AIOutputScopeScalarWhereInput | AIOutputScopeScalarWhereInput[]
  }

  export type SourceDocumentLinkUpdateManyWithoutCountyNestedInput = {
    create?: XOR<SourceDocumentLinkCreateWithoutCountyInput, SourceDocumentLinkUncheckedCreateWithoutCountyInput> | SourceDocumentLinkCreateWithoutCountyInput[] | SourceDocumentLinkUncheckedCreateWithoutCountyInput[]
    connectOrCreate?: SourceDocumentLinkCreateOrConnectWithoutCountyInput | SourceDocumentLinkCreateOrConnectWithoutCountyInput[]
    upsert?: SourceDocumentLinkUpsertWithWhereUniqueWithoutCountyInput | SourceDocumentLinkUpsertWithWhereUniqueWithoutCountyInput[]
    createMany?: SourceDocumentLinkCreateManyCountyInputEnvelope
    set?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
    disconnect?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
    delete?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
    connect?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
    update?: SourceDocumentLinkUpdateWithWhereUniqueWithoutCountyInput | SourceDocumentLinkUpdateWithWhereUniqueWithoutCountyInput[]
    updateMany?: SourceDocumentLinkUpdateManyWithWhereWithoutCountyInput | SourceDocumentLinkUpdateManyWithWhereWithoutCountyInput[]
    deleteMany?: SourceDocumentLinkScalarWhereInput | SourceDocumentLinkScalarWhereInput[]
  }

  export type BlueprintSectionUncheckedUpdateManyWithoutCountyNestedInput = {
    create?: XOR<BlueprintSectionCreateWithoutCountyInput, BlueprintSectionUncheckedCreateWithoutCountyInput> | BlueprintSectionCreateWithoutCountyInput[] | BlueprintSectionUncheckedCreateWithoutCountyInput[]
    connectOrCreate?: BlueprintSectionCreateOrConnectWithoutCountyInput | BlueprintSectionCreateOrConnectWithoutCountyInput[]
    upsert?: BlueprintSectionUpsertWithWhereUniqueWithoutCountyInput | BlueprintSectionUpsertWithWhereUniqueWithoutCountyInput[]
    createMany?: BlueprintSectionCreateManyCountyInputEnvelope
    set?: BlueprintSectionWhereUniqueInput | BlueprintSectionWhereUniqueInput[]
    disconnect?: BlueprintSectionWhereUniqueInput | BlueprintSectionWhereUniqueInput[]
    delete?: BlueprintSectionWhereUniqueInput | BlueprintSectionWhereUniqueInput[]
    connect?: BlueprintSectionWhereUniqueInput | BlueprintSectionWhereUniqueInput[]
    update?: BlueprintSectionUpdateWithWhereUniqueWithoutCountyInput | BlueprintSectionUpdateWithWhereUniqueWithoutCountyInput[]
    updateMany?: BlueprintSectionUpdateManyWithWhereWithoutCountyInput | BlueprintSectionUpdateManyWithWhereWithoutCountyInput[]
    deleteMany?: BlueprintSectionScalarWhereInput | BlueprintSectionScalarWhereInput[]
  }

  export type QuoteUncheckedUpdateManyWithoutCountyNestedInput = {
    create?: XOR<QuoteCreateWithoutCountyInput, QuoteUncheckedCreateWithoutCountyInput> | QuoteCreateWithoutCountyInput[] | QuoteUncheckedCreateWithoutCountyInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutCountyInput | QuoteCreateOrConnectWithoutCountyInput[]
    upsert?: QuoteUpsertWithWhereUniqueWithoutCountyInput | QuoteUpsertWithWhereUniqueWithoutCountyInput[]
    createMany?: QuoteCreateManyCountyInputEnvelope
    set?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    disconnect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    delete?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    update?: QuoteUpdateWithWhereUniqueWithoutCountyInput | QuoteUpdateWithWhereUniqueWithoutCountyInput[]
    updateMany?: QuoteUpdateManyWithWhereWithoutCountyInput | QuoteUpdateManyWithWhereWithoutCountyInput[]
    deleteMany?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
  }

  export type AssetUncheckedUpdateManyWithoutCountyNestedInput = {
    create?: XOR<AssetCreateWithoutCountyInput, AssetUncheckedCreateWithoutCountyInput> | AssetCreateWithoutCountyInput[] | AssetUncheckedCreateWithoutCountyInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutCountyInput | AssetCreateOrConnectWithoutCountyInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutCountyInput | AssetUpsertWithWhereUniqueWithoutCountyInput[]
    createMany?: AssetCreateManyCountyInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutCountyInput | AssetUpdateWithWhereUniqueWithoutCountyInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutCountyInput | AssetUpdateManyWithWhereWithoutCountyInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type CountyIssueUncheckedUpdateManyWithoutCountyNestedInput = {
    create?: XOR<CountyIssueCreateWithoutCountyInput, CountyIssueUncheckedCreateWithoutCountyInput> | CountyIssueCreateWithoutCountyInput[] | CountyIssueUncheckedCreateWithoutCountyInput[]
    connectOrCreate?: CountyIssueCreateOrConnectWithoutCountyInput | CountyIssueCreateOrConnectWithoutCountyInput[]
    upsert?: CountyIssueUpsertWithWhereUniqueWithoutCountyInput | CountyIssueUpsertWithWhereUniqueWithoutCountyInput[]
    createMany?: CountyIssueCreateManyCountyInputEnvelope
    set?: CountyIssueWhereUniqueInput | CountyIssueWhereUniqueInput[]
    disconnect?: CountyIssueWhereUniqueInput | CountyIssueWhereUniqueInput[]
    delete?: CountyIssueWhereUniqueInput | CountyIssueWhereUniqueInput[]
    connect?: CountyIssueWhereUniqueInput | CountyIssueWhereUniqueInput[]
    update?: CountyIssueUpdateWithWhereUniqueWithoutCountyInput | CountyIssueUpdateWithWhereUniqueWithoutCountyInput[]
    updateMany?: CountyIssueUpdateManyWithWhereWithoutCountyInput | CountyIssueUpdateManyWithWhereWithoutCountyInput[]
    deleteMany?: CountyIssueScalarWhereInput | CountyIssueScalarWhereInput[]
  }

  export type CensusMetricUncheckedUpdateManyWithoutCountyNestedInput = {
    create?: XOR<CensusMetricCreateWithoutCountyInput, CensusMetricUncheckedCreateWithoutCountyInput> | CensusMetricCreateWithoutCountyInput[] | CensusMetricUncheckedCreateWithoutCountyInput[]
    connectOrCreate?: CensusMetricCreateOrConnectWithoutCountyInput | CensusMetricCreateOrConnectWithoutCountyInput[]
    upsert?: CensusMetricUpsertWithWhereUniqueWithoutCountyInput | CensusMetricUpsertWithWhereUniqueWithoutCountyInput[]
    createMany?: CensusMetricCreateManyCountyInputEnvelope
    set?: CensusMetricWhereUniqueInput | CensusMetricWhereUniqueInput[]
    disconnect?: CensusMetricWhereUniqueInput | CensusMetricWhereUniqueInput[]
    delete?: CensusMetricWhereUniqueInput | CensusMetricWhereUniqueInput[]
    connect?: CensusMetricWhereUniqueInput | CensusMetricWhereUniqueInput[]
    update?: CensusMetricUpdateWithWhereUniqueWithoutCountyInput | CensusMetricUpdateWithWhereUniqueWithoutCountyInput[]
    updateMany?: CensusMetricUpdateManyWithWhereWithoutCountyInput | CensusMetricUpdateManyWithWhereWithoutCountyInput[]
    deleteMany?: CensusMetricScalarWhereInput | CensusMetricScalarWhereInput[]
  }

  export type BLSMetricUncheckedUpdateManyWithoutCountyNestedInput = {
    create?: XOR<BLSMetricCreateWithoutCountyInput, BLSMetricUncheckedCreateWithoutCountyInput> | BLSMetricCreateWithoutCountyInput[] | BLSMetricUncheckedCreateWithoutCountyInput[]
    connectOrCreate?: BLSMetricCreateOrConnectWithoutCountyInput | BLSMetricCreateOrConnectWithoutCountyInput[]
    upsert?: BLSMetricUpsertWithWhereUniqueWithoutCountyInput | BLSMetricUpsertWithWhereUniqueWithoutCountyInput[]
    createMany?: BLSMetricCreateManyCountyInputEnvelope
    set?: BLSMetricWhereUniqueInput | BLSMetricWhereUniqueInput[]
    disconnect?: BLSMetricWhereUniqueInput | BLSMetricWhereUniqueInput[]
    delete?: BLSMetricWhereUniqueInput | BLSMetricWhereUniqueInput[]
    connect?: BLSMetricWhereUniqueInput | BLSMetricWhereUniqueInput[]
    update?: BLSMetricUpdateWithWhereUniqueWithoutCountyInput | BLSMetricUpdateWithWhereUniqueWithoutCountyInput[]
    updateMany?: BLSMetricUpdateManyWithWhereWithoutCountyInput | BLSMetricUpdateManyWithWhereWithoutCountyInput[]
    deleteMany?: BLSMetricScalarWhereInput | BLSMetricScalarWhereInput[]
  }

  export type CivicsOfficialUncheckedUpdateManyWithoutCountyNestedInput = {
    create?: XOR<CivicsOfficialCreateWithoutCountyInput, CivicsOfficialUncheckedCreateWithoutCountyInput> | CivicsOfficialCreateWithoutCountyInput[] | CivicsOfficialUncheckedCreateWithoutCountyInput[]
    connectOrCreate?: CivicsOfficialCreateOrConnectWithoutCountyInput | CivicsOfficialCreateOrConnectWithoutCountyInput[]
    upsert?: CivicsOfficialUpsertWithWhereUniqueWithoutCountyInput | CivicsOfficialUpsertWithWhereUniqueWithoutCountyInput[]
    createMany?: CivicsOfficialCreateManyCountyInputEnvelope
    set?: CivicsOfficialWhereUniqueInput | CivicsOfficialWhereUniqueInput[]
    disconnect?: CivicsOfficialWhereUniqueInput | CivicsOfficialWhereUniqueInput[]
    delete?: CivicsOfficialWhereUniqueInput | CivicsOfficialWhereUniqueInput[]
    connect?: CivicsOfficialWhereUniqueInput | CivicsOfficialWhereUniqueInput[]
    update?: CivicsOfficialUpdateWithWhereUniqueWithoutCountyInput | CivicsOfficialUpdateWithWhereUniqueWithoutCountyInput[]
    updateMany?: CivicsOfficialUpdateManyWithWhereWithoutCountyInput | CivicsOfficialUpdateManyWithWhereWithoutCountyInput[]
    deleteMany?: CivicsOfficialScalarWhereInput | CivicsOfficialScalarWhereInput[]
  }

  export type ElectionResultUncheckedUpdateManyWithoutCountyNestedInput = {
    create?: XOR<ElectionResultCreateWithoutCountyInput, ElectionResultUncheckedCreateWithoutCountyInput> | ElectionResultCreateWithoutCountyInput[] | ElectionResultUncheckedCreateWithoutCountyInput[]
    connectOrCreate?: ElectionResultCreateOrConnectWithoutCountyInput | ElectionResultCreateOrConnectWithoutCountyInput[]
    upsert?: ElectionResultUpsertWithWhereUniqueWithoutCountyInput | ElectionResultUpsertWithWhereUniqueWithoutCountyInput[]
    createMany?: ElectionResultCreateManyCountyInputEnvelope
    set?: ElectionResultWhereUniqueInput | ElectionResultWhereUniqueInput[]
    disconnect?: ElectionResultWhereUniqueInput | ElectionResultWhereUniqueInput[]
    delete?: ElectionResultWhereUniqueInput | ElectionResultWhereUniqueInput[]
    connect?: ElectionResultWhereUniqueInput | ElectionResultWhereUniqueInput[]
    update?: ElectionResultUpdateWithWhereUniqueWithoutCountyInput | ElectionResultUpdateWithWhereUniqueWithoutCountyInput[]
    updateMany?: ElectionResultUpdateManyWithWhereWithoutCountyInput | ElectionResultUpdateManyWithWhereWithoutCountyInput[]
    deleteMany?: ElectionResultScalarWhereInput | ElectionResultScalarWhereInput[]
  }

  export type SurveyFormUncheckedUpdateManyWithoutCountyNestedInput = {
    create?: XOR<SurveyFormCreateWithoutCountyInput, SurveyFormUncheckedCreateWithoutCountyInput> | SurveyFormCreateWithoutCountyInput[] | SurveyFormUncheckedCreateWithoutCountyInput[]
    connectOrCreate?: SurveyFormCreateOrConnectWithoutCountyInput | SurveyFormCreateOrConnectWithoutCountyInput[]
    upsert?: SurveyFormUpsertWithWhereUniqueWithoutCountyInput | SurveyFormUpsertWithWhereUniqueWithoutCountyInput[]
    createMany?: SurveyFormCreateManyCountyInputEnvelope
    set?: SurveyFormWhereUniqueInput | SurveyFormWhereUniqueInput[]
    disconnect?: SurveyFormWhereUniqueInput | SurveyFormWhereUniqueInput[]
    delete?: SurveyFormWhereUniqueInput | SurveyFormWhereUniqueInput[]
    connect?: SurveyFormWhereUniqueInput | SurveyFormWhereUniqueInput[]
    update?: SurveyFormUpdateWithWhereUniqueWithoutCountyInput | SurveyFormUpdateWithWhereUniqueWithoutCountyInput[]
    updateMany?: SurveyFormUpdateManyWithWhereWithoutCountyInput | SurveyFormUpdateManyWithWhereWithoutCountyInput[]
    deleteMany?: SurveyFormScalarWhereInput | SurveyFormScalarWhereInput[]
  }

  export type SurveyResponseUncheckedUpdateManyWithoutCountyNestedInput = {
    create?: XOR<SurveyResponseCreateWithoutCountyInput, SurveyResponseUncheckedCreateWithoutCountyInput> | SurveyResponseCreateWithoutCountyInput[] | SurveyResponseUncheckedCreateWithoutCountyInput[]
    connectOrCreate?: SurveyResponseCreateOrConnectWithoutCountyInput | SurveyResponseCreateOrConnectWithoutCountyInput[]
    upsert?: SurveyResponseUpsertWithWhereUniqueWithoutCountyInput | SurveyResponseUpsertWithWhereUniqueWithoutCountyInput[]
    createMany?: SurveyResponseCreateManyCountyInputEnvelope
    set?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
    disconnect?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
    delete?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
    connect?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
    update?: SurveyResponseUpdateWithWhereUniqueWithoutCountyInput | SurveyResponseUpdateWithWhereUniqueWithoutCountyInput[]
    updateMany?: SurveyResponseUpdateManyWithWhereWithoutCountyInput | SurveyResponseUpdateManyWithWhereWithoutCountyInput[]
    deleteMany?: SurveyResponseScalarWhereInput | SurveyResponseScalarWhereInput[]
  }

  export type AIOutputScopeUncheckedUpdateManyWithoutCountyNestedInput = {
    create?: XOR<AIOutputScopeCreateWithoutCountyInput, AIOutputScopeUncheckedCreateWithoutCountyInput> | AIOutputScopeCreateWithoutCountyInput[] | AIOutputScopeUncheckedCreateWithoutCountyInput[]
    connectOrCreate?: AIOutputScopeCreateOrConnectWithoutCountyInput | AIOutputScopeCreateOrConnectWithoutCountyInput[]
    upsert?: AIOutputScopeUpsertWithWhereUniqueWithoutCountyInput | AIOutputScopeUpsertWithWhereUniqueWithoutCountyInput[]
    createMany?: AIOutputScopeCreateManyCountyInputEnvelope
    set?: AIOutputScopeWhereUniqueInput | AIOutputScopeWhereUniqueInput[]
    disconnect?: AIOutputScopeWhereUniqueInput | AIOutputScopeWhereUniqueInput[]
    delete?: AIOutputScopeWhereUniqueInput | AIOutputScopeWhereUniqueInput[]
    connect?: AIOutputScopeWhereUniqueInput | AIOutputScopeWhereUniqueInput[]
    update?: AIOutputScopeUpdateWithWhereUniqueWithoutCountyInput | AIOutputScopeUpdateWithWhereUniqueWithoutCountyInput[]
    updateMany?: AIOutputScopeUpdateManyWithWhereWithoutCountyInput | AIOutputScopeUpdateManyWithWhereWithoutCountyInput[]
    deleteMany?: AIOutputScopeScalarWhereInput | AIOutputScopeScalarWhereInput[]
  }

  export type SourceDocumentLinkUncheckedUpdateManyWithoutCountyNestedInput = {
    create?: XOR<SourceDocumentLinkCreateWithoutCountyInput, SourceDocumentLinkUncheckedCreateWithoutCountyInput> | SourceDocumentLinkCreateWithoutCountyInput[] | SourceDocumentLinkUncheckedCreateWithoutCountyInput[]
    connectOrCreate?: SourceDocumentLinkCreateOrConnectWithoutCountyInput | SourceDocumentLinkCreateOrConnectWithoutCountyInput[]
    upsert?: SourceDocumentLinkUpsertWithWhereUniqueWithoutCountyInput | SourceDocumentLinkUpsertWithWhereUniqueWithoutCountyInput[]
    createMany?: SourceDocumentLinkCreateManyCountyInputEnvelope
    set?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
    disconnect?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
    delete?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
    connect?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
    update?: SourceDocumentLinkUpdateWithWhereUniqueWithoutCountyInput | SourceDocumentLinkUpdateWithWhereUniqueWithoutCountyInput[]
    updateMany?: SourceDocumentLinkUpdateManyWithWhereWithoutCountyInput | SourceDocumentLinkUpdateManyWithWhereWithoutCountyInput[]
    deleteMany?: SourceDocumentLinkScalarWhereInput | SourceDocumentLinkScalarWhereInput[]
  }

  export type CountyIssueCreateNestedManyWithoutIssueInput = {
    create?: XOR<CountyIssueCreateWithoutIssueInput, CountyIssueUncheckedCreateWithoutIssueInput> | CountyIssueCreateWithoutIssueInput[] | CountyIssueUncheckedCreateWithoutIssueInput[]
    connectOrCreate?: CountyIssueCreateOrConnectWithoutIssueInput | CountyIssueCreateOrConnectWithoutIssueInput[]
    createMany?: CountyIssueCreateManyIssueInputEnvelope
    connect?: CountyIssueWhereUniqueInput | CountyIssueWhereUniqueInput[]
  }

  export type BlueprintSectionCreateNestedManyWithoutIssueInput = {
    create?: XOR<BlueprintSectionCreateWithoutIssueInput, BlueprintSectionUncheckedCreateWithoutIssueInput> | BlueprintSectionCreateWithoutIssueInput[] | BlueprintSectionUncheckedCreateWithoutIssueInput[]
    connectOrCreate?: BlueprintSectionCreateOrConnectWithoutIssueInput | BlueprintSectionCreateOrConnectWithoutIssueInput[]
    createMany?: BlueprintSectionCreateManyIssueInputEnvelope
    connect?: BlueprintSectionWhereUniqueInput | BlueprintSectionWhereUniqueInput[]
  }

  export type QuoteCreateNestedManyWithoutIssueInput = {
    create?: XOR<QuoteCreateWithoutIssueInput, QuoteUncheckedCreateWithoutIssueInput> | QuoteCreateWithoutIssueInput[] | QuoteUncheckedCreateWithoutIssueInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutIssueInput | QuoteCreateOrConnectWithoutIssueInput[]
    createMany?: QuoteCreateManyIssueInputEnvelope
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
  }

  export type AssetCreateNestedManyWithoutIssueInput = {
    create?: XOR<AssetCreateWithoutIssueInput, AssetUncheckedCreateWithoutIssueInput> | AssetCreateWithoutIssueInput[] | AssetUncheckedCreateWithoutIssueInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutIssueInput | AssetCreateOrConnectWithoutIssueInput[]
    createMany?: AssetCreateManyIssueInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type AIOutputScopeCreateNestedManyWithoutIssueInput = {
    create?: XOR<AIOutputScopeCreateWithoutIssueInput, AIOutputScopeUncheckedCreateWithoutIssueInput> | AIOutputScopeCreateWithoutIssueInput[] | AIOutputScopeUncheckedCreateWithoutIssueInput[]
    connectOrCreate?: AIOutputScopeCreateOrConnectWithoutIssueInput | AIOutputScopeCreateOrConnectWithoutIssueInput[]
    createMany?: AIOutputScopeCreateManyIssueInputEnvelope
    connect?: AIOutputScopeWhereUniqueInput | AIOutputScopeWhereUniqueInput[]
  }

  export type SourceDocumentLinkCreateNestedManyWithoutIssueInput = {
    create?: XOR<SourceDocumentLinkCreateWithoutIssueInput, SourceDocumentLinkUncheckedCreateWithoutIssueInput> | SourceDocumentLinkCreateWithoutIssueInput[] | SourceDocumentLinkUncheckedCreateWithoutIssueInput[]
    connectOrCreate?: SourceDocumentLinkCreateOrConnectWithoutIssueInput | SourceDocumentLinkCreateOrConnectWithoutIssueInput[]
    createMany?: SourceDocumentLinkCreateManyIssueInputEnvelope
    connect?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
  }

  export type CountyIssueUncheckedCreateNestedManyWithoutIssueInput = {
    create?: XOR<CountyIssueCreateWithoutIssueInput, CountyIssueUncheckedCreateWithoutIssueInput> | CountyIssueCreateWithoutIssueInput[] | CountyIssueUncheckedCreateWithoutIssueInput[]
    connectOrCreate?: CountyIssueCreateOrConnectWithoutIssueInput | CountyIssueCreateOrConnectWithoutIssueInput[]
    createMany?: CountyIssueCreateManyIssueInputEnvelope
    connect?: CountyIssueWhereUniqueInput | CountyIssueWhereUniqueInput[]
  }

  export type BlueprintSectionUncheckedCreateNestedManyWithoutIssueInput = {
    create?: XOR<BlueprintSectionCreateWithoutIssueInput, BlueprintSectionUncheckedCreateWithoutIssueInput> | BlueprintSectionCreateWithoutIssueInput[] | BlueprintSectionUncheckedCreateWithoutIssueInput[]
    connectOrCreate?: BlueprintSectionCreateOrConnectWithoutIssueInput | BlueprintSectionCreateOrConnectWithoutIssueInput[]
    createMany?: BlueprintSectionCreateManyIssueInputEnvelope
    connect?: BlueprintSectionWhereUniqueInput | BlueprintSectionWhereUniqueInput[]
  }

  export type QuoteUncheckedCreateNestedManyWithoutIssueInput = {
    create?: XOR<QuoteCreateWithoutIssueInput, QuoteUncheckedCreateWithoutIssueInput> | QuoteCreateWithoutIssueInput[] | QuoteUncheckedCreateWithoutIssueInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutIssueInput | QuoteCreateOrConnectWithoutIssueInput[]
    createMany?: QuoteCreateManyIssueInputEnvelope
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
  }

  export type AssetUncheckedCreateNestedManyWithoutIssueInput = {
    create?: XOR<AssetCreateWithoutIssueInput, AssetUncheckedCreateWithoutIssueInput> | AssetCreateWithoutIssueInput[] | AssetUncheckedCreateWithoutIssueInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutIssueInput | AssetCreateOrConnectWithoutIssueInput[]
    createMany?: AssetCreateManyIssueInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type AIOutputScopeUncheckedCreateNestedManyWithoutIssueInput = {
    create?: XOR<AIOutputScopeCreateWithoutIssueInput, AIOutputScopeUncheckedCreateWithoutIssueInput> | AIOutputScopeCreateWithoutIssueInput[] | AIOutputScopeUncheckedCreateWithoutIssueInput[]
    connectOrCreate?: AIOutputScopeCreateOrConnectWithoutIssueInput | AIOutputScopeCreateOrConnectWithoutIssueInput[]
    createMany?: AIOutputScopeCreateManyIssueInputEnvelope
    connect?: AIOutputScopeWhereUniqueInput | AIOutputScopeWhereUniqueInput[]
  }

  export type SourceDocumentLinkUncheckedCreateNestedManyWithoutIssueInput = {
    create?: XOR<SourceDocumentLinkCreateWithoutIssueInput, SourceDocumentLinkUncheckedCreateWithoutIssueInput> | SourceDocumentLinkCreateWithoutIssueInput[] | SourceDocumentLinkUncheckedCreateWithoutIssueInput[]
    connectOrCreate?: SourceDocumentLinkCreateOrConnectWithoutIssueInput | SourceDocumentLinkCreateOrConnectWithoutIssueInput[]
    createMany?: SourceDocumentLinkCreateManyIssueInputEnvelope
    connect?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
  }

  export type CountyIssueUpdateManyWithoutIssueNestedInput = {
    create?: XOR<CountyIssueCreateWithoutIssueInput, CountyIssueUncheckedCreateWithoutIssueInput> | CountyIssueCreateWithoutIssueInput[] | CountyIssueUncheckedCreateWithoutIssueInput[]
    connectOrCreate?: CountyIssueCreateOrConnectWithoutIssueInput | CountyIssueCreateOrConnectWithoutIssueInput[]
    upsert?: CountyIssueUpsertWithWhereUniqueWithoutIssueInput | CountyIssueUpsertWithWhereUniqueWithoutIssueInput[]
    createMany?: CountyIssueCreateManyIssueInputEnvelope
    set?: CountyIssueWhereUniqueInput | CountyIssueWhereUniqueInput[]
    disconnect?: CountyIssueWhereUniqueInput | CountyIssueWhereUniqueInput[]
    delete?: CountyIssueWhereUniqueInput | CountyIssueWhereUniqueInput[]
    connect?: CountyIssueWhereUniqueInput | CountyIssueWhereUniqueInput[]
    update?: CountyIssueUpdateWithWhereUniqueWithoutIssueInput | CountyIssueUpdateWithWhereUniqueWithoutIssueInput[]
    updateMany?: CountyIssueUpdateManyWithWhereWithoutIssueInput | CountyIssueUpdateManyWithWhereWithoutIssueInput[]
    deleteMany?: CountyIssueScalarWhereInput | CountyIssueScalarWhereInput[]
  }

  export type BlueprintSectionUpdateManyWithoutIssueNestedInput = {
    create?: XOR<BlueprintSectionCreateWithoutIssueInput, BlueprintSectionUncheckedCreateWithoutIssueInput> | BlueprintSectionCreateWithoutIssueInput[] | BlueprintSectionUncheckedCreateWithoutIssueInput[]
    connectOrCreate?: BlueprintSectionCreateOrConnectWithoutIssueInput | BlueprintSectionCreateOrConnectWithoutIssueInput[]
    upsert?: BlueprintSectionUpsertWithWhereUniqueWithoutIssueInput | BlueprintSectionUpsertWithWhereUniqueWithoutIssueInput[]
    createMany?: BlueprintSectionCreateManyIssueInputEnvelope
    set?: BlueprintSectionWhereUniqueInput | BlueprintSectionWhereUniqueInput[]
    disconnect?: BlueprintSectionWhereUniqueInput | BlueprintSectionWhereUniqueInput[]
    delete?: BlueprintSectionWhereUniqueInput | BlueprintSectionWhereUniqueInput[]
    connect?: BlueprintSectionWhereUniqueInput | BlueprintSectionWhereUniqueInput[]
    update?: BlueprintSectionUpdateWithWhereUniqueWithoutIssueInput | BlueprintSectionUpdateWithWhereUniqueWithoutIssueInput[]
    updateMany?: BlueprintSectionUpdateManyWithWhereWithoutIssueInput | BlueprintSectionUpdateManyWithWhereWithoutIssueInput[]
    deleteMany?: BlueprintSectionScalarWhereInput | BlueprintSectionScalarWhereInput[]
  }

  export type QuoteUpdateManyWithoutIssueNestedInput = {
    create?: XOR<QuoteCreateWithoutIssueInput, QuoteUncheckedCreateWithoutIssueInput> | QuoteCreateWithoutIssueInput[] | QuoteUncheckedCreateWithoutIssueInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutIssueInput | QuoteCreateOrConnectWithoutIssueInput[]
    upsert?: QuoteUpsertWithWhereUniqueWithoutIssueInput | QuoteUpsertWithWhereUniqueWithoutIssueInput[]
    createMany?: QuoteCreateManyIssueInputEnvelope
    set?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    disconnect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    delete?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    update?: QuoteUpdateWithWhereUniqueWithoutIssueInput | QuoteUpdateWithWhereUniqueWithoutIssueInput[]
    updateMany?: QuoteUpdateManyWithWhereWithoutIssueInput | QuoteUpdateManyWithWhereWithoutIssueInput[]
    deleteMany?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
  }

  export type AssetUpdateManyWithoutIssueNestedInput = {
    create?: XOR<AssetCreateWithoutIssueInput, AssetUncheckedCreateWithoutIssueInput> | AssetCreateWithoutIssueInput[] | AssetUncheckedCreateWithoutIssueInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutIssueInput | AssetCreateOrConnectWithoutIssueInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutIssueInput | AssetUpsertWithWhereUniqueWithoutIssueInput[]
    createMany?: AssetCreateManyIssueInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutIssueInput | AssetUpdateWithWhereUniqueWithoutIssueInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutIssueInput | AssetUpdateManyWithWhereWithoutIssueInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type AIOutputScopeUpdateManyWithoutIssueNestedInput = {
    create?: XOR<AIOutputScopeCreateWithoutIssueInput, AIOutputScopeUncheckedCreateWithoutIssueInput> | AIOutputScopeCreateWithoutIssueInput[] | AIOutputScopeUncheckedCreateWithoutIssueInput[]
    connectOrCreate?: AIOutputScopeCreateOrConnectWithoutIssueInput | AIOutputScopeCreateOrConnectWithoutIssueInput[]
    upsert?: AIOutputScopeUpsertWithWhereUniqueWithoutIssueInput | AIOutputScopeUpsertWithWhereUniqueWithoutIssueInput[]
    createMany?: AIOutputScopeCreateManyIssueInputEnvelope
    set?: AIOutputScopeWhereUniqueInput | AIOutputScopeWhereUniqueInput[]
    disconnect?: AIOutputScopeWhereUniqueInput | AIOutputScopeWhereUniqueInput[]
    delete?: AIOutputScopeWhereUniqueInput | AIOutputScopeWhereUniqueInput[]
    connect?: AIOutputScopeWhereUniqueInput | AIOutputScopeWhereUniqueInput[]
    update?: AIOutputScopeUpdateWithWhereUniqueWithoutIssueInput | AIOutputScopeUpdateWithWhereUniqueWithoutIssueInput[]
    updateMany?: AIOutputScopeUpdateManyWithWhereWithoutIssueInput | AIOutputScopeUpdateManyWithWhereWithoutIssueInput[]
    deleteMany?: AIOutputScopeScalarWhereInput | AIOutputScopeScalarWhereInput[]
  }

  export type SourceDocumentLinkUpdateManyWithoutIssueNestedInput = {
    create?: XOR<SourceDocumentLinkCreateWithoutIssueInput, SourceDocumentLinkUncheckedCreateWithoutIssueInput> | SourceDocumentLinkCreateWithoutIssueInput[] | SourceDocumentLinkUncheckedCreateWithoutIssueInput[]
    connectOrCreate?: SourceDocumentLinkCreateOrConnectWithoutIssueInput | SourceDocumentLinkCreateOrConnectWithoutIssueInput[]
    upsert?: SourceDocumentLinkUpsertWithWhereUniqueWithoutIssueInput | SourceDocumentLinkUpsertWithWhereUniqueWithoutIssueInput[]
    createMany?: SourceDocumentLinkCreateManyIssueInputEnvelope
    set?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
    disconnect?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
    delete?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
    connect?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
    update?: SourceDocumentLinkUpdateWithWhereUniqueWithoutIssueInput | SourceDocumentLinkUpdateWithWhereUniqueWithoutIssueInput[]
    updateMany?: SourceDocumentLinkUpdateManyWithWhereWithoutIssueInput | SourceDocumentLinkUpdateManyWithWhereWithoutIssueInput[]
    deleteMany?: SourceDocumentLinkScalarWhereInput | SourceDocumentLinkScalarWhereInput[]
  }

  export type CountyIssueUncheckedUpdateManyWithoutIssueNestedInput = {
    create?: XOR<CountyIssueCreateWithoutIssueInput, CountyIssueUncheckedCreateWithoutIssueInput> | CountyIssueCreateWithoutIssueInput[] | CountyIssueUncheckedCreateWithoutIssueInput[]
    connectOrCreate?: CountyIssueCreateOrConnectWithoutIssueInput | CountyIssueCreateOrConnectWithoutIssueInput[]
    upsert?: CountyIssueUpsertWithWhereUniqueWithoutIssueInput | CountyIssueUpsertWithWhereUniqueWithoutIssueInput[]
    createMany?: CountyIssueCreateManyIssueInputEnvelope
    set?: CountyIssueWhereUniqueInput | CountyIssueWhereUniqueInput[]
    disconnect?: CountyIssueWhereUniqueInput | CountyIssueWhereUniqueInput[]
    delete?: CountyIssueWhereUniqueInput | CountyIssueWhereUniqueInput[]
    connect?: CountyIssueWhereUniqueInput | CountyIssueWhereUniqueInput[]
    update?: CountyIssueUpdateWithWhereUniqueWithoutIssueInput | CountyIssueUpdateWithWhereUniqueWithoutIssueInput[]
    updateMany?: CountyIssueUpdateManyWithWhereWithoutIssueInput | CountyIssueUpdateManyWithWhereWithoutIssueInput[]
    deleteMany?: CountyIssueScalarWhereInput | CountyIssueScalarWhereInput[]
  }

  export type BlueprintSectionUncheckedUpdateManyWithoutIssueNestedInput = {
    create?: XOR<BlueprintSectionCreateWithoutIssueInput, BlueprintSectionUncheckedCreateWithoutIssueInput> | BlueprintSectionCreateWithoutIssueInput[] | BlueprintSectionUncheckedCreateWithoutIssueInput[]
    connectOrCreate?: BlueprintSectionCreateOrConnectWithoutIssueInput | BlueprintSectionCreateOrConnectWithoutIssueInput[]
    upsert?: BlueprintSectionUpsertWithWhereUniqueWithoutIssueInput | BlueprintSectionUpsertWithWhereUniqueWithoutIssueInput[]
    createMany?: BlueprintSectionCreateManyIssueInputEnvelope
    set?: BlueprintSectionWhereUniqueInput | BlueprintSectionWhereUniqueInput[]
    disconnect?: BlueprintSectionWhereUniqueInput | BlueprintSectionWhereUniqueInput[]
    delete?: BlueprintSectionWhereUniqueInput | BlueprintSectionWhereUniqueInput[]
    connect?: BlueprintSectionWhereUniqueInput | BlueprintSectionWhereUniqueInput[]
    update?: BlueprintSectionUpdateWithWhereUniqueWithoutIssueInput | BlueprintSectionUpdateWithWhereUniqueWithoutIssueInput[]
    updateMany?: BlueprintSectionUpdateManyWithWhereWithoutIssueInput | BlueprintSectionUpdateManyWithWhereWithoutIssueInput[]
    deleteMany?: BlueprintSectionScalarWhereInput | BlueprintSectionScalarWhereInput[]
  }

  export type QuoteUncheckedUpdateManyWithoutIssueNestedInput = {
    create?: XOR<QuoteCreateWithoutIssueInput, QuoteUncheckedCreateWithoutIssueInput> | QuoteCreateWithoutIssueInput[] | QuoteUncheckedCreateWithoutIssueInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutIssueInput | QuoteCreateOrConnectWithoutIssueInput[]
    upsert?: QuoteUpsertWithWhereUniqueWithoutIssueInput | QuoteUpsertWithWhereUniqueWithoutIssueInput[]
    createMany?: QuoteCreateManyIssueInputEnvelope
    set?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    disconnect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    delete?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    update?: QuoteUpdateWithWhereUniqueWithoutIssueInput | QuoteUpdateWithWhereUniqueWithoutIssueInput[]
    updateMany?: QuoteUpdateManyWithWhereWithoutIssueInput | QuoteUpdateManyWithWhereWithoutIssueInput[]
    deleteMany?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
  }

  export type AssetUncheckedUpdateManyWithoutIssueNestedInput = {
    create?: XOR<AssetCreateWithoutIssueInput, AssetUncheckedCreateWithoutIssueInput> | AssetCreateWithoutIssueInput[] | AssetUncheckedCreateWithoutIssueInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutIssueInput | AssetCreateOrConnectWithoutIssueInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutIssueInput | AssetUpsertWithWhereUniqueWithoutIssueInput[]
    createMany?: AssetCreateManyIssueInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutIssueInput | AssetUpdateWithWhereUniqueWithoutIssueInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutIssueInput | AssetUpdateManyWithWhereWithoutIssueInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type AIOutputScopeUncheckedUpdateManyWithoutIssueNestedInput = {
    create?: XOR<AIOutputScopeCreateWithoutIssueInput, AIOutputScopeUncheckedCreateWithoutIssueInput> | AIOutputScopeCreateWithoutIssueInput[] | AIOutputScopeUncheckedCreateWithoutIssueInput[]
    connectOrCreate?: AIOutputScopeCreateOrConnectWithoutIssueInput | AIOutputScopeCreateOrConnectWithoutIssueInput[]
    upsert?: AIOutputScopeUpsertWithWhereUniqueWithoutIssueInput | AIOutputScopeUpsertWithWhereUniqueWithoutIssueInput[]
    createMany?: AIOutputScopeCreateManyIssueInputEnvelope
    set?: AIOutputScopeWhereUniqueInput | AIOutputScopeWhereUniqueInput[]
    disconnect?: AIOutputScopeWhereUniqueInput | AIOutputScopeWhereUniqueInput[]
    delete?: AIOutputScopeWhereUniqueInput | AIOutputScopeWhereUniqueInput[]
    connect?: AIOutputScopeWhereUniqueInput | AIOutputScopeWhereUniqueInput[]
    update?: AIOutputScopeUpdateWithWhereUniqueWithoutIssueInput | AIOutputScopeUpdateWithWhereUniqueWithoutIssueInput[]
    updateMany?: AIOutputScopeUpdateManyWithWhereWithoutIssueInput | AIOutputScopeUpdateManyWithWhereWithoutIssueInput[]
    deleteMany?: AIOutputScopeScalarWhereInput | AIOutputScopeScalarWhereInput[]
  }

  export type SourceDocumentLinkUncheckedUpdateManyWithoutIssueNestedInput = {
    create?: XOR<SourceDocumentLinkCreateWithoutIssueInput, SourceDocumentLinkUncheckedCreateWithoutIssueInput> | SourceDocumentLinkCreateWithoutIssueInput[] | SourceDocumentLinkUncheckedCreateWithoutIssueInput[]
    connectOrCreate?: SourceDocumentLinkCreateOrConnectWithoutIssueInput | SourceDocumentLinkCreateOrConnectWithoutIssueInput[]
    upsert?: SourceDocumentLinkUpsertWithWhereUniqueWithoutIssueInput | SourceDocumentLinkUpsertWithWhereUniqueWithoutIssueInput[]
    createMany?: SourceDocumentLinkCreateManyIssueInputEnvelope
    set?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
    disconnect?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
    delete?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
    connect?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
    update?: SourceDocumentLinkUpdateWithWhereUniqueWithoutIssueInput | SourceDocumentLinkUpdateWithWhereUniqueWithoutIssueInput[]
    updateMany?: SourceDocumentLinkUpdateManyWithWhereWithoutIssueInput | SourceDocumentLinkUpdateManyWithWhereWithoutIssueInput[]
    deleteMany?: SourceDocumentLinkScalarWhereInput | SourceDocumentLinkScalarWhereInput[]
  }

  export type CountyCreateNestedOneWithoutCountyIssuesInput = {
    create?: XOR<CountyCreateWithoutCountyIssuesInput, CountyUncheckedCreateWithoutCountyIssuesInput>
    connectOrCreate?: CountyCreateOrConnectWithoutCountyIssuesInput
    connect?: CountyWhereUniqueInput
  }

  export type IssueCreateNestedOneWithoutCountyIssuesInput = {
    create?: XOR<IssueCreateWithoutCountyIssuesInput, IssueUncheckedCreateWithoutCountyIssuesInput>
    connectOrCreate?: IssueCreateOrConnectWithoutCountyIssuesInput
    connect?: IssueWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CountyUpdateOneRequiredWithoutCountyIssuesNestedInput = {
    create?: XOR<CountyCreateWithoutCountyIssuesInput, CountyUncheckedCreateWithoutCountyIssuesInput>
    connectOrCreate?: CountyCreateOrConnectWithoutCountyIssuesInput
    upsert?: CountyUpsertWithoutCountyIssuesInput
    connect?: CountyWhereUniqueInput
    update?: XOR<XOR<CountyUpdateToOneWithWhereWithoutCountyIssuesInput, CountyUpdateWithoutCountyIssuesInput>, CountyUncheckedUpdateWithoutCountyIssuesInput>
  }

  export type IssueUpdateOneRequiredWithoutCountyIssuesNestedInput = {
    create?: XOR<IssueCreateWithoutCountyIssuesInput, IssueUncheckedCreateWithoutCountyIssuesInput>
    connectOrCreate?: IssueCreateOrConnectWithoutCountyIssuesInput
    upsert?: IssueUpsertWithoutCountyIssuesInput
    connect?: IssueWhereUniqueInput
    update?: XOR<XOR<IssueUpdateToOneWithWhereWithoutCountyIssuesInput, IssueUpdateWithoutCountyIssuesInput>, IssueUncheckedUpdateWithoutCountyIssuesInput>
  }

  export type CountyCreateNestedOneWithoutBlueprintSectionsInput = {
    create?: XOR<CountyCreateWithoutBlueprintSectionsInput, CountyUncheckedCreateWithoutBlueprintSectionsInput>
    connectOrCreate?: CountyCreateOrConnectWithoutBlueprintSectionsInput
    connect?: CountyWhereUniqueInput
  }

  export type IssueCreateNestedOneWithoutBlueprintSectionsInput = {
    create?: XOR<IssueCreateWithoutBlueprintSectionsInput, IssueUncheckedCreateWithoutBlueprintSectionsInput>
    connectOrCreate?: IssueCreateOrConnectWithoutBlueprintSectionsInput
    connect?: IssueWhereUniqueInput
  }

  export type SourceDocumentLinkCreateNestedManyWithoutBlueprintSectionInput = {
    create?: XOR<SourceDocumentLinkCreateWithoutBlueprintSectionInput, SourceDocumentLinkUncheckedCreateWithoutBlueprintSectionInput> | SourceDocumentLinkCreateWithoutBlueprintSectionInput[] | SourceDocumentLinkUncheckedCreateWithoutBlueprintSectionInput[]
    connectOrCreate?: SourceDocumentLinkCreateOrConnectWithoutBlueprintSectionInput | SourceDocumentLinkCreateOrConnectWithoutBlueprintSectionInput[]
    createMany?: SourceDocumentLinkCreateManyBlueprintSectionInputEnvelope
    connect?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
  }

  export type SourceDocumentLinkUncheckedCreateNestedManyWithoutBlueprintSectionInput = {
    create?: XOR<SourceDocumentLinkCreateWithoutBlueprintSectionInput, SourceDocumentLinkUncheckedCreateWithoutBlueprintSectionInput> | SourceDocumentLinkCreateWithoutBlueprintSectionInput[] | SourceDocumentLinkUncheckedCreateWithoutBlueprintSectionInput[]
    connectOrCreate?: SourceDocumentLinkCreateOrConnectWithoutBlueprintSectionInput | SourceDocumentLinkCreateOrConnectWithoutBlueprintSectionInput[]
    createMany?: SourceDocumentLinkCreateManyBlueprintSectionInputEnvelope
    connect?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
  }

  export type CountyUpdateOneWithoutBlueprintSectionsNestedInput = {
    create?: XOR<CountyCreateWithoutBlueprintSectionsInput, CountyUncheckedCreateWithoutBlueprintSectionsInput>
    connectOrCreate?: CountyCreateOrConnectWithoutBlueprintSectionsInput
    upsert?: CountyUpsertWithoutBlueprintSectionsInput
    disconnect?: CountyWhereInput | boolean
    delete?: CountyWhereInput | boolean
    connect?: CountyWhereUniqueInput
    update?: XOR<XOR<CountyUpdateToOneWithWhereWithoutBlueprintSectionsInput, CountyUpdateWithoutBlueprintSectionsInput>, CountyUncheckedUpdateWithoutBlueprintSectionsInput>
  }

  export type IssueUpdateOneWithoutBlueprintSectionsNestedInput = {
    create?: XOR<IssueCreateWithoutBlueprintSectionsInput, IssueUncheckedCreateWithoutBlueprintSectionsInput>
    connectOrCreate?: IssueCreateOrConnectWithoutBlueprintSectionsInput
    upsert?: IssueUpsertWithoutBlueprintSectionsInput
    disconnect?: IssueWhereInput | boolean
    delete?: IssueWhereInput | boolean
    connect?: IssueWhereUniqueInput
    update?: XOR<XOR<IssueUpdateToOneWithWhereWithoutBlueprintSectionsInput, IssueUpdateWithoutBlueprintSectionsInput>, IssueUncheckedUpdateWithoutBlueprintSectionsInput>
  }

  export type SourceDocumentLinkUpdateManyWithoutBlueprintSectionNestedInput = {
    create?: XOR<SourceDocumentLinkCreateWithoutBlueprintSectionInput, SourceDocumentLinkUncheckedCreateWithoutBlueprintSectionInput> | SourceDocumentLinkCreateWithoutBlueprintSectionInput[] | SourceDocumentLinkUncheckedCreateWithoutBlueprintSectionInput[]
    connectOrCreate?: SourceDocumentLinkCreateOrConnectWithoutBlueprintSectionInput | SourceDocumentLinkCreateOrConnectWithoutBlueprintSectionInput[]
    upsert?: SourceDocumentLinkUpsertWithWhereUniqueWithoutBlueprintSectionInput | SourceDocumentLinkUpsertWithWhereUniqueWithoutBlueprintSectionInput[]
    createMany?: SourceDocumentLinkCreateManyBlueprintSectionInputEnvelope
    set?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
    disconnect?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
    delete?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
    connect?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
    update?: SourceDocumentLinkUpdateWithWhereUniqueWithoutBlueprintSectionInput | SourceDocumentLinkUpdateWithWhereUniqueWithoutBlueprintSectionInput[]
    updateMany?: SourceDocumentLinkUpdateManyWithWhereWithoutBlueprintSectionInput | SourceDocumentLinkUpdateManyWithWhereWithoutBlueprintSectionInput[]
    deleteMany?: SourceDocumentLinkScalarWhereInput | SourceDocumentLinkScalarWhereInput[]
  }

  export type SourceDocumentLinkUncheckedUpdateManyWithoutBlueprintSectionNestedInput = {
    create?: XOR<SourceDocumentLinkCreateWithoutBlueprintSectionInput, SourceDocumentLinkUncheckedCreateWithoutBlueprintSectionInput> | SourceDocumentLinkCreateWithoutBlueprintSectionInput[] | SourceDocumentLinkUncheckedCreateWithoutBlueprintSectionInput[]
    connectOrCreate?: SourceDocumentLinkCreateOrConnectWithoutBlueprintSectionInput | SourceDocumentLinkCreateOrConnectWithoutBlueprintSectionInput[]
    upsert?: SourceDocumentLinkUpsertWithWhereUniqueWithoutBlueprintSectionInput | SourceDocumentLinkUpsertWithWhereUniqueWithoutBlueprintSectionInput[]
    createMany?: SourceDocumentLinkCreateManyBlueprintSectionInputEnvelope
    set?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
    disconnect?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
    delete?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
    connect?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
    update?: SourceDocumentLinkUpdateWithWhereUniqueWithoutBlueprintSectionInput | SourceDocumentLinkUpdateWithWhereUniqueWithoutBlueprintSectionInput[]
    updateMany?: SourceDocumentLinkUpdateManyWithWhereWithoutBlueprintSectionInput | SourceDocumentLinkUpdateManyWithWhereWithoutBlueprintSectionInput[]
    deleteMany?: SourceDocumentLinkScalarWhereInput | SourceDocumentLinkScalarWhereInput[]
  }

  export type CountyCreateNestedOneWithoutQuotesInput = {
    create?: XOR<CountyCreateWithoutQuotesInput, CountyUncheckedCreateWithoutQuotesInput>
    connectOrCreate?: CountyCreateOrConnectWithoutQuotesInput
    connect?: CountyWhereUniqueInput
  }

  export type IssueCreateNestedOneWithoutQuotesInput = {
    create?: XOR<IssueCreateWithoutQuotesInput, IssueUncheckedCreateWithoutQuotesInput>
    connectOrCreate?: IssueCreateOrConnectWithoutQuotesInput
    connect?: IssueWhereUniqueInput
  }

  export type SourceDocumentLinkCreateNestedManyWithoutQuoteInput = {
    create?: XOR<SourceDocumentLinkCreateWithoutQuoteInput, SourceDocumentLinkUncheckedCreateWithoutQuoteInput> | SourceDocumentLinkCreateWithoutQuoteInput[] | SourceDocumentLinkUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: SourceDocumentLinkCreateOrConnectWithoutQuoteInput | SourceDocumentLinkCreateOrConnectWithoutQuoteInput[]
    createMany?: SourceDocumentLinkCreateManyQuoteInputEnvelope
    connect?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
  }

  export type SourceDocumentLinkUncheckedCreateNestedManyWithoutQuoteInput = {
    create?: XOR<SourceDocumentLinkCreateWithoutQuoteInput, SourceDocumentLinkUncheckedCreateWithoutQuoteInput> | SourceDocumentLinkCreateWithoutQuoteInput[] | SourceDocumentLinkUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: SourceDocumentLinkCreateOrConnectWithoutQuoteInput | SourceDocumentLinkCreateOrConnectWithoutQuoteInput[]
    createMany?: SourceDocumentLinkCreateManyQuoteInputEnvelope
    connect?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
  }

  export type CountyUpdateOneRequiredWithoutQuotesNestedInput = {
    create?: XOR<CountyCreateWithoutQuotesInput, CountyUncheckedCreateWithoutQuotesInput>
    connectOrCreate?: CountyCreateOrConnectWithoutQuotesInput
    upsert?: CountyUpsertWithoutQuotesInput
    connect?: CountyWhereUniqueInput
    update?: XOR<XOR<CountyUpdateToOneWithWhereWithoutQuotesInput, CountyUpdateWithoutQuotesInput>, CountyUncheckedUpdateWithoutQuotesInput>
  }

  export type IssueUpdateOneWithoutQuotesNestedInput = {
    create?: XOR<IssueCreateWithoutQuotesInput, IssueUncheckedCreateWithoutQuotesInput>
    connectOrCreate?: IssueCreateOrConnectWithoutQuotesInput
    upsert?: IssueUpsertWithoutQuotesInput
    disconnect?: IssueWhereInput | boolean
    delete?: IssueWhereInput | boolean
    connect?: IssueWhereUniqueInput
    update?: XOR<XOR<IssueUpdateToOneWithWhereWithoutQuotesInput, IssueUpdateWithoutQuotesInput>, IssueUncheckedUpdateWithoutQuotesInput>
  }

  export type SourceDocumentLinkUpdateManyWithoutQuoteNestedInput = {
    create?: XOR<SourceDocumentLinkCreateWithoutQuoteInput, SourceDocumentLinkUncheckedCreateWithoutQuoteInput> | SourceDocumentLinkCreateWithoutQuoteInput[] | SourceDocumentLinkUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: SourceDocumentLinkCreateOrConnectWithoutQuoteInput | SourceDocumentLinkCreateOrConnectWithoutQuoteInput[]
    upsert?: SourceDocumentLinkUpsertWithWhereUniqueWithoutQuoteInput | SourceDocumentLinkUpsertWithWhereUniqueWithoutQuoteInput[]
    createMany?: SourceDocumentLinkCreateManyQuoteInputEnvelope
    set?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
    disconnect?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
    delete?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
    connect?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
    update?: SourceDocumentLinkUpdateWithWhereUniqueWithoutQuoteInput | SourceDocumentLinkUpdateWithWhereUniqueWithoutQuoteInput[]
    updateMany?: SourceDocumentLinkUpdateManyWithWhereWithoutQuoteInput | SourceDocumentLinkUpdateManyWithWhereWithoutQuoteInput[]
    deleteMany?: SourceDocumentLinkScalarWhereInput | SourceDocumentLinkScalarWhereInput[]
  }

  export type SourceDocumentLinkUncheckedUpdateManyWithoutQuoteNestedInput = {
    create?: XOR<SourceDocumentLinkCreateWithoutQuoteInput, SourceDocumentLinkUncheckedCreateWithoutQuoteInput> | SourceDocumentLinkCreateWithoutQuoteInput[] | SourceDocumentLinkUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: SourceDocumentLinkCreateOrConnectWithoutQuoteInput | SourceDocumentLinkCreateOrConnectWithoutQuoteInput[]
    upsert?: SourceDocumentLinkUpsertWithWhereUniqueWithoutQuoteInput | SourceDocumentLinkUpsertWithWhereUniqueWithoutQuoteInput[]
    createMany?: SourceDocumentLinkCreateManyQuoteInputEnvelope
    set?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
    disconnect?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
    delete?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
    connect?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
    update?: SourceDocumentLinkUpdateWithWhereUniqueWithoutQuoteInput | SourceDocumentLinkUpdateWithWhereUniqueWithoutQuoteInput[]
    updateMany?: SourceDocumentLinkUpdateManyWithWhereWithoutQuoteInput | SourceDocumentLinkUpdateManyWithWhereWithoutQuoteInput[]
    deleteMany?: SourceDocumentLinkScalarWhereInput | SourceDocumentLinkScalarWhereInput[]
  }

  export type CountyCreateNestedOneWithoutAssetsInput = {
    create?: XOR<CountyCreateWithoutAssetsInput, CountyUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: CountyCreateOrConnectWithoutAssetsInput
    connect?: CountyWhereUniqueInput
  }

  export type IssueCreateNestedOneWithoutAssetsInput = {
    create?: XOR<IssueCreateWithoutAssetsInput, IssueUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: IssueCreateOrConnectWithoutAssetsInput
    connect?: IssueWhereUniqueInput
  }

  export type SourceDocumentLinkCreateNestedManyWithoutAssetInput = {
    create?: XOR<SourceDocumentLinkCreateWithoutAssetInput, SourceDocumentLinkUncheckedCreateWithoutAssetInput> | SourceDocumentLinkCreateWithoutAssetInput[] | SourceDocumentLinkUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: SourceDocumentLinkCreateOrConnectWithoutAssetInput | SourceDocumentLinkCreateOrConnectWithoutAssetInput[]
    createMany?: SourceDocumentLinkCreateManyAssetInputEnvelope
    connect?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
  }

  export type SourceDocumentLinkUncheckedCreateNestedManyWithoutAssetInput = {
    create?: XOR<SourceDocumentLinkCreateWithoutAssetInput, SourceDocumentLinkUncheckedCreateWithoutAssetInput> | SourceDocumentLinkCreateWithoutAssetInput[] | SourceDocumentLinkUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: SourceDocumentLinkCreateOrConnectWithoutAssetInput | SourceDocumentLinkCreateOrConnectWithoutAssetInput[]
    createMany?: SourceDocumentLinkCreateManyAssetInputEnvelope
    connect?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
  }

  export type EnumAssetTypeFieldUpdateOperationsInput = {
    set?: $Enums.AssetType
  }

  export type CountyUpdateOneWithoutAssetsNestedInput = {
    create?: XOR<CountyCreateWithoutAssetsInput, CountyUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: CountyCreateOrConnectWithoutAssetsInput
    upsert?: CountyUpsertWithoutAssetsInput
    disconnect?: CountyWhereInput | boolean
    delete?: CountyWhereInput | boolean
    connect?: CountyWhereUniqueInput
    update?: XOR<XOR<CountyUpdateToOneWithWhereWithoutAssetsInput, CountyUpdateWithoutAssetsInput>, CountyUncheckedUpdateWithoutAssetsInput>
  }

  export type IssueUpdateOneWithoutAssetsNestedInput = {
    create?: XOR<IssueCreateWithoutAssetsInput, IssueUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: IssueCreateOrConnectWithoutAssetsInput
    upsert?: IssueUpsertWithoutAssetsInput
    disconnect?: IssueWhereInput | boolean
    delete?: IssueWhereInput | boolean
    connect?: IssueWhereUniqueInput
    update?: XOR<XOR<IssueUpdateToOneWithWhereWithoutAssetsInput, IssueUpdateWithoutAssetsInput>, IssueUncheckedUpdateWithoutAssetsInput>
  }

  export type SourceDocumentLinkUpdateManyWithoutAssetNestedInput = {
    create?: XOR<SourceDocumentLinkCreateWithoutAssetInput, SourceDocumentLinkUncheckedCreateWithoutAssetInput> | SourceDocumentLinkCreateWithoutAssetInput[] | SourceDocumentLinkUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: SourceDocumentLinkCreateOrConnectWithoutAssetInput | SourceDocumentLinkCreateOrConnectWithoutAssetInput[]
    upsert?: SourceDocumentLinkUpsertWithWhereUniqueWithoutAssetInput | SourceDocumentLinkUpsertWithWhereUniqueWithoutAssetInput[]
    createMany?: SourceDocumentLinkCreateManyAssetInputEnvelope
    set?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
    disconnect?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
    delete?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
    connect?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
    update?: SourceDocumentLinkUpdateWithWhereUniqueWithoutAssetInput | SourceDocumentLinkUpdateWithWhereUniqueWithoutAssetInput[]
    updateMany?: SourceDocumentLinkUpdateManyWithWhereWithoutAssetInput | SourceDocumentLinkUpdateManyWithWhereWithoutAssetInput[]
    deleteMany?: SourceDocumentLinkScalarWhereInput | SourceDocumentLinkScalarWhereInput[]
  }

  export type SourceDocumentLinkUncheckedUpdateManyWithoutAssetNestedInput = {
    create?: XOR<SourceDocumentLinkCreateWithoutAssetInput, SourceDocumentLinkUncheckedCreateWithoutAssetInput> | SourceDocumentLinkCreateWithoutAssetInput[] | SourceDocumentLinkUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: SourceDocumentLinkCreateOrConnectWithoutAssetInput | SourceDocumentLinkCreateOrConnectWithoutAssetInput[]
    upsert?: SourceDocumentLinkUpsertWithWhereUniqueWithoutAssetInput | SourceDocumentLinkUpsertWithWhereUniqueWithoutAssetInput[]
    createMany?: SourceDocumentLinkCreateManyAssetInputEnvelope
    set?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
    disconnect?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
    delete?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
    connect?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
    update?: SourceDocumentLinkUpdateWithWhereUniqueWithoutAssetInput | SourceDocumentLinkUpdateWithWhereUniqueWithoutAssetInput[]
    updateMany?: SourceDocumentLinkUpdateManyWithWhereWithoutAssetInput | SourceDocumentLinkUpdateManyWithWhereWithoutAssetInput[]
    deleteMany?: SourceDocumentLinkScalarWhereInput | SourceDocumentLinkScalarWhereInput[]
  }

  export type SourceChunkCreateNestedManyWithoutSourceDocumentInput = {
    create?: XOR<SourceChunkCreateWithoutSourceDocumentInput, SourceChunkUncheckedCreateWithoutSourceDocumentInput> | SourceChunkCreateWithoutSourceDocumentInput[] | SourceChunkUncheckedCreateWithoutSourceDocumentInput[]
    connectOrCreate?: SourceChunkCreateOrConnectWithoutSourceDocumentInput | SourceChunkCreateOrConnectWithoutSourceDocumentInput[]
    createMany?: SourceChunkCreateManySourceDocumentInputEnvelope
    connect?: SourceChunkWhereUniqueInput | SourceChunkWhereUniqueInput[]
  }

  export type CitationCreateNestedManyWithoutSourceDocumentInput = {
    create?: XOR<CitationCreateWithoutSourceDocumentInput, CitationUncheckedCreateWithoutSourceDocumentInput> | CitationCreateWithoutSourceDocumentInput[] | CitationUncheckedCreateWithoutSourceDocumentInput[]
    connectOrCreate?: CitationCreateOrConnectWithoutSourceDocumentInput | CitationCreateOrConnectWithoutSourceDocumentInput[]
    createMany?: CitationCreateManySourceDocumentInputEnvelope
    connect?: CitationWhereUniqueInput | CitationWhereUniqueInput[]
  }

  export type AIRunInputSourceCreateNestedManyWithoutSourceDocumentInput = {
    create?: XOR<AIRunInputSourceCreateWithoutSourceDocumentInput, AIRunInputSourceUncheckedCreateWithoutSourceDocumentInput> | AIRunInputSourceCreateWithoutSourceDocumentInput[] | AIRunInputSourceUncheckedCreateWithoutSourceDocumentInput[]
    connectOrCreate?: AIRunInputSourceCreateOrConnectWithoutSourceDocumentInput | AIRunInputSourceCreateOrConnectWithoutSourceDocumentInput[]
    createMany?: AIRunInputSourceCreateManySourceDocumentInputEnvelope
    connect?: AIRunInputSourceWhereUniqueInput | AIRunInputSourceWhereUniqueInput[]
  }

  export type SourceDocumentLinkCreateNestedManyWithoutSourceDocumentInput = {
    create?: XOR<SourceDocumentLinkCreateWithoutSourceDocumentInput, SourceDocumentLinkUncheckedCreateWithoutSourceDocumentInput> | SourceDocumentLinkCreateWithoutSourceDocumentInput[] | SourceDocumentLinkUncheckedCreateWithoutSourceDocumentInput[]
    connectOrCreate?: SourceDocumentLinkCreateOrConnectWithoutSourceDocumentInput | SourceDocumentLinkCreateOrConnectWithoutSourceDocumentInput[]
    createMany?: SourceDocumentLinkCreateManySourceDocumentInputEnvelope
    connect?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
  }

  export type SourceChunkUncheckedCreateNestedManyWithoutSourceDocumentInput = {
    create?: XOR<SourceChunkCreateWithoutSourceDocumentInput, SourceChunkUncheckedCreateWithoutSourceDocumentInput> | SourceChunkCreateWithoutSourceDocumentInput[] | SourceChunkUncheckedCreateWithoutSourceDocumentInput[]
    connectOrCreate?: SourceChunkCreateOrConnectWithoutSourceDocumentInput | SourceChunkCreateOrConnectWithoutSourceDocumentInput[]
    createMany?: SourceChunkCreateManySourceDocumentInputEnvelope
    connect?: SourceChunkWhereUniqueInput | SourceChunkWhereUniqueInput[]
  }

  export type CitationUncheckedCreateNestedManyWithoutSourceDocumentInput = {
    create?: XOR<CitationCreateWithoutSourceDocumentInput, CitationUncheckedCreateWithoutSourceDocumentInput> | CitationCreateWithoutSourceDocumentInput[] | CitationUncheckedCreateWithoutSourceDocumentInput[]
    connectOrCreate?: CitationCreateOrConnectWithoutSourceDocumentInput | CitationCreateOrConnectWithoutSourceDocumentInput[]
    createMany?: CitationCreateManySourceDocumentInputEnvelope
    connect?: CitationWhereUniqueInput | CitationWhereUniqueInput[]
  }

  export type AIRunInputSourceUncheckedCreateNestedManyWithoutSourceDocumentInput = {
    create?: XOR<AIRunInputSourceCreateWithoutSourceDocumentInput, AIRunInputSourceUncheckedCreateWithoutSourceDocumentInput> | AIRunInputSourceCreateWithoutSourceDocumentInput[] | AIRunInputSourceUncheckedCreateWithoutSourceDocumentInput[]
    connectOrCreate?: AIRunInputSourceCreateOrConnectWithoutSourceDocumentInput | AIRunInputSourceCreateOrConnectWithoutSourceDocumentInput[]
    createMany?: AIRunInputSourceCreateManySourceDocumentInputEnvelope
    connect?: AIRunInputSourceWhereUniqueInput | AIRunInputSourceWhereUniqueInput[]
  }

  export type SourceDocumentLinkUncheckedCreateNestedManyWithoutSourceDocumentInput = {
    create?: XOR<SourceDocumentLinkCreateWithoutSourceDocumentInput, SourceDocumentLinkUncheckedCreateWithoutSourceDocumentInput> | SourceDocumentLinkCreateWithoutSourceDocumentInput[] | SourceDocumentLinkUncheckedCreateWithoutSourceDocumentInput[]
    connectOrCreate?: SourceDocumentLinkCreateOrConnectWithoutSourceDocumentInput | SourceDocumentLinkCreateOrConnectWithoutSourceDocumentInput[]
    createMany?: SourceDocumentLinkCreateManySourceDocumentInputEnvelope
    connect?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type SourceChunkUpdateManyWithoutSourceDocumentNestedInput = {
    create?: XOR<SourceChunkCreateWithoutSourceDocumentInput, SourceChunkUncheckedCreateWithoutSourceDocumentInput> | SourceChunkCreateWithoutSourceDocumentInput[] | SourceChunkUncheckedCreateWithoutSourceDocumentInput[]
    connectOrCreate?: SourceChunkCreateOrConnectWithoutSourceDocumentInput | SourceChunkCreateOrConnectWithoutSourceDocumentInput[]
    upsert?: SourceChunkUpsertWithWhereUniqueWithoutSourceDocumentInput | SourceChunkUpsertWithWhereUniqueWithoutSourceDocumentInput[]
    createMany?: SourceChunkCreateManySourceDocumentInputEnvelope
    set?: SourceChunkWhereUniqueInput | SourceChunkWhereUniqueInput[]
    disconnect?: SourceChunkWhereUniqueInput | SourceChunkWhereUniqueInput[]
    delete?: SourceChunkWhereUniqueInput | SourceChunkWhereUniqueInput[]
    connect?: SourceChunkWhereUniqueInput | SourceChunkWhereUniqueInput[]
    update?: SourceChunkUpdateWithWhereUniqueWithoutSourceDocumentInput | SourceChunkUpdateWithWhereUniqueWithoutSourceDocumentInput[]
    updateMany?: SourceChunkUpdateManyWithWhereWithoutSourceDocumentInput | SourceChunkUpdateManyWithWhereWithoutSourceDocumentInput[]
    deleteMany?: SourceChunkScalarWhereInput | SourceChunkScalarWhereInput[]
  }

  export type CitationUpdateManyWithoutSourceDocumentNestedInput = {
    create?: XOR<CitationCreateWithoutSourceDocumentInput, CitationUncheckedCreateWithoutSourceDocumentInput> | CitationCreateWithoutSourceDocumentInput[] | CitationUncheckedCreateWithoutSourceDocumentInput[]
    connectOrCreate?: CitationCreateOrConnectWithoutSourceDocumentInput | CitationCreateOrConnectWithoutSourceDocumentInput[]
    upsert?: CitationUpsertWithWhereUniqueWithoutSourceDocumentInput | CitationUpsertWithWhereUniqueWithoutSourceDocumentInput[]
    createMany?: CitationCreateManySourceDocumentInputEnvelope
    set?: CitationWhereUniqueInput | CitationWhereUniqueInput[]
    disconnect?: CitationWhereUniqueInput | CitationWhereUniqueInput[]
    delete?: CitationWhereUniqueInput | CitationWhereUniqueInput[]
    connect?: CitationWhereUniqueInput | CitationWhereUniqueInput[]
    update?: CitationUpdateWithWhereUniqueWithoutSourceDocumentInput | CitationUpdateWithWhereUniqueWithoutSourceDocumentInput[]
    updateMany?: CitationUpdateManyWithWhereWithoutSourceDocumentInput | CitationUpdateManyWithWhereWithoutSourceDocumentInput[]
    deleteMany?: CitationScalarWhereInput | CitationScalarWhereInput[]
  }

  export type AIRunInputSourceUpdateManyWithoutSourceDocumentNestedInput = {
    create?: XOR<AIRunInputSourceCreateWithoutSourceDocumentInput, AIRunInputSourceUncheckedCreateWithoutSourceDocumentInput> | AIRunInputSourceCreateWithoutSourceDocumentInput[] | AIRunInputSourceUncheckedCreateWithoutSourceDocumentInput[]
    connectOrCreate?: AIRunInputSourceCreateOrConnectWithoutSourceDocumentInput | AIRunInputSourceCreateOrConnectWithoutSourceDocumentInput[]
    upsert?: AIRunInputSourceUpsertWithWhereUniqueWithoutSourceDocumentInput | AIRunInputSourceUpsertWithWhereUniqueWithoutSourceDocumentInput[]
    createMany?: AIRunInputSourceCreateManySourceDocumentInputEnvelope
    set?: AIRunInputSourceWhereUniqueInput | AIRunInputSourceWhereUniqueInput[]
    disconnect?: AIRunInputSourceWhereUniqueInput | AIRunInputSourceWhereUniqueInput[]
    delete?: AIRunInputSourceWhereUniqueInput | AIRunInputSourceWhereUniqueInput[]
    connect?: AIRunInputSourceWhereUniqueInput | AIRunInputSourceWhereUniqueInput[]
    update?: AIRunInputSourceUpdateWithWhereUniqueWithoutSourceDocumentInput | AIRunInputSourceUpdateWithWhereUniqueWithoutSourceDocumentInput[]
    updateMany?: AIRunInputSourceUpdateManyWithWhereWithoutSourceDocumentInput | AIRunInputSourceUpdateManyWithWhereWithoutSourceDocumentInput[]
    deleteMany?: AIRunInputSourceScalarWhereInput | AIRunInputSourceScalarWhereInput[]
  }

  export type SourceDocumentLinkUpdateManyWithoutSourceDocumentNestedInput = {
    create?: XOR<SourceDocumentLinkCreateWithoutSourceDocumentInput, SourceDocumentLinkUncheckedCreateWithoutSourceDocumentInput> | SourceDocumentLinkCreateWithoutSourceDocumentInput[] | SourceDocumentLinkUncheckedCreateWithoutSourceDocumentInput[]
    connectOrCreate?: SourceDocumentLinkCreateOrConnectWithoutSourceDocumentInput | SourceDocumentLinkCreateOrConnectWithoutSourceDocumentInput[]
    upsert?: SourceDocumentLinkUpsertWithWhereUniqueWithoutSourceDocumentInput | SourceDocumentLinkUpsertWithWhereUniqueWithoutSourceDocumentInput[]
    createMany?: SourceDocumentLinkCreateManySourceDocumentInputEnvelope
    set?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
    disconnect?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
    delete?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
    connect?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
    update?: SourceDocumentLinkUpdateWithWhereUniqueWithoutSourceDocumentInput | SourceDocumentLinkUpdateWithWhereUniqueWithoutSourceDocumentInput[]
    updateMany?: SourceDocumentLinkUpdateManyWithWhereWithoutSourceDocumentInput | SourceDocumentLinkUpdateManyWithWhereWithoutSourceDocumentInput[]
    deleteMany?: SourceDocumentLinkScalarWhereInput | SourceDocumentLinkScalarWhereInput[]
  }

  export type SourceChunkUncheckedUpdateManyWithoutSourceDocumentNestedInput = {
    create?: XOR<SourceChunkCreateWithoutSourceDocumentInput, SourceChunkUncheckedCreateWithoutSourceDocumentInput> | SourceChunkCreateWithoutSourceDocumentInput[] | SourceChunkUncheckedCreateWithoutSourceDocumentInput[]
    connectOrCreate?: SourceChunkCreateOrConnectWithoutSourceDocumentInput | SourceChunkCreateOrConnectWithoutSourceDocumentInput[]
    upsert?: SourceChunkUpsertWithWhereUniqueWithoutSourceDocumentInput | SourceChunkUpsertWithWhereUniqueWithoutSourceDocumentInput[]
    createMany?: SourceChunkCreateManySourceDocumentInputEnvelope
    set?: SourceChunkWhereUniqueInput | SourceChunkWhereUniqueInput[]
    disconnect?: SourceChunkWhereUniqueInput | SourceChunkWhereUniqueInput[]
    delete?: SourceChunkWhereUniqueInput | SourceChunkWhereUniqueInput[]
    connect?: SourceChunkWhereUniqueInput | SourceChunkWhereUniqueInput[]
    update?: SourceChunkUpdateWithWhereUniqueWithoutSourceDocumentInput | SourceChunkUpdateWithWhereUniqueWithoutSourceDocumentInput[]
    updateMany?: SourceChunkUpdateManyWithWhereWithoutSourceDocumentInput | SourceChunkUpdateManyWithWhereWithoutSourceDocumentInput[]
    deleteMany?: SourceChunkScalarWhereInput | SourceChunkScalarWhereInput[]
  }

  export type CitationUncheckedUpdateManyWithoutSourceDocumentNestedInput = {
    create?: XOR<CitationCreateWithoutSourceDocumentInput, CitationUncheckedCreateWithoutSourceDocumentInput> | CitationCreateWithoutSourceDocumentInput[] | CitationUncheckedCreateWithoutSourceDocumentInput[]
    connectOrCreate?: CitationCreateOrConnectWithoutSourceDocumentInput | CitationCreateOrConnectWithoutSourceDocumentInput[]
    upsert?: CitationUpsertWithWhereUniqueWithoutSourceDocumentInput | CitationUpsertWithWhereUniqueWithoutSourceDocumentInput[]
    createMany?: CitationCreateManySourceDocumentInputEnvelope
    set?: CitationWhereUniqueInput | CitationWhereUniqueInput[]
    disconnect?: CitationWhereUniqueInput | CitationWhereUniqueInput[]
    delete?: CitationWhereUniqueInput | CitationWhereUniqueInput[]
    connect?: CitationWhereUniqueInput | CitationWhereUniqueInput[]
    update?: CitationUpdateWithWhereUniqueWithoutSourceDocumentInput | CitationUpdateWithWhereUniqueWithoutSourceDocumentInput[]
    updateMany?: CitationUpdateManyWithWhereWithoutSourceDocumentInput | CitationUpdateManyWithWhereWithoutSourceDocumentInput[]
    deleteMany?: CitationScalarWhereInput | CitationScalarWhereInput[]
  }

  export type AIRunInputSourceUncheckedUpdateManyWithoutSourceDocumentNestedInput = {
    create?: XOR<AIRunInputSourceCreateWithoutSourceDocumentInput, AIRunInputSourceUncheckedCreateWithoutSourceDocumentInput> | AIRunInputSourceCreateWithoutSourceDocumentInput[] | AIRunInputSourceUncheckedCreateWithoutSourceDocumentInput[]
    connectOrCreate?: AIRunInputSourceCreateOrConnectWithoutSourceDocumentInput | AIRunInputSourceCreateOrConnectWithoutSourceDocumentInput[]
    upsert?: AIRunInputSourceUpsertWithWhereUniqueWithoutSourceDocumentInput | AIRunInputSourceUpsertWithWhereUniqueWithoutSourceDocumentInput[]
    createMany?: AIRunInputSourceCreateManySourceDocumentInputEnvelope
    set?: AIRunInputSourceWhereUniqueInput | AIRunInputSourceWhereUniqueInput[]
    disconnect?: AIRunInputSourceWhereUniqueInput | AIRunInputSourceWhereUniqueInput[]
    delete?: AIRunInputSourceWhereUniqueInput | AIRunInputSourceWhereUniqueInput[]
    connect?: AIRunInputSourceWhereUniqueInput | AIRunInputSourceWhereUniqueInput[]
    update?: AIRunInputSourceUpdateWithWhereUniqueWithoutSourceDocumentInput | AIRunInputSourceUpdateWithWhereUniqueWithoutSourceDocumentInput[]
    updateMany?: AIRunInputSourceUpdateManyWithWhereWithoutSourceDocumentInput | AIRunInputSourceUpdateManyWithWhereWithoutSourceDocumentInput[]
    deleteMany?: AIRunInputSourceScalarWhereInput | AIRunInputSourceScalarWhereInput[]
  }

  export type SourceDocumentLinkUncheckedUpdateManyWithoutSourceDocumentNestedInput = {
    create?: XOR<SourceDocumentLinkCreateWithoutSourceDocumentInput, SourceDocumentLinkUncheckedCreateWithoutSourceDocumentInput> | SourceDocumentLinkCreateWithoutSourceDocumentInput[] | SourceDocumentLinkUncheckedCreateWithoutSourceDocumentInput[]
    connectOrCreate?: SourceDocumentLinkCreateOrConnectWithoutSourceDocumentInput | SourceDocumentLinkCreateOrConnectWithoutSourceDocumentInput[]
    upsert?: SourceDocumentLinkUpsertWithWhereUniqueWithoutSourceDocumentInput | SourceDocumentLinkUpsertWithWhereUniqueWithoutSourceDocumentInput[]
    createMany?: SourceDocumentLinkCreateManySourceDocumentInputEnvelope
    set?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
    disconnect?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
    delete?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
    connect?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
    update?: SourceDocumentLinkUpdateWithWhereUniqueWithoutSourceDocumentInput | SourceDocumentLinkUpdateWithWhereUniqueWithoutSourceDocumentInput[]
    updateMany?: SourceDocumentLinkUpdateManyWithWhereWithoutSourceDocumentInput | SourceDocumentLinkUpdateManyWithWhereWithoutSourceDocumentInput[]
    deleteMany?: SourceDocumentLinkScalarWhereInput | SourceDocumentLinkScalarWhereInput[]
  }

  export type SourceDocumentCreateNestedOneWithoutChunksInput = {
    create?: XOR<SourceDocumentCreateWithoutChunksInput, SourceDocumentUncheckedCreateWithoutChunksInput>
    connectOrCreate?: SourceDocumentCreateOrConnectWithoutChunksInput
    connect?: SourceDocumentWhereUniqueInput
  }

  export type CitationCreateNestedManyWithoutSourceChunkInput = {
    create?: XOR<CitationCreateWithoutSourceChunkInput, CitationUncheckedCreateWithoutSourceChunkInput> | CitationCreateWithoutSourceChunkInput[] | CitationUncheckedCreateWithoutSourceChunkInput[]
    connectOrCreate?: CitationCreateOrConnectWithoutSourceChunkInput | CitationCreateOrConnectWithoutSourceChunkInput[]
    createMany?: CitationCreateManySourceChunkInputEnvelope
    connect?: CitationWhereUniqueInput | CitationWhereUniqueInput[]
  }

  export type CitationUncheckedCreateNestedManyWithoutSourceChunkInput = {
    create?: XOR<CitationCreateWithoutSourceChunkInput, CitationUncheckedCreateWithoutSourceChunkInput> | CitationCreateWithoutSourceChunkInput[] | CitationUncheckedCreateWithoutSourceChunkInput[]
    connectOrCreate?: CitationCreateOrConnectWithoutSourceChunkInput | CitationCreateOrConnectWithoutSourceChunkInput[]
    createMany?: CitationCreateManySourceChunkInputEnvelope
    connect?: CitationWhereUniqueInput | CitationWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SourceDocumentUpdateOneRequiredWithoutChunksNestedInput = {
    create?: XOR<SourceDocumentCreateWithoutChunksInput, SourceDocumentUncheckedCreateWithoutChunksInput>
    connectOrCreate?: SourceDocumentCreateOrConnectWithoutChunksInput
    upsert?: SourceDocumentUpsertWithoutChunksInput
    connect?: SourceDocumentWhereUniqueInput
    update?: XOR<XOR<SourceDocumentUpdateToOneWithWhereWithoutChunksInput, SourceDocumentUpdateWithoutChunksInput>, SourceDocumentUncheckedUpdateWithoutChunksInput>
  }

  export type CitationUpdateManyWithoutSourceChunkNestedInput = {
    create?: XOR<CitationCreateWithoutSourceChunkInput, CitationUncheckedCreateWithoutSourceChunkInput> | CitationCreateWithoutSourceChunkInput[] | CitationUncheckedCreateWithoutSourceChunkInput[]
    connectOrCreate?: CitationCreateOrConnectWithoutSourceChunkInput | CitationCreateOrConnectWithoutSourceChunkInput[]
    upsert?: CitationUpsertWithWhereUniqueWithoutSourceChunkInput | CitationUpsertWithWhereUniqueWithoutSourceChunkInput[]
    createMany?: CitationCreateManySourceChunkInputEnvelope
    set?: CitationWhereUniqueInput | CitationWhereUniqueInput[]
    disconnect?: CitationWhereUniqueInput | CitationWhereUniqueInput[]
    delete?: CitationWhereUniqueInput | CitationWhereUniqueInput[]
    connect?: CitationWhereUniqueInput | CitationWhereUniqueInput[]
    update?: CitationUpdateWithWhereUniqueWithoutSourceChunkInput | CitationUpdateWithWhereUniqueWithoutSourceChunkInput[]
    updateMany?: CitationUpdateManyWithWhereWithoutSourceChunkInput | CitationUpdateManyWithWhereWithoutSourceChunkInput[]
    deleteMany?: CitationScalarWhereInput | CitationScalarWhereInput[]
  }

  export type CitationUncheckedUpdateManyWithoutSourceChunkNestedInput = {
    create?: XOR<CitationCreateWithoutSourceChunkInput, CitationUncheckedCreateWithoutSourceChunkInput> | CitationCreateWithoutSourceChunkInput[] | CitationUncheckedCreateWithoutSourceChunkInput[]
    connectOrCreate?: CitationCreateOrConnectWithoutSourceChunkInput | CitationCreateOrConnectWithoutSourceChunkInput[]
    upsert?: CitationUpsertWithWhereUniqueWithoutSourceChunkInput | CitationUpsertWithWhereUniqueWithoutSourceChunkInput[]
    createMany?: CitationCreateManySourceChunkInputEnvelope
    set?: CitationWhereUniqueInput | CitationWhereUniqueInput[]
    disconnect?: CitationWhereUniqueInput | CitationWhereUniqueInput[]
    delete?: CitationWhereUniqueInput | CitationWhereUniqueInput[]
    connect?: CitationWhereUniqueInput | CitationWhereUniqueInput[]
    update?: CitationUpdateWithWhereUniqueWithoutSourceChunkInput | CitationUpdateWithWhereUniqueWithoutSourceChunkInput[]
    updateMany?: CitationUpdateManyWithWhereWithoutSourceChunkInput | CitationUpdateManyWithWhereWithoutSourceChunkInput[]
    deleteMany?: CitationScalarWhereInput | CitationScalarWhereInput[]
  }

  export type SourceDocumentCreateNestedOneWithoutSourceLinksInput = {
    create?: XOR<SourceDocumentCreateWithoutSourceLinksInput, SourceDocumentUncheckedCreateWithoutSourceLinksInput>
    connectOrCreate?: SourceDocumentCreateOrConnectWithoutSourceLinksInput
    connect?: SourceDocumentWhereUniqueInput
  }

  export type CountyCreateNestedOneWithoutSourceLinksInput = {
    create?: XOR<CountyCreateWithoutSourceLinksInput, CountyUncheckedCreateWithoutSourceLinksInput>
    connectOrCreate?: CountyCreateOrConnectWithoutSourceLinksInput
    connect?: CountyWhereUniqueInput
  }

  export type IssueCreateNestedOneWithoutSourceLinksInput = {
    create?: XOR<IssueCreateWithoutSourceLinksInput, IssueUncheckedCreateWithoutSourceLinksInput>
    connectOrCreate?: IssueCreateOrConnectWithoutSourceLinksInput
    connect?: IssueWhereUniqueInput
  }

  export type BlueprintSectionCreateNestedOneWithoutSourceLinksInput = {
    create?: XOR<BlueprintSectionCreateWithoutSourceLinksInput, BlueprintSectionUncheckedCreateWithoutSourceLinksInput>
    connectOrCreate?: BlueprintSectionCreateOrConnectWithoutSourceLinksInput
    connect?: BlueprintSectionWhereUniqueInput
  }

  export type QuoteCreateNestedOneWithoutSourceLinksInput = {
    create?: XOR<QuoteCreateWithoutSourceLinksInput, QuoteUncheckedCreateWithoutSourceLinksInput>
    connectOrCreate?: QuoteCreateOrConnectWithoutSourceLinksInput
    connect?: QuoteWhereUniqueInput
  }

  export type AssetCreateNestedOneWithoutSourceLinksInput = {
    create?: XOR<AssetCreateWithoutSourceLinksInput, AssetUncheckedCreateWithoutSourceLinksInput>
    connectOrCreate?: AssetCreateOrConnectWithoutSourceLinksInput
    connect?: AssetWhereUniqueInput
  }

  export type SurveyFormCreateNestedOneWithoutSourceLinksInput = {
    create?: XOR<SurveyFormCreateWithoutSourceLinksInput, SurveyFormUncheckedCreateWithoutSourceLinksInput>
    connectOrCreate?: SurveyFormCreateOrConnectWithoutSourceLinksInput
    connect?: SurveyFormWhereUniqueInput
  }

  export type SourceDocumentUpdateOneRequiredWithoutSourceLinksNestedInput = {
    create?: XOR<SourceDocumentCreateWithoutSourceLinksInput, SourceDocumentUncheckedCreateWithoutSourceLinksInput>
    connectOrCreate?: SourceDocumentCreateOrConnectWithoutSourceLinksInput
    upsert?: SourceDocumentUpsertWithoutSourceLinksInput
    connect?: SourceDocumentWhereUniqueInput
    update?: XOR<XOR<SourceDocumentUpdateToOneWithWhereWithoutSourceLinksInput, SourceDocumentUpdateWithoutSourceLinksInput>, SourceDocumentUncheckedUpdateWithoutSourceLinksInput>
  }

  export type CountyUpdateOneWithoutSourceLinksNestedInput = {
    create?: XOR<CountyCreateWithoutSourceLinksInput, CountyUncheckedCreateWithoutSourceLinksInput>
    connectOrCreate?: CountyCreateOrConnectWithoutSourceLinksInput
    upsert?: CountyUpsertWithoutSourceLinksInput
    disconnect?: CountyWhereInput | boolean
    delete?: CountyWhereInput | boolean
    connect?: CountyWhereUniqueInput
    update?: XOR<XOR<CountyUpdateToOneWithWhereWithoutSourceLinksInput, CountyUpdateWithoutSourceLinksInput>, CountyUncheckedUpdateWithoutSourceLinksInput>
  }

  export type IssueUpdateOneWithoutSourceLinksNestedInput = {
    create?: XOR<IssueCreateWithoutSourceLinksInput, IssueUncheckedCreateWithoutSourceLinksInput>
    connectOrCreate?: IssueCreateOrConnectWithoutSourceLinksInput
    upsert?: IssueUpsertWithoutSourceLinksInput
    disconnect?: IssueWhereInput | boolean
    delete?: IssueWhereInput | boolean
    connect?: IssueWhereUniqueInput
    update?: XOR<XOR<IssueUpdateToOneWithWhereWithoutSourceLinksInput, IssueUpdateWithoutSourceLinksInput>, IssueUncheckedUpdateWithoutSourceLinksInput>
  }

  export type BlueprintSectionUpdateOneWithoutSourceLinksNestedInput = {
    create?: XOR<BlueprintSectionCreateWithoutSourceLinksInput, BlueprintSectionUncheckedCreateWithoutSourceLinksInput>
    connectOrCreate?: BlueprintSectionCreateOrConnectWithoutSourceLinksInput
    upsert?: BlueprintSectionUpsertWithoutSourceLinksInput
    disconnect?: BlueprintSectionWhereInput | boolean
    delete?: BlueprintSectionWhereInput | boolean
    connect?: BlueprintSectionWhereUniqueInput
    update?: XOR<XOR<BlueprintSectionUpdateToOneWithWhereWithoutSourceLinksInput, BlueprintSectionUpdateWithoutSourceLinksInput>, BlueprintSectionUncheckedUpdateWithoutSourceLinksInput>
  }

  export type QuoteUpdateOneWithoutSourceLinksNestedInput = {
    create?: XOR<QuoteCreateWithoutSourceLinksInput, QuoteUncheckedCreateWithoutSourceLinksInput>
    connectOrCreate?: QuoteCreateOrConnectWithoutSourceLinksInput
    upsert?: QuoteUpsertWithoutSourceLinksInput
    disconnect?: QuoteWhereInput | boolean
    delete?: QuoteWhereInput | boolean
    connect?: QuoteWhereUniqueInput
    update?: XOR<XOR<QuoteUpdateToOneWithWhereWithoutSourceLinksInput, QuoteUpdateWithoutSourceLinksInput>, QuoteUncheckedUpdateWithoutSourceLinksInput>
  }

  export type AssetUpdateOneWithoutSourceLinksNestedInput = {
    create?: XOR<AssetCreateWithoutSourceLinksInput, AssetUncheckedCreateWithoutSourceLinksInput>
    connectOrCreate?: AssetCreateOrConnectWithoutSourceLinksInput
    upsert?: AssetUpsertWithoutSourceLinksInput
    disconnect?: AssetWhereInput | boolean
    delete?: AssetWhereInput | boolean
    connect?: AssetWhereUniqueInput
    update?: XOR<XOR<AssetUpdateToOneWithWhereWithoutSourceLinksInput, AssetUpdateWithoutSourceLinksInput>, AssetUncheckedUpdateWithoutSourceLinksInput>
  }

  export type SurveyFormUpdateOneWithoutSourceLinksNestedInput = {
    create?: XOR<SurveyFormCreateWithoutSourceLinksInput, SurveyFormUncheckedCreateWithoutSourceLinksInput>
    connectOrCreate?: SurveyFormCreateOrConnectWithoutSourceLinksInput
    upsert?: SurveyFormUpsertWithoutSourceLinksInput
    disconnect?: SurveyFormWhereInput | boolean
    delete?: SurveyFormWhereInput | boolean
    connect?: SurveyFormWhereUniqueInput
    update?: XOR<XOR<SurveyFormUpdateToOneWithWhereWithoutSourceLinksInput, SurveyFormUpdateWithoutSourceLinksInput>, SurveyFormUncheckedUpdateWithoutSourceLinksInput>
  }

  export type CensusMetricCreateNestedManyWithoutGeoZipInput = {
    create?: XOR<CensusMetricCreateWithoutGeoZipInput, CensusMetricUncheckedCreateWithoutGeoZipInput> | CensusMetricCreateWithoutGeoZipInput[] | CensusMetricUncheckedCreateWithoutGeoZipInput[]
    connectOrCreate?: CensusMetricCreateOrConnectWithoutGeoZipInput | CensusMetricCreateOrConnectWithoutGeoZipInput[]
    createMany?: CensusMetricCreateManyGeoZipInputEnvelope
    connect?: CensusMetricWhereUniqueInput | CensusMetricWhereUniqueInput[]
  }

  export type AIOutputScopeCreateNestedManyWithoutGeoZipInput = {
    create?: XOR<AIOutputScopeCreateWithoutGeoZipInput, AIOutputScopeUncheckedCreateWithoutGeoZipInput> | AIOutputScopeCreateWithoutGeoZipInput[] | AIOutputScopeUncheckedCreateWithoutGeoZipInput[]
    connectOrCreate?: AIOutputScopeCreateOrConnectWithoutGeoZipInput | AIOutputScopeCreateOrConnectWithoutGeoZipInput[]
    createMany?: AIOutputScopeCreateManyGeoZipInputEnvelope
    connect?: AIOutputScopeWhereUniqueInput | AIOutputScopeWhereUniqueInput[]
  }

  export type ElectionResultCreateNestedManyWithoutGeoZipInput = {
    create?: XOR<ElectionResultCreateWithoutGeoZipInput, ElectionResultUncheckedCreateWithoutGeoZipInput> | ElectionResultCreateWithoutGeoZipInput[] | ElectionResultUncheckedCreateWithoutGeoZipInput[]
    connectOrCreate?: ElectionResultCreateOrConnectWithoutGeoZipInput | ElectionResultCreateOrConnectWithoutGeoZipInput[]
    createMany?: ElectionResultCreateManyGeoZipInputEnvelope
    connect?: ElectionResultWhereUniqueInput | ElectionResultWhereUniqueInput[]
  }

  export type CensusMetricUncheckedCreateNestedManyWithoutGeoZipInput = {
    create?: XOR<CensusMetricCreateWithoutGeoZipInput, CensusMetricUncheckedCreateWithoutGeoZipInput> | CensusMetricCreateWithoutGeoZipInput[] | CensusMetricUncheckedCreateWithoutGeoZipInput[]
    connectOrCreate?: CensusMetricCreateOrConnectWithoutGeoZipInput | CensusMetricCreateOrConnectWithoutGeoZipInput[]
    createMany?: CensusMetricCreateManyGeoZipInputEnvelope
    connect?: CensusMetricWhereUniqueInput | CensusMetricWhereUniqueInput[]
  }

  export type AIOutputScopeUncheckedCreateNestedManyWithoutGeoZipInput = {
    create?: XOR<AIOutputScopeCreateWithoutGeoZipInput, AIOutputScopeUncheckedCreateWithoutGeoZipInput> | AIOutputScopeCreateWithoutGeoZipInput[] | AIOutputScopeUncheckedCreateWithoutGeoZipInput[]
    connectOrCreate?: AIOutputScopeCreateOrConnectWithoutGeoZipInput | AIOutputScopeCreateOrConnectWithoutGeoZipInput[]
    createMany?: AIOutputScopeCreateManyGeoZipInputEnvelope
    connect?: AIOutputScopeWhereUniqueInput | AIOutputScopeWhereUniqueInput[]
  }

  export type ElectionResultUncheckedCreateNestedManyWithoutGeoZipInput = {
    create?: XOR<ElectionResultCreateWithoutGeoZipInput, ElectionResultUncheckedCreateWithoutGeoZipInput> | ElectionResultCreateWithoutGeoZipInput[] | ElectionResultUncheckedCreateWithoutGeoZipInput[]
    connectOrCreate?: ElectionResultCreateOrConnectWithoutGeoZipInput | ElectionResultCreateOrConnectWithoutGeoZipInput[]
    createMany?: ElectionResultCreateManyGeoZipInputEnvelope
    connect?: ElectionResultWhereUniqueInput | ElectionResultWhereUniqueInput[]
  }

  export type CensusMetricUpdateManyWithoutGeoZipNestedInput = {
    create?: XOR<CensusMetricCreateWithoutGeoZipInput, CensusMetricUncheckedCreateWithoutGeoZipInput> | CensusMetricCreateWithoutGeoZipInput[] | CensusMetricUncheckedCreateWithoutGeoZipInput[]
    connectOrCreate?: CensusMetricCreateOrConnectWithoutGeoZipInput | CensusMetricCreateOrConnectWithoutGeoZipInput[]
    upsert?: CensusMetricUpsertWithWhereUniqueWithoutGeoZipInput | CensusMetricUpsertWithWhereUniqueWithoutGeoZipInput[]
    createMany?: CensusMetricCreateManyGeoZipInputEnvelope
    set?: CensusMetricWhereUniqueInput | CensusMetricWhereUniqueInput[]
    disconnect?: CensusMetricWhereUniqueInput | CensusMetricWhereUniqueInput[]
    delete?: CensusMetricWhereUniqueInput | CensusMetricWhereUniqueInput[]
    connect?: CensusMetricWhereUniqueInput | CensusMetricWhereUniqueInput[]
    update?: CensusMetricUpdateWithWhereUniqueWithoutGeoZipInput | CensusMetricUpdateWithWhereUniqueWithoutGeoZipInput[]
    updateMany?: CensusMetricUpdateManyWithWhereWithoutGeoZipInput | CensusMetricUpdateManyWithWhereWithoutGeoZipInput[]
    deleteMany?: CensusMetricScalarWhereInput | CensusMetricScalarWhereInput[]
  }

  export type AIOutputScopeUpdateManyWithoutGeoZipNestedInput = {
    create?: XOR<AIOutputScopeCreateWithoutGeoZipInput, AIOutputScopeUncheckedCreateWithoutGeoZipInput> | AIOutputScopeCreateWithoutGeoZipInput[] | AIOutputScopeUncheckedCreateWithoutGeoZipInput[]
    connectOrCreate?: AIOutputScopeCreateOrConnectWithoutGeoZipInput | AIOutputScopeCreateOrConnectWithoutGeoZipInput[]
    upsert?: AIOutputScopeUpsertWithWhereUniqueWithoutGeoZipInput | AIOutputScopeUpsertWithWhereUniqueWithoutGeoZipInput[]
    createMany?: AIOutputScopeCreateManyGeoZipInputEnvelope
    set?: AIOutputScopeWhereUniqueInput | AIOutputScopeWhereUniqueInput[]
    disconnect?: AIOutputScopeWhereUniqueInput | AIOutputScopeWhereUniqueInput[]
    delete?: AIOutputScopeWhereUniqueInput | AIOutputScopeWhereUniqueInput[]
    connect?: AIOutputScopeWhereUniqueInput | AIOutputScopeWhereUniqueInput[]
    update?: AIOutputScopeUpdateWithWhereUniqueWithoutGeoZipInput | AIOutputScopeUpdateWithWhereUniqueWithoutGeoZipInput[]
    updateMany?: AIOutputScopeUpdateManyWithWhereWithoutGeoZipInput | AIOutputScopeUpdateManyWithWhereWithoutGeoZipInput[]
    deleteMany?: AIOutputScopeScalarWhereInput | AIOutputScopeScalarWhereInput[]
  }

  export type ElectionResultUpdateManyWithoutGeoZipNestedInput = {
    create?: XOR<ElectionResultCreateWithoutGeoZipInput, ElectionResultUncheckedCreateWithoutGeoZipInput> | ElectionResultCreateWithoutGeoZipInput[] | ElectionResultUncheckedCreateWithoutGeoZipInput[]
    connectOrCreate?: ElectionResultCreateOrConnectWithoutGeoZipInput | ElectionResultCreateOrConnectWithoutGeoZipInput[]
    upsert?: ElectionResultUpsertWithWhereUniqueWithoutGeoZipInput | ElectionResultUpsertWithWhereUniqueWithoutGeoZipInput[]
    createMany?: ElectionResultCreateManyGeoZipInputEnvelope
    set?: ElectionResultWhereUniqueInput | ElectionResultWhereUniqueInput[]
    disconnect?: ElectionResultWhereUniqueInput | ElectionResultWhereUniqueInput[]
    delete?: ElectionResultWhereUniqueInput | ElectionResultWhereUniqueInput[]
    connect?: ElectionResultWhereUniqueInput | ElectionResultWhereUniqueInput[]
    update?: ElectionResultUpdateWithWhereUniqueWithoutGeoZipInput | ElectionResultUpdateWithWhereUniqueWithoutGeoZipInput[]
    updateMany?: ElectionResultUpdateManyWithWhereWithoutGeoZipInput | ElectionResultUpdateManyWithWhereWithoutGeoZipInput[]
    deleteMany?: ElectionResultScalarWhereInput | ElectionResultScalarWhereInput[]
  }

  export type CensusMetricUncheckedUpdateManyWithoutGeoZipNestedInput = {
    create?: XOR<CensusMetricCreateWithoutGeoZipInput, CensusMetricUncheckedCreateWithoutGeoZipInput> | CensusMetricCreateWithoutGeoZipInput[] | CensusMetricUncheckedCreateWithoutGeoZipInput[]
    connectOrCreate?: CensusMetricCreateOrConnectWithoutGeoZipInput | CensusMetricCreateOrConnectWithoutGeoZipInput[]
    upsert?: CensusMetricUpsertWithWhereUniqueWithoutGeoZipInput | CensusMetricUpsertWithWhereUniqueWithoutGeoZipInput[]
    createMany?: CensusMetricCreateManyGeoZipInputEnvelope
    set?: CensusMetricWhereUniqueInput | CensusMetricWhereUniqueInput[]
    disconnect?: CensusMetricWhereUniqueInput | CensusMetricWhereUniqueInput[]
    delete?: CensusMetricWhereUniqueInput | CensusMetricWhereUniqueInput[]
    connect?: CensusMetricWhereUniqueInput | CensusMetricWhereUniqueInput[]
    update?: CensusMetricUpdateWithWhereUniqueWithoutGeoZipInput | CensusMetricUpdateWithWhereUniqueWithoutGeoZipInput[]
    updateMany?: CensusMetricUpdateManyWithWhereWithoutGeoZipInput | CensusMetricUpdateManyWithWhereWithoutGeoZipInput[]
    deleteMany?: CensusMetricScalarWhereInput | CensusMetricScalarWhereInput[]
  }

  export type AIOutputScopeUncheckedUpdateManyWithoutGeoZipNestedInput = {
    create?: XOR<AIOutputScopeCreateWithoutGeoZipInput, AIOutputScopeUncheckedCreateWithoutGeoZipInput> | AIOutputScopeCreateWithoutGeoZipInput[] | AIOutputScopeUncheckedCreateWithoutGeoZipInput[]
    connectOrCreate?: AIOutputScopeCreateOrConnectWithoutGeoZipInput | AIOutputScopeCreateOrConnectWithoutGeoZipInput[]
    upsert?: AIOutputScopeUpsertWithWhereUniqueWithoutGeoZipInput | AIOutputScopeUpsertWithWhereUniqueWithoutGeoZipInput[]
    createMany?: AIOutputScopeCreateManyGeoZipInputEnvelope
    set?: AIOutputScopeWhereUniqueInput | AIOutputScopeWhereUniqueInput[]
    disconnect?: AIOutputScopeWhereUniqueInput | AIOutputScopeWhereUniqueInput[]
    delete?: AIOutputScopeWhereUniqueInput | AIOutputScopeWhereUniqueInput[]
    connect?: AIOutputScopeWhereUniqueInput | AIOutputScopeWhereUniqueInput[]
    update?: AIOutputScopeUpdateWithWhereUniqueWithoutGeoZipInput | AIOutputScopeUpdateWithWhereUniqueWithoutGeoZipInput[]
    updateMany?: AIOutputScopeUpdateManyWithWhereWithoutGeoZipInput | AIOutputScopeUpdateManyWithWhereWithoutGeoZipInput[]
    deleteMany?: AIOutputScopeScalarWhereInput | AIOutputScopeScalarWhereInput[]
  }

  export type ElectionResultUncheckedUpdateManyWithoutGeoZipNestedInput = {
    create?: XOR<ElectionResultCreateWithoutGeoZipInput, ElectionResultUncheckedCreateWithoutGeoZipInput> | ElectionResultCreateWithoutGeoZipInput[] | ElectionResultUncheckedCreateWithoutGeoZipInput[]
    connectOrCreate?: ElectionResultCreateOrConnectWithoutGeoZipInput | ElectionResultCreateOrConnectWithoutGeoZipInput[]
    upsert?: ElectionResultUpsertWithWhereUniqueWithoutGeoZipInput | ElectionResultUpsertWithWhereUniqueWithoutGeoZipInput[]
    createMany?: ElectionResultCreateManyGeoZipInputEnvelope
    set?: ElectionResultWhereUniqueInput | ElectionResultWhereUniqueInput[]
    disconnect?: ElectionResultWhereUniqueInput | ElectionResultWhereUniqueInput[]
    delete?: ElectionResultWhereUniqueInput | ElectionResultWhereUniqueInput[]
    connect?: ElectionResultWhereUniqueInput | ElectionResultWhereUniqueInput[]
    update?: ElectionResultUpdateWithWhereUniqueWithoutGeoZipInput | ElectionResultUpdateWithWhereUniqueWithoutGeoZipInput[]
    updateMany?: ElectionResultUpdateManyWithWhereWithoutGeoZipInput | ElectionResultUpdateManyWithWhereWithoutGeoZipInput[]
    deleteMany?: ElectionResultScalarWhereInput | ElectionResultScalarWhereInput[]
  }

  export type ElectionResultCreateNestedManyWithoutPrecinctInput = {
    create?: XOR<ElectionResultCreateWithoutPrecinctInput, ElectionResultUncheckedCreateWithoutPrecinctInput> | ElectionResultCreateWithoutPrecinctInput[] | ElectionResultUncheckedCreateWithoutPrecinctInput[]
    connectOrCreate?: ElectionResultCreateOrConnectWithoutPrecinctInput | ElectionResultCreateOrConnectWithoutPrecinctInput[]
    createMany?: ElectionResultCreateManyPrecinctInputEnvelope
    connect?: ElectionResultWhereUniqueInput | ElectionResultWhereUniqueInput[]
  }

  export type ElectionResultUncheckedCreateNestedManyWithoutPrecinctInput = {
    create?: XOR<ElectionResultCreateWithoutPrecinctInput, ElectionResultUncheckedCreateWithoutPrecinctInput> | ElectionResultCreateWithoutPrecinctInput[] | ElectionResultUncheckedCreateWithoutPrecinctInput[]
    connectOrCreate?: ElectionResultCreateOrConnectWithoutPrecinctInput | ElectionResultCreateOrConnectWithoutPrecinctInput[]
    createMany?: ElectionResultCreateManyPrecinctInputEnvelope
    connect?: ElectionResultWhereUniqueInput | ElectionResultWhereUniqueInput[]
  }

  export type ElectionResultUpdateManyWithoutPrecinctNestedInput = {
    create?: XOR<ElectionResultCreateWithoutPrecinctInput, ElectionResultUncheckedCreateWithoutPrecinctInput> | ElectionResultCreateWithoutPrecinctInput[] | ElectionResultUncheckedCreateWithoutPrecinctInput[]
    connectOrCreate?: ElectionResultCreateOrConnectWithoutPrecinctInput | ElectionResultCreateOrConnectWithoutPrecinctInput[]
    upsert?: ElectionResultUpsertWithWhereUniqueWithoutPrecinctInput | ElectionResultUpsertWithWhereUniqueWithoutPrecinctInput[]
    createMany?: ElectionResultCreateManyPrecinctInputEnvelope
    set?: ElectionResultWhereUniqueInput | ElectionResultWhereUniqueInput[]
    disconnect?: ElectionResultWhereUniqueInput | ElectionResultWhereUniqueInput[]
    delete?: ElectionResultWhereUniqueInput | ElectionResultWhereUniqueInput[]
    connect?: ElectionResultWhereUniqueInput | ElectionResultWhereUniqueInput[]
    update?: ElectionResultUpdateWithWhereUniqueWithoutPrecinctInput | ElectionResultUpdateWithWhereUniqueWithoutPrecinctInput[]
    updateMany?: ElectionResultUpdateManyWithWhereWithoutPrecinctInput | ElectionResultUpdateManyWithWhereWithoutPrecinctInput[]
    deleteMany?: ElectionResultScalarWhereInput | ElectionResultScalarWhereInput[]
  }

  export type ElectionResultUncheckedUpdateManyWithoutPrecinctNestedInput = {
    create?: XOR<ElectionResultCreateWithoutPrecinctInput, ElectionResultUncheckedCreateWithoutPrecinctInput> | ElectionResultCreateWithoutPrecinctInput[] | ElectionResultUncheckedCreateWithoutPrecinctInput[]
    connectOrCreate?: ElectionResultCreateOrConnectWithoutPrecinctInput | ElectionResultCreateOrConnectWithoutPrecinctInput[]
    upsert?: ElectionResultUpsertWithWhereUniqueWithoutPrecinctInput | ElectionResultUpsertWithWhereUniqueWithoutPrecinctInput[]
    createMany?: ElectionResultCreateManyPrecinctInputEnvelope
    set?: ElectionResultWhereUniqueInput | ElectionResultWhereUniqueInput[]
    disconnect?: ElectionResultWhereUniqueInput | ElectionResultWhereUniqueInput[]
    delete?: ElectionResultWhereUniqueInput | ElectionResultWhereUniqueInput[]
    connect?: ElectionResultWhereUniqueInput | ElectionResultWhereUniqueInput[]
    update?: ElectionResultUpdateWithWhereUniqueWithoutPrecinctInput | ElectionResultUpdateWithWhereUniqueWithoutPrecinctInput[]
    updateMany?: ElectionResultUpdateManyWithWhereWithoutPrecinctInput | ElectionResultUpdateManyWithWhereWithoutPrecinctInput[]
    deleteMany?: ElectionResultScalarWhereInput | ElectionResultScalarWhereInput[]
  }

  export type CivicsOfficialCreateNestedManyWithoutDistrictInput = {
    create?: XOR<CivicsOfficialCreateWithoutDistrictInput, CivicsOfficialUncheckedCreateWithoutDistrictInput> | CivicsOfficialCreateWithoutDistrictInput[] | CivicsOfficialUncheckedCreateWithoutDistrictInput[]
    connectOrCreate?: CivicsOfficialCreateOrConnectWithoutDistrictInput | CivicsOfficialCreateOrConnectWithoutDistrictInput[]
    createMany?: CivicsOfficialCreateManyDistrictInputEnvelope
    connect?: CivicsOfficialWhereUniqueInput | CivicsOfficialWhereUniqueInput[]
  }

  export type AIOutputScopeCreateNestedManyWithoutDistrictInput = {
    create?: XOR<AIOutputScopeCreateWithoutDistrictInput, AIOutputScopeUncheckedCreateWithoutDistrictInput> | AIOutputScopeCreateWithoutDistrictInput[] | AIOutputScopeUncheckedCreateWithoutDistrictInput[]
    connectOrCreate?: AIOutputScopeCreateOrConnectWithoutDistrictInput | AIOutputScopeCreateOrConnectWithoutDistrictInput[]
    createMany?: AIOutputScopeCreateManyDistrictInputEnvelope
    connect?: AIOutputScopeWhereUniqueInput | AIOutputScopeWhereUniqueInput[]
  }

  export type CivicsOfficialUncheckedCreateNestedManyWithoutDistrictInput = {
    create?: XOR<CivicsOfficialCreateWithoutDistrictInput, CivicsOfficialUncheckedCreateWithoutDistrictInput> | CivicsOfficialCreateWithoutDistrictInput[] | CivicsOfficialUncheckedCreateWithoutDistrictInput[]
    connectOrCreate?: CivicsOfficialCreateOrConnectWithoutDistrictInput | CivicsOfficialCreateOrConnectWithoutDistrictInput[]
    createMany?: CivicsOfficialCreateManyDistrictInputEnvelope
    connect?: CivicsOfficialWhereUniqueInput | CivicsOfficialWhereUniqueInput[]
  }

  export type AIOutputScopeUncheckedCreateNestedManyWithoutDistrictInput = {
    create?: XOR<AIOutputScopeCreateWithoutDistrictInput, AIOutputScopeUncheckedCreateWithoutDistrictInput> | AIOutputScopeCreateWithoutDistrictInput[] | AIOutputScopeUncheckedCreateWithoutDistrictInput[]
    connectOrCreate?: AIOutputScopeCreateOrConnectWithoutDistrictInput | AIOutputScopeCreateOrConnectWithoutDistrictInput[]
    createMany?: AIOutputScopeCreateManyDistrictInputEnvelope
    connect?: AIOutputScopeWhereUniqueInput | AIOutputScopeWhereUniqueInput[]
  }

  export type CivicsOfficialUpdateManyWithoutDistrictNestedInput = {
    create?: XOR<CivicsOfficialCreateWithoutDistrictInput, CivicsOfficialUncheckedCreateWithoutDistrictInput> | CivicsOfficialCreateWithoutDistrictInput[] | CivicsOfficialUncheckedCreateWithoutDistrictInput[]
    connectOrCreate?: CivicsOfficialCreateOrConnectWithoutDistrictInput | CivicsOfficialCreateOrConnectWithoutDistrictInput[]
    upsert?: CivicsOfficialUpsertWithWhereUniqueWithoutDistrictInput | CivicsOfficialUpsertWithWhereUniqueWithoutDistrictInput[]
    createMany?: CivicsOfficialCreateManyDistrictInputEnvelope
    set?: CivicsOfficialWhereUniqueInput | CivicsOfficialWhereUniqueInput[]
    disconnect?: CivicsOfficialWhereUniqueInput | CivicsOfficialWhereUniqueInput[]
    delete?: CivicsOfficialWhereUniqueInput | CivicsOfficialWhereUniqueInput[]
    connect?: CivicsOfficialWhereUniqueInput | CivicsOfficialWhereUniqueInput[]
    update?: CivicsOfficialUpdateWithWhereUniqueWithoutDistrictInput | CivicsOfficialUpdateWithWhereUniqueWithoutDistrictInput[]
    updateMany?: CivicsOfficialUpdateManyWithWhereWithoutDistrictInput | CivicsOfficialUpdateManyWithWhereWithoutDistrictInput[]
    deleteMany?: CivicsOfficialScalarWhereInput | CivicsOfficialScalarWhereInput[]
  }

  export type AIOutputScopeUpdateManyWithoutDistrictNestedInput = {
    create?: XOR<AIOutputScopeCreateWithoutDistrictInput, AIOutputScopeUncheckedCreateWithoutDistrictInput> | AIOutputScopeCreateWithoutDistrictInput[] | AIOutputScopeUncheckedCreateWithoutDistrictInput[]
    connectOrCreate?: AIOutputScopeCreateOrConnectWithoutDistrictInput | AIOutputScopeCreateOrConnectWithoutDistrictInput[]
    upsert?: AIOutputScopeUpsertWithWhereUniqueWithoutDistrictInput | AIOutputScopeUpsertWithWhereUniqueWithoutDistrictInput[]
    createMany?: AIOutputScopeCreateManyDistrictInputEnvelope
    set?: AIOutputScopeWhereUniqueInput | AIOutputScopeWhereUniqueInput[]
    disconnect?: AIOutputScopeWhereUniqueInput | AIOutputScopeWhereUniqueInput[]
    delete?: AIOutputScopeWhereUniqueInput | AIOutputScopeWhereUniqueInput[]
    connect?: AIOutputScopeWhereUniqueInput | AIOutputScopeWhereUniqueInput[]
    update?: AIOutputScopeUpdateWithWhereUniqueWithoutDistrictInput | AIOutputScopeUpdateWithWhereUniqueWithoutDistrictInput[]
    updateMany?: AIOutputScopeUpdateManyWithWhereWithoutDistrictInput | AIOutputScopeUpdateManyWithWhereWithoutDistrictInput[]
    deleteMany?: AIOutputScopeScalarWhereInput | AIOutputScopeScalarWhereInput[]
  }

  export type CivicsOfficialUncheckedUpdateManyWithoutDistrictNestedInput = {
    create?: XOR<CivicsOfficialCreateWithoutDistrictInput, CivicsOfficialUncheckedCreateWithoutDistrictInput> | CivicsOfficialCreateWithoutDistrictInput[] | CivicsOfficialUncheckedCreateWithoutDistrictInput[]
    connectOrCreate?: CivicsOfficialCreateOrConnectWithoutDistrictInput | CivicsOfficialCreateOrConnectWithoutDistrictInput[]
    upsert?: CivicsOfficialUpsertWithWhereUniqueWithoutDistrictInput | CivicsOfficialUpsertWithWhereUniqueWithoutDistrictInput[]
    createMany?: CivicsOfficialCreateManyDistrictInputEnvelope
    set?: CivicsOfficialWhereUniqueInput | CivicsOfficialWhereUniqueInput[]
    disconnect?: CivicsOfficialWhereUniqueInput | CivicsOfficialWhereUniqueInput[]
    delete?: CivicsOfficialWhereUniqueInput | CivicsOfficialWhereUniqueInput[]
    connect?: CivicsOfficialWhereUniqueInput | CivicsOfficialWhereUniqueInput[]
    update?: CivicsOfficialUpdateWithWhereUniqueWithoutDistrictInput | CivicsOfficialUpdateWithWhereUniqueWithoutDistrictInput[]
    updateMany?: CivicsOfficialUpdateManyWithWhereWithoutDistrictInput | CivicsOfficialUpdateManyWithWhereWithoutDistrictInput[]
    deleteMany?: CivicsOfficialScalarWhereInput | CivicsOfficialScalarWhereInput[]
  }

  export type AIOutputScopeUncheckedUpdateManyWithoutDistrictNestedInput = {
    create?: XOR<AIOutputScopeCreateWithoutDistrictInput, AIOutputScopeUncheckedCreateWithoutDistrictInput> | AIOutputScopeCreateWithoutDistrictInput[] | AIOutputScopeUncheckedCreateWithoutDistrictInput[]
    connectOrCreate?: AIOutputScopeCreateOrConnectWithoutDistrictInput | AIOutputScopeCreateOrConnectWithoutDistrictInput[]
    upsert?: AIOutputScopeUpsertWithWhereUniqueWithoutDistrictInput | AIOutputScopeUpsertWithWhereUniqueWithoutDistrictInput[]
    createMany?: AIOutputScopeCreateManyDistrictInputEnvelope
    set?: AIOutputScopeWhereUniqueInput | AIOutputScopeWhereUniqueInput[]
    disconnect?: AIOutputScopeWhereUniqueInput | AIOutputScopeWhereUniqueInput[]
    delete?: AIOutputScopeWhereUniqueInput | AIOutputScopeWhereUniqueInput[]
    connect?: AIOutputScopeWhereUniqueInput | AIOutputScopeWhereUniqueInput[]
    update?: AIOutputScopeUpdateWithWhereUniqueWithoutDistrictInput | AIOutputScopeUpdateWithWhereUniqueWithoutDistrictInput[]
    updateMany?: AIOutputScopeUpdateManyWithWhereWithoutDistrictInput | AIOutputScopeUpdateManyWithWhereWithoutDistrictInput[]
    deleteMany?: AIOutputScopeScalarWhereInput | AIOutputScopeScalarWhereInput[]
  }

  export type EnumCrosswalkTypeFieldUpdateOperationsInput = {
    set?: $Enums.CrosswalkType
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CountyCreateNestedOneWithoutCensusMetricsInput = {
    create?: XOR<CountyCreateWithoutCensusMetricsInput, CountyUncheckedCreateWithoutCensusMetricsInput>
    connectOrCreate?: CountyCreateOrConnectWithoutCensusMetricsInput
    connect?: CountyWhereUniqueInput
  }

  export type GeoZipCreateNestedOneWithoutCensusMetricsInput = {
    create?: XOR<GeoZipCreateWithoutCensusMetricsInput, GeoZipUncheckedCreateWithoutCensusMetricsInput>
    connectOrCreate?: GeoZipCreateOrConnectWithoutCensusMetricsInput
    connect?: GeoZipWhereUniqueInput
  }

  export type CountyUpdateOneWithoutCensusMetricsNestedInput = {
    create?: XOR<CountyCreateWithoutCensusMetricsInput, CountyUncheckedCreateWithoutCensusMetricsInput>
    connectOrCreate?: CountyCreateOrConnectWithoutCensusMetricsInput
    upsert?: CountyUpsertWithoutCensusMetricsInput
    disconnect?: CountyWhereInput | boolean
    delete?: CountyWhereInput | boolean
    connect?: CountyWhereUniqueInput
    update?: XOR<XOR<CountyUpdateToOneWithWhereWithoutCensusMetricsInput, CountyUpdateWithoutCensusMetricsInput>, CountyUncheckedUpdateWithoutCensusMetricsInput>
  }

  export type GeoZipUpdateOneWithoutCensusMetricsNestedInput = {
    create?: XOR<GeoZipCreateWithoutCensusMetricsInput, GeoZipUncheckedCreateWithoutCensusMetricsInput>
    connectOrCreate?: GeoZipCreateOrConnectWithoutCensusMetricsInput
    upsert?: GeoZipUpsertWithoutCensusMetricsInput
    disconnect?: GeoZipWhereInput | boolean
    delete?: GeoZipWhereInput | boolean
    connect?: GeoZipWhereUniqueInput
    update?: XOR<XOR<GeoZipUpdateToOneWithWhereWithoutCensusMetricsInput, GeoZipUpdateWithoutCensusMetricsInput>, GeoZipUncheckedUpdateWithoutCensusMetricsInput>
  }

  export type CountyCreateNestedOneWithoutBlsMetricsInput = {
    create?: XOR<CountyCreateWithoutBlsMetricsInput, CountyUncheckedCreateWithoutBlsMetricsInput>
    connectOrCreate?: CountyCreateOrConnectWithoutBlsMetricsInput
    connect?: CountyWhereUniqueInput
  }

  export type CountyUpdateOneRequiredWithoutBlsMetricsNestedInput = {
    create?: XOR<CountyCreateWithoutBlsMetricsInput, CountyUncheckedCreateWithoutBlsMetricsInput>
    connectOrCreate?: CountyCreateOrConnectWithoutBlsMetricsInput
    upsert?: CountyUpsertWithoutBlsMetricsInput
    connect?: CountyWhereUniqueInput
    update?: XOR<XOR<CountyUpdateToOneWithWhereWithoutBlsMetricsInput, CountyUpdateWithoutBlsMetricsInput>, CountyUncheckedUpdateWithoutBlsMetricsInput>
  }

  export type CountyCreateNestedOneWithoutCivicsOfficialsInput = {
    create?: XOR<CountyCreateWithoutCivicsOfficialsInput, CountyUncheckedCreateWithoutCivicsOfficialsInput>
    connectOrCreate?: CountyCreateOrConnectWithoutCivicsOfficialsInput
    connect?: CountyWhereUniqueInput
  }

  export type GeoDistrictCreateNestedOneWithoutCivicsOfficialsInput = {
    create?: XOR<GeoDistrictCreateWithoutCivicsOfficialsInput, GeoDistrictUncheckedCreateWithoutCivicsOfficialsInput>
    connectOrCreate?: GeoDistrictCreateOrConnectWithoutCivicsOfficialsInput
    connect?: GeoDistrictWhereUniqueInput
  }

  export type CountyUpdateOneWithoutCivicsOfficialsNestedInput = {
    create?: XOR<CountyCreateWithoutCivicsOfficialsInput, CountyUncheckedCreateWithoutCivicsOfficialsInput>
    connectOrCreate?: CountyCreateOrConnectWithoutCivicsOfficialsInput
    upsert?: CountyUpsertWithoutCivicsOfficialsInput
    disconnect?: CountyWhereInput | boolean
    delete?: CountyWhereInput | boolean
    connect?: CountyWhereUniqueInput
    update?: XOR<XOR<CountyUpdateToOneWithWhereWithoutCivicsOfficialsInput, CountyUpdateWithoutCivicsOfficialsInput>, CountyUncheckedUpdateWithoutCivicsOfficialsInput>
  }

  export type GeoDistrictUpdateOneWithoutCivicsOfficialsNestedInput = {
    create?: XOR<GeoDistrictCreateWithoutCivicsOfficialsInput, GeoDistrictUncheckedCreateWithoutCivicsOfficialsInput>
    connectOrCreate?: GeoDistrictCreateOrConnectWithoutCivicsOfficialsInput
    upsert?: GeoDistrictUpsertWithoutCivicsOfficialsInput
    disconnect?: GeoDistrictWhereInput | boolean
    delete?: GeoDistrictWhereInput | boolean
    connect?: GeoDistrictWhereUniqueInput
    update?: XOR<XOR<GeoDistrictUpdateToOneWithWhereWithoutCivicsOfficialsInput, GeoDistrictUpdateWithoutCivicsOfficialsInput>, GeoDistrictUncheckedUpdateWithoutCivicsOfficialsInput>
  }

  export type ElectionResultCreateNestedManyWithoutElectionInput = {
    create?: XOR<ElectionResultCreateWithoutElectionInput, ElectionResultUncheckedCreateWithoutElectionInput> | ElectionResultCreateWithoutElectionInput[] | ElectionResultUncheckedCreateWithoutElectionInput[]
    connectOrCreate?: ElectionResultCreateOrConnectWithoutElectionInput | ElectionResultCreateOrConnectWithoutElectionInput[]
    createMany?: ElectionResultCreateManyElectionInputEnvelope
    connect?: ElectionResultWhereUniqueInput | ElectionResultWhereUniqueInput[]
  }

  export type ElectionResultUncheckedCreateNestedManyWithoutElectionInput = {
    create?: XOR<ElectionResultCreateWithoutElectionInput, ElectionResultUncheckedCreateWithoutElectionInput> | ElectionResultCreateWithoutElectionInput[] | ElectionResultUncheckedCreateWithoutElectionInput[]
    connectOrCreate?: ElectionResultCreateOrConnectWithoutElectionInput | ElectionResultCreateOrConnectWithoutElectionInput[]
    createMany?: ElectionResultCreateManyElectionInputEnvelope
    connect?: ElectionResultWhereUniqueInput | ElectionResultWhereUniqueInput[]
  }

  export type ElectionResultUpdateManyWithoutElectionNestedInput = {
    create?: XOR<ElectionResultCreateWithoutElectionInput, ElectionResultUncheckedCreateWithoutElectionInput> | ElectionResultCreateWithoutElectionInput[] | ElectionResultUncheckedCreateWithoutElectionInput[]
    connectOrCreate?: ElectionResultCreateOrConnectWithoutElectionInput | ElectionResultCreateOrConnectWithoutElectionInput[]
    upsert?: ElectionResultUpsertWithWhereUniqueWithoutElectionInput | ElectionResultUpsertWithWhereUniqueWithoutElectionInput[]
    createMany?: ElectionResultCreateManyElectionInputEnvelope
    set?: ElectionResultWhereUniqueInput | ElectionResultWhereUniqueInput[]
    disconnect?: ElectionResultWhereUniqueInput | ElectionResultWhereUniqueInput[]
    delete?: ElectionResultWhereUniqueInput | ElectionResultWhereUniqueInput[]
    connect?: ElectionResultWhereUniqueInput | ElectionResultWhereUniqueInput[]
    update?: ElectionResultUpdateWithWhereUniqueWithoutElectionInput | ElectionResultUpdateWithWhereUniqueWithoutElectionInput[]
    updateMany?: ElectionResultUpdateManyWithWhereWithoutElectionInput | ElectionResultUpdateManyWithWhereWithoutElectionInput[]
    deleteMany?: ElectionResultScalarWhereInput | ElectionResultScalarWhereInput[]
  }

  export type ElectionResultUncheckedUpdateManyWithoutElectionNestedInput = {
    create?: XOR<ElectionResultCreateWithoutElectionInput, ElectionResultUncheckedCreateWithoutElectionInput> | ElectionResultCreateWithoutElectionInput[] | ElectionResultUncheckedCreateWithoutElectionInput[]
    connectOrCreate?: ElectionResultCreateOrConnectWithoutElectionInput | ElectionResultCreateOrConnectWithoutElectionInput[]
    upsert?: ElectionResultUpsertWithWhereUniqueWithoutElectionInput | ElectionResultUpsertWithWhereUniqueWithoutElectionInput[]
    createMany?: ElectionResultCreateManyElectionInputEnvelope
    set?: ElectionResultWhereUniqueInput | ElectionResultWhereUniqueInput[]
    disconnect?: ElectionResultWhereUniqueInput | ElectionResultWhereUniqueInput[]
    delete?: ElectionResultWhereUniqueInput | ElectionResultWhereUniqueInput[]
    connect?: ElectionResultWhereUniqueInput | ElectionResultWhereUniqueInput[]
    update?: ElectionResultUpdateWithWhereUniqueWithoutElectionInput | ElectionResultUpdateWithWhereUniqueWithoutElectionInput[]
    updateMany?: ElectionResultUpdateManyWithWhereWithoutElectionInput | ElectionResultUpdateManyWithWhereWithoutElectionInput[]
    deleteMany?: ElectionResultScalarWhereInput | ElectionResultScalarWhereInput[]
  }

  export type ElectionCreateNestedOneWithoutResultsInput = {
    create?: XOR<ElectionCreateWithoutResultsInput, ElectionUncheckedCreateWithoutResultsInput>
    connectOrCreate?: ElectionCreateOrConnectWithoutResultsInput
    connect?: ElectionWhereUniqueInput
  }

  export type CountyCreateNestedOneWithoutElectionResultsInput = {
    create?: XOR<CountyCreateWithoutElectionResultsInput, CountyUncheckedCreateWithoutElectionResultsInput>
    connectOrCreate?: CountyCreateOrConnectWithoutElectionResultsInput
    connect?: CountyWhereUniqueInput
  }

  export type GeoZipCreateNestedOneWithoutElectionResultsInput = {
    create?: XOR<GeoZipCreateWithoutElectionResultsInput, GeoZipUncheckedCreateWithoutElectionResultsInput>
    connectOrCreate?: GeoZipCreateOrConnectWithoutElectionResultsInput
    connect?: GeoZipWhereUniqueInput
  }

  export type GeoPrecinctCreateNestedOneWithoutElectionResultsInput = {
    create?: XOR<GeoPrecinctCreateWithoutElectionResultsInput, GeoPrecinctUncheckedCreateWithoutElectionResultsInput>
    connectOrCreate?: GeoPrecinctCreateOrConnectWithoutElectionResultsInput
    connect?: GeoPrecinctWhereUniqueInput
  }

  export type ElectionUpdateOneRequiredWithoutResultsNestedInput = {
    create?: XOR<ElectionCreateWithoutResultsInput, ElectionUncheckedCreateWithoutResultsInput>
    connectOrCreate?: ElectionCreateOrConnectWithoutResultsInput
    upsert?: ElectionUpsertWithoutResultsInput
    connect?: ElectionWhereUniqueInput
    update?: XOR<XOR<ElectionUpdateToOneWithWhereWithoutResultsInput, ElectionUpdateWithoutResultsInput>, ElectionUncheckedUpdateWithoutResultsInput>
  }

  export type CountyUpdateOneWithoutElectionResultsNestedInput = {
    create?: XOR<CountyCreateWithoutElectionResultsInput, CountyUncheckedCreateWithoutElectionResultsInput>
    connectOrCreate?: CountyCreateOrConnectWithoutElectionResultsInput
    upsert?: CountyUpsertWithoutElectionResultsInput
    disconnect?: CountyWhereInput | boolean
    delete?: CountyWhereInput | boolean
    connect?: CountyWhereUniqueInput
    update?: XOR<XOR<CountyUpdateToOneWithWhereWithoutElectionResultsInput, CountyUpdateWithoutElectionResultsInput>, CountyUncheckedUpdateWithoutElectionResultsInput>
  }

  export type GeoZipUpdateOneWithoutElectionResultsNestedInput = {
    create?: XOR<GeoZipCreateWithoutElectionResultsInput, GeoZipUncheckedCreateWithoutElectionResultsInput>
    connectOrCreate?: GeoZipCreateOrConnectWithoutElectionResultsInput
    upsert?: GeoZipUpsertWithoutElectionResultsInput
    disconnect?: GeoZipWhereInput | boolean
    delete?: GeoZipWhereInput | boolean
    connect?: GeoZipWhereUniqueInput
    update?: XOR<XOR<GeoZipUpdateToOneWithWhereWithoutElectionResultsInput, GeoZipUpdateWithoutElectionResultsInput>, GeoZipUncheckedUpdateWithoutElectionResultsInput>
  }

  export type GeoPrecinctUpdateOneWithoutElectionResultsNestedInput = {
    create?: XOR<GeoPrecinctCreateWithoutElectionResultsInput, GeoPrecinctUncheckedCreateWithoutElectionResultsInput>
    connectOrCreate?: GeoPrecinctCreateOrConnectWithoutElectionResultsInput
    upsert?: GeoPrecinctUpsertWithoutElectionResultsInput
    disconnect?: GeoPrecinctWhereInput | boolean
    delete?: GeoPrecinctWhereInput | boolean
    connect?: GeoPrecinctWhereUniqueInput
    update?: XOR<XOR<GeoPrecinctUpdateToOneWithWhereWithoutElectionResultsInput, GeoPrecinctUpdateWithoutElectionResultsInput>, GeoPrecinctUncheckedUpdateWithoutElectionResultsInput>
  }

  export type AIRunCreateNestedManyWithoutPromptInput = {
    create?: XOR<AIRunCreateWithoutPromptInput, AIRunUncheckedCreateWithoutPromptInput> | AIRunCreateWithoutPromptInput[] | AIRunUncheckedCreateWithoutPromptInput[]
    connectOrCreate?: AIRunCreateOrConnectWithoutPromptInput | AIRunCreateOrConnectWithoutPromptInput[]
    createMany?: AIRunCreateManyPromptInputEnvelope
    connect?: AIRunWhereUniqueInput | AIRunWhereUniqueInput[]
  }

  export type AIRunUncheckedCreateNestedManyWithoutPromptInput = {
    create?: XOR<AIRunCreateWithoutPromptInput, AIRunUncheckedCreateWithoutPromptInput> | AIRunCreateWithoutPromptInput[] | AIRunUncheckedCreateWithoutPromptInput[]
    connectOrCreate?: AIRunCreateOrConnectWithoutPromptInput | AIRunCreateOrConnectWithoutPromptInput[]
    createMany?: AIRunCreateManyPromptInputEnvelope
    connect?: AIRunWhereUniqueInput | AIRunWhereUniqueInput[]
  }

  export type AIRunUpdateManyWithoutPromptNestedInput = {
    create?: XOR<AIRunCreateWithoutPromptInput, AIRunUncheckedCreateWithoutPromptInput> | AIRunCreateWithoutPromptInput[] | AIRunUncheckedCreateWithoutPromptInput[]
    connectOrCreate?: AIRunCreateOrConnectWithoutPromptInput | AIRunCreateOrConnectWithoutPromptInput[]
    upsert?: AIRunUpsertWithWhereUniqueWithoutPromptInput | AIRunUpsertWithWhereUniqueWithoutPromptInput[]
    createMany?: AIRunCreateManyPromptInputEnvelope
    set?: AIRunWhereUniqueInput | AIRunWhereUniqueInput[]
    disconnect?: AIRunWhereUniqueInput | AIRunWhereUniqueInput[]
    delete?: AIRunWhereUniqueInput | AIRunWhereUniqueInput[]
    connect?: AIRunWhereUniqueInput | AIRunWhereUniqueInput[]
    update?: AIRunUpdateWithWhereUniqueWithoutPromptInput | AIRunUpdateWithWhereUniqueWithoutPromptInput[]
    updateMany?: AIRunUpdateManyWithWhereWithoutPromptInput | AIRunUpdateManyWithWhereWithoutPromptInput[]
    deleteMany?: AIRunScalarWhereInput | AIRunScalarWhereInput[]
  }

  export type AIRunUncheckedUpdateManyWithoutPromptNestedInput = {
    create?: XOR<AIRunCreateWithoutPromptInput, AIRunUncheckedCreateWithoutPromptInput> | AIRunCreateWithoutPromptInput[] | AIRunUncheckedCreateWithoutPromptInput[]
    connectOrCreate?: AIRunCreateOrConnectWithoutPromptInput | AIRunCreateOrConnectWithoutPromptInput[]
    upsert?: AIRunUpsertWithWhereUniqueWithoutPromptInput | AIRunUpsertWithWhereUniqueWithoutPromptInput[]
    createMany?: AIRunCreateManyPromptInputEnvelope
    set?: AIRunWhereUniqueInput | AIRunWhereUniqueInput[]
    disconnect?: AIRunWhereUniqueInput | AIRunWhereUniqueInput[]
    delete?: AIRunWhereUniqueInput | AIRunWhereUniqueInput[]
    connect?: AIRunWhereUniqueInput | AIRunWhereUniqueInput[]
    update?: AIRunUpdateWithWhereUniqueWithoutPromptInput | AIRunUpdateWithWhereUniqueWithoutPromptInput[]
    updateMany?: AIRunUpdateManyWithWhereWithoutPromptInput | AIRunUpdateManyWithWhereWithoutPromptInput[]
    deleteMany?: AIRunScalarWhereInput | AIRunScalarWhereInput[]
  }

  export type AIPromptCreateNestedOneWithoutRunsInput = {
    create?: XOR<AIPromptCreateWithoutRunsInput, AIPromptUncheckedCreateWithoutRunsInput>
    connectOrCreate?: AIPromptCreateOrConnectWithoutRunsInput
    connect?: AIPromptWhereUniqueInput
  }

  export type AIOutputCreateNestedManyWithoutRunInput = {
    create?: XOR<AIOutputCreateWithoutRunInput, AIOutputUncheckedCreateWithoutRunInput> | AIOutputCreateWithoutRunInput[] | AIOutputUncheckedCreateWithoutRunInput[]
    connectOrCreate?: AIOutputCreateOrConnectWithoutRunInput | AIOutputCreateOrConnectWithoutRunInput[]
    createMany?: AIOutputCreateManyRunInputEnvelope
    connect?: AIOutputWhereUniqueInput | AIOutputWhereUniqueInput[]
  }

  export type AIRunInputSourceCreateNestedManyWithoutRunInput = {
    create?: XOR<AIRunInputSourceCreateWithoutRunInput, AIRunInputSourceUncheckedCreateWithoutRunInput> | AIRunInputSourceCreateWithoutRunInput[] | AIRunInputSourceUncheckedCreateWithoutRunInput[]
    connectOrCreate?: AIRunInputSourceCreateOrConnectWithoutRunInput | AIRunInputSourceCreateOrConnectWithoutRunInput[]
    createMany?: AIRunInputSourceCreateManyRunInputEnvelope
    connect?: AIRunInputSourceWhereUniqueInput | AIRunInputSourceWhereUniqueInput[]
  }

  export type AIAnalysisCreateNestedManyWithoutAiRunInput = {
    create?: XOR<AIAnalysisCreateWithoutAiRunInput, AIAnalysisUncheckedCreateWithoutAiRunInput> | AIAnalysisCreateWithoutAiRunInput[] | AIAnalysisUncheckedCreateWithoutAiRunInput[]
    connectOrCreate?: AIAnalysisCreateOrConnectWithoutAiRunInput | AIAnalysisCreateOrConnectWithoutAiRunInput[]
    createMany?: AIAnalysisCreateManyAiRunInputEnvelope
    connect?: AIAnalysisWhereUniqueInput | AIAnalysisWhereUniqueInput[]
  }

  export type AIOutputUncheckedCreateNestedManyWithoutRunInput = {
    create?: XOR<AIOutputCreateWithoutRunInput, AIOutputUncheckedCreateWithoutRunInput> | AIOutputCreateWithoutRunInput[] | AIOutputUncheckedCreateWithoutRunInput[]
    connectOrCreate?: AIOutputCreateOrConnectWithoutRunInput | AIOutputCreateOrConnectWithoutRunInput[]
    createMany?: AIOutputCreateManyRunInputEnvelope
    connect?: AIOutputWhereUniqueInput | AIOutputWhereUniqueInput[]
  }

  export type AIRunInputSourceUncheckedCreateNestedManyWithoutRunInput = {
    create?: XOR<AIRunInputSourceCreateWithoutRunInput, AIRunInputSourceUncheckedCreateWithoutRunInput> | AIRunInputSourceCreateWithoutRunInput[] | AIRunInputSourceUncheckedCreateWithoutRunInput[]
    connectOrCreate?: AIRunInputSourceCreateOrConnectWithoutRunInput | AIRunInputSourceCreateOrConnectWithoutRunInput[]
    createMany?: AIRunInputSourceCreateManyRunInputEnvelope
    connect?: AIRunInputSourceWhereUniqueInput | AIRunInputSourceWhereUniqueInput[]
  }

  export type AIAnalysisUncheckedCreateNestedManyWithoutAiRunInput = {
    create?: XOR<AIAnalysisCreateWithoutAiRunInput, AIAnalysisUncheckedCreateWithoutAiRunInput> | AIAnalysisCreateWithoutAiRunInput[] | AIAnalysisUncheckedCreateWithoutAiRunInput[]
    connectOrCreate?: AIAnalysisCreateOrConnectWithoutAiRunInput | AIAnalysisCreateOrConnectWithoutAiRunInput[]
    createMany?: AIAnalysisCreateManyAiRunInputEnvelope
    connect?: AIAnalysisWhereUniqueInput | AIAnalysisWhereUniqueInput[]
  }

  export type EnumAIRunStatusFieldUpdateOperationsInput = {
    set?: $Enums.AIRunStatus
  }

  export type AIPromptUpdateOneRequiredWithoutRunsNestedInput = {
    create?: XOR<AIPromptCreateWithoutRunsInput, AIPromptUncheckedCreateWithoutRunsInput>
    connectOrCreate?: AIPromptCreateOrConnectWithoutRunsInput
    upsert?: AIPromptUpsertWithoutRunsInput
    connect?: AIPromptWhereUniqueInput
    update?: XOR<XOR<AIPromptUpdateToOneWithWhereWithoutRunsInput, AIPromptUpdateWithoutRunsInput>, AIPromptUncheckedUpdateWithoutRunsInput>
  }

  export type AIOutputUpdateManyWithoutRunNestedInput = {
    create?: XOR<AIOutputCreateWithoutRunInput, AIOutputUncheckedCreateWithoutRunInput> | AIOutputCreateWithoutRunInput[] | AIOutputUncheckedCreateWithoutRunInput[]
    connectOrCreate?: AIOutputCreateOrConnectWithoutRunInput | AIOutputCreateOrConnectWithoutRunInput[]
    upsert?: AIOutputUpsertWithWhereUniqueWithoutRunInput | AIOutputUpsertWithWhereUniqueWithoutRunInput[]
    createMany?: AIOutputCreateManyRunInputEnvelope
    set?: AIOutputWhereUniqueInput | AIOutputWhereUniqueInput[]
    disconnect?: AIOutputWhereUniqueInput | AIOutputWhereUniqueInput[]
    delete?: AIOutputWhereUniqueInput | AIOutputWhereUniqueInput[]
    connect?: AIOutputWhereUniqueInput | AIOutputWhereUniqueInput[]
    update?: AIOutputUpdateWithWhereUniqueWithoutRunInput | AIOutputUpdateWithWhereUniqueWithoutRunInput[]
    updateMany?: AIOutputUpdateManyWithWhereWithoutRunInput | AIOutputUpdateManyWithWhereWithoutRunInput[]
    deleteMany?: AIOutputScalarWhereInput | AIOutputScalarWhereInput[]
  }

  export type AIRunInputSourceUpdateManyWithoutRunNestedInput = {
    create?: XOR<AIRunInputSourceCreateWithoutRunInput, AIRunInputSourceUncheckedCreateWithoutRunInput> | AIRunInputSourceCreateWithoutRunInput[] | AIRunInputSourceUncheckedCreateWithoutRunInput[]
    connectOrCreate?: AIRunInputSourceCreateOrConnectWithoutRunInput | AIRunInputSourceCreateOrConnectWithoutRunInput[]
    upsert?: AIRunInputSourceUpsertWithWhereUniqueWithoutRunInput | AIRunInputSourceUpsertWithWhereUniqueWithoutRunInput[]
    createMany?: AIRunInputSourceCreateManyRunInputEnvelope
    set?: AIRunInputSourceWhereUniqueInput | AIRunInputSourceWhereUniqueInput[]
    disconnect?: AIRunInputSourceWhereUniqueInput | AIRunInputSourceWhereUniqueInput[]
    delete?: AIRunInputSourceWhereUniqueInput | AIRunInputSourceWhereUniqueInput[]
    connect?: AIRunInputSourceWhereUniqueInput | AIRunInputSourceWhereUniqueInput[]
    update?: AIRunInputSourceUpdateWithWhereUniqueWithoutRunInput | AIRunInputSourceUpdateWithWhereUniqueWithoutRunInput[]
    updateMany?: AIRunInputSourceUpdateManyWithWhereWithoutRunInput | AIRunInputSourceUpdateManyWithWhereWithoutRunInput[]
    deleteMany?: AIRunInputSourceScalarWhereInput | AIRunInputSourceScalarWhereInput[]
  }

  export type AIAnalysisUpdateManyWithoutAiRunNestedInput = {
    create?: XOR<AIAnalysisCreateWithoutAiRunInput, AIAnalysisUncheckedCreateWithoutAiRunInput> | AIAnalysisCreateWithoutAiRunInput[] | AIAnalysisUncheckedCreateWithoutAiRunInput[]
    connectOrCreate?: AIAnalysisCreateOrConnectWithoutAiRunInput | AIAnalysisCreateOrConnectWithoutAiRunInput[]
    upsert?: AIAnalysisUpsertWithWhereUniqueWithoutAiRunInput | AIAnalysisUpsertWithWhereUniqueWithoutAiRunInput[]
    createMany?: AIAnalysisCreateManyAiRunInputEnvelope
    set?: AIAnalysisWhereUniqueInput | AIAnalysisWhereUniqueInput[]
    disconnect?: AIAnalysisWhereUniqueInput | AIAnalysisWhereUniqueInput[]
    delete?: AIAnalysisWhereUniqueInput | AIAnalysisWhereUniqueInput[]
    connect?: AIAnalysisWhereUniqueInput | AIAnalysisWhereUniqueInput[]
    update?: AIAnalysisUpdateWithWhereUniqueWithoutAiRunInput | AIAnalysisUpdateWithWhereUniqueWithoutAiRunInput[]
    updateMany?: AIAnalysisUpdateManyWithWhereWithoutAiRunInput | AIAnalysisUpdateManyWithWhereWithoutAiRunInput[]
    deleteMany?: AIAnalysisScalarWhereInput | AIAnalysisScalarWhereInput[]
  }

  export type AIOutputUncheckedUpdateManyWithoutRunNestedInput = {
    create?: XOR<AIOutputCreateWithoutRunInput, AIOutputUncheckedCreateWithoutRunInput> | AIOutputCreateWithoutRunInput[] | AIOutputUncheckedCreateWithoutRunInput[]
    connectOrCreate?: AIOutputCreateOrConnectWithoutRunInput | AIOutputCreateOrConnectWithoutRunInput[]
    upsert?: AIOutputUpsertWithWhereUniqueWithoutRunInput | AIOutputUpsertWithWhereUniqueWithoutRunInput[]
    createMany?: AIOutputCreateManyRunInputEnvelope
    set?: AIOutputWhereUniqueInput | AIOutputWhereUniqueInput[]
    disconnect?: AIOutputWhereUniqueInput | AIOutputWhereUniqueInput[]
    delete?: AIOutputWhereUniqueInput | AIOutputWhereUniqueInput[]
    connect?: AIOutputWhereUniqueInput | AIOutputWhereUniqueInput[]
    update?: AIOutputUpdateWithWhereUniqueWithoutRunInput | AIOutputUpdateWithWhereUniqueWithoutRunInput[]
    updateMany?: AIOutputUpdateManyWithWhereWithoutRunInput | AIOutputUpdateManyWithWhereWithoutRunInput[]
    deleteMany?: AIOutputScalarWhereInput | AIOutputScalarWhereInput[]
  }

  export type AIRunInputSourceUncheckedUpdateManyWithoutRunNestedInput = {
    create?: XOR<AIRunInputSourceCreateWithoutRunInput, AIRunInputSourceUncheckedCreateWithoutRunInput> | AIRunInputSourceCreateWithoutRunInput[] | AIRunInputSourceUncheckedCreateWithoutRunInput[]
    connectOrCreate?: AIRunInputSourceCreateOrConnectWithoutRunInput | AIRunInputSourceCreateOrConnectWithoutRunInput[]
    upsert?: AIRunInputSourceUpsertWithWhereUniqueWithoutRunInput | AIRunInputSourceUpsertWithWhereUniqueWithoutRunInput[]
    createMany?: AIRunInputSourceCreateManyRunInputEnvelope
    set?: AIRunInputSourceWhereUniqueInput | AIRunInputSourceWhereUniqueInput[]
    disconnect?: AIRunInputSourceWhereUniqueInput | AIRunInputSourceWhereUniqueInput[]
    delete?: AIRunInputSourceWhereUniqueInput | AIRunInputSourceWhereUniqueInput[]
    connect?: AIRunInputSourceWhereUniqueInput | AIRunInputSourceWhereUniqueInput[]
    update?: AIRunInputSourceUpdateWithWhereUniqueWithoutRunInput | AIRunInputSourceUpdateWithWhereUniqueWithoutRunInput[]
    updateMany?: AIRunInputSourceUpdateManyWithWhereWithoutRunInput | AIRunInputSourceUpdateManyWithWhereWithoutRunInput[]
    deleteMany?: AIRunInputSourceScalarWhereInput | AIRunInputSourceScalarWhereInput[]
  }

  export type AIAnalysisUncheckedUpdateManyWithoutAiRunNestedInput = {
    create?: XOR<AIAnalysisCreateWithoutAiRunInput, AIAnalysisUncheckedCreateWithoutAiRunInput> | AIAnalysisCreateWithoutAiRunInput[] | AIAnalysisUncheckedCreateWithoutAiRunInput[]
    connectOrCreate?: AIAnalysisCreateOrConnectWithoutAiRunInput | AIAnalysisCreateOrConnectWithoutAiRunInput[]
    upsert?: AIAnalysisUpsertWithWhereUniqueWithoutAiRunInput | AIAnalysisUpsertWithWhereUniqueWithoutAiRunInput[]
    createMany?: AIAnalysisCreateManyAiRunInputEnvelope
    set?: AIAnalysisWhereUniqueInput | AIAnalysisWhereUniqueInput[]
    disconnect?: AIAnalysisWhereUniqueInput | AIAnalysisWhereUniqueInput[]
    delete?: AIAnalysisWhereUniqueInput | AIAnalysisWhereUniqueInput[]
    connect?: AIAnalysisWhereUniqueInput | AIAnalysisWhereUniqueInput[]
    update?: AIAnalysisUpdateWithWhereUniqueWithoutAiRunInput | AIAnalysisUpdateWithWhereUniqueWithoutAiRunInput[]
    updateMany?: AIAnalysisUpdateManyWithWhereWithoutAiRunInput | AIAnalysisUpdateManyWithWhereWithoutAiRunInput[]
    deleteMany?: AIAnalysisScalarWhereInput | AIAnalysisScalarWhereInput[]
  }

  export type AIRunCreateNestedOneWithoutInputSourcesInput = {
    create?: XOR<AIRunCreateWithoutInputSourcesInput, AIRunUncheckedCreateWithoutInputSourcesInput>
    connectOrCreate?: AIRunCreateOrConnectWithoutInputSourcesInput
    connect?: AIRunWhereUniqueInput
  }

  export type SourceDocumentCreateNestedOneWithoutRunInputsInput = {
    create?: XOR<SourceDocumentCreateWithoutRunInputsInput, SourceDocumentUncheckedCreateWithoutRunInputsInput>
    connectOrCreate?: SourceDocumentCreateOrConnectWithoutRunInputsInput
    connect?: SourceDocumentWhereUniqueInput
  }

  export type EnumAIRunInputKindFieldUpdateOperationsInput = {
    set?: $Enums.AIRunInputKind
  }

  export type AIRunUpdateOneRequiredWithoutInputSourcesNestedInput = {
    create?: XOR<AIRunCreateWithoutInputSourcesInput, AIRunUncheckedCreateWithoutInputSourcesInput>
    connectOrCreate?: AIRunCreateOrConnectWithoutInputSourcesInput
    upsert?: AIRunUpsertWithoutInputSourcesInput
    connect?: AIRunWhereUniqueInput
    update?: XOR<XOR<AIRunUpdateToOneWithWhereWithoutInputSourcesInput, AIRunUpdateWithoutInputSourcesInput>, AIRunUncheckedUpdateWithoutInputSourcesInput>
  }

  export type SourceDocumentUpdateOneWithoutRunInputsNestedInput = {
    create?: XOR<SourceDocumentCreateWithoutRunInputsInput, SourceDocumentUncheckedCreateWithoutRunInputsInput>
    connectOrCreate?: SourceDocumentCreateOrConnectWithoutRunInputsInput
    upsert?: SourceDocumentUpsertWithoutRunInputsInput
    disconnect?: SourceDocumentWhereInput | boolean
    delete?: SourceDocumentWhereInput | boolean
    connect?: SourceDocumentWhereUniqueInput
    update?: XOR<XOR<SourceDocumentUpdateToOneWithWhereWithoutRunInputsInput, SourceDocumentUpdateWithoutRunInputsInput>, SourceDocumentUncheckedUpdateWithoutRunInputsInput>
  }

  export type AIRunCreateNestedOneWithoutOutputsInput = {
    create?: XOR<AIRunCreateWithoutOutputsInput, AIRunUncheckedCreateWithoutOutputsInput>
    connectOrCreate?: AIRunCreateOrConnectWithoutOutputsInput
    connect?: AIRunWhereUniqueInput
  }

  export type AIOutputSectionCreateNestedManyWithoutOutputInput = {
    create?: XOR<AIOutputSectionCreateWithoutOutputInput, AIOutputSectionUncheckedCreateWithoutOutputInput> | AIOutputSectionCreateWithoutOutputInput[] | AIOutputSectionUncheckedCreateWithoutOutputInput[]
    connectOrCreate?: AIOutputSectionCreateOrConnectWithoutOutputInput | AIOutputSectionCreateOrConnectWithoutOutputInput[]
    createMany?: AIOutputSectionCreateManyOutputInputEnvelope
    connect?: AIOutputSectionWhereUniqueInput | AIOutputSectionWhereUniqueInput[]
  }

  export type AIOutputScopeCreateNestedManyWithoutOutputInput = {
    create?: XOR<AIOutputScopeCreateWithoutOutputInput, AIOutputScopeUncheckedCreateWithoutOutputInput> | AIOutputScopeCreateWithoutOutputInput[] | AIOutputScopeUncheckedCreateWithoutOutputInput[]
    connectOrCreate?: AIOutputScopeCreateOrConnectWithoutOutputInput | AIOutputScopeCreateOrConnectWithoutOutputInput[]
    createMany?: AIOutputScopeCreateManyOutputInputEnvelope
    connect?: AIOutputScopeWhereUniqueInput | AIOutputScopeWhereUniqueInput[]
  }

  export type AIOutputSectionUncheckedCreateNestedManyWithoutOutputInput = {
    create?: XOR<AIOutputSectionCreateWithoutOutputInput, AIOutputSectionUncheckedCreateWithoutOutputInput> | AIOutputSectionCreateWithoutOutputInput[] | AIOutputSectionUncheckedCreateWithoutOutputInput[]
    connectOrCreate?: AIOutputSectionCreateOrConnectWithoutOutputInput | AIOutputSectionCreateOrConnectWithoutOutputInput[]
    createMany?: AIOutputSectionCreateManyOutputInputEnvelope
    connect?: AIOutputSectionWhereUniqueInput | AIOutputSectionWhereUniqueInput[]
  }

  export type AIOutputScopeUncheckedCreateNestedManyWithoutOutputInput = {
    create?: XOR<AIOutputScopeCreateWithoutOutputInput, AIOutputScopeUncheckedCreateWithoutOutputInput> | AIOutputScopeCreateWithoutOutputInput[] | AIOutputScopeUncheckedCreateWithoutOutputInput[]
    connectOrCreate?: AIOutputScopeCreateOrConnectWithoutOutputInput | AIOutputScopeCreateOrConnectWithoutOutputInput[]
    createMany?: AIOutputScopeCreateManyOutputInputEnvelope
    connect?: AIOutputScopeWhereUniqueInput | AIOutputScopeWhereUniqueInput[]
  }

  export type EnumAIOutputTypeFieldUpdateOperationsInput = {
    set?: $Enums.AIOutputType
  }

  export type EnumPublishStatusFieldUpdateOperationsInput = {
    set?: $Enums.PublishStatus
  }

  export type AIRunUpdateOneRequiredWithoutOutputsNestedInput = {
    create?: XOR<AIRunCreateWithoutOutputsInput, AIRunUncheckedCreateWithoutOutputsInput>
    connectOrCreate?: AIRunCreateOrConnectWithoutOutputsInput
    upsert?: AIRunUpsertWithoutOutputsInput
    connect?: AIRunWhereUniqueInput
    update?: XOR<XOR<AIRunUpdateToOneWithWhereWithoutOutputsInput, AIRunUpdateWithoutOutputsInput>, AIRunUncheckedUpdateWithoutOutputsInput>
  }

  export type AIOutputSectionUpdateManyWithoutOutputNestedInput = {
    create?: XOR<AIOutputSectionCreateWithoutOutputInput, AIOutputSectionUncheckedCreateWithoutOutputInput> | AIOutputSectionCreateWithoutOutputInput[] | AIOutputSectionUncheckedCreateWithoutOutputInput[]
    connectOrCreate?: AIOutputSectionCreateOrConnectWithoutOutputInput | AIOutputSectionCreateOrConnectWithoutOutputInput[]
    upsert?: AIOutputSectionUpsertWithWhereUniqueWithoutOutputInput | AIOutputSectionUpsertWithWhereUniqueWithoutOutputInput[]
    createMany?: AIOutputSectionCreateManyOutputInputEnvelope
    set?: AIOutputSectionWhereUniqueInput | AIOutputSectionWhereUniqueInput[]
    disconnect?: AIOutputSectionWhereUniqueInput | AIOutputSectionWhereUniqueInput[]
    delete?: AIOutputSectionWhereUniqueInput | AIOutputSectionWhereUniqueInput[]
    connect?: AIOutputSectionWhereUniqueInput | AIOutputSectionWhereUniqueInput[]
    update?: AIOutputSectionUpdateWithWhereUniqueWithoutOutputInput | AIOutputSectionUpdateWithWhereUniqueWithoutOutputInput[]
    updateMany?: AIOutputSectionUpdateManyWithWhereWithoutOutputInput | AIOutputSectionUpdateManyWithWhereWithoutOutputInput[]
    deleteMany?: AIOutputSectionScalarWhereInput | AIOutputSectionScalarWhereInput[]
  }

  export type AIOutputScopeUpdateManyWithoutOutputNestedInput = {
    create?: XOR<AIOutputScopeCreateWithoutOutputInput, AIOutputScopeUncheckedCreateWithoutOutputInput> | AIOutputScopeCreateWithoutOutputInput[] | AIOutputScopeUncheckedCreateWithoutOutputInput[]
    connectOrCreate?: AIOutputScopeCreateOrConnectWithoutOutputInput | AIOutputScopeCreateOrConnectWithoutOutputInput[]
    upsert?: AIOutputScopeUpsertWithWhereUniqueWithoutOutputInput | AIOutputScopeUpsertWithWhereUniqueWithoutOutputInput[]
    createMany?: AIOutputScopeCreateManyOutputInputEnvelope
    set?: AIOutputScopeWhereUniqueInput | AIOutputScopeWhereUniqueInput[]
    disconnect?: AIOutputScopeWhereUniqueInput | AIOutputScopeWhereUniqueInput[]
    delete?: AIOutputScopeWhereUniqueInput | AIOutputScopeWhereUniqueInput[]
    connect?: AIOutputScopeWhereUniqueInput | AIOutputScopeWhereUniqueInput[]
    update?: AIOutputScopeUpdateWithWhereUniqueWithoutOutputInput | AIOutputScopeUpdateWithWhereUniqueWithoutOutputInput[]
    updateMany?: AIOutputScopeUpdateManyWithWhereWithoutOutputInput | AIOutputScopeUpdateManyWithWhereWithoutOutputInput[]
    deleteMany?: AIOutputScopeScalarWhereInput | AIOutputScopeScalarWhereInput[]
  }

  export type AIOutputSectionUncheckedUpdateManyWithoutOutputNestedInput = {
    create?: XOR<AIOutputSectionCreateWithoutOutputInput, AIOutputSectionUncheckedCreateWithoutOutputInput> | AIOutputSectionCreateWithoutOutputInput[] | AIOutputSectionUncheckedCreateWithoutOutputInput[]
    connectOrCreate?: AIOutputSectionCreateOrConnectWithoutOutputInput | AIOutputSectionCreateOrConnectWithoutOutputInput[]
    upsert?: AIOutputSectionUpsertWithWhereUniqueWithoutOutputInput | AIOutputSectionUpsertWithWhereUniqueWithoutOutputInput[]
    createMany?: AIOutputSectionCreateManyOutputInputEnvelope
    set?: AIOutputSectionWhereUniqueInput | AIOutputSectionWhereUniqueInput[]
    disconnect?: AIOutputSectionWhereUniqueInput | AIOutputSectionWhereUniqueInput[]
    delete?: AIOutputSectionWhereUniqueInput | AIOutputSectionWhereUniqueInput[]
    connect?: AIOutputSectionWhereUniqueInput | AIOutputSectionWhereUniqueInput[]
    update?: AIOutputSectionUpdateWithWhereUniqueWithoutOutputInput | AIOutputSectionUpdateWithWhereUniqueWithoutOutputInput[]
    updateMany?: AIOutputSectionUpdateManyWithWhereWithoutOutputInput | AIOutputSectionUpdateManyWithWhereWithoutOutputInput[]
    deleteMany?: AIOutputSectionScalarWhereInput | AIOutputSectionScalarWhereInput[]
  }

  export type AIOutputScopeUncheckedUpdateManyWithoutOutputNestedInput = {
    create?: XOR<AIOutputScopeCreateWithoutOutputInput, AIOutputScopeUncheckedCreateWithoutOutputInput> | AIOutputScopeCreateWithoutOutputInput[] | AIOutputScopeUncheckedCreateWithoutOutputInput[]
    connectOrCreate?: AIOutputScopeCreateOrConnectWithoutOutputInput | AIOutputScopeCreateOrConnectWithoutOutputInput[]
    upsert?: AIOutputScopeUpsertWithWhereUniqueWithoutOutputInput | AIOutputScopeUpsertWithWhereUniqueWithoutOutputInput[]
    createMany?: AIOutputScopeCreateManyOutputInputEnvelope
    set?: AIOutputScopeWhereUniqueInput | AIOutputScopeWhereUniqueInput[]
    disconnect?: AIOutputScopeWhereUniqueInput | AIOutputScopeWhereUniqueInput[]
    delete?: AIOutputScopeWhereUniqueInput | AIOutputScopeWhereUniqueInput[]
    connect?: AIOutputScopeWhereUniqueInput | AIOutputScopeWhereUniqueInput[]
    update?: AIOutputScopeUpdateWithWhereUniqueWithoutOutputInput | AIOutputScopeUpdateWithWhereUniqueWithoutOutputInput[]
    updateMany?: AIOutputScopeUpdateManyWithWhereWithoutOutputInput | AIOutputScopeUpdateManyWithWhereWithoutOutputInput[]
    deleteMany?: AIOutputScopeScalarWhereInput | AIOutputScopeScalarWhereInput[]
  }

  export type AIOutputCreateNestedOneWithoutSectionsInput = {
    create?: XOR<AIOutputCreateWithoutSectionsInput, AIOutputUncheckedCreateWithoutSectionsInput>
    connectOrCreate?: AIOutputCreateOrConnectWithoutSectionsInput
    connect?: AIOutputWhereUniqueInput
  }

  export type CitationCreateNestedManyWithoutOutputSectionInput = {
    create?: XOR<CitationCreateWithoutOutputSectionInput, CitationUncheckedCreateWithoutOutputSectionInput> | CitationCreateWithoutOutputSectionInput[] | CitationUncheckedCreateWithoutOutputSectionInput[]
    connectOrCreate?: CitationCreateOrConnectWithoutOutputSectionInput | CitationCreateOrConnectWithoutOutputSectionInput[]
    createMany?: CitationCreateManyOutputSectionInputEnvelope
    connect?: CitationWhereUniqueInput | CitationWhereUniqueInput[]
  }

  export type CitationUncheckedCreateNestedManyWithoutOutputSectionInput = {
    create?: XOR<CitationCreateWithoutOutputSectionInput, CitationUncheckedCreateWithoutOutputSectionInput> | CitationCreateWithoutOutputSectionInput[] | CitationUncheckedCreateWithoutOutputSectionInput[]
    connectOrCreate?: CitationCreateOrConnectWithoutOutputSectionInput | CitationCreateOrConnectWithoutOutputSectionInput[]
    createMany?: CitationCreateManyOutputSectionInputEnvelope
    connect?: CitationWhereUniqueInput | CitationWhereUniqueInput[]
  }

  export type AIOutputUpdateOneRequiredWithoutSectionsNestedInput = {
    create?: XOR<AIOutputCreateWithoutSectionsInput, AIOutputUncheckedCreateWithoutSectionsInput>
    connectOrCreate?: AIOutputCreateOrConnectWithoutSectionsInput
    upsert?: AIOutputUpsertWithoutSectionsInput
    connect?: AIOutputWhereUniqueInput
    update?: XOR<XOR<AIOutputUpdateToOneWithWhereWithoutSectionsInput, AIOutputUpdateWithoutSectionsInput>, AIOutputUncheckedUpdateWithoutSectionsInput>
  }

  export type CitationUpdateManyWithoutOutputSectionNestedInput = {
    create?: XOR<CitationCreateWithoutOutputSectionInput, CitationUncheckedCreateWithoutOutputSectionInput> | CitationCreateWithoutOutputSectionInput[] | CitationUncheckedCreateWithoutOutputSectionInput[]
    connectOrCreate?: CitationCreateOrConnectWithoutOutputSectionInput | CitationCreateOrConnectWithoutOutputSectionInput[]
    upsert?: CitationUpsertWithWhereUniqueWithoutOutputSectionInput | CitationUpsertWithWhereUniqueWithoutOutputSectionInput[]
    createMany?: CitationCreateManyOutputSectionInputEnvelope
    set?: CitationWhereUniqueInput | CitationWhereUniqueInput[]
    disconnect?: CitationWhereUniqueInput | CitationWhereUniqueInput[]
    delete?: CitationWhereUniqueInput | CitationWhereUniqueInput[]
    connect?: CitationWhereUniqueInput | CitationWhereUniqueInput[]
    update?: CitationUpdateWithWhereUniqueWithoutOutputSectionInput | CitationUpdateWithWhereUniqueWithoutOutputSectionInput[]
    updateMany?: CitationUpdateManyWithWhereWithoutOutputSectionInput | CitationUpdateManyWithWhereWithoutOutputSectionInput[]
    deleteMany?: CitationScalarWhereInput | CitationScalarWhereInput[]
  }

  export type CitationUncheckedUpdateManyWithoutOutputSectionNestedInput = {
    create?: XOR<CitationCreateWithoutOutputSectionInput, CitationUncheckedCreateWithoutOutputSectionInput> | CitationCreateWithoutOutputSectionInput[] | CitationUncheckedCreateWithoutOutputSectionInput[]
    connectOrCreate?: CitationCreateOrConnectWithoutOutputSectionInput | CitationCreateOrConnectWithoutOutputSectionInput[]
    upsert?: CitationUpsertWithWhereUniqueWithoutOutputSectionInput | CitationUpsertWithWhereUniqueWithoutOutputSectionInput[]
    createMany?: CitationCreateManyOutputSectionInputEnvelope
    set?: CitationWhereUniqueInput | CitationWhereUniqueInput[]
    disconnect?: CitationWhereUniqueInput | CitationWhereUniqueInput[]
    delete?: CitationWhereUniqueInput | CitationWhereUniqueInput[]
    connect?: CitationWhereUniqueInput | CitationWhereUniqueInput[]
    update?: CitationUpdateWithWhereUniqueWithoutOutputSectionInput | CitationUpdateWithWhereUniqueWithoutOutputSectionInput[]
    updateMany?: CitationUpdateManyWithWhereWithoutOutputSectionInput | CitationUpdateManyWithWhereWithoutOutputSectionInput[]
    deleteMany?: CitationScalarWhereInput | CitationScalarWhereInput[]
  }

  export type AIOutputCreateNestedOneWithoutScopesInput = {
    create?: XOR<AIOutputCreateWithoutScopesInput, AIOutputUncheckedCreateWithoutScopesInput>
    connectOrCreate?: AIOutputCreateOrConnectWithoutScopesInput
    connect?: AIOutputWhereUniqueInput
  }

  export type CountyCreateNestedOneWithoutAiOutputScopesInput = {
    create?: XOR<CountyCreateWithoutAiOutputScopesInput, CountyUncheckedCreateWithoutAiOutputScopesInput>
    connectOrCreate?: CountyCreateOrConnectWithoutAiOutputScopesInput
    connect?: CountyWhereUniqueInput
  }

  export type IssueCreateNestedOneWithoutAiOutputScopesInput = {
    create?: XOR<IssueCreateWithoutAiOutputScopesInput, IssueUncheckedCreateWithoutAiOutputScopesInput>
    connectOrCreate?: IssueCreateOrConnectWithoutAiOutputScopesInput
    connect?: IssueWhereUniqueInput
  }

  export type GeoZipCreateNestedOneWithoutAiOutputScopesInput = {
    create?: XOR<GeoZipCreateWithoutAiOutputScopesInput, GeoZipUncheckedCreateWithoutAiOutputScopesInput>
    connectOrCreate?: GeoZipCreateOrConnectWithoutAiOutputScopesInput
    connect?: GeoZipWhereUniqueInput
  }

  export type GeoDistrictCreateNestedOneWithoutAiOutputScopesInput = {
    create?: XOR<GeoDistrictCreateWithoutAiOutputScopesInput, GeoDistrictUncheckedCreateWithoutAiOutputScopesInput>
    connectOrCreate?: GeoDistrictCreateOrConnectWithoutAiOutputScopesInput
    connect?: GeoDistrictWhereUniqueInput
  }

  export type EnumAIScopeTypeFieldUpdateOperationsInput = {
    set?: $Enums.AIScopeType
  }

  export type AIOutputUpdateOneRequiredWithoutScopesNestedInput = {
    create?: XOR<AIOutputCreateWithoutScopesInput, AIOutputUncheckedCreateWithoutScopesInput>
    connectOrCreate?: AIOutputCreateOrConnectWithoutScopesInput
    upsert?: AIOutputUpsertWithoutScopesInput
    connect?: AIOutputWhereUniqueInput
    update?: XOR<XOR<AIOutputUpdateToOneWithWhereWithoutScopesInput, AIOutputUpdateWithoutScopesInput>, AIOutputUncheckedUpdateWithoutScopesInput>
  }

  export type CountyUpdateOneWithoutAiOutputScopesNestedInput = {
    create?: XOR<CountyCreateWithoutAiOutputScopesInput, CountyUncheckedCreateWithoutAiOutputScopesInput>
    connectOrCreate?: CountyCreateOrConnectWithoutAiOutputScopesInput
    upsert?: CountyUpsertWithoutAiOutputScopesInput
    disconnect?: CountyWhereInput | boolean
    delete?: CountyWhereInput | boolean
    connect?: CountyWhereUniqueInput
    update?: XOR<XOR<CountyUpdateToOneWithWhereWithoutAiOutputScopesInput, CountyUpdateWithoutAiOutputScopesInput>, CountyUncheckedUpdateWithoutAiOutputScopesInput>
  }

  export type IssueUpdateOneWithoutAiOutputScopesNestedInput = {
    create?: XOR<IssueCreateWithoutAiOutputScopesInput, IssueUncheckedCreateWithoutAiOutputScopesInput>
    connectOrCreate?: IssueCreateOrConnectWithoutAiOutputScopesInput
    upsert?: IssueUpsertWithoutAiOutputScopesInput
    disconnect?: IssueWhereInput | boolean
    delete?: IssueWhereInput | boolean
    connect?: IssueWhereUniqueInput
    update?: XOR<XOR<IssueUpdateToOneWithWhereWithoutAiOutputScopesInput, IssueUpdateWithoutAiOutputScopesInput>, IssueUncheckedUpdateWithoutAiOutputScopesInput>
  }

  export type GeoZipUpdateOneWithoutAiOutputScopesNestedInput = {
    create?: XOR<GeoZipCreateWithoutAiOutputScopesInput, GeoZipUncheckedCreateWithoutAiOutputScopesInput>
    connectOrCreate?: GeoZipCreateOrConnectWithoutAiOutputScopesInput
    upsert?: GeoZipUpsertWithoutAiOutputScopesInput
    disconnect?: GeoZipWhereInput | boolean
    delete?: GeoZipWhereInput | boolean
    connect?: GeoZipWhereUniqueInput
    update?: XOR<XOR<GeoZipUpdateToOneWithWhereWithoutAiOutputScopesInput, GeoZipUpdateWithoutAiOutputScopesInput>, GeoZipUncheckedUpdateWithoutAiOutputScopesInput>
  }

  export type GeoDistrictUpdateOneWithoutAiOutputScopesNestedInput = {
    create?: XOR<GeoDistrictCreateWithoutAiOutputScopesInput, GeoDistrictUncheckedCreateWithoutAiOutputScopesInput>
    connectOrCreate?: GeoDistrictCreateOrConnectWithoutAiOutputScopesInput
    upsert?: GeoDistrictUpsertWithoutAiOutputScopesInput
    disconnect?: GeoDistrictWhereInput | boolean
    delete?: GeoDistrictWhereInput | boolean
    connect?: GeoDistrictWhereUniqueInput
    update?: XOR<XOR<GeoDistrictUpdateToOneWithWhereWithoutAiOutputScopesInput, GeoDistrictUpdateWithoutAiOutputScopesInput>, GeoDistrictUncheckedUpdateWithoutAiOutputScopesInput>
  }

  export type AIOutputSectionCreateNestedOneWithoutCitationsInput = {
    create?: XOR<AIOutputSectionCreateWithoutCitationsInput, AIOutputSectionUncheckedCreateWithoutCitationsInput>
    connectOrCreate?: AIOutputSectionCreateOrConnectWithoutCitationsInput
    connect?: AIOutputSectionWhereUniqueInput
  }

  export type SourceChunkCreateNestedOneWithoutCitationsInput = {
    create?: XOR<SourceChunkCreateWithoutCitationsInput, SourceChunkUncheckedCreateWithoutCitationsInput>
    connectOrCreate?: SourceChunkCreateOrConnectWithoutCitationsInput
    connect?: SourceChunkWhereUniqueInput
  }

  export type SourceDocumentCreateNestedOneWithoutCitationsInput = {
    create?: XOR<SourceDocumentCreateWithoutCitationsInput, SourceDocumentUncheckedCreateWithoutCitationsInput>
    connectOrCreate?: SourceDocumentCreateOrConnectWithoutCitationsInput
    connect?: SourceDocumentWhereUniqueInput
  }

  export type AIOutputSectionUpdateOneRequiredWithoutCitationsNestedInput = {
    create?: XOR<AIOutputSectionCreateWithoutCitationsInput, AIOutputSectionUncheckedCreateWithoutCitationsInput>
    connectOrCreate?: AIOutputSectionCreateOrConnectWithoutCitationsInput
    upsert?: AIOutputSectionUpsertWithoutCitationsInput
    connect?: AIOutputSectionWhereUniqueInput
    update?: XOR<XOR<AIOutputSectionUpdateToOneWithWhereWithoutCitationsInput, AIOutputSectionUpdateWithoutCitationsInput>, AIOutputSectionUncheckedUpdateWithoutCitationsInput>
  }

  export type SourceChunkUpdateOneWithoutCitationsNestedInput = {
    create?: XOR<SourceChunkCreateWithoutCitationsInput, SourceChunkUncheckedCreateWithoutCitationsInput>
    connectOrCreate?: SourceChunkCreateOrConnectWithoutCitationsInput
    upsert?: SourceChunkUpsertWithoutCitationsInput
    disconnect?: SourceChunkWhereInput | boolean
    delete?: SourceChunkWhereInput | boolean
    connect?: SourceChunkWhereUniqueInput
    update?: XOR<XOR<SourceChunkUpdateToOneWithWhereWithoutCitationsInput, SourceChunkUpdateWithoutCitationsInput>, SourceChunkUncheckedUpdateWithoutCitationsInput>
  }

  export type SourceDocumentUpdateOneWithoutCitationsNestedInput = {
    create?: XOR<SourceDocumentCreateWithoutCitationsInput, SourceDocumentUncheckedCreateWithoutCitationsInput>
    connectOrCreate?: SourceDocumentCreateOrConnectWithoutCitationsInput
    upsert?: SourceDocumentUpsertWithoutCitationsInput
    disconnect?: SourceDocumentWhereInput | boolean
    delete?: SourceDocumentWhereInput | boolean
    connect?: SourceDocumentWhereUniqueInput
    update?: XOR<XOR<SourceDocumentUpdateToOneWithWhereWithoutCitationsInput, SourceDocumentUpdateWithoutCitationsInput>, SourceDocumentUncheckedUpdateWithoutCitationsInput>
  }

  export type CountyCreateNestedOneWithoutSurveyFormsInput = {
    create?: XOR<CountyCreateWithoutSurveyFormsInput, CountyUncheckedCreateWithoutSurveyFormsInput>
    connectOrCreate?: CountyCreateOrConnectWithoutSurveyFormsInput
    connect?: CountyWhereUniqueInput
  }

  export type SurveyQuestionCreateNestedManyWithoutFormInput = {
    create?: XOR<SurveyQuestionCreateWithoutFormInput, SurveyQuestionUncheckedCreateWithoutFormInput> | SurveyQuestionCreateWithoutFormInput[] | SurveyQuestionUncheckedCreateWithoutFormInput[]
    connectOrCreate?: SurveyQuestionCreateOrConnectWithoutFormInput | SurveyQuestionCreateOrConnectWithoutFormInput[]
    createMany?: SurveyQuestionCreateManyFormInputEnvelope
    connect?: SurveyQuestionWhereUniqueInput | SurveyQuestionWhereUniqueInput[]
  }

  export type SurveyResponseCreateNestedManyWithoutFormInput = {
    create?: XOR<SurveyResponseCreateWithoutFormInput, SurveyResponseUncheckedCreateWithoutFormInput> | SurveyResponseCreateWithoutFormInput[] | SurveyResponseUncheckedCreateWithoutFormInput[]
    connectOrCreate?: SurveyResponseCreateOrConnectWithoutFormInput | SurveyResponseCreateOrConnectWithoutFormInput[]
    createMany?: SurveyResponseCreateManyFormInputEnvelope
    connect?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
  }

  export type SourceDocumentLinkCreateNestedManyWithoutSurveyFormInput = {
    create?: XOR<SourceDocumentLinkCreateWithoutSurveyFormInput, SourceDocumentLinkUncheckedCreateWithoutSurveyFormInput> | SourceDocumentLinkCreateWithoutSurveyFormInput[] | SourceDocumentLinkUncheckedCreateWithoutSurveyFormInput[]
    connectOrCreate?: SourceDocumentLinkCreateOrConnectWithoutSurveyFormInput | SourceDocumentLinkCreateOrConnectWithoutSurveyFormInput[]
    createMany?: SourceDocumentLinkCreateManySurveyFormInputEnvelope
    connect?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
  }

  export type SurveyQuestionUncheckedCreateNestedManyWithoutFormInput = {
    create?: XOR<SurveyQuestionCreateWithoutFormInput, SurveyQuestionUncheckedCreateWithoutFormInput> | SurveyQuestionCreateWithoutFormInput[] | SurveyQuestionUncheckedCreateWithoutFormInput[]
    connectOrCreate?: SurveyQuestionCreateOrConnectWithoutFormInput | SurveyQuestionCreateOrConnectWithoutFormInput[]
    createMany?: SurveyQuestionCreateManyFormInputEnvelope
    connect?: SurveyQuestionWhereUniqueInput | SurveyQuestionWhereUniqueInput[]
  }

  export type SurveyResponseUncheckedCreateNestedManyWithoutFormInput = {
    create?: XOR<SurveyResponseCreateWithoutFormInput, SurveyResponseUncheckedCreateWithoutFormInput> | SurveyResponseCreateWithoutFormInput[] | SurveyResponseUncheckedCreateWithoutFormInput[]
    connectOrCreate?: SurveyResponseCreateOrConnectWithoutFormInput | SurveyResponseCreateOrConnectWithoutFormInput[]
    createMany?: SurveyResponseCreateManyFormInputEnvelope
    connect?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
  }

  export type SourceDocumentLinkUncheckedCreateNestedManyWithoutSurveyFormInput = {
    create?: XOR<SourceDocumentLinkCreateWithoutSurveyFormInput, SourceDocumentLinkUncheckedCreateWithoutSurveyFormInput> | SourceDocumentLinkCreateWithoutSurveyFormInput[] | SourceDocumentLinkUncheckedCreateWithoutSurveyFormInput[]
    connectOrCreate?: SourceDocumentLinkCreateOrConnectWithoutSurveyFormInput | SourceDocumentLinkCreateOrConnectWithoutSurveyFormInput[]
    createMany?: SourceDocumentLinkCreateManySurveyFormInputEnvelope
    connect?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
  }

  export type EnumSurveyFormStatusFieldUpdateOperationsInput = {
    set?: $Enums.SurveyFormStatus
  }

  export type CountyUpdateOneWithoutSurveyFormsNestedInput = {
    create?: XOR<CountyCreateWithoutSurveyFormsInput, CountyUncheckedCreateWithoutSurveyFormsInput>
    connectOrCreate?: CountyCreateOrConnectWithoutSurveyFormsInput
    upsert?: CountyUpsertWithoutSurveyFormsInput
    disconnect?: CountyWhereInput | boolean
    delete?: CountyWhereInput | boolean
    connect?: CountyWhereUniqueInput
    update?: XOR<XOR<CountyUpdateToOneWithWhereWithoutSurveyFormsInput, CountyUpdateWithoutSurveyFormsInput>, CountyUncheckedUpdateWithoutSurveyFormsInput>
  }

  export type SurveyQuestionUpdateManyWithoutFormNestedInput = {
    create?: XOR<SurveyQuestionCreateWithoutFormInput, SurveyQuestionUncheckedCreateWithoutFormInput> | SurveyQuestionCreateWithoutFormInput[] | SurveyQuestionUncheckedCreateWithoutFormInput[]
    connectOrCreate?: SurveyQuestionCreateOrConnectWithoutFormInput | SurveyQuestionCreateOrConnectWithoutFormInput[]
    upsert?: SurveyQuestionUpsertWithWhereUniqueWithoutFormInput | SurveyQuestionUpsertWithWhereUniqueWithoutFormInput[]
    createMany?: SurveyQuestionCreateManyFormInputEnvelope
    set?: SurveyQuestionWhereUniqueInput | SurveyQuestionWhereUniqueInput[]
    disconnect?: SurveyQuestionWhereUniqueInput | SurveyQuestionWhereUniqueInput[]
    delete?: SurveyQuestionWhereUniqueInput | SurveyQuestionWhereUniqueInput[]
    connect?: SurveyQuestionWhereUniqueInput | SurveyQuestionWhereUniqueInput[]
    update?: SurveyQuestionUpdateWithWhereUniqueWithoutFormInput | SurveyQuestionUpdateWithWhereUniqueWithoutFormInput[]
    updateMany?: SurveyQuestionUpdateManyWithWhereWithoutFormInput | SurveyQuestionUpdateManyWithWhereWithoutFormInput[]
    deleteMany?: SurveyQuestionScalarWhereInput | SurveyQuestionScalarWhereInput[]
  }

  export type SurveyResponseUpdateManyWithoutFormNestedInput = {
    create?: XOR<SurveyResponseCreateWithoutFormInput, SurveyResponseUncheckedCreateWithoutFormInput> | SurveyResponseCreateWithoutFormInput[] | SurveyResponseUncheckedCreateWithoutFormInput[]
    connectOrCreate?: SurveyResponseCreateOrConnectWithoutFormInput | SurveyResponseCreateOrConnectWithoutFormInput[]
    upsert?: SurveyResponseUpsertWithWhereUniqueWithoutFormInput | SurveyResponseUpsertWithWhereUniqueWithoutFormInput[]
    createMany?: SurveyResponseCreateManyFormInputEnvelope
    set?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
    disconnect?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
    delete?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
    connect?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
    update?: SurveyResponseUpdateWithWhereUniqueWithoutFormInput | SurveyResponseUpdateWithWhereUniqueWithoutFormInput[]
    updateMany?: SurveyResponseUpdateManyWithWhereWithoutFormInput | SurveyResponseUpdateManyWithWhereWithoutFormInput[]
    deleteMany?: SurveyResponseScalarWhereInput | SurveyResponseScalarWhereInput[]
  }

  export type SourceDocumentLinkUpdateManyWithoutSurveyFormNestedInput = {
    create?: XOR<SourceDocumentLinkCreateWithoutSurveyFormInput, SourceDocumentLinkUncheckedCreateWithoutSurveyFormInput> | SourceDocumentLinkCreateWithoutSurveyFormInput[] | SourceDocumentLinkUncheckedCreateWithoutSurveyFormInput[]
    connectOrCreate?: SourceDocumentLinkCreateOrConnectWithoutSurveyFormInput | SourceDocumentLinkCreateOrConnectWithoutSurveyFormInput[]
    upsert?: SourceDocumentLinkUpsertWithWhereUniqueWithoutSurveyFormInput | SourceDocumentLinkUpsertWithWhereUniqueWithoutSurveyFormInput[]
    createMany?: SourceDocumentLinkCreateManySurveyFormInputEnvelope
    set?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
    disconnect?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
    delete?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
    connect?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
    update?: SourceDocumentLinkUpdateWithWhereUniqueWithoutSurveyFormInput | SourceDocumentLinkUpdateWithWhereUniqueWithoutSurveyFormInput[]
    updateMany?: SourceDocumentLinkUpdateManyWithWhereWithoutSurveyFormInput | SourceDocumentLinkUpdateManyWithWhereWithoutSurveyFormInput[]
    deleteMany?: SourceDocumentLinkScalarWhereInput | SourceDocumentLinkScalarWhereInput[]
  }

  export type SurveyQuestionUncheckedUpdateManyWithoutFormNestedInput = {
    create?: XOR<SurveyQuestionCreateWithoutFormInput, SurveyQuestionUncheckedCreateWithoutFormInput> | SurveyQuestionCreateWithoutFormInput[] | SurveyQuestionUncheckedCreateWithoutFormInput[]
    connectOrCreate?: SurveyQuestionCreateOrConnectWithoutFormInput | SurveyQuestionCreateOrConnectWithoutFormInput[]
    upsert?: SurveyQuestionUpsertWithWhereUniqueWithoutFormInput | SurveyQuestionUpsertWithWhereUniqueWithoutFormInput[]
    createMany?: SurveyQuestionCreateManyFormInputEnvelope
    set?: SurveyQuestionWhereUniqueInput | SurveyQuestionWhereUniqueInput[]
    disconnect?: SurveyQuestionWhereUniqueInput | SurveyQuestionWhereUniqueInput[]
    delete?: SurveyQuestionWhereUniqueInput | SurveyQuestionWhereUniqueInput[]
    connect?: SurveyQuestionWhereUniqueInput | SurveyQuestionWhereUniqueInput[]
    update?: SurveyQuestionUpdateWithWhereUniqueWithoutFormInput | SurveyQuestionUpdateWithWhereUniqueWithoutFormInput[]
    updateMany?: SurveyQuestionUpdateManyWithWhereWithoutFormInput | SurveyQuestionUpdateManyWithWhereWithoutFormInput[]
    deleteMany?: SurveyQuestionScalarWhereInput | SurveyQuestionScalarWhereInput[]
  }

  export type SurveyResponseUncheckedUpdateManyWithoutFormNestedInput = {
    create?: XOR<SurveyResponseCreateWithoutFormInput, SurveyResponseUncheckedCreateWithoutFormInput> | SurveyResponseCreateWithoutFormInput[] | SurveyResponseUncheckedCreateWithoutFormInput[]
    connectOrCreate?: SurveyResponseCreateOrConnectWithoutFormInput | SurveyResponseCreateOrConnectWithoutFormInput[]
    upsert?: SurveyResponseUpsertWithWhereUniqueWithoutFormInput | SurveyResponseUpsertWithWhereUniqueWithoutFormInput[]
    createMany?: SurveyResponseCreateManyFormInputEnvelope
    set?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
    disconnect?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
    delete?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
    connect?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
    update?: SurveyResponseUpdateWithWhereUniqueWithoutFormInput | SurveyResponseUpdateWithWhereUniqueWithoutFormInput[]
    updateMany?: SurveyResponseUpdateManyWithWhereWithoutFormInput | SurveyResponseUpdateManyWithWhereWithoutFormInput[]
    deleteMany?: SurveyResponseScalarWhereInput | SurveyResponseScalarWhereInput[]
  }

  export type SourceDocumentLinkUncheckedUpdateManyWithoutSurveyFormNestedInput = {
    create?: XOR<SourceDocumentLinkCreateWithoutSurveyFormInput, SourceDocumentLinkUncheckedCreateWithoutSurveyFormInput> | SourceDocumentLinkCreateWithoutSurveyFormInput[] | SourceDocumentLinkUncheckedCreateWithoutSurveyFormInput[]
    connectOrCreate?: SourceDocumentLinkCreateOrConnectWithoutSurveyFormInput | SourceDocumentLinkCreateOrConnectWithoutSurveyFormInput[]
    upsert?: SourceDocumentLinkUpsertWithWhereUniqueWithoutSurveyFormInput | SourceDocumentLinkUpsertWithWhereUniqueWithoutSurveyFormInput[]
    createMany?: SourceDocumentLinkCreateManySurveyFormInputEnvelope
    set?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
    disconnect?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
    delete?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
    connect?: SourceDocumentLinkWhereUniqueInput | SourceDocumentLinkWhereUniqueInput[]
    update?: SourceDocumentLinkUpdateWithWhereUniqueWithoutSurveyFormInput | SourceDocumentLinkUpdateWithWhereUniqueWithoutSurveyFormInput[]
    updateMany?: SourceDocumentLinkUpdateManyWithWhereWithoutSurveyFormInput | SourceDocumentLinkUpdateManyWithWhereWithoutSurveyFormInput[]
    deleteMany?: SourceDocumentLinkScalarWhereInput | SourceDocumentLinkScalarWhereInput[]
  }

  export type SurveyFormCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<SurveyFormCreateWithoutQuestionsInput, SurveyFormUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: SurveyFormCreateOrConnectWithoutQuestionsInput
    connect?: SurveyFormWhereUniqueInput
  }

  export type SurveyQuestionOptionCreateNestedManyWithoutQuestionInput = {
    create?: XOR<SurveyQuestionOptionCreateWithoutQuestionInput, SurveyQuestionOptionUncheckedCreateWithoutQuestionInput> | SurveyQuestionOptionCreateWithoutQuestionInput[] | SurveyQuestionOptionUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: SurveyQuestionOptionCreateOrConnectWithoutQuestionInput | SurveyQuestionOptionCreateOrConnectWithoutQuestionInput[]
    createMany?: SurveyQuestionOptionCreateManyQuestionInputEnvelope
    connect?: SurveyQuestionOptionWhereUniqueInput | SurveyQuestionOptionWhereUniqueInput[]
  }

  export type SurveyResponseItemCreateNestedManyWithoutQuestionInput = {
    create?: XOR<SurveyResponseItemCreateWithoutQuestionInput, SurveyResponseItemUncheckedCreateWithoutQuestionInput> | SurveyResponseItemCreateWithoutQuestionInput[] | SurveyResponseItemUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: SurveyResponseItemCreateOrConnectWithoutQuestionInput | SurveyResponseItemCreateOrConnectWithoutQuestionInput[]
    createMany?: SurveyResponseItemCreateManyQuestionInputEnvelope
    connect?: SurveyResponseItemWhereUniqueInput | SurveyResponseItemWhereUniqueInput[]
  }

  export type SurveyQuestionOptionUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<SurveyQuestionOptionCreateWithoutQuestionInput, SurveyQuestionOptionUncheckedCreateWithoutQuestionInput> | SurveyQuestionOptionCreateWithoutQuestionInput[] | SurveyQuestionOptionUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: SurveyQuestionOptionCreateOrConnectWithoutQuestionInput | SurveyQuestionOptionCreateOrConnectWithoutQuestionInput[]
    createMany?: SurveyQuestionOptionCreateManyQuestionInputEnvelope
    connect?: SurveyQuestionOptionWhereUniqueInput | SurveyQuestionOptionWhereUniqueInput[]
  }

  export type SurveyResponseItemUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<SurveyResponseItemCreateWithoutQuestionInput, SurveyResponseItemUncheckedCreateWithoutQuestionInput> | SurveyResponseItemCreateWithoutQuestionInput[] | SurveyResponseItemUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: SurveyResponseItemCreateOrConnectWithoutQuestionInput | SurveyResponseItemCreateOrConnectWithoutQuestionInput[]
    createMany?: SurveyResponseItemCreateManyQuestionInputEnvelope
    connect?: SurveyResponseItemWhereUniqueInput | SurveyResponseItemWhereUniqueInput[]
  }

  export type EnumSurveyQuestionTypeFieldUpdateOperationsInput = {
    set?: $Enums.SurveyQuestionType
  }

  export type SurveyFormUpdateOneRequiredWithoutQuestionsNestedInput = {
    create?: XOR<SurveyFormCreateWithoutQuestionsInput, SurveyFormUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: SurveyFormCreateOrConnectWithoutQuestionsInput
    upsert?: SurveyFormUpsertWithoutQuestionsInput
    connect?: SurveyFormWhereUniqueInput
    update?: XOR<XOR<SurveyFormUpdateToOneWithWhereWithoutQuestionsInput, SurveyFormUpdateWithoutQuestionsInput>, SurveyFormUncheckedUpdateWithoutQuestionsInput>
  }

  export type SurveyQuestionOptionUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<SurveyQuestionOptionCreateWithoutQuestionInput, SurveyQuestionOptionUncheckedCreateWithoutQuestionInput> | SurveyQuestionOptionCreateWithoutQuestionInput[] | SurveyQuestionOptionUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: SurveyQuestionOptionCreateOrConnectWithoutQuestionInput | SurveyQuestionOptionCreateOrConnectWithoutQuestionInput[]
    upsert?: SurveyQuestionOptionUpsertWithWhereUniqueWithoutQuestionInput | SurveyQuestionOptionUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: SurveyQuestionOptionCreateManyQuestionInputEnvelope
    set?: SurveyQuestionOptionWhereUniqueInput | SurveyQuestionOptionWhereUniqueInput[]
    disconnect?: SurveyQuestionOptionWhereUniqueInput | SurveyQuestionOptionWhereUniqueInput[]
    delete?: SurveyQuestionOptionWhereUniqueInput | SurveyQuestionOptionWhereUniqueInput[]
    connect?: SurveyQuestionOptionWhereUniqueInput | SurveyQuestionOptionWhereUniqueInput[]
    update?: SurveyQuestionOptionUpdateWithWhereUniqueWithoutQuestionInput | SurveyQuestionOptionUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: SurveyQuestionOptionUpdateManyWithWhereWithoutQuestionInput | SurveyQuestionOptionUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: SurveyQuestionOptionScalarWhereInput | SurveyQuestionOptionScalarWhereInput[]
  }

  export type SurveyResponseItemUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<SurveyResponseItemCreateWithoutQuestionInput, SurveyResponseItemUncheckedCreateWithoutQuestionInput> | SurveyResponseItemCreateWithoutQuestionInput[] | SurveyResponseItemUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: SurveyResponseItemCreateOrConnectWithoutQuestionInput | SurveyResponseItemCreateOrConnectWithoutQuestionInput[]
    upsert?: SurveyResponseItemUpsertWithWhereUniqueWithoutQuestionInput | SurveyResponseItemUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: SurveyResponseItemCreateManyQuestionInputEnvelope
    set?: SurveyResponseItemWhereUniqueInput | SurveyResponseItemWhereUniqueInput[]
    disconnect?: SurveyResponseItemWhereUniqueInput | SurveyResponseItemWhereUniqueInput[]
    delete?: SurveyResponseItemWhereUniqueInput | SurveyResponseItemWhereUniqueInput[]
    connect?: SurveyResponseItemWhereUniqueInput | SurveyResponseItemWhereUniqueInput[]
    update?: SurveyResponseItemUpdateWithWhereUniqueWithoutQuestionInput | SurveyResponseItemUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: SurveyResponseItemUpdateManyWithWhereWithoutQuestionInput | SurveyResponseItemUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: SurveyResponseItemScalarWhereInput | SurveyResponseItemScalarWhereInput[]
  }

  export type SurveyQuestionOptionUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<SurveyQuestionOptionCreateWithoutQuestionInput, SurveyQuestionOptionUncheckedCreateWithoutQuestionInput> | SurveyQuestionOptionCreateWithoutQuestionInput[] | SurveyQuestionOptionUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: SurveyQuestionOptionCreateOrConnectWithoutQuestionInput | SurveyQuestionOptionCreateOrConnectWithoutQuestionInput[]
    upsert?: SurveyQuestionOptionUpsertWithWhereUniqueWithoutQuestionInput | SurveyQuestionOptionUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: SurveyQuestionOptionCreateManyQuestionInputEnvelope
    set?: SurveyQuestionOptionWhereUniqueInput | SurveyQuestionOptionWhereUniqueInput[]
    disconnect?: SurveyQuestionOptionWhereUniqueInput | SurveyQuestionOptionWhereUniqueInput[]
    delete?: SurveyQuestionOptionWhereUniqueInput | SurveyQuestionOptionWhereUniqueInput[]
    connect?: SurveyQuestionOptionWhereUniqueInput | SurveyQuestionOptionWhereUniqueInput[]
    update?: SurveyQuestionOptionUpdateWithWhereUniqueWithoutQuestionInput | SurveyQuestionOptionUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: SurveyQuestionOptionUpdateManyWithWhereWithoutQuestionInput | SurveyQuestionOptionUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: SurveyQuestionOptionScalarWhereInput | SurveyQuestionOptionScalarWhereInput[]
  }

  export type SurveyResponseItemUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<SurveyResponseItemCreateWithoutQuestionInput, SurveyResponseItemUncheckedCreateWithoutQuestionInput> | SurveyResponseItemCreateWithoutQuestionInput[] | SurveyResponseItemUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: SurveyResponseItemCreateOrConnectWithoutQuestionInput | SurveyResponseItemCreateOrConnectWithoutQuestionInput[]
    upsert?: SurveyResponseItemUpsertWithWhereUniqueWithoutQuestionInput | SurveyResponseItemUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: SurveyResponseItemCreateManyQuestionInputEnvelope
    set?: SurveyResponseItemWhereUniqueInput | SurveyResponseItemWhereUniqueInput[]
    disconnect?: SurveyResponseItemWhereUniqueInput | SurveyResponseItemWhereUniqueInput[]
    delete?: SurveyResponseItemWhereUniqueInput | SurveyResponseItemWhereUniqueInput[]
    connect?: SurveyResponseItemWhereUniqueInput | SurveyResponseItemWhereUniqueInput[]
    update?: SurveyResponseItemUpdateWithWhereUniqueWithoutQuestionInput | SurveyResponseItemUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: SurveyResponseItemUpdateManyWithWhereWithoutQuestionInput | SurveyResponseItemUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: SurveyResponseItemScalarWhereInput | SurveyResponseItemScalarWhereInput[]
  }

  export type SurveyQuestionCreateNestedOneWithoutOptionsInput = {
    create?: XOR<SurveyQuestionCreateWithoutOptionsInput, SurveyQuestionUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: SurveyQuestionCreateOrConnectWithoutOptionsInput
    connect?: SurveyQuestionWhereUniqueInput
  }

  export type SurveyResponseItemOptionCreateNestedManyWithoutOptionInput = {
    create?: XOR<SurveyResponseItemOptionCreateWithoutOptionInput, SurveyResponseItemOptionUncheckedCreateWithoutOptionInput> | SurveyResponseItemOptionCreateWithoutOptionInput[] | SurveyResponseItemOptionUncheckedCreateWithoutOptionInput[]
    connectOrCreate?: SurveyResponseItemOptionCreateOrConnectWithoutOptionInput | SurveyResponseItemOptionCreateOrConnectWithoutOptionInput[]
    createMany?: SurveyResponseItemOptionCreateManyOptionInputEnvelope
    connect?: SurveyResponseItemOptionWhereUniqueInput | SurveyResponseItemOptionWhereUniqueInput[]
  }

  export type SurveyResponseItemCreateNestedManyWithoutSelectedOptionInput = {
    create?: XOR<SurveyResponseItemCreateWithoutSelectedOptionInput, SurveyResponseItemUncheckedCreateWithoutSelectedOptionInput> | SurveyResponseItemCreateWithoutSelectedOptionInput[] | SurveyResponseItemUncheckedCreateWithoutSelectedOptionInput[]
    connectOrCreate?: SurveyResponseItemCreateOrConnectWithoutSelectedOptionInput | SurveyResponseItemCreateOrConnectWithoutSelectedOptionInput[]
    createMany?: SurveyResponseItemCreateManySelectedOptionInputEnvelope
    connect?: SurveyResponseItemWhereUniqueInput | SurveyResponseItemWhereUniqueInput[]
  }

  export type SurveyResponseItemOptionUncheckedCreateNestedManyWithoutOptionInput = {
    create?: XOR<SurveyResponseItemOptionCreateWithoutOptionInput, SurveyResponseItemOptionUncheckedCreateWithoutOptionInput> | SurveyResponseItemOptionCreateWithoutOptionInput[] | SurveyResponseItemOptionUncheckedCreateWithoutOptionInput[]
    connectOrCreate?: SurveyResponseItemOptionCreateOrConnectWithoutOptionInput | SurveyResponseItemOptionCreateOrConnectWithoutOptionInput[]
    createMany?: SurveyResponseItemOptionCreateManyOptionInputEnvelope
    connect?: SurveyResponseItemOptionWhereUniqueInput | SurveyResponseItemOptionWhereUniqueInput[]
  }

  export type SurveyResponseItemUncheckedCreateNestedManyWithoutSelectedOptionInput = {
    create?: XOR<SurveyResponseItemCreateWithoutSelectedOptionInput, SurveyResponseItemUncheckedCreateWithoutSelectedOptionInput> | SurveyResponseItemCreateWithoutSelectedOptionInput[] | SurveyResponseItemUncheckedCreateWithoutSelectedOptionInput[]
    connectOrCreate?: SurveyResponseItemCreateOrConnectWithoutSelectedOptionInput | SurveyResponseItemCreateOrConnectWithoutSelectedOptionInput[]
    createMany?: SurveyResponseItemCreateManySelectedOptionInputEnvelope
    connect?: SurveyResponseItemWhereUniqueInput | SurveyResponseItemWhereUniqueInput[]
  }

  export type SurveyQuestionUpdateOneRequiredWithoutOptionsNestedInput = {
    create?: XOR<SurveyQuestionCreateWithoutOptionsInput, SurveyQuestionUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: SurveyQuestionCreateOrConnectWithoutOptionsInput
    upsert?: SurveyQuestionUpsertWithoutOptionsInput
    connect?: SurveyQuestionWhereUniqueInput
    update?: XOR<XOR<SurveyQuestionUpdateToOneWithWhereWithoutOptionsInput, SurveyQuestionUpdateWithoutOptionsInput>, SurveyQuestionUncheckedUpdateWithoutOptionsInput>
  }

  export type SurveyResponseItemOptionUpdateManyWithoutOptionNestedInput = {
    create?: XOR<SurveyResponseItemOptionCreateWithoutOptionInput, SurveyResponseItemOptionUncheckedCreateWithoutOptionInput> | SurveyResponseItemOptionCreateWithoutOptionInput[] | SurveyResponseItemOptionUncheckedCreateWithoutOptionInput[]
    connectOrCreate?: SurveyResponseItemOptionCreateOrConnectWithoutOptionInput | SurveyResponseItemOptionCreateOrConnectWithoutOptionInput[]
    upsert?: SurveyResponseItemOptionUpsertWithWhereUniqueWithoutOptionInput | SurveyResponseItemOptionUpsertWithWhereUniqueWithoutOptionInput[]
    createMany?: SurveyResponseItemOptionCreateManyOptionInputEnvelope
    set?: SurveyResponseItemOptionWhereUniqueInput | SurveyResponseItemOptionWhereUniqueInput[]
    disconnect?: SurveyResponseItemOptionWhereUniqueInput | SurveyResponseItemOptionWhereUniqueInput[]
    delete?: SurveyResponseItemOptionWhereUniqueInput | SurveyResponseItemOptionWhereUniqueInput[]
    connect?: SurveyResponseItemOptionWhereUniqueInput | SurveyResponseItemOptionWhereUniqueInput[]
    update?: SurveyResponseItemOptionUpdateWithWhereUniqueWithoutOptionInput | SurveyResponseItemOptionUpdateWithWhereUniqueWithoutOptionInput[]
    updateMany?: SurveyResponseItemOptionUpdateManyWithWhereWithoutOptionInput | SurveyResponseItemOptionUpdateManyWithWhereWithoutOptionInput[]
    deleteMany?: SurveyResponseItemOptionScalarWhereInput | SurveyResponseItemOptionScalarWhereInput[]
  }

  export type SurveyResponseItemUpdateManyWithoutSelectedOptionNestedInput = {
    create?: XOR<SurveyResponseItemCreateWithoutSelectedOptionInput, SurveyResponseItemUncheckedCreateWithoutSelectedOptionInput> | SurveyResponseItemCreateWithoutSelectedOptionInput[] | SurveyResponseItemUncheckedCreateWithoutSelectedOptionInput[]
    connectOrCreate?: SurveyResponseItemCreateOrConnectWithoutSelectedOptionInput | SurveyResponseItemCreateOrConnectWithoutSelectedOptionInput[]
    upsert?: SurveyResponseItemUpsertWithWhereUniqueWithoutSelectedOptionInput | SurveyResponseItemUpsertWithWhereUniqueWithoutSelectedOptionInput[]
    createMany?: SurveyResponseItemCreateManySelectedOptionInputEnvelope
    set?: SurveyResponseItemWhereUniqueInput | SurveyResponseItemWhereUniqueInput[]
    disconnect?: SurveyResponseItemWhereUniqueInput | SurveyResponseItemWhereUniqueInput[]
    delete?: SurveyResponseItemWhereUniqueInput | SurveyResponseItemWhereUniqueInput[]
    connect?: SurveyResponseItemWhereUniqueInput | SurveyResponseItemWhereUniqueInput[]
    update?: SurveyResponseItemUpdateWithWhereUniqueWithoutSelectedOptionInput | SurveyResponseItemUpdateWithWhereUniqueWithoutSelectedOptionInput[]
    updateMany?: SurveyResponseItemUpdateManyWithWhereWithoutSelectedOptionInput | SurveyResponseItemUpdateManyWithWhereWithoutSelectedOptionInput[]
    deleteMany?: SurveyResponseItemScalarWhereInput | SurveyResponseItemScalarWhereInput[]
  }

  export type SurveyResponseItemOptionUncheckedUpdateManyWithoutOptionNestedInput = {
    create?: XOR<SurveyResponseItemOptionCreateWithoutOptionInput, SurveyResponseItemOptionUncheckedCreateWithoutOptionInput> | SurveyResponseItemOptionCreateWithoutOptionInput[] | SurveyResponseItemOptionUncheckedCreateWithoutOptionInput[]
    connectOrCreate?: SurveyResponseItemOptionCreateOrConnectWithoutOptionInput | SurveyResponseItemOptionCreateOrConnectWithoutOptionInput[]
    upsert?: SurveyResponseItemOptionUpsertWithWhereUniqueWithoutOptionInput | SurveyResponseItemOptionUpsertWithWhereUniqueWithoutOptionInput[]
    createMany?: SurveyResponseItemOptionCreateManyOptionInputEnvelope
    set?: SurveyResponseItemOptionWhereUniqueInput | SurveyResponseItemOptionWhereUniqueInput[]
    disconnect?: SurveyResponseItemOptionWhereUniqueInput | SurveyResponseItemOptionWhereUniqueInput[]
    delete?: SurveyResponseItemOptionWhereUniqueInput | SurveyResponseItemOptionWhereUniqueInput[]
    connect?: SurveyResponseItemOptionWhereUniqueInput | SurveyResponseItemOptionWhereUniqueInput[]
    update?: SurveyResponseItemOptionUpdateWithWhereUniqueWithoutOptionInput | SurveyResponseItemOptionUpdateWithWhereUniqueWithoutOptionInput[]
    updateMany?: SurveyResponseItemOptionUpdateManyWithWhereWithoutOptionInput | SurveyResponseItemOptionUpdateManyWithWhereWithoutOptionInput[]
    deleteMany?: SurveyResponseItemOptionScalarWhereInput | SurveyResponseItemOptionScalarWhereInput[]
  }

  export type SurveyResponseItemUncheckedUpdateManyWithoutSelectedOptionNestedInput = {
    create?: XOR<SurveyResponseItemCreateWithoutSelectedOptionInput, SurveyResponseItemUncheckedCreateWithoutSelectedOptionInput> | SurveyResponseItemCreateWithoutSelectedOptionInput[] | SurveyResponseItemUncheckedCreateWithoutSelectedOptionInput[]
    connectOrCreate?: SurveyResponseItemCreateOrConnectWithoutSelectedOptionInput | SurveyResponseItemCreateOrConnectWithoutSelectedOptionInput[]
    upsert?: SurveyResponseItemUpsertWithWhereUniqueWithoutSelectedOptionInput | SurveyResponseItemUpsertWithWhereUniqueWithoutSelectedOptionInput[]
    createMany?: SurveyResponseItemCreateManySelectedOptionInputEnvelope
    set?: SurveyResponseItemWhereUniqueInput | SurveyResponseItemWhereUniqueInput[]
    disconnect?: SurveyResponseItemWhereUniqueInput | SurveyResponseItemWhereUniqueInput[]
    delete?: SurveyResponseItemWhereUniqueInput | SurveyResponseItemWhereUniqueInput[]
    connect?: SurveyResponseItemWhereUniqueInput | SurveyResponseItemWhereUniqueInput[]
    update?: SurveyResponseItemUpdateWithWhereUniqueWithoutSelectedOptionInput | SurveyResponseItemUpdateWithWhereUniqueWithoutSelectedOptionInput[]
    updateMany?: SurveyResponseItemUpdateManyWithWhereWithoutSelectedOptionInput | SurveyResponseItemUpdateManyWithWhereWithoutSelectedOptionInput[]
    deleteMany?: SurveyResponseItemScalarWhereInput | SurveyResponseItemScalarWhereInput[]
  }

  export type SurveyFormCreateNestedOneWithoutResponsesInput = {
    create?: XOR<SurveyFormCreateWithoutResponsesInput, SurveyFormUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: SurveyFormCreateOrConnectWithoutResponsesInput
    connect?: SurveyFormWhereUniqueInput
  }

  export type CountyCreateNestedOneWithoutSurveyResponsesInput = {
    create?: XOR<CountyCreateWithoutSurveyResponsesInput, CountyUncheckedCreateWithoutSurveyResponsesInput>
    connectOrCreate?: CountyCreateOrConnectWithoutSurveyResponsesInput
    connect?: CountyWhereUniqueInput
  }

  export type SurveyResponseItemCreateNestedManyWithoutResponseInput = {
    create?: XOR<SurveyResponseItemCreateWithoutResponseInput, SurveyResponseItemUncheckedCreateWithoutResponseInput> | SurveyResponseItemCreateWithoutResponseInput[] | SurveyResponseItemUncheckedCreateWithoutResponseInput[]
    connectOrCreate?: SurveyResponseItemCreateOrConnectWithoutResponseInput | SurveyResponseItemCreateOrConnectWithoutResponseInput[]
    createMany?: SurveyResponseItemCreateManyResponseInputEnvelope
    connect?: SurveyResponseItemWhereUniqueInput | SurveyResponseItemWhereUniqueInput[]
  }

  export type SurveyResponseItemUncheckedCreateNestedManyWithoutResponseInput = {
    create?: XOR<SurveyResponseItemCreateWithoutResponseInput, SurveyResponseItemUncheckedCreateWithoutResponseInput> | SurveyResponseItemCreateWithoutResponseInput[] | SurveyResponseItemUncheckedCreateWithoutResponseInput[]
    connectOrCreate?: SurveyResponseItemCreateOrConnectWithoutResponseInput | SurveyResponseItemCreateOrConnectWithoutResponseInput[]
    createMany?: SurveyResponseItemCreateManyResponseInputEnvelope
    connect?: SurveyResponseItemWhereUniqueInput | SurveyResponseItemWhereUniqueInput[]
  }

  export type SurveyFormUpdateOneRequiredWithoutResponsesNestedInput = {
    create?: XOR<SurveyFormCreateWithoutResponsesInput, SurveyFormUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: SurveyFormCreateOrConnectWithoutResponsesInput
    upsert?: SurveyFormUpsertWithoutResponsesInput
    connect?: SurveyFormWhereUniqueInput
    update?: XOR<XOR<SurveyFormUpdateToOneWithWhereWithoutResponsesInput, SurveyFormUpdateWithoutResponsesInput>, SurveyFormUncheckedUpdateWithoutResponsesInput>
  }

  export type CountyUpdateOneWithoutSurveyResponsesNestedInput = {
    create?: XOR<CountyCreateWithoutSurveyResponsesInput, CountyUncheckedCreateWithoutSurveyResponsesInput>
    connectOrCreate?: CountyCreateOrConnectWithoutSurveyResponsesInput
    upsert?: CountyUpsertWithoutSurveyResponsesInput
    disconnect?: CountyWhereInput | boolean
    delete?: CountyWhereInput | boolean
    connect?: CountyWhereUniqueInput
    update?: XOR<XOR<CountyUpdateToOneWithWhereWithoutSurveyResponsesInput, CountyUpdateWithoutSurveyResponsesInput>, CountyUncheckedUpdateWithoutSurveyResponsesInput>
  }

  export type SurveyResponseItemUpdateManyWithoutResponseNestedInput = {
    create?: XOR<SurveyResponseItemCreateWithoutResponseInput, SurveyResponseItemUncheckedCreateWithoutResponseInput> | SurveyResponseItemCreateWithoutResponseInput[] | SurveyResponseItemUncheckedCreateWithoutResponseInput[]
    connectOrCreate?: SurveyResponseItemCreateOrConnectWithoutResponseInput | SurveyResponseItemCreateOrConnectWithoutResponseInput[]
    upsert?: SurveyResponseItemUpsertWithWhereUniqueWithoutResponseInput | SurveyResponseItemUpsertWithWhereUniqueWithoutResponseInput[]
    createMany?: SurveyResponseItemCreateManyResponseInputEnvelope
    set?: SurveyResponseItemWhereUniqueInput | SurveyResponseItemWhereUniqueInput[]
    disconnect?: SurveyResponseItemWhereUniqueInput | SurveyResponseItemWhereUniqueInput[]
    delete?: SurveyResponseItemWhereUniqueInput | SurveyResponseItemWhereUniqueInput[]
    connect?: SurveyResponseItemWhereUniqueInput | SurveyResponseItemWhereUniqueInput[]
    update?: SurveyResponseItemUpdateWithWhereUniqueWithoutResponseInput | SurveyResponseItemUpdateWithWhereUniqueWithoutResponseInput[]
    updateMany?: SurveyResponseItemUpdateManyWithWhereWithoutResponseInput | SurveyResponseItemUpdateManyWithWhereWithoutResponseInput[]
    deleteMany?: SurveyResponseItemScalarWhereInput | SurveyResponseItemScalarWhereInput[]
  }

  export type SurveyResponseItemUncheckedUpdateManyWithoutResponseNestedInput = {
    create?: XOR<SurveyResponseItemCreateWithoutResponseInput, SurveyResponseItemUncheckedCreateWithoutResponseInput> | SurveyResponseItemCreateWithoutResponseInput[] | SurveyResponseItemUncheckedCreateWithoutResponseInput[]
    connectOrCreate?: SurveyResponseItemCreateOrConnectWithoutResponseInput | SurveyResponseItemCreateOrConnectWithoutResponseInput[]
    upsert?: SurveyResponseItemUpsertWithWhereUniqueWithoutResponseInput | SurveyResponseItemUpsertWithWhereUniqueWithoutResponseInput[]
    createMany?: SurveyResponseItemCreateManyResponseInputEnvelope
    set?: SurveyResponseItemWhereUniqueInput | SurveyResponseItemWhereUniqueInput[]
    disconnect?: SurveyResponseItemWhereUniqueInput | SurveyResponseItemWhereUniqueInput[]
    delete?: SurveyResponseItemWhereUniqueInput | SurveyResponseItemWhereUniqueInput[]
    connect?: SurveyResponseItemWhereUniqueInput | SurveyResponseItemWhereUniqueInput[]
    update?: SurveyResponseItemUpdateWithWhereUniqueWithoutResponseInput | SurveyResponseItemUpdateWithWhereUniqueWithoutResponseInput[]
    updateMany?: SurveyResponseItemUpdateManyWithWhereWithoutResponseInput | SurveyResponseItemUpdateManyWithWhereWithoutResponseInput[]
    deleteMany?: SurveyResponseItemScalarWhereInput | SurveyResponseItemScalarWhereInput[]
  }

  export type SurveyResponseCreateNestedOneWithoutItemsInput = {
    create?: XOR<SurveyResponseCreateWithoutItemsInput, SurveyResponseUncheckedCreateWithoutItemsInput>
    connectOrCreate?: SurveyResponseCreateOrConnectWithoutItemsInput
    connect?: SurveyResponseWhereUniqueInput
  }

  export type SurveyQuestionCreateNestedOneWithoutResponseItemsInput = {
    create?: XOR<SurveyQuestionCreateWithoutResponseItemsInput, SurveyQuestionUncheckedCreateWithoutResponseItemsInput>
    connectOrCreate?: SurveyQuestionCreateOrConnectWithoutResponseItemsInput
    connect?: SurveyQuestionWhereUniqueInput
  }

  export type SurveyQuestionOptionCreateNestedOneWithoutSelectedByResponseItemsInput = {
    create?: XOR<SurveyQuestionOptionCreateWithoutSelectedByResponseItemsInput, SurveyQuestionOptionUncheckedCreateWithoutSelectedByResponseItemsInput>
    connectOrCreate?: SurveyQuestionOptionCreateOrConnectWithoutSelectedByResponseItemsInput
    connect?: SurveyQuestionOptionWhereUniqueInput
  }

  export type MediaAssetCreateNestedOneWithoutSurveyResponseItemsInput = {
    create?: XOR<MediaAssetCreateWithoutSurveyResponseItemsInput, MediaAssetUncheckedCreateWithoutSurveyResponseItemsInput>
    connectOrCreate?: MediaAssetCreateOrConnectWithoutSurveyResponseItemsInput
    connect?: MediaAssetWhereUniqueInput
  }

  export type SurveyResponseItemOptionCreateNestedManyWithoutResponseItemInput = {
    create?: XOR<SurveyResponseItemOptionCreateWithoutResponseItemInput, SurveyResponseItemOptionUncheckedCreateWithoutResponseItemInput> | SurveyResponseItemOptionCreateWithoutResponseItemInput[] | SurveyResponseItemOptionUncheckedCreateWithoutResponseItemInput[]
    connectOrCreate?: SurveyResponseItemOptionCreateOrConnectWithoutResponseItemInput | SurveyResponseItemOptionCreateOrConnectWithoutResponseItemInput[]
    createMany?: SurveyResponseItemOptionCreateManyResponseItemInputEnvelope
    connect?: SurveyResponseItemOptionWhereUniqueInput | SurveyResponseItemOptionWhereUniqueInput[]
  }

  export type SurveyResponseItemOptionUncheckedCreateNestedManyWithoutResponseItemInput = {
    create?: XOR<SurveyResponseItemOptionCreateWithoutResponseItemInput, SurveyResponseItemOptionUncheckedCreateWithoutResponseItemInput> | SurveyResponseItemOptionCreateWithoutResponseItemInput[] | SurveyResponseItemOptionUncheckedCreateWithoutResponseItemInput[]
    connectOrCreate?: SurveyResponseItemOptionCreateOrConnectWithoutResponseItemInput | SurveyResponseItemOptionCreateOrConnectWithoutResponseItemInput[]
    createMany?: SurveyResponseItemOptionCreateManyResponseItemInputEnvelope
    connect?: SurveyResponseItemOptionWhereUniqueInput | SurveyResponseItemOptionWhereUniqueInput[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type SurveyResponseUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<SurveyResponseCreateWithoutItemsInput, SurveyResponseUncheckedCreateWithoutItemsInput>
    connectOrCreate?: SurveyResponseCreateOrConnectWithoutItemsInput
    upsert?: SurveyResponseUpsertWithoutItemsInput
    connect?: SurveyResponseWhereUniqueInput
    update?: XOR<XOR<SurveyResponseUpdateToOneWithWhereWithoutItemsInput, SurveyResponseUpdateWithoutItemsInput>, SurveyResponseUncheckedUpdateWithoutItemsInput>
  }

  export type SurveyQuestionUpdateOneRequiredWithoutResponseItemsNestedInput = {
    create?: XOR<SurveyQuestionCreateWithoutResponseItemsInput, SurveyQuestionUncheckedCreateWithoutResponseItemsInput>
    connectOrCreate?: SurveyQuestionCreateOrConnectWithoutResponseItemsInput
    upsert?: SurveyQuestionUpsertWithoutResponseItemsInput
    connect?: SurveyQuestionWhereUniqueInput
    update?: XOR<XOR<SurveyQuestionUpdateToOneWithWhereWithoutResponseItemsInput, SurveyQuestionUpdateWithoutResponseItemsInput>, SurveyQuestionUncheckedUpdateWithoutResponseItemsInput>
  }

  export type SurveyQuestionOptionUpdateOneWithoutSelectedByResponseItemsNestedInput = {
    create?: XOR<SurveyQuestionOptionCreateWithoutSelectedByResponseItemsInput, SurveyQuestionOptionUncheckedCreateWithoutSelectedByResponseItemsInput>
    connectOrCreate?: SurveyQuestionOptionCreateOrConnectWithoutSelectedByResponseItemsInput
    upsert?: SurveyQuestionOptionUpsertWithoutSelectedByResponseItemsInput
    disconnect?: SurveyQuestionOptionWhereInput | boolean
    delete?: SurveyQuestionOptionWhereInput | boolean
    connect?: SurveyQuestionOptionWhereUniqueInput
    update?: XOR<XOR<SurveyQuestionOptionUpdateToOneWithWhereWithoutSelectedByResponseItemsInput, SurveyQuestionOptionUpdateWithoutSelectedByResponseItemsInput>, SurveyQuestionOptionUncheckedUpdateWithoutSelectedByResponseItemsInput>
  }

  export type MediaAssetUpdateOneWithoutSurveyResponseItemsNestedInput = {
    create?: XOR<MediaAssetCreateWithoutSurveyResponseItemsInput, MediaAssetUncheckedCreateWithoutSurveyResponseItemsInput>
    connectOrCreate?: MediaAssetCreateOrConnectWithoutSurveyResponseItemsInput
    upsert?: MediaAssetUpsertWithoutSurveyResponseItemsInput
    disconnect?: MediaAssetWhereInput | boolean
    delete?: MediaAssetWhereInput | boolean
    connect?: MediaAssetWhereUniqueInput
    update?: XOR<XOR<MediaAssetUpdateToOneWithWhereWithoutSurveyResponseItemsInput, MediaAssetUpdateWithoutSurveyResponseItemsInput>, MediaAssetUncheckedUpdateWithoutSurveyResponseItemsInput>
  }

  export type SurveyResponseItemOptionUpdateManyWithoutResponseItemNestedInput = {
    create?: XOR<SurveyResponseItemOptionCreateWithoutResponseItemInput, SurveyResponseItemOptionUncheckedCreateWithoutResponseItemInput> | SurveyResponseItemOptionCreateWithoutResponseItemInput[] | SurveyResponseItemOptionUncheckedCreateWithoutResponseItemInput[]
    connectOrCreate?: SurveyResponseItemOptionCreateOrConnectWithoutResponseItemInput | SurveyResponseItemOptionCreateOrConnectWithoutResponseItemInput[]
    upsert?: SurveyResponseItemOptionUpsertWithWhereUniqueWithoutResponseItemInput | SurveyResponseItemOptionUpsertWithWhereUniqueWithoutResponseItemInput[]
    createMany?: SurveyResponseItemOptionCreateManyResponseItemInputEnvelope
    set?: SurveyResponseItemOptionWhereUniqueInput | SurveyResponseItemOptionWhereUniqueInput[]
    disconnect?: SurveyResponseItemOptionWhereUniqueInput | SurveyResponseItemOptionWhereUniqueInput[]
    delete?: SurveyResponseItemOptionWhereUniqueInput | SurveyResponseItemOptionWhereUniqueInput[]
    connect?: SurveyResponseItemOptionWhereUniqueInput | SurveyResponseItemOptionWhereUniqueInput[]
    update?: SurveyResponseItemOptionUpdateWithWhereUniqueWithoutResponseItemInput | SurveyResponseItemOptionUpdateWithWhereUniqueWithoutResponseItemInput[]
    updateMany?: SurveyResponseItemOptionUpdateManyWithWhereWithoutResponseItemInput | SurveyResponseItemOptionUpdateManyWithWhereWithoutResponseItemInput[]
    deleteMany?: SurveyResponseItemOptionScalarWhereInput | SurveyResponseItemOptionScalarWhereInput[]
  }

  export type SurveyResponseItemOptionUncheckedUpdateManyWithoutResponseItemNestedInput = {
    create?: XOR<SurveyResponseItemOptionCreateWithoutResponseItemInput, SurveyResponseItemOptionUncheckedCreateWithoutResponseItemInput> | SurveyResponseItemOptionCreateWithoutResponseItemInput[] | SurveyResponseItemOptionUncheckedCreateWithoutResponseItemInput[]
    connectOrCreate?: SurveyResponseItemOptionCreateOrConnectWithoutResponseItemInput | SurveyResponseItemOptionCreateOrConnectWithoutResponseItemInput[]
    upsert?: SurveyResponseItemOptionUpsertWithWhereUniqueWithoutResponseItemInput | SurveyResponseItemOptionUpsertWithWhereUniqueWithoutResponseItemInput[]
    createMany?: SurveyResponseItemOptionCreateManyResponseItemInputEnvelope
    set?: SurveyResponseItemOptionWhereUniqueInput | SurveyResponseItemOptionWhereUniqueInput[]
    disconnect?: SurveyResponseItemOptionWhereUniqueInput | SurveyResponseItemOptionWhereUniqueInput[]
    delete?: SurveyResponseItemOptionWhereUniqueInput | SurveyResponseItemOptionWhereUniqueInput[]
    connect?: SurveyResponseItemOptionWhereUniqueInput | SurveyResponseItemOptionWhereUniqueInput[]
    update?: SurveyResponseItemOptionUpdateWithWhereUniqueWithoutResponseItemInput | SurveyResponseItemOptionUpdateWithWhereUniqueWithoutResponseItemInput[]
    updateMany?: SurveyResponseItemOptionUpdateManyWithWhereWithoutResponseItemInput | SurveyResponseItemOptionUpdateManyWithWhereWithoutResponseItemInput[]
    deleteMany?: SurveyResponseItemOptionScalarWhereInput | SurveyResponseItemOptionScalarWhereInput[]
  }

  export type SurveyResponseItemCreateNestedOneWithoutMultiSelectedOptionsInput = {
    create?: XOR<SurveyResponseItemCreateWithoutMultiSelectedOptionsInput, SurveyResponseItemUncheckedCreateWithoutMultiSelectedOptionsInput>
    connectOrCreate?: SurveyResponseItemCreateOrConnectWithoutMultiSelectedOptionsInput
    connect?: SurveyResponseItemWhereUniqueInput
  }

  export type SurveyQuestionOptionCreateNestedOneWithoutResponseItemOptionsInput = {
    create?: XOR<SurveyQuestionOptionCreateWithoutResponseItemOptionsInput, SurveyQuestionOptionUncheckedCreateWithoutResponseItemOptionsInput>
    connectOrCreate?: SurveyQuestionOptionCreateOrConnectWithoutResponseItemOptionsInput
    connect?: SurveyQuestionOptionWhereUniqueInput
  }

  export type SurveyResponseItemUpdateOneRequiredWithoutMultiSelectedOptionsNestedInput = {
    create?: XOR<SurveyResponseItemCreateWithoutMultiSelectedOptionsInput, SurveyResponseItemUncheckedCreateWithoutMultiSelectedOptionsInput>
    connectOrCreate?: SurveyResponseItemCreateOrConnectWithoutMultiSelectedOptionsInput
    upsert?: SurveyResponseItemUpsertWithoutMultiSelectedOptionsInput
    connect?: SurveyResponseItemWhereUniqueInput
    update?: XOR<XOR<SurveyResponseItemUpdateToOneWithWhereWithoutMultiSelectedOptionsInput, SurveyResponseItemUpdateWithoutMultiSelectedOptionsInput>, SurveyResponseItemUncheckedUpdateWithoutMultiSelectedOptionsInput>
  }

  export type SurveyQuestionOptionUpdateOneRequiredWithoutResponseItemOptionsNestedInput = {
    create?: XOR<SurveyQuestionOptionCreateWithoutResponseItemOptionsInput, SurveyQuestionOptionUncheckedCreateWithoutResponseItemOptionsInput>
    connectOrCreate?: SurveyQuestionOptionCreateOrConnectWithoutResponseItemOptionsInput
    upsert?: SurveyQuestionOptionUpsertWithoutResponseItemOptionsInput
    connect?: SurveyQuestionOptionWhereUniqueInput
    update?: XOR<XOR<SurveyQuestionOptionUpdateToOneWithWhereWithoutResponseItemOptionsInput, SurveyQuestionOptionUpdateWithoutResponseItemOptionsInput>, SurveyQuestionOptionUncheckedUpdateWithoutResponseItemOptionsInput>
  }

  export type SurveyResponseItemCreateNestedManyWithoutMediaAssetInput = {
    create?: XOR<SurveyResponseItemCreateWithoutMediaAssetInput, SurveyResponseItemUncheckedCreateWithoutMediaAssetInput> | SurveyResponseItemCreateWithoutMediaAssetInput[] | SurveyResponseItemUncheckedCreateWithoutMediaAssetInput[]
    connectOrCreate?: SurveyResponseItemCreateOrConnectWithoutMediaAssetInput | SurveyResponseItemCreateOrConnectWithoutMediaAssetInput[]
    createMany?: SurveyResponseItemCreateManyMediaAssetInputEnvelope
    connect?: SurveyResponseItemWhereUniqueInput | SurveyResponseItemWhereUniqueInput[]
  }

  export type TranscriptCreateNestedManyWithoutMediaAssetInput = {
    create?: XOR<TranscriptCreateWithoutMediaAssetInput, TranscriptUncheckedCreateWithoutMediaAssetInput> | TranscriptCreateWithoutMediaAssetInput[] | TranscriptUncheckedCreateWithoutMediaAssetInput[]
    connectOrCreate?: TranscriptCreateOrConnectWithoutMediaAssetInput | TranscriptCreateOrConnectWithoutMediaAssetInput[]
    createMany?: TranscriptCreateManyMediaAssetInputEnvelope
    connect?: TranscriptWhereUniqueInput | TranscriptWhereUniqueInput[]
  }

  export type AIAnalysisCreateNestedManyWithoutMediaAssetInput = {
    create?: XOR<AIAnalysisCreateWithoutMediaAssetInput, AIAnalysisUncheckedCreateWithoutMediaAssetInput> | AIAnalysisCreateWithoutMediaAssetInput[] | AIAnalysisUncheckedCreateWithoutMediaAssetInput[]
    connectOrCreate?: AIAnalysisCreateOrConnectWithoutMediaAssetInput | AIAnalysisCreateOrConnectWithoutMediaAssetInput[]
    createMany?: AIAnalysisCreateManyMediaAssetInputEnvelope
    connect?: AIAnalysisWhereUniqueInput | AIAnalysisWhereUniqueInput[]
  }

  export type SurveyResponseItemUncheckedCreateNestedManyWithoutMediaAssetInput = {
    create?: XOR<SurveyResponseItemCreateWithoutMediaAssetInput, SurveyResponseItemUncheckedCreateWithoutMediaAssetInput> | SurveyResponseItemCreateWithoutMediaAssetInput[] | SurveyResponseItemUncheckedCreateWithoutMediaAssetInput[]
    connectOrCreate?: SurveyResponseItemCreateOrConnectWithoutMediaAssetInput | SurveyResponseItemCreateOrConnectWithoutMediaAssetInput[]
    createMany?: SurveyResponseItemCreateManyMediaAssetInputEnvelope
    connect?: SurveyResponseItemWhereUniqueInput | SurveyResponseItemWhereUniqueInput[]
  }

  export type TranscriptUncheckedCreateNestedManyWithoutMediaAssetInput = {
    create?: XOR<TranscriptCreateWithoutMediaAssetInput, TranscriptUncheckedCreateWithoutMediaAssetInput> | TranscriptCreateWithoutMediaAssetInput[] | TranscriptUncheckedCreateWithoutMediaAssetInput[]
    connectOrCreate?: TranscriptCreateOrConnectWithoutMediaAssetInput | TranscriptCreateOrConnectWithoutMediaAssetInput[]
    createMany?: TranscriptCreateManyMediaAssetInputEnvelope
    connect?: TranscriptWhereUniqueInput | TranscriptWhereUniqueInput[]
  }

  export type AIAnalysisUncheckedCreateNestedManyWithoutMediaAssetInput = {
    create?: XOR<AIAnalysisCreateWithoutMediaAssetInput, AIAnalysisUncheckedCreateWithoutMediaAssetInput> | AIAnalysisCreateWithoutMediaAssetInput[] | AIAnalysisUncheckedCreateWithoutMediaAssetInput[]
    connectOrCreate?: AIAnalysisCreateOrConnectWithoutMediaAssetInput | AIAnalysisCreateOrConnectWithoutMediaAssetInput[]
    createMany?: AIAnalysisCreateManyMediaAssetInputEnvelope
    connect?: AIAnalysisWhereUniqueInput | AIAnalysisWhereUniqueInput[]
  }

  export type SurveyResponseItemUpdateManyWithoutMediaAssetNestedInput = {
    create?: XOR<SurveyResponseItemCreateWithoutMediaAssetInput, SurveyResponseItemUncheckedCreateWithoutMediaAssetInput> | SurveyResponseItemCreateWithoutMediaAssetInput[] | SurveyResponseItemUncheckedCreateWithoutMediaAssetInput[]
    connectOrCreate?: SurveyResponseItemCreateOrConnectWithoutMediaAssetInput | SurveyResponseItemCreateOrConnectWithoutMediaAssetInput[]
    upsert?: SurveyResponseItemUpsertWithWhereUniqueWithoutMediaAssetInput | SurveyResponseItemUpsertWithWhereUniqueWithoutMediaAssetInput[]
    createMany?: SurveyResponseItemCreateManyMediaAssetInputEnvelope
    set?: SurveyResponseItemWhereUniqueInput | SurveyResponseItemWhereUniqueInput[]
    disconnect?: SurveyResponseItemWhereUniqueInput | SurveyResponseItemWhereUniqueInput[]
    delete?: SurveyResponseItemWhereUniqueInput | SurveyResponseItemWhereUniqueInput[]
    connect?: SurveyResponseItemWhereUniqueInput | SurveyResponseItemWhereUniqueInput[]
    update?: SurveyResponseItemUpdateWithWhereUniqueWithoutMediaAssetInput | SurveyResponseItemUpdateWithWhereUniqueWithoutMediaAssetInput[]
    updateMany?: SurveyResponseItemUpdateManyWithWhereWithoutMediaAssetInput | SurveyResponseItemUpdateManyWithWhereWithoutMediaAssetInput[]
    deleteMany?: SurveyResponseItemScalarWhereInput | SurveyResponseItemScalarWhereInput[]
  }

  export type TranscriptUpdateManyWithoutMediaAssetNestedInput = {
    create?: XOR<TranscriptCreateWithoutMediaAssetInput, TranscriptUncheckedCreateWithoutMediaAssetInput> | TranscriptCreateWithoutMediaAssetInput[] | TranscriptUncheckedCreateWithoutMediaAssetInput[]
    connectOrCreate?: TranscriptCreateOrConnectWithoutMediaAssetInput | TranscriptCreateOrConnectWithoutMediaAssetInput[]
    upsert?: TranscriptUpsertWithWhereUniqueWithoutMediaAssetInput | TranscriptUpsertWithWhereUniqueWithoutMediaAssetInput[]
    createMany?: TranscriptCreateManyMediaAssetInputEnvelope
    set?: TranscriptWhereUniqueInput | TranscriptWhereUniqueInput[]
    disconnect?: TranscriptWhereUniqueInput | TranscriptWhereUniqueInput[]
    delete?: TranscriptWhereUniqueInput | TranscriptWhereUniqueInput[]
    connect?: TranscriptWhereUniqueInput | TranscriptWhereUniqueInput[]
    update?: TranscriptUpdateWithWhereUniqueWithoutMediaAssetInput | TranscriptUpdateWithWhereUniqueWithoutMediaAssetInput[]
    updateMany?: TranscriptUpdateManyWithWhereWithoutMediaAssetInput | TranscriptUpdateManyWithWhereWithoutMediaAssetInput[]
    deleteMany?: TranscriptScalarWhereInput | TranscriptScalarWhereInput[]
  }

  export type AIAnalysisUpdateManyWithoutMediaAssetNestedInput = {
    create?: XOR<AIAnalysisCreateWithoutMediaAssetInput, AIAnalysisUncheckedCreateWithoutMediaAssetInput> | AIAnalysisCreateWithoutMediaAssetInput[] | AIAnalysisUncheckedCreateWithoutMediaAssetInput[]
    connectOrCreate?: AIAnalysisCreateOrConnectWithoutMediaAssetInput | AIAnalysisCreateOrConnectWithoutMediaAssetInput[]
    upsert?: AIAnalysisUpsertWithWhereUniqueWithoutMediaAssetInput | AIAnalysisUpsertWithWhereUniqueWithoutMediaAssetInput[]
    createMany?: AIAnalysisCreateManyMediaAssetInputEnvelope
    set?: AIAnalysisWhereUniqueInput | AIAnalysisWhereUniqueInput[]
    disconnect?: AIAnalysisWhereUniqueInput | AIAnalysisWhereUniqueInput[]
    delete?: AIAnalysisWhereUniqueInput | AIAnalysisWhereUniqueInput[]
    connect?: AIAnalysisWhereUniqueInput | AIAnalysisWhereUniqueInput[]
    update?: AIAnalysisUpdateWithWhereUniqueWithoutMediaAssetInput | AIAnalysisUpdateWithWhereUniqueWithoutMediaAssetInput[]
    updateMany?: AIAnalysisUpdateManyWithWhereWithoutMediaAssetInput | AIAnalysisUpdateManyWithWhereWithoutMediaAssetInput[]
    deleteMany?: AIAnalysisScalarWhereInput | AIAnalysisScalarWhereInput[]
  }

  export type SurveyResponseItemUncheckedUpdateManyWithoutMediaAssetNestedInput = {
    create?: XOR<SurveyResponseItemCreateWithoutMediaAssetInput, SurveyResponseItemUncheckedCreateWithoutMediaAssetInput> | SurveyResponseItemCreateWithoutMediaAssetInput[] | SurveyResponseItemUncheckedCreateWithoutMediaAssetInput[]
    connectOrCreate?: SurveyResponseItemCreateOrConnectWithoutMediaAssetInput | SurveyResponseItemCreateOrConnectWithoutMediaAssetInput[]
    upsert?: SurveyResponseItemUpsertWithWhereUniqueWithoutMediaAssetInput | SurveyResponseItemUpsertWithWhereUniqueWithoutMediaAssetInput[]
    createMany?: SurveyResponseItemCreateManyMediaAssetInputEnvelope
    set?: SurveyResponseItemWhereUniqueInput | SurveyResponseItemWhereUniqueInput[]
    disconnect?: SurveyResponseItemWhereUniqueInput | SurveyResponseItemWhereUniqueInput[]
    delete?: SurveyResponseItemWhereUniqueInput | SurveyResponseItemWhereUniqueInput[]
    connect?: SurveyResponseItemWhereUniqueInput | SurveyResponseItemWhereUniqueInput[]
    update?: SurveyResponseItemUpdateWithWhereUniqueWithoutMediaAssetInput | SurveyResponseItemUpdateWithWhereUniqueWithoutMediaAssetInput[]
    updateMany?: SurveyResponseItemUpdateManyWithWhereWithoutMediaAssetInput | SurveyResponseItemUpdateManyWithWhereWithoutMediaAssetInput[]
    deleteMany?: SurveyResponseItemScalarWhereInput | SurveyResponseItemScalarWhereInput[]
  }

  export type TranscriptUncheckedUpdateManyWithoutMediaAssetNestedInput = {
    create?: XOR<TranscriptCreateWithoutMediaAssetInput, TranscriptUncheckedCreateWithoutMediaAssetInput> | TranscriptCreateWithoutMediaAssetInput[] | TranscriptUncheckedCreateWithoutMediaAssetInput[]
    connectOrCreate?: TranscriptCreateOrConnectWithoutMediaAssetInput | TranscriptCreateOrConnectWithoutMediaAssetInput[]
    upsert?: TranscriptUpsertWithWhereUniqueWithoutMediaAssetInput | TranscriptUpsertWithWhereUniqueWithoutMediaAssetInput[]
    createMany?: TranscriptCreateManyMediaAssetInputEnvelope
    set?: TranscriptWhereUniqueInput | TranscriptWhereUniqueInput[]
    disconnect?: TranscriptWhereUniqueInput | TranscriptWhereUniqueInput[]
    delete?: TranscriptWhereUniqueInput | TranscriptWhereUniqueInput[]
    connect?: TranscriptWhereUniqueInput | TranscriptWhereUniqueInput[]
    update?: TranscriptUpdateWithWhereUniqueWithoutMediaAssetInput | TranscriptUpdateWithWhereUniqueWithoutMediaAssetInput[]
    updateMany?: TranscriptUpdateManyWithWhereWithoutMediaAssetInput | TranscriptUpdateManyWithWhereWithoutMediaAssetInput[]
    deleteMany?: TranscriptScalarWhereInput | TranscriptScalarWhereInput[]
  }

  export type AIAnalysisUncheckedUpdateManyWithoutMediaAssetNestedInput = {
    create?: XOR<AIAnalysisCreateWithoutMediaAssetInput, AIAnalysisUncheckedCreateWithoutMediaAssetInput> | AIAnalysisCreateWithoutMediaAssetInput[] | AIAnalysisUncheckedCreateWithoutMediaAssetInput[]
    connectOrCreate?: AIAnalysisCreateOrConnectWithoutMediaAssetInput | AIAnalysisCreateOrConnectWithoutMediaAssetInput[]
    upsert?: AIAnalysisUpsertWithWhereUniqueWithoutMediaAssetInput | AIAnalysisUpsertWithWhereUniqueWithoutMediaAssetInput[]
    createMany?: AIAnalysisCreateManyMediaAssetInputEnvelope
    set?: AIAnalysisWhereUniqueInput | AIAnalysisWhereUniqueInput[]
    disconnect?: AIAnalysisWhereUniqueInput | AIAnalysisWhereUniqueInput[]
    delete?: AIAnalysisWhereUniqueInput | AIAnalysisWhereUniqueInput[]
    connect?: AIAnalysisWhereUniqueInput | AIAnalysisWhereUniqueInput[]
    update?: AIAnalysisUpdateWithWhereUniqueWithoutMediaAssetInput | AIAnalysisUpdateWithWhereUniqueWithoutMediaAssetInput[]
    updateMany?: AIAnalysisUpdateManyWithWhereWithoutMediaAssetInput | AIAnalysisUpdateManyWithWhereWithoutMediaAssetInput[]
    deleteMany?: AIAnalysisScalarWhereInput | AIAnalysisScalarWhereInput[]
  }

  export type MediaAssetCreateNestedOneWithoutTranscriptsInput = {
    create?: XOR<MediaAssetCreateWithoutTranscriptsInput, MediaAssetUncheckedCreateWithoutTranscriptsInput>
    connectOrCreate?: MediaAssetCreateOrConnectWithoutTranscriptsInput
    connect?: MediaAssetWhereUniqueInput
  }

  export type AIAnalysisCreateNestedManyWithoutTranscriptInput = {
    create?: XOR<AIAnalysisCreateWithoutTranscriptInput, AIAnalysisUncheckedCreateWithoutTranscriptInput> | AIAnalysisCreateWithoutTranscriptInput[] | AIAnalysisUncheckedCreateWithoutTranscriptInput[]
    connectOrCreate?: AIAnalysisCreateOrConnectWithoutTranscriptInput | AIAnalysisCreateOrConnectWithoutTranscriptInput[]
    createMany?: AIAnalysisCreateManyTranscriptInputEnvelope
    connect?: AIAnalysisWhereUniqueInput | AIAnalysisWhereUniqueInput[]
  }

  export type AIAnalysisUncheckedCreateNestedManyWithoutTranscriptInput = {
    create?: XOR<AIAnalysisCreateWithoutTranscriptInput, AIAnalysisUncheckedCreateWithoutTranscriptInput> | AIAnalysisCreateWithoutTranscriptInput[] | AIAnalysisUncheckedCreateWithoutTranscriptInput[]
    connectOrCreate?: AIAnalysisCreateOrConnectWithoutTranscriptInput | AIAnalysisCreateOrConnectWithoutTranscriptInput[]
    createMany?: AIAnalysisCreateManyTranscriptInputEnvelope
    connect?: AIAnalysisWhereUniqueInput | AIAnalysisWhereUniqueInput[]
  }

  export type MediaAssetUpdateOneRequiredWithoutTranscriptsNestedInput = {
    create?: XOR<MediaAssetCreateWithoutTranscriptsInput, MediaAssetUncheckedCreateWithoutTranscriptsInput>
    connectOrCreate?: MediaAssetCreateOrConnectWithoutTranscriptsInput
    upsert?: MediaAssetUpsertWithoutTranscriptsInput
    connect?: MediaAssetWhereUniqueInput
    update?: XOR<XOR<MediaAssetUpdateToOneWithWhereWithoutTranscriptsInput, MediaAssetUpdateWithoutTranscriptsInput>, MediaAssetUncheckedUpdateWithoutTranscriptsInput>
  }

  export type AIAnalysisUpdateManyWithoutTranscriptNestedInput = {
    create?: XOR<AIAnalysisCreateWithoutTranscriptInput, AIAnalysisUncheckedCreateWithoutTranscriptInput> | AIAnalysisCreateWithoutTranscriptInput[] | AIAnalysisUncheckedCreateWithoutTranscriptInput[]
    connectOrCreate?: AIAnalysisCreateOrConnectWithoutTranscriptInput | AIAnalysisCreateOrConnectWithoutTranscriptInput[]
    upsert?: AIAnalysisUpsertWithWhereUniqueWithoutTranscriptInput | AIAnalysisUpsertWithWhereUniqueWithoutTranscriptInput[]
    createMany?: AIAnalysisCreateManyTranscriptInputEnvelope
    set?: AIAnalysisWhereUniqueInput | AIAnalysisWhereUniqueInput[]
    disconnect?: AIAnalysisWhereUniqueInput | AIAnalysisWhereUniqueInput[]
    delete?: AIAnalysisWhereUniqueInput | AIAnalysisWhereUniqueInput[]
    connect?: AIAnalysisWhereUniqueInput | AIAnalysisWhereUniqueInput[]
    update?: AIAnalysisUpdateWithWhereUniqueWithoutTranscriptInput | AIAnalysisUpdateWithWhereUniqueWithoutTranscriptInput[]
    updateMany?: AIAnalysisUpdateManyWithWhereWithoutTranscriptInput | AIAnalysisUpdateManyWithWhereWithoutTranscriptInput[]
    deleteMany?: AIAnalysisScalarWhereInput | AIAnalysisScalarWhereInput[]
  }

  export type AIAnalysisUncheckedUpdateManyWithoutTranscriptNestedInput = {
    create?: XOR<AIAnalysisCreateWithoutTranscriptInput, AIAnalysisUncheckedCreateWithoutTranscriptInput> | AIAnalysisCreateWithoutTranscriptInput[] | AIAnalysisUncheckedCreateWithoutTranscriptInput[]
    connectOrCreate?: AIAnalysisCreateOrConnectWithoutTranscriptInput | AIAnalysisCreateOrConnectWithoutTranscriptInput[]
    upsert?: AIAnalysisUpsertWithWhereUniqueWithoutTranscriptInput | AIAnalysisUpsertWithWhereUniqueWithoutTranscriptInput[]
    createMany?: AIAnalysisCreateManyTranscriptInputEnvelope
    set?: AIAnalysisWhereUniqueInput | AIAnalysisWhereUniqueInput[]
    disconnect?: AIAnalysisWhereUniqueInput | AIAnalysisWhereUniqueInput[]
    delete?: AIAnalysisWhereUniqueInput | AIAnalysisWhereUniqueInput[]
    connect?: AIAnalysisWhereUniqueInput | AIAnalysisWhereUniqueInput[]
    update?: AIAnalysisUpdateWithWhereUniqueWithoutTranscriptInput | AIAnalysisUpdateWithWhereUniqueWithoutTranscriptInput[]
    updateMany?: AIAnalysisUpdateManyWithWhereWithoutTranscriptInput | AIAnalysisUpdateManyWithWhereWithoutTranscriptInput[]
    deleteMany?: AIAnalysisScalarWhereInput | AIAnalysisScalarWhereInput[]
  }

  export type TranscriptCreateNestedOneWithoutAnalysesInput = {
    create?: XOR<TranscriptCreateWithoutAnalysesInput, TranscriptUncheckedCreateWithoutAnalysesInput>
    connectOrCreate?: TranscriptCreateOrConnectWithoutAnalysesInput
    connect?: TranscriptWhereUniqueInput
  }

  export type MediaAssetCreateNestedOneWithoutAnalysesInput = {
    create?: XOR<MediaAssetCreateWithoutAnalysesInput, MediaAssetUncheckedCreateWithoutAnalysesInput>
    connectOrCreate?: MediaAssetCreateOrConnectWithoutAnalysesInput
    connect?: MediaAssetWhereUniqueInput
  }

  export type AIRunCreateNestedOneWithoutAnalysesInput = {
    create?: XOR<AIRunCreateWithoutAnalysesInput, AIRunUncheckedCreateWithoutAnalysesInput>
    connectOrCreate?: AIRunCreateOrConnectWithoutAnalysesInput
    connect?: AIRunWhereUniqueInput
  }

  export type EnumAnalysisTypeFieldUpdateOperationsInput = {
    set?: $Enums.AnalysisType
  }

  export type TranscriptUpdateOneWithoutAnalysesNestedInput = {
    create?: XOR<TranscriptCreateWithoutAnalysesInput, TranscriptUncheckedCreateWithoutAnalysesInput>
    connectOrCreate?: TranscriptCreateOrConnectWithoutAnalysesInput
    upsert?: TranscriptUpsertWithoutAnalysesInput
    disconnect?: TranscriptWhereInput | boolean
    delete?: TranscriptWhereInput | boolean
    connect?: TranscriptWhereUniqueInput
    update?: XOR<XOR<TranscriptUpdateToOneWithWhereWithoutAnalysesInput, TranscriptUpdateWithoutAnalysesInput>, TranscriptUncheckedUpdateWithoutAnalysesInput>
  }

  export type MediaAssetUpdateOneWithoutAnalysesNestedInput = {
    create?: XOR<MediaAssetCreateWithoutAnalysesInput, MediaAssetUncheckedCreateWithoutAnalysesInput>
    connectOrCreate?: MediaAssetCreateOrConnectWithoutAnalysesInput
    upsert?: MediaAssetUpsertWithoutAnalysesInput
    disconnect?: MediaAssetWhereInput | boolean
    delete?: MediaAssetWhereInput | boolean
    connect?: MediaAssetWhereUniqueInput
    update?: XOR<XOR<MediaAssetUpdateToOneWithWhereWithoutAnalysesInput, MediaAssetUpdateWithoutAnalysesInput>, MediaAssetUncheckedUpdateWithoutAnalysesInput>
  }

  export type AIRunUpdateOneWithoutAnalysesNestedInput = {
    create?: XOR<AIRunCreateWithoutAnalysesInput, AIRunUncheckedCreateWithoutAnalysesInput>
    connectOrCreate?: AIRunCreateOrConnectWithoutAnalysesInput
    upsert?: AIRunUpsertWithoutAnalysesInput
    disconnect?: AIRunWhereInput | boolean
    delete?: AIRunWhereInput | boolean
    connect?: AIRunWhereUniqueInput
    update?: XOR<XOR<AIRunUpdateToOneWithWhereWithoutAnalysesInput, AIRunUpdateWithoutAnalysesInput>, AIRunUncheckedUpdateWithoutAnalysesInput>
  }

  export type VoteHistoryCreateNestedManyWithoutVoterInput = {
    create?: XOR<VoteHistoryCreateWithoutVoterInput, VoteHistoryUncheckedCreateWithoutVoterInput> | VoteHistoryCreateWithoutVoterInput[] | VoteHistoryUncheckedCreateWithoutVoterInput[]
    connectOrCreate?: VoteHistoryCreateOrConnectWithoutVoterInput | VoteHistoryCreateOrConnectWithoutVoterInput[]
    createMany?: VoteHistoryCreateManyVoterInputEnvelope
    connect?: VoteHistoryWhereUniqueInput | VoteHistoryWhereUniqueInput[]
  }

  export type SegmentMemberCreateNestedManyWithoutVoterInput = {
    create?: XOR<SegmentMemberCreateWithoutVoterInput, SegmentMemberUncheckedCreateWithoutVoterInput> | SegmentMemberCreateWithoutVoterInput[] | SegmentMemberUncheckedCreateWithoutVoterInput[]
    connectOrCreate?: SegmentMemberCreateOrConnectWithoutVoterInput | SegmentMemberCreateOrConnectWithoutVoterInput[]
    createMany?: SegmentMemberCreateManyVoterInputEnvelope
    connect?: SegmentMemberWhereUniqueInput | SegmentMemberWhereUniqueInput[]
  }

  export type VoteHistoryUncheckedCreateNestedManyWithoutVoterInput = {
    create?: XOR<VoteHistoryCreateWithoutVoterInput, VoteHistoryUncheckedCreateWithoutVoterInput> | VoteHistoryCreateWithoutVoterInput[] | VoteHistoryUncheckedCreateWithoutVoterInput[]
    connectOrCreate?: VoteHistoryCreateOrConnectWithoutVoterInput | VoteHistoryCreateOrConnectWithoutVoterInput[]
    createMany?: VoteHistoryCreateManyVoterInputEnvelope
    connect?: VoteHistoryWhereUniqueInput | VoteHistoryWhereUniqueInput[]
  }

  export type SegmentMemberUncheckedCreateNestedManyWithoutVoterInput = {
    create?: XOR<SegmentMemberCreateWithoutVoterInput, SegmentMemberUncheckedCreateWithoutVoterInput> | SegmentMemberCreateWithoutVoterInput[] | SegmentMemberUncheckedCreateWithoutVoterInput[]
    connectOrCreate?: SegmentMemberCreateOrConnectWithoutVoterInput | SegmentMemberCreateOrConnectWithoutVoterInput[]
    createMany?: SegmentMemberCreateManyVoterInputEnvelope
    connect?: SegmentMemberWhereUniqueInput | SegmentMemberWhereUniqueInput[]
  }

  export type VoteHistoryUpdateManyWithoutVoterNestedInput = {
    create?: XOR<VoteHistoryCreateWithoutVoterInput, VoteHistoryUncheckedCreateWithoutVoterInput> | VoteHistoryCreateWithoutVoterInput[] | VoteHistoryUncheckedCreateWithoutVoterInput[]
    connectOrCreate?: VoteHistoryCreateOrConnectWithoutVoterInput | VoteHistoryCreateOrConnectWithoutVoterInput[]
    upsert?: VoteHistoryUpsertWithWhereUniqueWithoutVoterInput | VoteHistoryUpsertWithWhereUniqueWithoutVoterInput[]
    createMany?: VoteHistoryCreateManyVoterInputEnvelope
    set?: VoteHistoryWhereUniqueInput | VoteHistoryWhereUniqueInput[]
    disconnect?: VoteHistoryWhereUniqueInput | VoteHistoryWhereUniqueInput[]
    delete?: VoteHistoryWhereUniqueInput | VoteHistoryWhereUniqueInput[]
    connect?: VoteHistoryWhereUniqueInput | VoteHistoryWhereUniqueInput[]
    update?: VoteHistoryUpdateWithWhereUniqueWithoutVoterInput | VoteHistoryUpdateWithWhereUniqueWithoutVoterInput[]
    updateMany?: VoteHistoryUpdateManyWithWhereWithoutVoterInput | VoteHistoryUpdateManyWithWhereWithoutVoterInput[]
    deleteMany?: VoteHistoryScalarWhereInput | VoteHistoryScalarWhereInput[]
  }

  export type SegmentMemberUpdateManyWithoutVoterNestedInput = {
    create?: XOR<SegmentMemberCreateWithoutVoterInput, SegmentMemberUncheckedCreateWithoutVoterInput> | SegmentMemberCreateWithoutVoterInput[] | SegmentMemberUncheckedCreateWithoutVoterInput[]
    connectOrCreate?: SegmentMemberCreateOrConnectWithoutVoterInput | SegmentMemberCreateOrConnectWithoutVoterInput[]
    upsert?: SegmentMemberUpsertWithWhereUniqueWithoutVoterInput | SegmentMemberUpsertWithWhereUniqueWithoutVoterInput[]
    createMany?: SegmentMemberCreateManyVoterInputEnvelope
    set?: SegmentMemberWhereUniqueInput | SegmentMemberWhereUniqueInput[]
    disconnect?: SegmentMemberWhereUniqueInput | SegmentMemberWhereUniqueInput[]
    delete?: SegmentMemberWhereUniqueInput | SegmentMemberWhereUniqueInput[]
    connect?: SegmentMemberWhereUniqueInput | SegmentMemberWhereUniqueInput[]
    update?: SegmentMemberUpdateWithWhereUniqueWithoutVoterInput | SegmentMemberUpdateWithWhereUniqueWithoutVoterInput[]
    updateMany?: SegmentMemberUpdateManyWithWhereWithoutVoterInput | SegmentMemberUpdateManyWithWhereWithoutVoterInput[]
    deleteMany?: SegmentMemberScalarWhereInput | SegmentMemberScalarWhereInput[]
  }

  export type VoteHistoryUncheckedUpdateManyWithoutVoterNestedInput = {
    create?: XOR<VoteHistoryCreateWithoutVoterInput, VoteHistoryUncheckedCreateWithoutVoterInput> | VoteHistoryCreateWithoutVoterInput[] | VoteHistoryUncheckedCreateWithoutVoterInput[]
    connectOrCreate?: VoteHistoryCreateOrConnectWithoutVoterInput | VoteHistoryCreateOrConnectWithoutVoterInput[]
    upsert?: VoteHistoryUpsertWithWhereUniqueWithoutVoterInput | VoteHistoryUpsertWithWhereUniqueWithoutVoterInput[]
    createMany?: VoteHistoryCreateManyVoterInputEnvelope
    set?: VoteHistoryWhereUniqueInput | VoteHistoryWhereUniqueInput[]
    disconnect?: VoteHistoryWhereUniqueInput | VoteHistoryWhereUniqueInput[]
    delete?: VoteHistoryWhereUniqueInput | VoteHistoryWhereUniqueInput[]
    connect?: VoteHistoryWhereUniqueInput | VoteHistoryWhereUniqueInput[]
    update?: VoteHistoryUpdateWithWhereUniqueWithoutVoterInput | VoteHistoryUpdateWithWhereUniqueWithoutVoterInput[]
    updateMany?: VoteHistoryUpdateManyWithWhereWithoutVoterInput | VoteHistoryUpdateManyWithWhereWithoutVoterInput[]
    deleteMany?: VoteHistoryScalarWhereInput | VoteHistoryScalarWhereInput[]
  }

  export type SegmentMemberUncheckedUpdateManyWithoutVoterNestedInput = {
    create?: XOR<SegmentMemberCreateWithoutVoterInput, SegmentMemberUncheckedCreateWithoutVoterInput> | SegmentMemberCreateWithoutVoterInput[] | SegmentMemberUncheckedCreateWithoutVoterInput[]
    connectOrCreate?: SegmentMemberCreateOrConnectWithoutVoterInput | SegmentMemberCreateOrConnectWithoutVoterInput[]
    upsert?: SegmentMemberUpsertWithWhereUniqueWithoutVoterInput | SegmentMemberUpsertWithWhereUniqueWithoutVoterInput[]
    createMany?: SegmentMemberCreateManyVoterInputEnvelope
    set?: SegmentMemberWhereUniqueInput | SegmentMemberWhereUniqueInput[]
    disconnect?: SegmentMemberWhereUniqueInput | SegmentMemberWhereUniqueInput[]
    delete?: SegmentMemberWhereUniqueInput | SegmentMemberWhereUniqueInput[]
    connect?: SegmentMemberWhereUniqueInput | SegmentMemberWhereUniqueInput[]
    update?: SegmentMemberUpdateWithWhereUniqueWithoutVoterInput | SegmentMemberUpdateWithWhereUniqueWithoutVoterInput[]
    updateMany?: SegmentMemberUpdateManyWithWhereWithoutVoterInput | SegmentMemberUpdateManyWithWhereWithoutVoterInput[]
    deleteMany?: SegmentMemberScalarWhereInput | SegmentMemberScalarWhereInput[]
  }

  export type VoterRegistrationCreateNestedOneWithoutVoteHistoryInput = {
    create?: XOR<VoterRegistrationCreateWithoutVoteHistoryInput, VoterRegistrationUncheckedCreateWithoutVoteHistoryInput>
    connectOrCreate?: VoterRegistrationCreateOrConnectWithoutVoteHistoryInput
    connect?: VoterRegistrationWhereUniqueInput
  }

  export type VoterRegistrationUpdateOneRequiredWithoutVoteHistoryNestedInput = {
    create?: XOR<VoterRegistrationCreateWithoutVoteHistoryInput, VoterRegistrationUncheckedCreateWithoutVoteHistoryInput>
    connectOrCreate?: VoterRegistrationCreateOrConnectWithoutVoteHistoryInput
    upsert?: VoterRegistrationUpsertWithoutVoteHistoryInput
    connect?: VoterRegistrationWhereUniqueInput
    update?: XOR<XOR<VoterRegistrationUpdateToOneWithWhereWithoutVoteHistoryInput, VoterRegistrationUpdateWithoutVoteHistoryInput>, VoterRegistrationUncheckedUpdateWithoutVoteHistoryInput>
  }

  export type SegmentMemberCreateNestedManyWithoutSegmentInput = {
    create?: XOR<SegmentMemberCreateWithoutSegmentInput, SegmentMemberUncheckedCreateWithoutSegmentInput> | SegmentMemberCreateWithoutSegmentInput[] | SegmentMemberUncheckedCreateWithoutSegmentInput[]
    connectOrCreate?: SegmentMemberCreateOrConnectWithoutSegmentInput | SegmentMemberCreateOrConnectWithoutSegmentInput[]
    createMany?: SegmentMemberCreateManySegmentInputEnvelope
    connect?: SegmentMemberWhereUniqueInput | SegmentMemberWhereUniqueInput[]
  }

  export type SegmentMemberUncheckedCreateNestedManyWithoutSegmentInput = {
    create?: XOR<SegmentMemberCreateWithoutSegmentInput, SegmentMemberUncheckedCreateWithoutSegmentInput> | SegmentMemberCreateWithoutSegmentInput[] | SegmentMemberUncheckedCreateWithoutSegmentInput[]
    connectOrCreate?: SegmentMemberCreateOrConnectWithoutSegmentInput | SegmentMemberCreateOrConnectWithoutSegmentInput[]
    createMany?: SegmentMemberCreateManySegmentInputEnvelope
    connect?: SegmentMemberWhereUniqueInput | SegmentMemberWhereUniqueInput[]
  }

  export type SegmentMemberUpdateManyWithoutSegmentNestedInput = {
    create?: XOR<SegmentMemberCreateWithoutSegmentInput, SegmentMemberUncheckedCreateWithoutSegmentInput> | SegmentMemberCreateWithoutSegmentInput[] | SegmentMemberUncheckedCreateWithoutSegmentInput[]
    connectOrCreate?: SegmentMemberCreateOrConnectWithoutSegmentInput | SegmentMemberCreateOrConnectWithoutSegmentInput[]
    upsert?: SegmentMemberUpsertWithWhereUniqueWithoutSegmentInput | SegmentMemberUpsertWithWhereUniqueWithoutSegmentInput[]
    createMany?: SegmentMemberCreateManySegmentInputEnvelope
    set?: SegmentMemberWhereUniqueInput | SegmentMemberWhereUniqueInput[]
    disconnect?: SegmentMemberWhereUniqueInput | SegmentMemberWhereUniqueInput[]
    delete?: SegmentMemberWhereUniqueInput | SegmentMemberWhereUniqueInput[]
    connect?: SegmentMemberWhereUniqueInput | SegmentMemberWhereUniqueInput[]
    update?: SegmentMemberUpdateWithWhereUniqueWithoutSegmentInput | SegmentMemberUpdateWithWhereUniqueWithoutSegmentInput[]
    updateMany?: SegmentMemberUpdateManyWithWhereWithoutSegmentInput | SegmentMemberUpdateManyWithWhereWithoutSegmentInput[]
    deleteMany?: SegmentMemberScalarWhereInput | SegmentMemberScalarWhereInput[]
  }

  export type SegmentMemberUncheckedUpdateManyWithoutSegmentNestedInput = {
    create?: XOR<SegmentMemberCreateWithoutSegmentInput, SegmentMemberUncheckedCreateWithoutSegmentInput> | SegmentMemberCreateWithoutSegmentInput[] | SegmentMemberUncheckedCreateWithoutSegmentInput[]
    connectOrCreate?: SegmentMemberCreateOrConnectWithoutSegmentInput | SegmentMemberCreateOrConnectWithoutSegmentInput[]
    upsert?: SegmentMemberUpsertWithWhereUniqueWithoutSegmentInput | SegmentMemberUpsertWithWhereUniqueWithoutSegmentInput[]
    createMany?: SegmentMemberCreateManySegmentInputEnvelope
    set?: SegmentMemberWhereUniqueInput | SegmentMemberWhereUniqueInput[]
    disconnect?: SegmentMemberWhereUniqueInput | SegmentMemberWhereUniqueInput[]
    delete?: SegmentMemberWhereUniqueInput | SegmentMemberWhereUniqueInput[]
    connect?: SegmentMemberWhereUniqueInput | SegmentMemberWhereUniqueInput[]
    update?: SegmentMemberUpdateWithWhereUniqueWithoutSegmentInput | SegmentMemberUpdateWithWhereUniqueWithoutSegmentInput[]
    updateMany?: SegmentMemberUpdateManyWithWhereWithoutSegmentInput | SegmentMemberUpdateManyWithWhereWithoutSegmentInput[]
    deleteMany?: SegmentMemberScalarWhereInput | SegmentMemberScalarWhereInput[]
  }

  export type SegmentCreateNestedOneWithoutMembersInput = {
    create?: XOR<SegmentCreateWithoutMembersInput, SegmentUncheckedCreateWithoutMembersInput>
    connectOrCreate?: SegmentCreateOrConnectWithoutMembersInput
    connect?: SegmentWhereUniqueInput
  }

  export type VoterRegistrationCreateNestedOneWithoutSegmentMembershipsInput = {
    create?: XOR<VoterRegistrationCreateWithoutSegmentMembershipsInput, VoterRegistrationUncheckedCreateWithoutSegmentMembershipsInput>
    connectOrCreate?: VoterRegistrationCreateOrConnectWithoutSegmentMembershipsInput
    connect?: VoterRegistrationWhereUniqueInput
  }

  export type SegmentUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<SegmentCreateWithoutMembersInput, SegmentUncheckedCreateWithoutMembersInput>
    connectOrCreate?: SegmentCreateOrConnectWithoutMembersInput
    upsert?: SegmentUpsertWithoutMembersInput
    connect?: SegmentWhereUniqueInput
    update?: XOR<XOR<SegmentUpdateToOneWithWhereWithoutMembersInput, SegmentUpdateWithoutMembersInput>, SegmentUncheckedUpdateWithoutMembersInput>
  }

  export type VoterRegistrationUpdateOneRequiredWithoutSegmentMembershipsNestedInput = {
    create?: XOR<VoterRegistrationCreateWithoutSegmentMembershipsInput, VoterRegistrationUncheckedCreateWithoutSegmentMembershipsInput>
    connectOrCreate?: VoterRegistrationCreateOrConnectWithoutSegmentMembershipsInput
    upsert?: VoterRegistrationUpsertWithoutSegmentMembershipsInput
    connect?: VoterRegistrationWhereUniqueInput
    update?: XOR<XOR<VoterRegistrationUpdateToOneWithWhereWithoutSegmentMembershipsInput, VoterRegistrationUpdateWithoutSegmentMembershipsInput>, VoterRegistrationUncheckedUpdateWithoutSegmentMembershipsInput>
  }

  export type AuditLogCreateNestedManyWithoutImportJobInput = {
    create?: XOR<AuditLogCreateWithoutImportJobInput, AuditLogUncheckedCreateWithoutImportJobInput> | AuditLogCreateWithoutImportJobInput[] | AuditLogUncheckedCreateWithoutImportJobInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutImportJobInput | AuditLogCreateOrConnectWithoutImportJobInput[]
    createMany?: AuditLogCreateManyImportJobInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutImportJobInput = {
    create?: XOR<AuditLogCreateWithoutImportJobInput, AuditLogUncheckedCreateWithoutImportJobInput> | AuditLogCreateWithoutImportJobInput[] | AuditLogUncheckedCreateWithoutImportJobInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutImportJobInput | AuditLogCreateOrConnectWithoutImportJobInput[]
    createMany?: AuditLogCreateManyImportJobInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type EnumImportJobKindFieldUpdateOperationsInput = {
    set?: $Enums.ImportJobKind
  }

  export type EnumImportJobStatusFieldUpdateOperationsInput = {
    set?: $Enums.ImportJobStatus
  }

  export type AuditLogUpdateManyWithoutImportJobNestedInput = {
    create?: XOR<AuditLogCreateWithoutImportJobInput, AuditLogUncheckedCreateWithoutImportJobInput> | AuditLogCreateWithoutImportJobInput[] | AuditLogUncheckedCreateWithoutImportJobInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutImportJobInput | AuditLogCreateOrConnectWithoutImportJobInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutImportJobInput | AuditLogUpsertWithWhereUniqueWithoutImportJobInput[]
    createMany?: AuditLogCreateManyImportJobInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutImportJobInput | AuditLogUpdateWithWhereUniqueWithoutImportJobInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutImportJobInput | AuditLogUpdateManyWithWhereWithoutImportJobInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutImportJobNestedInput = {
    create?: XOR<AuditLogCreateWithoutImportJobInput, AuditLogUncheckedCreateWithoutImportJobInput> | AuditLogCreateWithoutImportJobInput[] | AuditLogUncheckedCreateWithoutImportJobInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutImportJobInput | AuditLogCreateOrConnectWithoutImportJobInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutImportJobInput | AuditLogUpsertWithWhereUniqueWithoutImportJobInput[]
    createMany?: AuditLogCreateManyImportJobInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutImportJobInput | AuditLogUpdateWithWhereUniqueWithoutImportJobInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutImportJobInput | AuditLogUpdateManyWithWhereWithoutImportJobInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type ImportJobCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<ImportJobCreateWithoutAuditLogsInput, ImportJobUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: ImportJobCreateOrConnectWithoutAuditLogsInput
    connect?: ImportJobWhereUniqueInput
  }

  export type ImportJobUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<ImportJobCreateWithoutAuditLogsInput, ImportJobUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: ImportJobCreateOrConnectWithoutAuditLogsInput
    upsert?: ImportJobUpsertWithoutAuditLogsInput
    disconnect?: ImportJobWhereInput | boolean
    delete?: ImportJobWhereInput | boolean
    connect?: ImportJobWhereUniqueInput
    update?: XOR<XOR<ImportJobUpdateToOneWithWhereWithoutAuditLogsInput, ImportJobUpdateWithoutAuditLogsInput>, ImportJobUncheckedUpdateWithoutAuditLogsInput>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumAssetTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetType | EnumAssetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AssetType[] | ListEnumAssetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssetType[] | ListEnumAssetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAssetTypeFilter<$PrismaModel> | $Enums.AssetType
  }

  export type NestedEnumAssetTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetType | EnumAssetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AssetType[] | ListEnumAssetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssetType[] | ListEnumAssetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAssetTypeWithAggregatesFilter<$PrismaModel> | $Enums.AssetType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAssetTypeFilter<$PrismaModel>
    _max?: NestedEnumAssetTypeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumCrosswalkTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CrosswalkType | EnumCrosswalkTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CrosswalkType[] | ListEnumCrosswalkTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CrosswalkType[] | ListEnumCrosswalkTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCrosswalkTypeFilter<$PrismaModel> | $Enums.CrosswalkType
  }

  export type NestedEnumCrosswalkTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CrosswalkType | EnumCrosswalkTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CrosswalkType[] | ListEnumCrosswalkTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CrosswalkType[] | ListEnumCrosswalkTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCrosswalkTypeWithAggregatesFilter<$PrismaModel> | $Enums.CrosswalkType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCrosswalkTypeFilter<$PrismaModel>
    _max?: NestedEnumCrosswalkTypeFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumAIRunStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AIRunStatus | EnumAIRunStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AIRunStatus[] | ListEnumAIRunStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AIRunStatus[] | ListEnumAIRunStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAIRunStatusFilter<$PrismaModel> | $Enums.AIRunStatus
  }

  export type NestedEnumAIRunStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AIRunStatus | EnumAIRunStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AIRunStatus[] | ListEnumAIRunStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AIRunStatus[] | ListEnumAIRunStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAIRunStatusWithAggregatesFilter<$PrismaModel> | $Enums.AIRunStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAIRunStatusFilter<$PrismaModel>
    _max?: NestedEnumAIRunStatusFilter<$PrismaModel>
  }

  export type NestedEnumAIRunInputKindFilter<$PrismaModel = never> = {
    equals?: $Enums.AIRunInputKind | EnumAIRunInputKindFieldRefInput<$PrismaModel>
    in?: $Enums.AIRunInputKind[] | ListEnumAIRunInputKindFieldRefInput<$PrismaModel>
    notIn?: $Enums.AIRunInputKind[] | ListEnumAIRunInputKindFieldRefInput<$PrismaModel>
    not?: NestedEnumAIRunInputKindFilter<$PrismaModel> | $Enums.AIRunInputKind
  }

  export type NestedEnumAIRunInputKindWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AIRunInputKind | EnumAIRunInputKindFieldRefInput<$PrismaModel>
    in?: $Enums.AIRunInputKind[] | ListEnumAIRunInputKindFieldRefInput<$PrismaModel>
    notIn?: $Enums.AIRunInputKind[] | ListEnumAIRunInputKindFieldRefInput<$PrismaModel>
    not?: NestedEnumAIRunInputKindWithAggregatesFilter<$PrismaModel> | $Enums.AIRunInputKind
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAIRunInputKindFilter<$PrismaModel>
    _max?: NestedEnumAIRunInputKindFilter<$PrismaModel>
  }

  export type NestedEnumAIOutputTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AIOutputType | EnumAIOutputTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AIOutputType[] | ListEnumAIOutputTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AIOutputType[] | ListEnumAIOutputTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAIOutputTypeFilter<$PrismaModel> | $Enums.AIOutputType
  }

  export type NestedEnumPublishStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PublishStatus | EnumPublishStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PublishStatus[] | ListEnumPublishStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PublishStatus[] | ListEnumPublishStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPublishStatusFilter<$PrismaModel> | $Enums.PublishStatus
  }

  export type NestedEnumAIOutputTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AIOutputType | EnumAIOutputTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AIOutputType[] | ListEnumAIOutputTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AIOutputType[] | ListEnumAIOutputTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAIOutputTypeWithAggregatesFilter<$PrismaModel> | $Enums.AIOutputType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAIOutputTypeFilter<$PrismaModel>
    _max?: NestedEnumAIOutputTypeFilter<$PrismaModel>
  }

  export type NestedEnumPublishStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PublishStatus | EnumPublishStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PublishStatus[] | ListEnumPublishStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PublishStatus[] | ListEnumPublishStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPublishStatusWithAggregatesFilter<$PrismaModel> | $Enums.PublishStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPublishStatusFilter<$PrismaModel>
    _max?: NestedEnumPublishStatusFilter<$PrismaModel>
  }

  export type NestedEnumAIScopeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AIScopeType | EnumAIScopeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AIScopeType[] | ListEnumAIScopeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AIScopeType[] | ListEnumAIScopeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAIScopeTypeFilter<$PrismaModel> | $Enums.AIScopeType
  }

  export type NestedEnumAIScopeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AIScopeType | EnumAIScopeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AIScopeType[] | ListEnumAIScopeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AIScopeType[] | ListEnumAIScopeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAIScopeTypeWithAggregatesFilter<$PrismaModel> | $Enums.AIScopeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAIScopeTypeFilter<$PrismaModel>
    _max?: NestedEnumAIScopeTypeFilter<$PrismaModel>
  }

  export type NestedEnumSurveyFormStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SurveyFormStatus | EnumSurveyFormStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SurveyFormStatus[] | ListEnumSurveyFormStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SurveyFormStatus[] | ListEnumSurveyFormStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSurveyFormStatusFilter<$PrismaModel> | $Enums.SurveyFormStatus
  }

  export type NestedEnumSurveyFormStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SurveyFormStatus | EnumSurveyFormStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SurveyFormStatus[] | ListEnumSurveyFormStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SurveyFormStatus[] | ListEnumSurveyFormStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSurveyFormStatusWithAggregatesFilter<$PrismaModel> | $Enums.SurveyFormStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSurveyFormStatusFilter<$PrismaModel>
    _max?: NestedEnumSurveyFormStatusFilter<$PrismaModel>
  }

  export type NestedEnumSurveyQuestionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SurveyQuestionType | EnumSurveyQuestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SurveyQuestionType[] | ListEnumSurveyQuestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SurveyQuestionType[] | ListEnumSurveyQuestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSurveyQuestionTypeFilter<$PrismaModel> | $Enums.SurveyQuestionType
  }

  export type NestedEnumSurveyQuestionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SurveyQuestionType | EnumSurveyQuestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SurveyQuestionType[] | ListEnumSurveyQuestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SurveyQuestionType[] | ListEnumSurveyQuestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSurveyQuestionTypeWithAggregatesFilter<$PrismaModel> | $Enums.SurveyQuestionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSurveyQuestionTypeFilter<$PrismaModel>
    _max?: NestedEnumSurveyQuestionTypeFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumAnalysisTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AnalysisType | EnumAnalysisTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AnalysisType[] | ListEnumAnalysisTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AnalysisType[] | ListEnumAnalysisTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAnalysisTypeFilter<$PrismaModel> | $Enums.AnalysisType
  }

  export type NestedEnumAnalysisTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AnalysisType | EnumAnalysisTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AnalysisType[] | ListEnumAnalysisTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AnalysisType[] | ListEnumAnalysisTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAnalysisTypeWithAggregatesFilter<$PrismaModel> | $Enums.AnalysisType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAnalysisTypeFilter<$PrismaModel>
    _max?: NestedEnumAnalysisTypeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumImportJobKindFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportJobKind | EnumImportJobKindFieldRefInput<$PrismaModel>
    in?: $Enums.ImportJobKind[] | ListEnumImportJobKindFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImportJobKind[] | ListEnumImportJobKindFieldRefInput<$PrismaModel>
    not?: NestedEnumImportJobKindFilter<$PrismaModel> | $Enums.ImportJobKind
  }

  export type NestedEnumImportJobStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportJobStatus | EnumImportJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ImportJobStatus[] | ListEnumImportJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImportJobStatus[] | ListEnumImportJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumImportJobStatusFilter<$PrismaModel> | $Enums.ImportJobStatus
  }

  export type NestedEnumImportJobKindWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportJobKind | EnumImportJobKindFieldRefInput<$PrismaModel>
    in?: $Enums.ImportJobKind[] | ListEnumImportJobKindFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImportJobKind[] | ListEnumImportJobKindFieldRefInput<$PrismaModel>
    not?: NestedEnumImportJobKindWithAggregatesFilter<$PrismaModel> | $Enums.ImportJobKind
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumImportJobKindFilter<$PrismaModel>
    _max?: NestedEnumImportJobKindFilter<$PrismaModel>
  }

  export type NestedEnumImportJobStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportJobStatus | EnumImportJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ImportJobStatus[] | ListEnumImportJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImportJobStatus[] | ListEnumImportJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumImportJobStatusWithAggregatesFilter<$PrismaModel> | $Enums.ImportJobStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumImportJobStatusFilter<$PrismaModel>
    _max?: NestedEnumImportJobStatusFilter<$PrismaModel>
  }

  export type BlueprintSectionCreateWithoutCountyInput = {
    id?: string
    slug: string
    title: string
    bodyMd: string
    sortOrder?: number | null
    isPinned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    issue?: IssueCreateNestedOneWithoutBlueprintSectionsInput
    sourceLinks?: SourceDocumentLinkCreateNestedManyWithoutBlueprintSectionInput
  }

  export type BlueprintSectionUncheckedCreateWithoutCountyInput = {
    id?: string
    slug: string
    title: string
    bodyMd: string
    issueId?: string | null
    sortOrder?: number | null
    isPinned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceLinks?: SourceDocumentLinkUncheckedCreateNestedManyWithoutBlueprintSectionInput
  }

  export type BlueprintSectionCreateOrConnectWithoutCountyInput = {
    where: BlueprintSectionWhereUniqueInput
    create: XOR<BlueprintSectionCreateWithoutCountyInput, BlueprintSectionUncheckedCreateWithoutCountyInput>
  }

  export type BlueprintSectionCreateManyCountyInputEnvelope = {
    data: BlueprintSectionCreateManyCountyInput | BlueprintSectionCreateManyCountyInput[]
    skipDuplicates?: boolean
  }

  export type QuoteCreateWithoutCountyInput = {
    id?: string
    text: string
    attributionLabel?: string | null
    sourceNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    issue?: IssueCreateNestedOneWithoutQuotesInput
    sourceLinks?: SourceDocumentLinkCreateNestedManyWithoutQuoteInput
  }

  export type QuoteUncheckedCreateWithoutCountyInput = {
    id?: string
    text: string
    attributionLabel?: string | null
    issueId?: string | null
    sourceNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceLinks?: SourceDocumentLinkUncheckedCreateNestedManyWithoutQuoteInput
  }

  export type QuoteCreateOrConnectWithoutCountyInput = {
    where: QuoteWhereUniqueInput
    create: XOR<QuoteCreateWithoutCountyInput, QuoteUncheckedCreateWithoutCountyInput>
  }

  export type QuoteCreateManyCountyInputEnvelope = {
    data: QuoteCreateManyCountyInput | QuoteCreateManyCountyInput[]
    skipDuplicates?: boolean
  }

  export type AssetCreateWithoutCountyInput = {
    id?: string
    assetType?: $Enums.AssetType
    title?: string | null
    caption?: string | null
    credit?: string | null
    license?: string | null
    url?: string | null
    storageKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    issue?: IssueCreateNestedOneWithoutAssetsInput
    sourceLinks?: SourceDocumentLinkCreateNestedManyWithoutAssetInput
  }

  export type AssetUncheckedCreateWithoutCountyInput = {
    id?: string
    assetType?: $Enums.AssetType
    title?: string | null
    caption?: string | null
    credit?: string | null
    license?: string | null
    url?: string | null
    storageKey?: string | null
    issueId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceLinks?: SourceDocumentLinkUncheckedCreateNestedManyWithoutAssetInput
  }

  export type AssetCreateOrConnectWithoutCountyInput = {
    where: AssetWhereUniqueInput
    create: XOR<AssetCreateWithoutCountyInput, AssetUncheckedCreateWithoutCountyInput>
  }

  export type AssetCreateManyCountyInputEnvelope = {
    data: AssetCreateManyCountyInput | AssetCreateManyCountyInput[]
    skipDuplicates?: boolean
  }

  export type CountyIssueCreateWithoutCountyInput = {
    id?: string
    featured?: boolean
    sortOrder?: number | null
    createdAt?: Date | string
    issue: IssueCreateNestedOneWithoutCountyIssuesInput
  }

  export type CountyIssueUncheckedCreateWithoutCountyInput = {
    id?: string
    issueId: string
    featured?: boolean
    sortOrder?: number | null
    createdAt?: Date | string
  }

  export type CountyIssueCreateOrConnectWithoutCountyInput = {
    where: CountyIssueWhereUniqueInput
    create: XOR<CountyIssueCreateWithoutCountyInput, CountyIssueUncheckedCreateWithoutCountyInput>
  }

  export type CountyIssueCreateManyCountyInputEnvelope = {
    data: CountyIssueCreateManyCountyInput | CountyIssueCreateManyCountyInput[]
    skipDuplicates?: boolean
  }

  export type CensusMetricCreateWithoutCountyInput = {
    id?: string
    metricKey: string
    metricLabel?: string | null
    value?: number | null
    valueText?: string | null
    asOfDate?: Date | string | null
    sourceNote?: string | null
    createdAt?: Date | string
    geoZip?: GeoZipCreateNestedOneWithoutCensusMetricsInput
  }

  export type CensusMetricUncheckedCreateWithoutCountyInput = {
    id?: string
    geoZipId?: string | null
    metricKey: string
    metricLabel?: string | null
    value?: number | null
    valueText?: string | null
    asOfDate?: Date | string | null
    sourceNote?: string | null
    createdAt?: Date | string
  }

  export type CensusMetricCreateOrConnectWithoutCountyInput = {
    where: CensusMetricWhereUniqueInput
    create: XOR<CensusMetricCreateWithoutCountyInput, CensusMetricUncheckedCreateWithoutCountyInput>
  }

  export type CensusMetricCreateManyCountyInputEnvelope = {
    data: CensusMetricCreateManyCountyInput | CensusMetricCreateManyCountyInput[]
    skipDuplicates?: boolean
  }

  export type BLSMetricCreateWithoutCountyInput = {
    id?: string
    seriesKey: string
    seriesLabel?: string | null
    value?: number | null
    asOfDate?: Date | string | null
    sourceNote?: string | null
    createdAt?: Date | string
  }

  export type BLSMetricUncheckedCreateWithoutCountyInput = {
    id?: string
    seriesKey: string
    seriesLabel?: string | null
    value?: number | null
    asOfDate?: Date | string | null
    sourceNote?: string | null
    createdAt?: Date | string
  }

  export type BLSMetricCreateOrConnectWithoutCountyInput = {
    where: BLSMetricWhereUniqueInput
    create: XOR<BLSMetricCreateWithoutCountyInput, BLSMetricUncheckedCreateWithoutCountyInput>
  }

  export type BLSMetricCreateManyCountyInputEnvelope = {
    data: BLSMetricCreateManyCountyInput | BLSMetricCreateManyCountyInput[]
    skipDuplicates?: boolean
  }

  export type CivicsOfficialCreateWithoutCountyInput = {
    id?: string
    name: string
    officeName: string
    party?: string | null
    phone?: string | null
    website?: string | null
    photoUrl?: string | null
    sourceNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    district?: GeoDistrictCreateNestedOneWithoutCivicsOfficialsInput
  }

  export type CivicsOfficialUncheckedCreateWithoutCountyInput = {
    id?: string
    name: string
    officeName: string
    party?: string | null
    phone?: string | null
    website?: string | null
    photoUrl?: string | null
    districtId?: string | null
    sourceNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CivicsOfficialCreateOrConnectWithoutCountyInput = {
    where: CivicsOfficialWhereUniqueInput
    create: XOR<CivicsOfficialCreateWithoutCountyInput, CivicsOfficialUncheckedCreateWithoutCountyInput>
  }

  export type CivicsOfficialCreateManyCountyInputEnvelope = {
    data: CivicsOfficialCreateManyCountyInput | CivicsOfficialCreateManyCountyInput[]
    skipDuplicates?: boolean
  }

  export type ElectionResultCreateWithoutCountyInput = {
    id?: string
    choiceLabel: string
    votes?: number | null
    voteShare?: number | null
    createdAt?: Date | string
    election: ElectionCreateNestedOneWithoutResultsInput
    geoZip?: GeoZipCreateNestedOneWithoutElectionResultsInput
    precinct?: GeoPrecinctCreateNestedOneWithoutElectionResultsInput
  }

  export type ElectionResultUncheckedCreateWithoutCountyInput = {
    id?: string
    electionId: string
    geoZipId?: string | null
    precinctId?: string | null
    choiceLabel: string
    votes?: number | null
    voteShare?: number | null
    createdAt?: Date | string
  }

  export type ElectionResultCreateOrConnectWithoutCountyInput = {
    where: ElectionResultWhereUniqueInput
    create: XOR<ElectionResultCreateWithoutCountyInput, ElectionResultUncheckedCreateWithoutCountyInput>
  }

  export type ElectionResultCreateManyCountyInputEnvelope = {
    data: ElectionResultCreateManyCountyInput | ElectionResultCreateManyCountyInput[]
    skipDuplicates?: boolean
  }

  export type SurveyFormCreateWithoutCountyInput = {
    id?: string
    title: string
    descriptionMd?: string | null
    slug: string
    status?: $Enums.SurveyFormStatus
    startAt?: Date | string | null
    endAt?: Date | string | null
    contextLabel?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: SurveyQuestionCreateNestedManyWithoutFormInput
    responses?: SurveyResponseCreateNestedManyWithoutFormInput
    sourceLinks?: SourceDocumentLinkCreateNestedManyWithoutSurveyFormInput
  }

  export type SurveyFormUncheckedCreateWithoutCountyInput = {
    id?: string
    title: string
    descriptionMd?: string | null
    slug: string
    status?: $Enums.SurveyFormStatus
    startAt?: Date | string | null
    endAt?: Date | string | null
    contextLabel?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: SurveyQuestionUncheckedCreateNestedManyWithoutFormInput
    responses?: SurveyResponseUncheckedCreateNestedManyWithoutFormInput
    sourceLinks?: SourceDocumentLinkUncheckedCreateNestedManyWithoutSurveyFormInput
  }

  export type SurveyFormCreateOrConnectWithoutCountyInput = {
    where: SurveyFormWhereUniqueInput
    create: XOR<SurveyFormCreateWithoutCountyInput, SurveyFormUncheckedCreateWithoutCountyInput>
  }

  export type SurveyFormCreateManyCountyInputEnvelope = {
    data: SurveyFormCreateManyCountyInput | SurveyFormCreateManyCountyInput[]
    skipDuplicates?: boolean
  }

  export type SurveyResponseCreateWithoutCountyInput = {
    id?: string
    sourceLabel?: string | null
    submittedAt?: Date | string
    ipHash?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    form: SurveyFormCreateNestedOneWithoutResponsesInput
    items?: SurveyResponseItemCreateNestedManyWithoutResponseInput
  }

  export type SurveyResponseUncheckedCreateWithoutCountyInput = {
    id?: string
    formId: string
    sourceLabel?: string | null
    submittedAt?: Date | string
    ipHash?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    items?: SurveyResponseItemUncheckedCreateNestedManyWithoutResponseInput
  }

  export type SurveyResponseCreateOrConnectWithoutCountyInput = {
    where: SurveyResponseWhereUniqueInput
    create: XOR<SurveyResponseCreateWithoutCountyInput, SurveyResponseUncheckedCreateWithoutCountyInput>
  }

  export type SurveyResponseCreateManyCountyInputEnvelope = {
    data: SurveyResponseCreateManyCountyInput | SurveyResponseCreateManyCountyInput[]
    skipDuplicates?: boolean
  }

  export type AIOutputScopeCreateWithoutCountyInput = {
    id?: string
    scopeType: $Enums.AIScopeType
    customKey?: string | null
    createdAt?: Date | string
    output: AIOutputCreateNestedOneWithoutScopesInput
    issue?: IssueCreateNestedOneWithoutAiOutputScopesInput
    geoZip?: GeoZipCreateNestedOneWithoutAiOutputScopesInput
    district?: GeoDistrictCreateNestedOneWithoutAiOutputScopesInput
  }

  export type AIOutputScopeUncheckedCreateWithoutCountyInput = {
    id?: string
    outputId: string
    scopeType: $Enums.AIScopeType
    issueId?: string | null
    geoZipId?: string | null
    districtId?: string | null
    customKey?: string | null
    createdAt?: Date | string
  }

  export type AIOutputScopeCreateOrConnectWithoutCountyInput = {
    where: AIOutputScopeWhereUniqueInput
    create: XOR<AIOutputScopeCreateWithoutCountyInput, AIOutputScopeUncheckedCreateWithoutCountyInput>
  }

  export type AIOutputScopeCreateManyCountyInputEnvelope = {
    data: AIOutputScopeCreateManyCountyInput | AIOutputScopeCreateManyCountyInput[]
    skipDuplicates?: boolean
  }

  export type SourceDocumentLinkCreateWithoutCountyInput = {
    id?: string
    note?: string | null
    createdAt?: Date | string
    sourceDocument: SourceDocumentCreateNestedOneWithoutSourceLinksInput
    issue?: IssueCreateNestedOneWithoutSourceLinksInput
    blueprintSection?: BlueprintSectionCreateNestedOneWithoutSourceLinksInput
    quote?: QuoteCreateNestedOneWithoutSourceLinksInput
    asset?: AssetCreateNestedOneWithoutSourceLinksInput
    surveyForm?: SurveyFormCreateNestedOneWithoutSourceLinksInput
  }

  export type SourceDocumentLinkUncheckedCreateWithoutCountyInput = {
    id?: string
    sourceDocumentId: string
    issueId?: string | null
    blueprintSectionId?: string | null
    quoteId?: string | null
    assetId?: string | null
    surveyFormId?: string | null
    note?: string | null
    createdAt?: Date | string
  }

  export type SourceDocumentLinkCreateOrConnectWithoutCountyInput = {
    where: SourceDocumentLinkWhereUniqueInput
    create: XOR<SourceDocumentLinkCreateWithoutCountyInput, SourceDocumentLinkUncheckedCreateWithoutCountyInput>
  }

  export type SourceDocumentLinkCreateManyCountyInputEnvelope = {
    data: SourceDocumentLinkCreateManyCountyInput | SourceDocumentLinkCreateManyCountyInput[]
    skipDuplicates?: boolean
  }

  export type BlueprintSectionUpsertWithWhereUniqueWithoutCountyInput = {
    where: BlueprintSectionWhereUniqueInput
    update: XOR<BlueprintSectionUpdateWithoutCountyInput, BlueprintSectionUncheckedUpdateWithoutCountyInput>
    create: XOR<BlueprintSectionCreateWithoutCountyInput, BlueprintSectionUncheckedCreateWithoutCountyInput>
  }

  export type BlueprintSectionUpdateWithWhereUniqueWithoutCountyInput = {
    where: BlueprintSectionWhereUniqueInput
    data: XOR<BlueprintSectionUpdateWithoutCountyInput, BlueprintSectionUncheckedUpdateWithoutCountyInput>
  }

  export type BlueprintSectionUpdateManyWithWhereWithoutCountyInput = {
    where: BlueprintSectionScalarWhereInput
    data: XOR<BlueprintSectionUpdateManyMutationInput, BlueprintSectionUncheckedUpdateManyWithoutCountyInput>
  }

  export type BlueprintSectionScalarWhereInput = {
    AND?: BlueprintSectionScalarWhereInput | BlueprintSectionScalarWhereInput[]
    OR?: BlueprintSectionScalarWhereInput[]
    NOT?: BlueprintSectionScalarWhereInput | BlueprintSectionScalarWhereInput[]
    id?: UuidFilter<"BlueprintSection"> | string
    slug?: StringFilter<"BlueprintSection"> | string
    title?: StringFilter<"BlueprintSection"> | string
    bodyMd?: StringFilter<"BlueprintSection"> | string
    countyId?: UuidNullableFilter<"BlueprintSection"> | string | null
    issueId?: UuidNullableFilter<"BlueprintSection"> | string | null
    sortOrder?: IntNullableFilter<"BlueprintSection"> | number | null
    isPinned?: BoolFilter<"BlueprintSection"> | boolean
    createdAt?: DateTimeFilter<"BlueprintSection"> | Date | string
    updatedAt?: DateTimeFilter<"BlueprintSection"> | Date | string
  }

  export type QuoteUpsertWithWhereUniqueWithoutCountyInput = {
    where: QuoteWhereUniqueInput
    update: XOR<QuoteUpdateWithoutCountyInput, QuoteUncheckedUpdateWithoutCountyInput>
    create: XOR<QuoteCreateWithoutCountyInput, QuoteUncheckedCreateWithoutCountyInput>
  }

  export type QuoteUpdateWithWhereUniqueWithoutCountyInput = {
    where: QuoteWhereUniqueInput
    data: XOR<QuoteUpdateWithoutCountyInput, QuoteUncheckedUpdateWithoutCountyInput>
  }

  export type QuoteUpdateManyWithWhereWithoutCountyInput = {
    where: QuoteScalarWhereInput
    data: XOR<QuoteUpdateManyMutationInput, QuoteUncheckedUpdateManyWithoutCountyInput>
  }

  export type QuoteScalarWhereInput = {
    AND?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
    OR?: QuoteScalarWhereInput[]
    NOT?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
    id?: UuidFilter<"Quote"> | string
    text?: StringFilter<"Quote"> | string
    attributionLabel?: StringNullableFilter<"Quote"> | string | null
    countyId?: UuidFilter<"Quote"> | string
    issueId?: UuidNullableFilter<"Quote"> | string | null
    sourceNote?: StringNullableFilter<"Quote"> | string | null
    createdAt?: DateTimeFilter<"Quote"> | Date | string
    updatedAt?: DateTimeFilter<"Quote"> | Date | string
  }

  export type AssetUpsertWithWhereUniqueWithoutCountyInput = {
    where: AssetWhereUniqueInput
    update: XOR<AssetUpdateWithoutCountyInput, AssetUncheckedUpdateWithoutCountyInput>
    create: XOR<AssetCreateWithoutCountyInput, AssetUncheckedCreateWithoutCountyInput>
  }

  export type AssetUpdateWithWhereUniqueWithoutCountyInput = {
    where: AssetWhereUniqueInput
    data: XOR<AssetUpdateWithoutCountyInput, AssetUncheckedUpdateWithoutCountyInput>
  }

  export type AssetUpdateManyWithWhereWithoutCountyInput = {
    where: AssetScalarWhereInput
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyWithoutCountyInput>
  }

  export type AssetScalarWhereInput = {
    AND?: AssetScalarWhereInput | AssetScalarWhereInput[]
    OR?: AssetScalarWhereInput[]
    NOT?: AssetScalarWhereInput | AssetScalarWhereInput[]
    id?: UuidFilter<"Asset"> | string
    assetType?: EnumAssetTypeFilter<"Asset"> | $Enums.AssetType
    title?: StringNullableFilter<"Asset"> | string | null
    caption?: StringNullableFilter<"Asset"> | string | null
    credit?: StringNullableFilter<"Asset"> | string | null
    license?: StringNullableFilter<"Asset"> | string | null
    url?: StringNullableFilter<"Asset"> | string | null
    storageKey?: StringNullableFilter<"Asset"> | string | null
    countyId?: UuidNullableFilter<"Asset"> | string | null
    issueId?: UuidNullableFilter<"Asset"> | string | null
    createdAt?: DateTimeFilter<"Asset"> | Date | string
    updatedAt?: DateTimeFilter<"Asset"> | Date | string
  }

  export type CountyIssueUpsertWithWhereUniqueWithoutCountyInput = {
    where: CountyIssueWhereUniqueInput
    update: XOR<CountyIssueUpdateWithoutCountyInput, CountyIssueUncheckedUpdateWithoutCountyInput>
    create: XOR<CountyIssueCreateWithoutCountyInput, CountyIssueUncheckedCreateWithoutCountyInput>
  }

  export type CountyIssueUpdateWithWhereUniqueWithoutCountyInput = {
    where: CountyIssueWhereUniqueInput
    data: XOR<CountyIssueUpdateWithoutCountyInput, CountyIssueUncheckedUpdateWithoutCountyInput>
  }

  export type CountyIssueUpdateManyWithWhereWithoutCountyInput = {
    where: CountyIssueScalarWhereInput
    data: XOR<CountyIssueUpdateManyMutationInput, CountyIssueUncheckedUpdateManyWithoutCountyInput>
  }

  export type CountyIssueScalarWhereInput = {
    AND?: CountyIssueScalarWhereInput | CountyIssueScalarWhereInput[]
    OR?: CountyIssueScalarWhereInput[]
    NOT?: CountyIssueScalarWhereInput | CountyIssueScalarWhereInput[]
    id?: UuidFilter<"CountyIssue"> | string
    countyId?: UuidFilter<"CountyIssue"> | string
    issueId?: UuidFilter<"CountyIssue"> | string
    featured?: BoolFilter<"CountyIssue"> | boolean
    sortOrder?: IntNullableFilter<"CountyIssue"> | number | null
    createdAt?: DateTimeFilter<"CountyIssue"> | Date | string
  }

  export type CensusMetricUpsertWithWhereUniqueWithoutCountyInput = {
    where: CensusMetricWhereUniqueInput
    update: XOR<CensusMetricUpdateWithoutCountyInput, CensusMetricUncheckedUpdateWithoutCountyInput>
    create: XOR<CensusMetricCreateWithoutCountyInput, CensusMetricUncheckedCreateWithoutCountyInput>
  }

  export type CensusMetricUpdateWithWhereUniqueWithoutCountyInput = {
    where: CensusMetricWhereUniqueInput
    data: XOR<CensusMetricUpdateWithoutCountyInput, CensusMetricUncheckedUpdateWithoutCountyInput>
  }

  export type CensusMetricUpdateManyWithWhereWithoutCountyInput = {
    where: CensusMetricScalarWhereInput
    data: XOR<CensusMetricUpdateManyMutationInput, CensusMetricUncheckedUpdateManyWithoutCountyInput>
  }

  export type CensusMetricScalarWhereInput = {
    AND?: CensusMetricScalarWhereInput | CensusMetricScalarWhereInput[]
    OR?: CensusMetricScalarWhereInput[]
    NOT?: CensusMetricScalarWhereInput | CensusMetricScalarWhereInput[]
    id?: UuidFilter<"CensusMetric"> | string
    countyId?: UuidNullableFilter<"CensusMetric"> | string | null
    geoZipId?: UuidNullableFilter<"CensusMetric"> | string | null
    metricKey?: StringFilter<"CensusMetric"> | string
    metricLabel?: StringNullableFilter<"CensusMetric"> | string | null
    value?: FloatNullableFilter<"CensusMetric"> | number | null
    valueText?: StringNullableFilter<"CensusMetric"> | string | null
    asOfDate?: DateTimeNullableFilter<"CensusMetric"> | Date | string | null
    sourceNote?: StringNullableFilter<"CensusMetric"> | string | null
    createdAt?: DateTimeFilter<"CensusMetric"> | Date | string
  }

  export type BLSMetricUpsertWithWhereUniqueWithoutCountyInput = {
    where: BLSMetricWhereUniqueInput
    update: XOR<BLSMetricUpdateWithoutCountyInput, BLSMetricUncheckedUpdateWithoutCountyInput>
    create: XOR<BLSMetricCreateWithoutCountyInput, BLSMetricUncheckedCreateWithoutCountyInput>
  }

  export type BLSMetricUpdateWithWhereUniqueWithoutCountyInput = {
    where: BLSMetricWhereUniqueInput
    data: XOR<BLSMetricUpdateWithoutCountyInput, BLSMetricUncheckedUpdateWithoutCountyInput>
  }

  export type BLSMetricUpdateManyWithWhereWithoutCountyInput = {
    where: BLSMetricScalarWhereInput
    data: XOR<BLSMetricUpdateManyMutationInput, BLSMetricUncheckedUpdateManyWithoutCountyInput>
  }

  export type BLSMetricScalarWhereInput = {
    AND?: BLSMetricScalarWhereInput | BLSMetricScalarWhereInput[]
    OR?: BLSMetricScalarWhereInput[]
    NOT?: BLSMetricScalarWhereInput | BLSMetricScalarWhereInput[]
    id?: UuidFilter<"BLSMetric"> | string
    countyId?: UuidFilter<"BLSMetric"> | string
    seriesKey?: StringFilter<"BLSMetric"> | string
    seriesLabel?: StringNullableFilter<"BLSMetric"> | string | null
    value?: FloatNullableFilter<"BLSMetric"> | number | null
    asOfDate?: DateTimeNullableFilter<"BLSMetric"> | Date | string | null
    sourceNote?: StringNullableFilter<"BLSMetric"> | string | null
    createdAt?: DateTimeFilter<"BLSMetric"> | Date | string
  }

  export type CivicsOfficialUpsertWithWhereUniqueWithoutCountyInput = {
    where: CivicsOfficialWhereUniqueInput
    update: XOR<CivicsOfficialUpdateWithoutCountyInput, CivicsOfficialUncheckedUpdateWithoutCountyInput>
    create: XOR<CivicsOfficialCreateWithoutCountyInput, CivicsOfficialUncheckedCreateWithoutCountyInput>
  }

  export type CivicsOfficialUpdateWithWhereUniqueWithoutCountyInput = {
    where: CivicsOfficialWhereUniqueInput
    data: XOR<CivicsOfficialUpdateWithoutCountyInput, CivicsOfficialUncheckedUpdateWithoutCountyInput>
  }

  export type CivicsOfficialUpdateManyWithWhereWithoutCountyInput = {
    where: CivicsOfficialScalarWhereInput
    data: XOR<CivicsOfficialUpdateManyMutationInput, CivicsOfficialUncheckedUpdateManyWithoutCountyInput>
  }

  export type CivicsOfficialScalarWhereInput = {
    AND?: CivicsOfficialScalarWhereInput | CivicsOfficialScalarWhereInput[]
    OR?: CivicsOfficialScalarWhereInput[]
    NOT?: CivicsOfficialScalarWhereInput | CivicsOfficialScalarWhereInput[]
    id?: UuidFilter<"CivicsOfficial"> | string
    name?: StringFilter<"CivicsOfficial"> | string
    officeName?: StringFilter<"CivicsOfficial"> | string
    party?: StringNullableFilter<"CivicsOfficial"> | string | null
    phone?: StringNullableFilter<"CivicsOfficial"> | string | null
    website?: StringNullableFilter<"CivicsOfficial"> | string | null
    photoUrl?: StringNullableFilter<"CivicsOfficial"> | string | null
    countyId?: UuidNullableFilter<"CivicsOfficial"> | string | null
    districtId?: UuidNullableFilter<"CivicsOfficial"> | string | null
    sourceNote?: StringNullableFilter<"CivicsOfficial"> | string | null
    createdAt?: DateTimeFilter<"CivicsOfficial"> | Date | string
    updatedAt?: DateTimeFilter<"CivicsOfficial"> | Date | string
  }

  export type ElectionResultUpsertWithWhereUniqueWithoutCountyInput = {
    where: ElectionResultWhereUniqueInput
    update: XOR<ElectionResultUpdateWithoutCountyInput, ElectionResultUncheckedUpdateWithoutCountyInput>
    create: XOR<ElectionResultCreateWithoutCountyInput, ElectionResultUncheckedCreateWithoutCountyInput>
  }

  export type ElectionResultUpdateWithWhereUniqueWithoutCountyInput = {
    where: ElectionResultWhereUniqueInput
    data: XOR<ElectionResultUpdateWithoutCountyInput, ElectionResultUncheckedUpdateWithoutCountyInput>
  }

  export type ElectionResultUpdateManyWithWhereWithoutCountyInput = {
    where: ElectionResultScalarWhereInput
    data: XOR<ElectionResultUpdateManyMutationInput, ElectionResultUncheckedUpdateManyWithoutCountyInput>
  }

  export type ElectionResultScalarWhereInput = {
    AND?: ElectionResultScalarWhereInput | ElectionResultScalarWhereInput[]
    OR?: ElectionResultScalarWhereInput[]
    NOT?: ElectionResultScalarWhereInput | ElectionResultScalarWhereInput[]
    id?: UuidFilter<"ElectionResult"> | string
    electionId?: UuidFilter<"ElectionResult"> | string
    countyId?: UuidNullableFilter<"ElectionResult"> | string | null
    geoZipId?: UuidNullableFilter<"ElectionResult"> | string | null
    precinctId?: UuidNullableFilter<"ElectionResult"> | string | null
    choiceLabel?: StringFilter<"ElectionResult"> | string
    votes?: IntNullableFilter<"ElectionResult"> | number | null
    voteShare?: FloatNullableFilter<"ElectionResult"> | number | null
    createdAt?: DateTimeFilter<"ElectionResult"> | Date | string
  }

  export type SurveyFormUpsertWithWhereUniqueWithoutCountyInput = {
    where: SurveyFormWhereUniqueInput
    update: XOR<SurveyFormUpdateWithoutCountyInput, SurveyFormUncheckedUpdateWithoutCountyInput>
    create: XOR<SurveyFormCreateWithoutCountyInput, SurveyFormUncheckedCreateWithoutCountyInput>
  }

  export type SurveyFormUpdateWithWhereUniqueWithoutCountyInput = {
    where: SurveyFormWhereUniqueInput
    data: XOR<SurveyFormUpdateWithoutCountyInput, SurveyFormUncheckedUpdateWithoutCountyInput>
  }

  export type SurveyFormUpdateManyWithWhereWithoutCountyInput = {
    where: SurveyFormScalarWhereInput
    data: XOR<SurveyFormUpdateManyMutationInput, SurveyFormUncheckedUpdateManyWithoutCountyInput>
  }

  export type SurveyFormScalarWhereInput = {
    AND?: SurveyFormScalarWhereInput | SurveyFormScalarWhereInput[]
    OR?: SurveyFormScalarWhereInput[]
    NOT?: SurveyFormScalarWhereInput | SurveyFormScalarWhereInput[]
    id?: UuidFilter<"SurveyForm"> | string
    title?: StringFilter<"SurveyForm"> | string
    descriptionMd?: StringNullableFilter<"SurveyForm"> | string | null
    slug?: StringFilter<"SurveyForm"> | string
    status?: EnumSurveyFormStatusFilter<"SurveyForm"> | $Enums.SurveyFormStatus
    startAt?: DateTimeNullableFilter<"SurveyForm"> | Date | string | null
    endAt?: DateTimeNullableFilter<"SurveyForm"> | Date | string | null
    countyId?: UuidNullableFilter<"SurveyForm"> | string | null
    contextLabel?: StringNullableFilter<"SurveyForm"> | string | null
    createdAt?: DateTimeFilter<"SurveyForm"> | Date | string
    updatedAt?: DateTimeFilter<"SurveyForm"> | Date | string
  }

  export type SurveyResponseUpsertWithWhereUniqueWithoutCountyInput = {
    where: SurveyResponseWhereUniqueInput
    update: XOR<SurveyResponseUpdateWithoutCountyInput, SurveyResponseUncheckedUpdateWithoutCountyInput>
    create: XOR<SurveyResponseCreateWithoutCountyInput, SurveyResponseUncheckedCreateWithoutCountyInput>
  }

  export type SurveyResponseUpdateWithWhereUniqueWithoutCountyInput = {
    where: SurveyResponseWhereUniqueInput
    data: XOR<SurveyResponseUpdateWithoutCountyInput, SurveyResponseUncheckedUpdateWithoutCountyInput>
  }

  export type SurveyResponseUpdateManyWithWhereWithoutCountyInput = {
    where: SurveyResponseScalarWhereInput
    data: XOR<SurveyResponseUpdateManyMutationInput, SurveyResponseUncheckedUpdateManyWithoutCountyInput>
  }

  export type SurveyResponseScalarWhereInput = {
    AND?: SurveyResponseScalarWhereInput | SurveyResponseScalarWhereInput[]
    OR?: SurveyResponseScalarWhereInput[]
    NOT?: SurveyResponseScalarWhereInput | SurveyResponseScalarWhereInput[]
    id?: UuidFilter<"SurveyResponse"> | string
    formId?: UuidFilter<"SurveyResponse"> | string
    countyId?: UuidNullableFilter<"SurveyResponse"> | string | null
    sourceLabel?: StringNullableFilter<"SurveyResponse"> | string | null
    submittedAt?: DateTimeFilter<"SurveyResponse"> | Date | string
    ipHash?: StringNullableFilter<"SurveyResponse"> | string | null
    userAgent?: StringNullableFilter<"SurveyResponse"> | string | null
    createdAt?: DateTimeFilter<"SurveyResponse"> | Date | string
  }

  export type AIOutputScopeUpsertWithWhereUniqueWithoutCountyInput = {
    where: AIOutputScopeWhereUniqueInput
    update: XOR<AIOutputScopeUpdateWithoutCountyInput, AIOutputScopeUncheckedUpdateWithoutCountyInput>
    create: XOR<AIOutputScopeCreateWithoutCountyInput, AIOutputScopeUncheckedCreateWithoutCountyInput>
  }

  export type AIOutputScopeUpdateWithWhereUniqueWithoutCountyInput = {
    where: AIOutputScopeWhereUniqueInput
    data: XOR<AIOutputScopeUpdateWithoutCountyInput, AIOutputScopeUncheckedUpdateWithoutCountyInput>
  }

  export type AIOutputScopeUpdateManyWithWhereWithoutCountyInput = {
    where: AIOutputScopeScalarWhereInput
    data: XOR<AIOutputScopeUpdateManyMutationInput, AIOutputScopeUncheckedUpdateManyWithoutCountyInput>
  }

  export type AIOutputScopeScalarWhereInput = {
    AND?: AIOutputScopeScalarWhereInput | AIOutputScopeScalarWhereInput[]
    OR?: AIOutputScopeScalarWhereInput[]
    NOT?: AIOutputScopeScalarWhereInput | AIOutputScopeScalarWhereInput[]
    id?: UuidFilter<"AIOutputScope"> | string
    outputId?: UuidFilter<"AIOutputScope"> | string
    scopeType?: EnumAIScopeTypeFilter<"AIOutputScope"> | $Enums.AIScopeType
    countyId?: UuidNullableFilter<"AIOutputScope"> | string | null
    issueId?: UuidNullableFilter<"AIOutputScope"> | string | null
    geoZipId?: UuidNullableFilter<"AIOutputScope"> | string | null
    districtId?: UuidNullableFilter<"AIOutputScope"> | string | null
    customKey?: StringNullableFilter<"AIOutputScope"> | string | null
    createdAt?: DateTimeFilter<"AIOutputScope"> | Date | string
  }

  export type SourceDocumentLinkUpsertWithWhereUniqueWithoutCountyInput = {
    where: SourceDocumentLinkWhereUniqueInput
    update: XOR<SourceDocumentLinkUpdateWithoutCountyInput, SourceDocumentLinkUncheckedUpdateWithoutCountyInput>
    create: XOR<SourceDocumentLinkCreateWithoutCountyInput, SourceDocumentLinkUncheckedCreateWithoutCountyInput>
  }

  export type SourceDocumentLinkUpdateWithWhereUniqueWithoutCountyInput = {
    where: SourceDocumentLinkWhereUniqueInput
    data: XOR<SourceDocumentLinkUpdateWithoutCountyInput, SourceDocumentLinkUncheckedUpdateWithoutCountyInput>
  }

  export type SourceDocumentLinkUpdateManyWithWhereWithoutCountyInput = {
    where: SourceDocumentLinkScalarWhereInput
    data: XOR<SourceDocumentLinkUpdateManyMutationInput, SourceDocumentLinkUncheckedUpdateManyWithoutCountyInput>
  }

  export type SourceDocumentLinkScalarWhereInput = {
    AND?: SourceDocumentLinkScalarWhereInput | SourceDocumentLinkScalarWhereInput[]
    OR?: SourceDocumentLinkScalarWhereInput[]
    NOT?: SourceDocumentLinkScalarWhereInput | SourceDocumentLinkScalarWhereInput[]
    id?: UuidFilter<"SourceDocumentLink"> | string
    sourceDocumentId?: UuidFilter<"SourceDocumentLink"> | string
    countyId?: UuidNullableFilter<"SourceDocumentLink"> | string | null
    issueId?: UuidNullableFilter<"SourceDocumentLink"> | string | null
    blueprintSectionId?: UuidNullableFilter<"SourceDocumentLink"> | string | null
    quoteId?: UuidNullableFilter<"SourceDocumentLink"> | string | null
    assetId?: UuidNullableFilter<"SourceDocumentLink"> | string | null
    surveyFormId?: UuidNullableFilter<"SourceDocumentLink"> | string | null
    note?: StringNullableFilter<"SourceDocumentLink"> | string | null
    createdAt?: DateTimeFilter<"SourceDocumentLink"> | Date | string
  }

  export type CountyIssueCreateWithoutIssueInput = {
    id?: string
    featured?: boolean
    sortOrder?: number | null
    createdAt?: Date | string
    county: CountyCreateNestedOneWithoutCountyIssuesInput
  }

  export type CountyIssueUncheckedCreateWithoutIssueInput = {
    id?: string
    countyId: string
    featured?: boolean
    sortOrder?: number | null
    createdAt?: Date | string
  }

  export type CountyIssueCreateOrConnectWithoutIssueInput = {
    where: CountyIssueWhereUniqueInput
    create: XOR<CountyIssueCreateWithoutIssueInput, CountyIssueUncheckedCreateWithoutIssueInput>
  }

  export type CountyIssueCreateManyIssueInputEnvelope = {
    data: CountyIssueCreateManyIssueInput | CountyIssueCreateManyIssueInput[]
    skipDuplicates?: boolean
  }

  export type BlueprintSectionCreateWithoutIssueInput = {
    id?: string
    slug: string
    title: string
    bodyMd: string
    sortOrder?: number | null
    isPinned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    county?: CountyCreateNestedOneWithoutBlueprintSectionsInput
    sourceLinks?: SourceDocumentLinkCreateNestedManyWithoutBlueprintSectionInput
  }

  export type BlueprintSectionUncheckedCreateWithoutIssueInput = {
    id?: string
    slug: string
    title: string
    bodyMd: string
    countyId?: string | null
    sortOrder?: number | null
    isPinned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceLinks?: SourceDocumentLinkUncheckedCreateNestedManyWithoutBlueprintSectionInput
  }

  export type BlueprintSectionCreateOrConnectWithoutIssueInput = {
    where: BlueprintSectionWhereUniqueInput
    create: XOR<BlueprintSectionCreateWithoutIssueInput, BlueprintSectionUncheckedCreateWithoutIssueInput>
  }

  export type BlueprintSectionCreateManyIssueInputEnvelope = {
    data: BlueprintSectionCreateManyIssueInput | BlueprintSectionCreateManyIssueInput[]
    skipDuplicates?: boolean
  }

  export type QuoteCreateWithoutIssueInput = {
    id?: string
    text: string
    attributionLabel?: string | null
    sourceNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    county: CountyCreateNestedOneWithoutQuotesInput
    sourceLinks?: SourceDocumentLinkCreateNestedManyWithoutQuoteInput
  }

  export type QuoteUncheckedCreateWithoutIssueInput = {
    id?: string
    text: string
    attributionLabel?: string | null
    countyId: string
    sourceNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceLinks?: SourceDocumentLinkUncheckedCreateNestedManyWithoutQuoteInput
  }

  export type QuoteCreateOrConnectWithoutIssueInput = {
    where: QuoteWhereUniqueInput
    create: XOR<QuoteCreateWithoutIssueInput, QuoteUncheckedCreateWithoutIssueInput>
  }

  export type QuoteCreateManyIssueInputEnvelope = {
    data: QuoteCreateManyIssueInput | QuoteCreateManyIssueInput[]
    skipDuplicates?: boolean
  }

  export type AssetCreateWithoutIssueInput = {
    id?: string
    assetType?: $Enums.AssetType
    title?: string | null
    caption?: string | null
    credit?: string | null
    license?: string | null
    url?: string | null
    storageKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    county?: CountyCreateNestedOneWithoutAssetsInput
    sourceLinks?: SourceDocumentLinkCreateNestedManyWithoutAssetInput
  }

  export type AssetUncheckedCreateWithoutIssueInput = {
    id?: string
    assetType?: $Enums.AssetType
    title?: string | null
    caption?: string | null
    credit?: string | null
    license?: string | null
    url?: string | null
    storageKey?: string | null
    countyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceLinks?: SourceDocumentLinkUncheckedCreateNestedManyWithoutAssetInput
  }

  export type AssetCreateOrConnectWithoutIssueInput = {
    where: AssetWhereUniqueInput
    create: XOR<AssetCreateWithoutIssueInput, AssetUncheckedCreateWithoutIssueInput>
  }

  export type AssetCreateManyIssueInputEnvelope = {
    data: AssetCreateManyIssueInput | AssetCreateManyIssueInput[]
    skipDuplicates?: boolean
  }

  export type AIOutputScopeCreateWithoutIssueInput = {
    id?: string
    scopeType: $Enums.AIScopeType
    customKey?: string | null
    createdAt?: Date | string
    output: AIOutputCreateNestedOneWithoutScopesInput
    county?: CountyCreateNestedOneWithoutAiOutputScopesInput
    geoZip?: GeoZipCreateNestedOneWithoutAiOutputScopesInput
    district?: GeoDistrictCreateNestedOneWithoutAiOutputScopesInput
  }

  export type AIOutputScopeUncheckedCreateWithoutIssueInput = {
    id?: string
    outputId: string
    scopeType: $Enums.AIScopeType
    countyId?: string | null
    geoZipId?: string | null
    districtId?: string | null
    customKey?: string | null
    createdAt?: Date | string
  }

  export type AIOutputScopeCreateOrConnectWithoutIssueInput = {
    where: AIOutputScopeWhereUniqueInput
    create: XOR<AIOutputScopeCreateWithoutIssueInput, AIOutputScopeUncheckedCreateWithoutIssueInput>
  }

  export type AIOutputScopeCreateManyIssueInputEnvelope = {
    data: AIOutputScopeCreateManyIssueInput | AIOutputScopeCreateManyIssueInput[]
    skipDuplicates?: boolean
  }

  export type SourceDocumentLinkCreateWithoutIssueInput = {
    id?: string
    note?: string | null
    createdAt?: Date | string
    sourceDocument: SourceDocumentCreateNestedOneWithoutSourceLinksInput
    county?: CountyCreateNestedOneWithoutSourceLinksInput
    blueprintSection?: BlueprintSectionCreateNestedOneWithoutSourceLinksInput
    quote?: QuoteCreateNestedOneWithoutSourceLinksInput
    asset?: AssetCreateNestedOneWithoutSourceLinksInput
    surveyForm?: SurveyFormCreateNestedOneWithoutSourceLinksInput
  }

  export type SourceDocumentLinkUncheckedCreateWithoutIssueInput = {
    id?: string
    sourceDocumentId: string
    countyId?: string | null
    blueprintSectionId?: string | null
    quoteId?: string | null
    assetId?: string | null
    surveyFormId?: string | null
    note?: string | null
    createdAt?: Date | string
  }

  export type SourceDocumentLinkCreateOrConnectWithoutIssueInput = {
    where: SourceDocumentLinkWhereUniqueInput
    create: XOR<SourceDocumentLinkCreateWithoutIssueInput, SourceDocumentLinkUncheckedCreateWithoutIssueInput>
  }

  export type SourceDocumentLinkCreateManyIssueInputEnvelope = {
    data: SourceDocumentLinkCreateManyIssueInput | SourceDocumentLinkCreateManyIssueInput[]
    skipDuplicates?: boolean
  }

  export type CountyIssueUpsertWithWhereUniqueWithoutIssueInput = {
    where: CountyIssueWhereUniqueInput
    update: XOR<CountyIssueUpdateWithoutIssueInput, CountyIssueUncheckedUpdateWithoutIssueInput>
    create: XOR<CountyIssueCreateWithoutIssueInput, CountyIssueUncheckedCreateWithoutIssueInput>
  }

  export type CountyIssueUpdateWithWhereUniqueWithoutIssueInput = {
    where: CountyIssueWhereUniqueInput
    data: XOR<CountyIssueUpdateWithoutIssueInput, CountyIssueUncheckedUpdateWithoutIssueInput>
  }

  export type CountyIssueUpdateManyWithWhereWithoutIssueInput = {
    where: CountyIssueScalarWhereInput
    data: XOR<CountyIssueUpdateManyMutationInput, CountyIssueUncheckedUpdateManyWithoutIssueInput>
  }

  export type BlueprintSectionUpsertWithWhereUniqueWithoutIssueInput = {
    where: BlueprintSectionWhereUniqueInput
    update: XOR<BlueprintSectionUpdateWithoutIssueInput, BlueprintSectionUncheckedUpdateWithoutIssueInput>
    create: XOR<BlueprintSectionCreateWithoutIssueInput, BlueprintSectionUncheckedCreateWithoutIssueInput>
  }

  export type BlueprintSectionUpdateWithWhereUniqueWithoutIssueInput = {
    where: BlueprintSectionWhereUniqueInput
    data: XOR<BlueprintSectionUpdateWithoutIssueInput, BlueprintSectionUncheckedUpdateWithoutIssueInput>
  }

  export type BlueprintSectionUpdateManyWithWhereWithoutIssueInput = {
    where: BlueprintSectionScalarWhereInput
    data: XOR<BlueprintSectionUpdateManyMutationInput, BlueprintSectionUncheckedUpdateManyWithoutIssueInput>
  }

  export type QuoteUpsertWithWhereUniqueWithoutIssueInput = {
    where: QuoteWhereUniqueInput
    update: XOR<QuoteUpdateWithoutIssueInput, QuoteUncheckedUpdateWithoutIssueInput>
    create: XOR<QuoteCreateWithoutIssueInput, QuoteUncheckedCreateWithoutIssueInput>
  }

  export type QuoteUpdateWithWhereUniqueWithoutIssueInput = {
    where: QuoteWhereUniqueInput
    data: XOR<QuoteUpdateWithoutIssueInput, QuoteUncheckedUpdateWithoutIssueInput>
  }

  export type QuoteUpdateManyWithWhereWithoutIssueInput = {
    where: QuoteScalarWhereInput
    data: XOR<QuoteUpdateManyMutationInput, QuoteUncheckedUpdateManyWithoutIssueInput>
  }

  export type AssetUpsertWithWhereUniqueWithoutIssueInput = {
    where: AssetWhereUniqueInput
    update: XOR<AssetUpdateWithoutIssueInput, AssetUncheckedUpdateWithoutIssueInput>
    create: XOR<AssetCreateWithoutIssueInput, AssetUncheckedCreateWithoutIssueInput>
  }

  export type AssetUpdateWithWhereUniqueWithoutIssueInput = {
    where: AssetWhereUniqueInput
    data: XOR<AssetUpdateWithoutIssueInput, AssetUncheckedUpdateWithoutIssueInput>
  }

  export type AssetUpdateManyWithWhereWithoutIssueInput = {
    where: AssetScalarWhereInput
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyWithoutIssueInput>
  }

  export type AIOutputScopeUpsertWithWhereUniqueWithoutIssueInput = {
    where: AIOutputScopeWhereUniqueInput
    update: XOR<AIOutputScopeUpdateWithoutIssueInput, AIOutputScopeUncheckedUpdateWithoutIssueInput>
    create: XOR<AIOutputScopeCreateWithoutIssueInput, AIOutputScopeUncheckedCreateWithoutIssueInput>
  }

  export type AIOutputScopeUpdateWithWhereUniqueWithoutIssueInput = {
    where: AIOutputScopeWhereUniqueInput
    data: XOR<AIOutputScopeUpdateWithoutIssueInput, AIOutputScopeUncheckedUpdateWithoutIssueInput>
  }

  export type AIOutputScopeUpdateManyWithWhereWithoutIssueInput = {
    where: AIOutputScopeScalarWhereInput
    data: XOR<AIOutputScopeUpdateManyMutationInput, AIOutputScopeUncheckedUpdateManyWithoutIssueInput>
  }

  export type SourceDocumentLinkUpsertWithWhereUniqueWithoutIssueInput = {
    where: SourceDocumentLinkWhereUniqueInput
    update: XOR<SourceDocumentLinkUpdateWithoutIssueInput, SourceDocumentLinkUncheckedUpdateWithoutIssueInput>
    create: XOR<SourceDocumentLinkCreateWithoutIssueInput, SourceDocumentLinkUncheckedCreateWithoutIssueInput>
  }

  export type SourceDocumentLinkUpdateWithWhereUniqueWithoutIssueInput = {
    where: SourceDocumentLinkWhereUniqueInput
    data: XOR<SourceDocumentLinkUpdateWithoutIssueInput, SourceDocumentLinkUncheckedUpdateWithoutIssueInput>
  }

  export type SourceDocumentLinkUpdateManyWithWhereWithoutIssueInput = {
    where: SourceDocumentLinkScalarWhereInput
    data: XOR<SourceDocumentLinkUpdateManyMutationInput, SourceDocumentLinkUncheckedUpdateManyWithoutIssueInput>
  }

  export type CountyCreateWithoutCountyIssuesInput = {
    id?: string
    name: string
    slug: string
    fipsCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blueprintSections?: BlueprintSectionCreateNestedManyWithoutCountyInput
    quotes?: QuoteCreateNestedManyWithoutCountyInput
    assets?: AssetCreateNestedManyWithoutCountyInput
    censusMetrics?: CensusMetricCreateNestedManyWithoutCountyInput
    blsMetrics?: BLSMetricCreateNestedManyWithoutCountyInput
    civicsOfficials?: CivicsOfficialCreateNestedManyWithoutCountyInput
    electionResults?: ElectionResultCreateNestedManyWithoutCountyInput
    surveyForms?: SurveyFormCreateNestedManyWithoutCountyInput
    surveyResponses?: SurveyResponseCreateNestedManyWithoutCountyInput
    aiOutputScopes?: AIOutputScopeCreateNestedManyWithoutCountyInput
    sourceLinks?: SourceDocumentLinkCreateNestedManyWithoutCountyInput
  }

  export type CountyUncheckedCreateWithoutCountyIssuesInput = {
    id?: string
    name: string
    slug: string
    fipsCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blueprintSections?: BlueprintSectionUncheckedCreateNestedManyWithoutCountyInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutCountyInput
    assets?: AssetUncheckedCreateNestedManyWithoutCountyInput
    censusMetrics?: CensusMetricUncheckedCreateNestedManyWithoutCountyInput
    blsMetrics?: BLSMetricUncheckedCreateNestedManyWithoutCountyInput
    civicsOfficials?: CivicsOfficialUncheckedCreateNestedManyWithoutCountyInput
    electionResults?: ElectionResultUncheckedCreateNestedManyWithoutCountyInput
    surveyForms?: SurveyFormUncheckedCreateNestedManyWithoutCountyInput
    surveyResponses?: SurveyResponseUncheckedCreateNestedManyWithoutCountyInput
    aiOutputScopes?: AIOutputScopeUncheckedCreateNestedManyWithoutCountyInput
    sourceLinks?: SourceDocumentLinkUncheckedCreateNestedManyWithoutCountyInput
  }

  export type CountyCreateOrConnectWithoutCountyIssuesInput = {
    where: CountyWhereUniqueInput
    create: XOR<CountyCreateWithoutCountyIssuesInput, CountyUncheckedCreateWithoutCountyIssuesInput>
  }

  export type IssueCreateWithoutCountyIssuesInput = {
    id?: string
    name: string
    slug: string
    summary?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blueprintSections?: BlueprintSectionCreateNestedManyWithoutIssueInput
    quotes?: QuoteCreateNestedManyWithoutIssueInput
    assets?: AssetCreateNestedManyWithoutIssueInput
    aiOutputScopes?: AIOutputScopeCreateNestedManyWithoutIssueInput
    sourceLinks?: SourceDocumentLinkCreateNestedManyWithoutIssueInput
  }

  export type IssueUncheckedCreateWithoutCountyIssuesInput = {
    id?: string
    name: string
    slug: string
    summary?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blueprintSections?: BlueprintSectionUncheckedCreateNestedManyWithoutIssueInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutIssueInput
    assets?: AssetUncheckedCreateNestedManyWithoutIssueInput
    aiOutputScopes?: AIOutputScopeUncheckedCreateNestedManyWithoutIssueInput
    sourceLinks?: SourceDocumentLinkUncheckedCreateNestedManyWithoutIssueInput
  }

  export type IssueCreateOrConnectWithoutCountyIssuesInput = {
    where: IssueWhereUniqueInput
    create: XOR<IssueCreateWithoutCountyIssuesInput, IssueUncheckedCreateWithoutCountyIssuesInput>
  }

  export type CountyUpsertWithoutCountyIssuesInput = {
    update: XOR<CountyUpdateWithoutCountyIssuesInput, CountyUncheckedUpdateWithoutCountyIssuesInput>
    create: XOR<CountyCreateWithoutCountyIssuesInput, CountyUncheckedCreateWithoutCountyIssuesInput>
    where?: CountyWhereInput
  }

  export type CountyUpdateToOneWithWhereWithoutCountyIssuesInput = {
    where?: CountyWhereInput
    data: XOR<CountyUpdateWithoutCountyIssuesInput, CountyUncheckedUpdateWithoutCountyIssuesInput>
  }

  export type CountyUpdateWithoutCountyIssuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fipsCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blueprintSections?: BlueprintSectionUpdateManyWithoutCountyNestedInput
    quotes?: QuoteUpdateManyWithoutCountyNestedInput
    assets?: AssetUpdateManyWithoutCountyNestedInput
    censusMetrics?: CensusMetricUpdateManyWithoutCountyNestedInput
    blsMetrics?: BLSMetricUpdateManyWithoutCountyNestedInput
    civicsOfficials?: CivicsOfficialUpdateManyWithoutCountyNestedInput
    electionResults?: ElectionResultUpdateManyWithoutCountyNestedInput
    surveyForms?: SurveyFormUpdateManyWithoutCountyNestedInput
    surveyResponses?: SurveyResponseUpdateManyWithoutCountyNestedInput
    aiOutputScopes?: AIOutputScopeUpdateManyWithoutCountyNestedInput
    sourceLinks?: SourceDocumentLinkUpdateManyWithoutCountyNestedInput
  }

  export type CountyUncheckedUpdateWithoutCountyIssuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fipsCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blueprintSections?: BlueprintSectionUncheckedUpdateManyWithoutCountyNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutCountyNestedInput
    assets?: AssetUncheckedUpdateManyWithoutCountyNestedInput
    censusMetrics?: CensusMetricUncheckedUpdateManyWithoutCountyNestedInput
    blsMetrics?: BLSMetricUncheckedUpdateManyWithoutCountyNestedInput
    civicsOfficials?: CivicsOfficialUncheckedUpdateManyWithoutCountyNestedInput
    electionResults?: ElectionResultUncheckedUpdateManyWithoutCountyNestedInput
    surveyForms?: SurveyFormUncheckedUpdateManyWithoutCountyNestedInput
    surveyResponses?: SurveyResponseUncheckedUpdateManyWithoutCountyNestedInput
    aiOutputScopes?: AIOutputScopeUncheckedUpdateManyWithoutCountyNestedInput
    sourceLinks?: SourceDocumentLinkUncheckedUpdateManyWithoutCountyNestedInput
  }

  export type IssueUpsertWithoutCountyIssuesInput = {
    update: XOR<IssueUpdateWithoutCountyIssuesInput, IssueUncheckedUpdateWithoutCountyIssuesInput>
    create: XOR<IssueCreateWithoutCountyIssuesInput, IssueUncheckedCreateWithoutCountyIssuesInput>
    where?: IssueWhereInput
  }

  export type IssueUpdateToOneWithWhereWithoutCountyIssuesInput = {
    where?: IssueWhereInput
    data: XOR<IssueUpdateWithoutCountyIssuesInput, IssueUncheckedUpdateWithoutCountyIssuesInput>
  }

  export type IssueUpdateWithoutCountyIssuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blueprintSections?: BlueprintSectionUpdateManyWithoutIssueNestedInput
    quotes?: QuoteUpdateManyWithoutIssueNestedInput
    assets?: AssetUpdateManyWithoutIssueNestedInput
    aiOutputScopes?: AIOutputScopeUpdateManyWithoutIssueNestedInput
    sourceLinks?: SourceDocumentLinkUpdateManyWithoutIssueNestedInput
  }

  export type IssueUncheckedUpdateWithoutCountyIssuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blueprintSections?: BlueprintSectionUncheckedUpdateManyWithoutIssueNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutIssueNestedInput
    assets?: AssetUncheckedUpdateManyWithoutIssueNestedInput
    aiOutputScopes?: AIOutputScopeUncheckedUpdateManyWithoutIssueNestedInput
    sourceLinks?: SourceDocumentLinkUncheckedUpdateManyWithoutIssueNestedInput
  }

  export type CountyCreateWithoutBlueprintSectionsInput = {
    id?: string
    name: string
    slug: string
    fipsCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    quotes?: QuoteCreateNestedManyWithoutCountyInput
    assets?: AssetCreateNestedManyWithoutCountyInput
    countyIssues?: CountyIssueCreateNestedManyWithoutCountyInput
    censusMetrics?: CensusMetricCreateNestedManyWithoutCountyInput
    blsMetrics?: BLSMetricCreateNestedManyWithoutCountyInput
    civicsOfficials?: CivicsOfficialCreateNestedManyWithoutCountyInput
    electionResults?: ElectionResultCreateNestedManyWithoutCountyInput
    surveyForms?: SurveyFormCreateNestedManyWithoutCountyInput
    surveyResponses?: SurveyResponseCreateNestedManyWithoutCountyInput
    aiOutputScopes?: AIOutputScopeCreateNestedManyWithoutCountyInput
    sourceLinks?: SourceDocumentLinkCreateNestedManyWithoutCountyInput
  }

  export type CountyUncheckedCreateWithoutBlueprintSectionsInput = {
    id?: string
    name: string
    slug: string
    fipsCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    quotes?: QuoteUncheckedCreateNestedManyWithoutCountyInput
    assets?: AssetUncheckedCreateNestedManyWithoutCountyInput
    countyIssues?: CountyIssueUncheckedCreateNestedManyWithoutCountyInput
    censusMetrics?: CensusMetricUncheckedCreateNestedManyWithoutCountyInput
    blsMetrics?: BLSMetricUncheckedCreateNestedManyWithoutCountyInput
    civicsOfficials?: CivicsOfficialUncheckedCreateNestedManyWithoutCountyInput
    electionResults?: ElectionResultUncheckedCreateNestedManyWithoutCountyInput
    surveyForms?: SurveyFormUncheckedCreateNestedManyWithoutCountyInput
    surveyResponses?: SurveyResponseUncheckedCreateNestedManyWithoutCountyInput
    aiOutputScopes?: AIOutputScopeUncheckedCreateNestedManyWithoutCountyInput
    sourceLinks?: SourceDocumentLinkUncheckedCreateNestedManyWithoutCountyInput
  }

  export type CountyCreateOrConnectWithoutBlueprintSectionsInput = {
    where: CountyWhereUniqueInput
    create: XOR<CountyCreateWithoutBlueprintSectionsInput, CountyUncheckedCreateWithoutBlueprintSectionsInput>
  }

  export type IssueCreateWithoutBlueprintSectionsInput = {
    id?: string
    name: string
    slug: string
    summary?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    countyIssues?: CountyIssueCreateNestedManyWithoutIssueInput
    quotes?: QuoteCreateNestedManyWithoutIssueInput
    assets?: AssetCreateNestedManyWithoutIssueInput
    aiOutputScopes?: AIOutputScopeCreateNestedManyWithoutIssueInput
    sourceLinks?: SourceDocumentLinkCreateNestedManyWithoutIssueInput
  }

  export type IssueUncheckedCreateWithoutBlueprintSectionsInput = {
    id?: string
    name: string
    slug: string
    summary?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    countyIssues?: CountyIssueUncheckedCreateNestedManyWithoutIssueInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutIssueInput
    assets?: AssetUncheckedCreateNestedManyWithoutIssueInput
    aiOutputScopes?: AIOutputScopeUncheckedCreateNestedManyWithoutIssueInput
    sourceLinks?: SourceDocumentLinkUncheckedCreateNestedManyWithoutIssueInput
  }

  export type IssueCreateOrConnectWithoutBlueprintSectionsInput = {
    where: IssueWhereUniqueInput
    create: XOR<IssueCreateWithoutBlueprintSectionsInput, IssueUncheckedCreateWithoutBlueprintSectionsInput>
  }

  export type SourceDocumentLinkCreateWithoutBlueprintSectionInput = {
    id?: string
    note?: string | null
    createdAt?: Date | string
    sourceDocument: SourceDocumentCreateNestedOneWithoutSourceLinksInput
    county?: CountyCreateNestedOneWithoutSourceLinksInput
    issue?: IssueCreateNestedOneWithoutSourceLinksInput
    quote?: QuoteCreateNestedOneWithoutSourceLinksInput
    asset?: AssetCreateNestedOneWithoutSourceLinksInput
    surveyForm?: SurveyFormCreateNestedOneWithoutSourceLinksInput
  }

  export type SourceDocumentLinkUncheckedCreateWithoutBlueprintSectionInput = {
    id?: string
    sourceDocumentId: string
    countyId?: string | null
    issueId?: string | null
    quoteId?: string | null
    assetId?: string | null
    surveyFormId?: string | null
    note?: string | null
    createdAt?: Date | string
  }

  export type SourceDocumentLinkCreateOrConnectWithoutBlueprintSectionInput = {
    where: SourceDocumentLinkWhereUniqueInput
    create: XOR<SourceDocumentLinkCreateWithoutBlueprintSectionInput, SourceDocumentLinkUncheckedCreateWithoutBlueprintSectionInput>
  }

  export type SourceDocumentLinkCreateManyBlueprintSectionInputEnvelope = {
    data: SourceDocumentLinkCreateManyBlueprintSectionInput | SourceDocumentLinkCreateManyBlueprintSectionInput[]
    skipDuplicates?: boolean
  }

  export type CountyUpsertWithoutBlueprintSectionsInput = {
    update: XOR<CountyUpdateWithoutBlueprintSectionsInput, CountyUncheckedUpdateWithoutBlueprintSectionsInput>
    create: XOR<CountyCreateWithoutBlueprintSectionsInput, CountyUncheckedCreateWithoutBlueprintSectionsInput>
    where?: CountyWhereInput
  }

  export type CountyUpdateToOneWithWhereWithoutBlueprintSectionsInput = {
    where?: CountyWhereInput
    data: XOR<CountyUpdateWithoutBlueprintSectionsInput, CountyUncheckedUpdateWithoutBlueprintSectionsInput>
  }

  export type CountyUpdateWithoutBlueprintSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fipsCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotes?: QuoteUpdateManyWithoutCountyNestedInput
    assets?: AssetUpdateManyWithoutCountyNestedInput
    countyIssues?: CountyIssueUpdateManyWithoutCountyNestedInput
    censusMetrics?: CensusMetricUpdateManyWithoutCountyNestedInput
    blsMetrics?: BLSMetricUpdateManyWithoutCountyNestedInput
    civicsOfficials?: CivicsOfficialUpdateManyWithoutCountyNestedInput
    electionResults?: ElectionResultUpdateManyWithoutCountyNestedInput
    surveyForms?: SurveyFormUpdateManyWithoutCountyNestedInput
    surveyResponses?: SurveyResponseUpdateManyWithoutCountyNestedInput
    aiOutputScopes?: AIOutputScopeUpdateManyWithoutCountyNestedInput
    sourceLinks?: SourceDocumentLinkUpdateManyWithoutCountyNestedInput
  }

  export type CountyUncheckedUpdateWithoutBlueprintSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fipsCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotes?: QuoteUncheckedUpdateManyWithoutCountyNestedInput
    assets?: AssetUncheckedUpdateManyWithoutCountyNestedInput
    countyIssues?: CountyIssueUncheckedUpdateManyWithoutCountyNestedInput
    censusMetrics?: CensusMetricUncheckedUpdateManyWithoutCountyNestedInput
    blsMetrics?: BLSMetricUncheckedUpdateManyWithoutCountyNestedInput
    civicsOfficials?: CivicsOfficialUncheckedUpdateManyWithoutCountyNestedInput
    electionResults?: ElectionResultUncheckedUpdateManyWithoutCountyNestedInput
    surveyForms?: SurveyFormUncheckedUpdateManyWithoutCountyNestedInput
    surveyResponses?: SurveyResponseUncheckedUpdateManyWithoutCountyNestedInput
    aiOutputScopes?: AIOutputScopeUncheckedUpdateManyWithoutCountyNestedInput
    sourceLinks?: SourceDocumentLinkUncheckedUpdateManyWithoutCountyNestedInput
  }

  export type IssueUpsertWithoutBlueprintSectionsInput = {
    update: XOR<IssueUpdateWithoutBlueprintSectionsInput, IssueUncheckedUpdateWithoutBlueprintSectionsInput>
    create: XOR<IssueCreateWithoutBlueprintSectionsInput, IssueUncheckedCreateWithoutBlueprintSectionsInput>
    where?: IssueWhereInput
  }

  export type IssueUpdateToOneWithWhereWithoutBlueprintSectionsInput = {
    where?: IssueWhereInput
    data: XOR<IssueUpdateWithoutBlueprintSectionsInput, IssueUncheckedUpdateWithoutBlueprintSectionsInput>
  }

  export type IssueUpdateWithoutBlueprintSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    countyIssues?: CountyIssueUpdateManyWithoutIssueNestedInput
    quotes?: QuoteUpdateManyWithoutIssueNestedInput
    assets?: AssetUpdateManyWithoutIssueNestedInput
    aiOutputScopes?: AIOutputScopeUpdateManyWithoutIssueNestedInput
    sourceLinks?: SourceDocumentLinkUpdateManyWithoutIssueNestedInput
  }

  export type IssueUncheckedUpdateWithoutBlueprintSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    countyIssues?: CountyIssueUncheckedUpdateManyWithoutIssueNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutIssueNestedInput
    assets?: AssetUncheckedUpdateManyWithoutIssueNestedInput
    aiOutputScopes?: AIOutputScopeUncheckedUpdateManyWithoutIssueNestedInput
    sourceLinks?: SourceDocumentLinkUncheckedUpdateManyWithoutIssueNestedInput
  }

  export type SourceDocumentLinkUpsertWithWhereUniqueWithoutBlueprintSectionInput = {
    where: SourceDocumentLinkWhereUniqueInput
    update: XOR<SourceDocumentLinkUpdateWithoutBlueprintSectionInput, SourceDocumentLinkUncheckedUpdateWithoutBlueprintSectionInput>
    create: XOR<SourceDocumentLinkCreateWithoutBlueprintSectionInput, SourceDocumentLinkUncheckedCreateWithoutBlueprintSectionInput>
  }

  export type SourceDocumentLinkUpdateWithWhereUniqueWithoutBlueprintSectionInput = {
    where: SourceDocumentLinkWhereUniqueInput
    data: XOR<SourceDocumentLinkUpdateWithoutBlueprintSectionInput, SourceDocumentLinkUncheckedUpdateWithoutBlueprintSectionInput>
  }

  export type SourceDocumentLinkUpdateManyWithWhereWithoutBlueprintSectionInput = {
    where: SourceDocumentLinkScalarWhereInput
    data: XOR<SourceDocumentLinkUpdateManyMutationInput, SourceDocumentLinkUncheckedUpdateManyWithoutBlueprintSectionInput>
  }

  export type CountyCreateWithoutQuotesInput = {
    id?: string
    name: string
    slug: string
    fipsCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blueprintSections?: BlueprintSectionCreateNestedManyWithoutCountyInput
    assets?: AssetCreateNestedManyWithoutCountyInput
    countyIssues?: CountyIssueCreateNestedManyWithoutCountyInput
    censusMetrics?: CensusMetricCreateNestedManyWithoutCountyInput
    blsMetrics?: BLSMetricCreateNestedManyWithoutCountyInput
    civicsOfficials?: CivicsOfficialCreateNestedManyWithoutCountyInput
    electionResults?: ElectionResultCreateNestedManyWithoutCountyInput
    surveyForms?: SurveyFormCreateNestedManyWithoutCountyInput
    surveyResponses?: SurveyResponseCreateNestedManyWithoutCountyInput
    aiOutputScopes?: AIOutputScopeCreateNestedManyWithoutCountyInput
    sourceLinks?: SourceDocumentLinkCreateNestedManyWithoutCountyInput
  }

  export type CountyUncheckedCreateWithoutQuotesInput = {
    id?: string
    name: string
    slug: string
    fipsCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blueprintSections?: BlueprintSectionUncheckedCreateNestedManyWithoutCountyInput
    assets?: AssetUncheckedCreateNestedManyWithoutCountyInput
    countyIssues?: CountyIssueUncheckedCreateNestedManyWithoutCountyInput
    censusMetrics?: CensusMetricUncheckedCreateNestedManyWithoutCountyInput
    blsMetrics?: BLSMetricUncheckedCreateNestedManyWithoutCountyInput
    civicsOfficials?: CivicsOfficialUncheckedCreateNestedManyWithoutCountyInput
    electionResults?: ElectionResultUncheckedCreateNestedManyWithoutCountyInput
    surveyForms?: SurveyFormUncheckedCreateNestedManyWithoutCountyInput
    surveyResponses?: SurveyResponseUncheckedCreateNestedManyWithoutCountyInput
    aiOutputScopes?: AIOutputScopeUncheckedCreateNestedManyWithoutCountyInput
    sourceLinks?: SourceDocumentLinkUncheckedCreateNestedManyWithoutCountyInput
  }

  export type CountyCreateOrConnectWithoutQuotesInput = {
    where: CountyWhereUniqueInput
    create: XOR<CountyCreateWithoutQuotesInput, CountyUncheckedCreateWithoutQuotesInput>
  }

  export type IssueCreateWithoutQuotesInput = {
    id?: string
    name: string
    slug: string
    summary?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    countyIssues?: CountyIssueCreateNestedManyWithoutIssueInput
    blueprintSections?: BlueprintSectionCreateNestedManyWithoutIssueInput
    assets?: AssetCreateNestedManyWithoutIssueInput
    aiOutputScopes?: AIOutputScopeCreateNestedManyWithoutIssueInput
    sourceLinks?: SourceDocumentLinkCreateNestedManyWithoutIssueInput
  }

  export type IssueUncheckedCreateWithoutQuotesInput = {
    id?: string
    name: string
    slug: string
    summary?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    countyIssues?: CountyIssueUncheckedCreateNestedManyWithoutIssueInput
    blueprintSections?: BlueprintSectionUncheckedCreateNestedManyWithoutIssueInput
    assets?: AssetUncheckedCreateNestedManyWithoutIssueInput
    aiOutputScopes?: AIOutputScopeUncheckedCreateNestedManyWithoutIssueInput
    sourceLinks?: SourceDocumentLinkUncheckedCreateNestedManyWithoutIssueInput
  }

  export type IssueCreateOrConnectWithoutQuotesInput = {
    where: IssueWhereUniqueInput
    create: XOR<IssueCreateWithoutQuotesInput, IssueUncheckedCreateWithoutQuotesInput>
  }

  export type SourceDocumentLinkCreateWithoutQuoteInput = {
    id?: string
    note?: string | null
    createdAt?: Date | string
    sourceDocument: SourceDocumentCreateNestedOneWithoutSourceLinksInput
    county?: CountyCreateNestedOneWithoutSourceLinksInput
    issue?: IssueCreateNestedOneWithoutSourceLinksInput
    blueprintSection?: BlueprintSectionCreateNestedOneWithoutSourceLinksInput
    asset?: AssetCreateNestedOneWithoutSourceLinksInput
    surveyForm?: SurveyFormCreateNestedOneWithoutSourceLinksInput
  }

  export type SourceDocumentLinkUncheckedCreateWithoutQuoteInput = {
    id?: string
    sourceDocumentId: string
    countyId?: string | null
    issueId?: string | null
    blueprintSectionId?: string | null
    assetId?: string | null
    surveyFormId?: string | null
    note?: string | null
    createdAt?: Date | string
  }

  export type SourceDocumentLinkCreateOrConnectWithoutQuoteInput = {
    where: SourceDocumentLinkWhereUniqueInput
    create: XOR<SourceDocumentLinkCreateWithoutQuoteInput, SourceDocumentLinkUncheckedCreateWithoutQuoteInput>
  }

  export type SourceDocumentLinkCreateManyQuoteInputEnvelope = {
    data: SourceDocumentLinkCreateManyQuoteInput | SourceDocumentLinkCreateManyQuoteInput[]
    skipDuplicates?: boolean
  }

  export type CountyUpsertWithoutQuotesInput = {
    update: XOR<CountyUpdateWithoutQuotesInput, CountyUncheckedUpdateWithoutQuotesInput>
    create: XOR<CountyCreateWithoutQuotesInput, CountyUncheckedCreateWithoutQuotesInput>
    where?: CountyWhereInput
  }

  export type CountyUpdateToOneWithWhereWithoutQuotesInput = {
    where?: CountyWhereInput
    data: XOR<CountyUpdateWithoutQuotesInput, CountyUncheckedUpdateWithoutQuotesInput>
  }

  export type CountyUpdateWithoutQuotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fipsCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blueprintSections?: BlueprintSectionUpdateManyWithoutCountyNestedInput
    assets?: AssetUpdateManyWithoutCountyNestedInput
    countyIssues?: CountyIssueUpdateManyWithoutCountyNestedInput
    censusMetrics?: CensusMetricUpdateManyWithoutCountyNestedInput
    blsMetrics?: BLSMetricUpdateManyWithoutCountyNestedInput
    civicsOfficials?: CivicsOfficialUpdateManyWithoutCountyNestedInput
    electionResults?: ElectionResultUpdateManyWithoutCountyNestedInput
    surveyForms?: SurveyFormUpdateManyWithoutCountyNestedInput
    surveyResponses?: SurveyResponseUpdateManyWithoutCountyNestedInput
    aiOutputScopes?: AIOutputScopeUpdateManyWithoutCountyNestedInput
    sourceLinks?: SourceDocumentLinkUpdateManyWithoutCountyNestedInput
  }

  export type CountyUncheckedUpdateWithoutQuotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fipsCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blueprintSections?: BlueprintSectionUncheckedUpdateManyWithoutCountyNestedInput
    assets?: AssetUncheckedUpdateManyWithoutCountyNestedInput
    countyIssues?: CountyIssueUncheckedUpdateManyWithoutCountyNestedInput
    censusMetrics?: CensusMetricUncheckedUpdateManyWithoutCountyNestedInput
    blsMetrics?: BLSMetricUncheckedUpdateManyWithoutCountyNestedInput
    civicsOfficials?: CivicsOfficialUncheckedUpdateManyWithoutCountyNestedInput
    electionResults?: ElectionResultUncheckedUpdateManyWithoutCountyNestedInput
    surveyForms?: SurveyFormUncheckedUpdateManyWithoutCountyNestedInput
    surveyResponses?: SurveyResponseUncheckedUpdateManyWithoutCountyNestedInput
    aiOutputScopes?: AIOutputScopeUncheckedUpdateManyWithoutCountyNestedInput
    sourceLinks?: SourceDocumentLinkUncheckedUpdateManyWithoutCountyNestedInput
  }

  export type IssueUpsertWithoutQuotesInput = {
    update: XOR<IssueUpdateWithoutQuotesInput, IssueUncheckedUpdateWithoutQuotesInput>
    create: XOR<IssueCreateWithoutQuotesInput, IssueUncheckedCreateWithoutQuotesInput>
    where?: IssueWhereInput
  }

  export type IssueUpdateToOneWithWhereWithoutQuotesInput = {
    where?: IssueWhereInput
    data: XOR<IssueUpdateWithoutQuotesInput, IssueUncheckedUpdateWithoutQuotesInput>
  }

  export type IssueUpdateWithoutQuotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    countyIssues?: CountyIssueUpdateManyWithoutIssueNestedInput
    blueprintSections?: BlueprintSectionUpdateManyWithoutIssueNestedInput
    assets?: AssetUpdateManyWithoutIssueNestedInput
    aiOutputScopes?: AIOutputScopeUpdateManyWithoutIssueNestedInput
    sourceLinks?: SourceDocumentLinkUpdateManyWithoutIssueNestedInput
  }

  export type IssueUncheckedUpdateWithoutQuotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    countyIssues?: CountyIssueUncheckedUpdateManyWithoutIssueNestedInput
    blueprintSections?: BlueprintSectionUncheckedUpdateManyWithoutIssueNestedInput
    assets?: AssetUncheckedUpdateManyWithoutIssueNestedInput
    aiOutputScopes?: AIOutputScopeUncheckedUpdateManyWithoutIssueNestedInput
    sourceLinks?: SourceDocumentLinkUncheckedUpdateManyWithoutIssueNestedInput
  }

  export type SourceDocumentLinkUpsertWithWhereUniqueWithoutQuoteInput = {
    where: SourceDocumentLinkWhereUniqueInput
    update: XOR<SourceDocumentLinkUpdateWithoutQuoteInput, SourceDocumentLinkUncheckedUpdateWithoutQuoteInput>
    create: XOR<SourceDocumentLinkCreateWithoutQuoteInput, SourceDocumentLinkUncheckedCreateWithoutQuoteInput>
  }

  export type SourceDocumentLinkUpdateWithWhereUniqueWithoutQuoteInput = {
    where: SourceDocumentLinkWhereUniqueInput
    data: XOR<SourceDocumentLinkUpdateWithoutQuoteInput, SourceDocumentLinkUncheckedUpdateWithoutQuoteInput>
  }

  export type SourceDocumentLinkUpdateManyWithWhereWithoutQuoteInput = {
    where: SourceDocumentLinkScalarWhereInput
    data: XOR<SourceDocumentLinkUpdateManyMutationInput, SourceDocumentLinkUncheckedUpdateManyWithoutQuoteInput>
  }

  export type CountyCreateWithoutAssetsInput = {
    id?: string
    name: string
    slug: string
    fipsCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blueprintSections?: BlueprintSectionCreateNestedManyWithoutCountyInput
    quotes?: QuoteCreateNestedManyWithoutCountyInput
    countyIssues?: CountyIssueCreateNestedManyWithoutCountyInput
    censusMetrics?: CensusMetricCreateNestedManyWithoutCountyInput
    blsMetrics?: BLSMetricCreateNestedManyWithoutCountyInput
    civicsOfficials?: CivicsOfficialCreateNestedManyWithoutCountyInput
    electionResults?: ElectionResultCreateNestedManyWithoutCountyInput
    surveyForms?: SurveyFormCreateNestedManyWithoutCountyInput
    surveyResponses?: SurveyResponseCreateNestedManyWithoutCountyInput
    aiOutputScopes?: AIOutputScopeCreateNestedManyWithoutCountyInput
    sourceLinks?: SourceDocumentLinkCreateNestedManyWithoutCountyInput
  }

  export type CountyUncheckedCreateWithoutAssetsInput = {
    id?: string
    name: string
    slug: string
    fipsCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blueprintSections?: BlueprintSectionUncheckedCreateNestedManyWithoutCountyInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutCountyInput
    countyIssues?: CountyIssueUncheckedCreateNestedManyWithoutCountyInput
    censusMetrics?: CensusMetricUncheckedCreateNestedManyWithoutCountyInput
    blsMetrics?: BLSMetricUncheckedCreateNestedManyWithoutCountyInput
    civicsOfficials?: CivicsOfficialUncheckedCreateNestedManyWithoutCountyInput
    electionResults?: ElectionResultUncheckedCreateNestedManyWithoutCountyInput
    surveyForms?: SurveyFormUncheckedCreateNestedManyWithoutCountyInput
    surveyResponses?: SurveyResponseUncheckedCreateNestedManyWithoutCountyInput
    aiOutputScopes?: AIOutputScopeUncheckedCreateNestedManyWithoutCountyInput
    sourceLinks?: SourceDocumentLinkUncheckedCreateNestedManyWithoutCountyInput
  }

  export type CountyCreateOrConnectWithoutAssetsInput = {
    where: CountyWhereUniqueInput
    create: XOR<CountyCreateWithoutAssetsInput, CountyUncheckedCreateWithoutAssetsInput>
  }

  export type IssueCreateWithoutAssetsInput = {
    id?: string
    name: string
    slug: string
    summary?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    countyIssues?: CountyIssueCreateNestedManyWithoutIssueInput
    blueprintSections?: BlueprintSectionCreateNestedManyWithoutIssueInput
    quotes?: QuoteCreateNestedManyWithoutIssueInput
    aiOutputScopes?: AIOutputScopeCreateNestedManyWithoutIssueInput
    sourceLinks?: SourceDocumentLinkCreateNestedManyWithoutIssueInput
  }

  export type IssueUncheckedCreateWithoutAssetsInput = {
    id?: string
    name: string
    slug: string
    summary?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    countyIssues?: CountyIssueUncheckedCreateNestedManyWithoutIssueInput
    blueprintSections?: BlueprintSectionUncheckedCreateNestedManyWithoutIssueInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutIssueInput
    aiOutputScopes?: AIOutputScopeUncheckedCreateNestedManyWithoutIssueInput
    sourceLinks?: SourceDocumentLinkUncheckedCreateNestedManyWithoutIssueInput
  }

  export type IssueCreateOrConnectWithoutAssetsInput = {
    where: IssueWhereUniqueInput
    create: XOR<IssueCreateWithoutAssetsInput, IssueUncheckedCreateWithoutAssetsInput>
  }

  export type SourceDocumentLinkCreateWithoutAssetInput = {
    id?: string
    note?: string | null
    createdAt?: Date | string
    sourceDocument: SourceDocumentCreateNestedOneWithoutSourceLinksInput
    county?: CountyCreateNestedOneWithoutSourceLinksInput
    issue?: IssueCreateNestedOneWithoutSourceLinksInput
    blueprintSection?: BlueprintSectionCreateNestedOneWithoutSourceLinksInput
    quote?: QuoteCreateNestedOneWithoutSourceLinksInput
    surveyForm?: SurveyFormCreateNestedOneWithoutSourceLinksInput
  }

  export type SourceDocumentLinkUncheckedCreateWithoutAssetInput = {
    id?: string
    sourceDocumentId: string
    countyId?: string | null
    issueId?: string | null
    blueprintSectionId?: string | null
    quoteId?: string | null
    surveyFormId?: string | null
    note?: string | null
    createdAt?: Date | string
  }

  export type SourceDocumentLinkCreateOrConnectWithoutAssetInput = {
    where: SourceDocumentLinkWhereUniqueInput
    create: XOR<SourceDocumentLinkCreateWithoutAssetInput, SourceDocumentLinkUncheckedCreateWithoutAssetInput>
  }

  export type SourceDocumentLinkCreateManyAssetInputEnvelope = {
    data: SourceDocumentLinkCreateManyAssetInput | SourceDocumentLinkCreateManyAssetInput[]
    skipDuplicates?: boolean
  }

  export type CountyUpsertWithoutAssetsInput = {
    update: XOR<CountyUpdateWithoutAssetsInput, CountyUncheckedUpdateWithoutAssetsInput>
    create: XOR<CountyCreateWithoutAssetsInput, CountyUncheckedCreateWithoutAssetsInput>
    where?: CountyWhereInput
  }

  export type CountyUpdateToOneWithWhereWithoutAssetsInput = {
    where?: CountyWhereInput
    data: XOR<CountyUpdateWithoutAssetsInput, CountyUncheckedUpdateWithoutAssetsInput>
  }

  export type CountyUpdateWithoutAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fipsCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blueprintSections?: BlueprintSectionUpdateManyWithoutCountyNestedInput
    quotes?: QuoteUpdateManyWithoutCountyNestedInput
    countyIssues?: CountyIssueUpdateManyWithoutCountyNestedInput
    censusMetrics?: CensusMetricUpdateManyWithoutCountyNestedInput
    blsMetrics?: BLSMetricUpdateManyWithoutCountyNestedInput
    civicsOfficials?: CivicsOfficialUpdateManyWithoutCountyNestedInput
    electionResults?: ElectionResultUpdateManyWithoutCountyNestedInput
    surveyForms?: SurveyFormUpdateManyWithoutCountyNestedInput
    surveyResponses?: SurveyResponseUpdateManyWithoutCountyNestedInput
    aiOutputScopes?: AIOutputScopeUpdateManyWithoutCountyNestedInput
    sourceLinks?: SourceDocumentLinkUpdateManyWithoutCountyNestedInput
  }

  export type CountyUncheckedUpdateWithoutAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fipsCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blueprintSections?: BlueprintSectionUncheckedUpdateManyWithoutCountyNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutCountyNestedInput
    countyIssues?: CountyIssueUncheckedUpdateManyWithoutCountyNestedInput
    censusMetrics?: CensusMetricUncheckedUpdateManyWithoutCountyNestedInput
    blsMetrics?: BLSMetricUncheckedUpdateManyWithoutCountyNestedInput
    civicsOfficials?: CivicsOfficialUncheckedUpdateManyWithoutCountyNestedInput
    electionResults?: ElectionResultUncheckedUpdateManyWithoutCountyNestedInput
    surveyForms?: SurveyFormUncheckedUpdateManyWithoutCountyNestedInput
    surveyResponses?: SurveyResponseUncheckedUpdateManyWithoutCountyNestedInput
    aiOutputScopes?: AIOutputScopeUncheckedUpdateManyWithoutCountyNestedInput
    sourceLinks?: SourceDocumentLinkUncheckedUpdateManyWithoutCountyNestedInput
  }

  export type IssueUpsertWithoutAssetsInput = {
    update: XOR<IssueUpdateWithoutAssetsInput, IssueUncheckedUpdateWithoutAssetsInput>
    create: XOR<IssueCreateWithoutAssetsInput, IssueUncheckedCreateWithoutAssetsInput>
    where?: IssueWhereInput
  }

  export type IssueUpdateToOneWithWhereWithoutAssetsInput = {
    where?: IssueWhereInput
    data: XOR<IssueUpdateWithoutAssetsInput, IssueUncheckedUpdateWithoutAssetsInput>
  }

  export type IssueUpdateWithoutAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    countyIssues?: CountyIssueUpdateManyWithoutIssueNestedInput
    blueprintSections?: BlueprintSectionUpdateManyWithoutIssueNestedInput
    quotes?: QuoteUpdateManyWithoutIssueNestedInput
    aiOutputScopes?: AIOutputScopeUpdateManyWithoutIssueNestedInput
    sourceLinks?: SourceDocumentLinkUpdateManyWithoutIssueNestedInput
  }

  export type IssueUncheckedUpdateWithoutAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    countyIssues?: CountyIssueUncheckedUpdateManyWithoutIssueNestedInput
    blueprintSections?: BlueprintSectionUncheckedUpdateManyWithoutIssueNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutIssueNestedInput
    aiOutputScopes?: AIOutputScopeUncheckedUpdateManyWithoutIssueNestedInput
    sourceLinks?: SourceDocumentLinkUncheckedUpdateManyWithoutIssueNestedInput
  }

  export type SourceDocumentLinkUpsertWithWhereUniqueWithoutAssetInput = {
    where: SourceDocumentLinkWhereUniqueInput
    update: XOR<SourceDocumentLinkUpdateWithoutAssetInput, SourceDocumentLinkUncheckedUpdateWithoutAssetInput>
    create: XOR<SourceDocumentLinkCreateWithoutAssetInput, SourceDocumentLinkUncheckedCreateWithoutAssetInput>
  }

  export type SourceDocumentLinkUpdateWithWhereUniqueWithoutAssetInput = {
    where: SourceDocumentLinkWhereUniqueInput
    data: XOR<SourceDocumentLinkUpdateWithoutAssetInput, SourceDocumentLinkUncheckedUpdateWithoutAssetInput>
  }

  export type SourceDocumentLinkUpdateManyWithWhereWithoutAssetInput = {
    where: SourceDocumentLinkScalarWhereInput
    data: XOR<SourceDocumentLinkUpdateManyMutationInput, SourceDocumentLinkUncheckedUpdateManyWithoutAssetInput>
  }

  export type SourceChunkCreateWithoutSourceDocumentInput = {
    id?: string
    chunkIndex: number
    content: string
    contentHash: string
    locatorJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    citations?: CitationCreateNestedManyWithoutSourceChunkInput
  }

  export type SourceChunkUncheckedCreateWithoutSourceDocumentInput = {
    id?: string
    chunkIndex: number
    content: string
    contentHash: string
    locatorJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    citations?: CitationUncheckedCreateNestedManyWithoutSourceChunkInput
  }

  export type SourceChunkCreateOrConnectWithoutSourceDocumentInput = {
    where: SourceChunkWhereUniqueInput
    create: XOR<SourceChunkCreateWithoutSourceDocumentInput, SourceChunkUncheckedCreateWithoutSourceDocumentInput>
  }

  export type SourceChunkCreateManySourceDocumentInputEnvelope = {
    data: SourceChunkCreateManySourceDocumentInput | SourceChunkCreateManySourceDocumentInput[]
    skipDuplicates?: boolean
  }

  export type CitationCreateWithoutSourceDocumentInput = {
    id?: string
    label?: string | null
    locatorJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    outputSection: AIOutputSectionCreateNestedOneWithoutCitationsInput
    sourceChunk?: SourceChunkCreateNestedOneWithoutCitationsInput
  }

  export type CitationUncheckedCreateWithoutSourceDocumentInput = {
    id?: string
    outputSectionId: string
    sourceChunkId?: string | null
    label?: string | null
    locatorJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type CitationCreateOrConnectWithoutSourceDocumentInput = {
    where: CitationWhereUniqueInput
    create: XOR<CitationCreateWithoutSourceDocumentInput, CitationUncheckedCreateWithoutSourceDocumentInput>
  }

  export type CitationCreateManySourceDocumentInputEnvelope = {
    data: CitationCreateManySourceDocumentInput | CitationCreateManySourceDocumentInput[]
    skipDuplicates?: boolean
  }

  export type AIRunInputSourceCreateWithoutSourceDocumentInput = {
    id?: string
    kind?: $Enums.AIRunInputKind
    externalKey?: string | null
    notes?: string | null
    createdAt?: Date | string
    run: AIRunCreateNestedOneWithoutInputSourcesInput
  }

  export type AIRunInputSourceUncheckedCreateWithoutSourceDocumentInput = {
    id?: string
    runId: string
    kind?: $Enums.AIRunInputKind
    externalKey?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type AIRunInputSourceCreateOrConnectWithoutSourceDocumentInput = {
    where: AIRunInputSourceWhereUniqueInput
    create: XOR<AIRunInputSourceCreateWithoutSourceDocumentInput, AIRunInputSourceUncheckedCreateWithoutSourceDocumentInput>
  }

  export type AIRunInputSourceCreateManySourceDocumentInputEnvelope = {
    data: AIRunInputSourceCreateManySourceDocumentInput | AIRunInputSourceCreateManySourceDocumentInput[]
    skipDuplicates?: boolean
  }

  export type SourceDocumentLinkCreateWithoutSourceDocumentInput = {
    id?: string
    note?: string | null
    createdAt?: Date | string
    county?: CountyCreateNestedOneWithoutSourceLinksInput
    issue?: IssueCreateNestedOneWithoutSourceLinksInput
    blueprintSection?: BlueprintSectionCreateNestedOneWithoutSourceLinksInput
    quote?: QuoteCreateNestedOneWithoutSourceLinksInput
    asset?: AssetCreateNestedOneWithoutSourceLinksInput
    surveyForm?: SurveyFormCreateNestedOneWithoutSourceLinksInput
  }

  export type SourceDocumentLinkUncheckedCreateWithoutSourceDocumentInput = {
    id?: string
    countyId?: string | null
    issueId?: string | null
    blueprintSectionId?: string | null
    quoteId?: string | null
    assetId?: string | null
    surveyFormId?: string | null
    note?: string | null
    createdAt?: Date | string
  }

  export type SourceDocumentLinkCreateOrConnectWithoutSourceDocumentInput = {
    where: SourceDocumentLinkWhereUniqueInput
    create: XOR<SourceDocumentLinkCreateWithoutSourceDocumentInput, SourceDocumentLinkUncheckedCreateWithoutSourceDocumentInput>
  }

  export type SourceDocumentLinkCreateManySourceDocumentInputEnvelope = {
    data: SourceDocumentLinkCreateManySourceDocumentInput | SourceDocumentLinkCreateManySourceDocumentInput[]
    skipDuplicates?: boolean
  }

  export type SourceChunkUpsertWithWhereUniqueWithoutSourceDocumentInput = {
    where: SourceChunkWhereUniqueInput
    update: XOR<SourceChunkUpdateWithoutSourceDocumentInput, SourceChunkUncheckedUpdateWithoutSourceDocumentInput>
    create: XOR<SourceChunkCreateWithoutSourceDocumentInput, SourceChunkUncheckedCreateWithoutSourceDocumentInput>
  }

  export type SourceChunkUpdateWithWhereUniqueWithoutSourceDocumentInput = {
    where: SourceChunkWhereUniqueInput
    data: XOR<SourceChunkUpdateWithoutSourceDocumentInput, SourceChunkUncheckedUpdateWithoutSourceDocumentInput>
  }

  export type SourceChunkUpdateManyWithWhereWithoutSourceDocumentInput = {
    where: SourceChunkScalarWhereInput
    data: XOR<SourceChunkUpdateManyMutationInput, SourceChunkUncheckedUpdateManyWithoutSourceDocumentInput>
  }

  export type SourceChunkScalarWhereInput = {
    AND?: SourceChunkScalarWhereInput | SourceChunkScalarWhereInput[]
    OR?: SourceChunkScalarWhereInput[]
    NOT?: SourceChunkScalarWhereInput | SourceChunkScalarWhereInput[]
    id?: UuidFilter<"SourceChunk"> | string
    sourceDocumentId?: UuidFilter<"SourceChunk"> | string
    chunkIndex?: IntFilter<"SourceChunk"> | number
    content?: StringFilter<"SourceChunk"> | string
    contentHash?: StringFilter<"SourceChunk"> | string
    locatorJson?: JsonNullableFilter<"SourceChunk">
    createdAt?: DateTimeFilter<"SourceChunk"> | Date | string
  }

  export type CitationUpsertWithWhereUniqueWithoutSourceDocumentInput = {
    where: CitationWhereUniqueInput
    update: XOR<CitationUpdateWithoutSourceDocumentInput, CitationUncheckedUpdateWithoutSourceDocumentInput>
    create: XOR<CitationCreateWithoutSourceDocumentInput, CitationUncheckedCreateWithoutSourceDocumentInput>
  }

  export type CitationUpdateWithWhereUniqueWithoutSourceDocumentInput = {
    where: CitationWhereUniqueInput
    data: XOR<CitationUpdateWithoutSourceDocumentInput, CitationUncheckedUpdateWithoutSourceDocumentInput>
  }

  export type CitationUpdateManyWithWhereWithoutSourceDocumentInput = {
    where: CitationScalarWhereInput
    data: XOR<CitationUpdateManyMutationInput, CitationUncheckedUpdateManyWithoutSourceDocumentInput>
  }

  export type CitationScalarWhereInput = {
    AND?: CitationScalarWhereInput | CitationScalarWhereInput[]
    OR?: CitationScalarWhereInput[]
    NOT?: CitationScalarWhereInput | CitationScalarWhereInput[]
    id?: UuidFilter<"Citation"> | string
    outputSectionId?: UuidFilter<"Citation"> | string
    sourceChunkId?: UuidNullableFilter<"Citation"> | string | null
    sourceDocumentId?: UuidNullableFilter<"Citation"> | string | null
    label?: StringNullableFilter<"Citation"> | string | null
    locatorJson?: JsonNullableFilter<"Citation">
    createdAt?: DateTimeFilter<"Citation"> | Date | string
  }

  export type AIRunInputSourceUpsertWithWhereUniqueWithoutSourceDocumentInput = {
    where: AIRunInputSourceWhereUniqueInput
    update: XOR<AIRunInputSourceUpdateWithoutSourceDocumentInput, AIRunInputSourceUncheckedUpdateWithoutSourceDocumentInput>
    create: XOR<AIRunInputSourceCreateWithoutSourceDocumentInput, AIRunInputSourceUncheckedCreateWithoutSourceDocumentInput>
  }

  export type AIRunInputSourceUpdateWithWhereUniqueWithoutSourceDocumentInput = {
    where: AIRunInputSourceWhereUniqueInput
    data: XOR<AIRunInputSourceUpdateWithoutSourceDocumentInput, AIRunInputSourceUncheckedUpdateWithoutSourceDocumentInput>
  }

  export type AIRunInputSourceUpdateManyWithWhereWithoutSourceDocumentInput = {
    where: AIRunInputSourceScalarWhereInput
    data: XOR<AIRunInputSourceUpdateManyMutationInput, AIRunInputSourceUncheckedUpdateManyWithoutSourceDocumentInput>
  }

  export type AIRunInputSourceScalarWhereInput = {
    AND?: AIRunInputSourceScalarWhereInput | AIRunInputSourceScalarWhereInput[]
    OR?: AIRunInputSourceScalarWhereInput[]
    NOT?: AIRunInputSourceScalarWhereInput | AIRunInputSourceScalarWhereInput[]
    id?: UuidFilter<"AIRunInputSource"> | string
    runId?: UuidFilter<"AIRunInputSource"> | string
    kind?: EnumAIRunInputKindFilter<"AIRunInputSource"> | $Enums.AIRunInputKind
    sourceDocumentId?: UuidNullableFilter<"AIRunInputSource"> | string | null
    externalKey?: StringNullableFilter<"AIRunInputSource"> | string | null
    notes?: StringNullableFilter<"AIRunInputSource"> | string | null
    createdAt?: DateTimeFilter<"AIRunInputSource"> | Date | string
  }

  export type SourceDocumentLinkUpsertWithWhereUniqueWithoutSourceDocumentInput = {
    where: SourceDocumentLinkWhereUniqueInput
    update: XOR<SourceDocumentLinkUpdateWithoutSourceDocumentInput, SourceDocumentLinkUncheckedUpdateWithoutSourceDocumentInput>
    create: XOR<SourceDocumentLinkCreateWithoutSourceDocumentInput, SourceDocumentLinkUncheckedCreateWithoutSourceDocumentInput>
  }

  export type SourceDocumentLinkUpdateWithWhereUniqueWithoutSourceDocumentInput = {
    where: SourceDocumentLinkWhereUniqueInput
    data: XOR<SourceDocumentLinkUpdateWithoutSourceDocumentInput, SourceDocumentLinkUncheckedUpdateWithoutSourceDocumentInput>
  }

  export type SourceDocumentLinkUpdateManyWithWhereWithoutSourceDocumentInput = {
    where: SourceDocumentLinkScalarWhereInput
    data: XOR<SourceDocumentLinkUpdateManyMutationInput, SourceDocumentLinkUncheckedUpdateManyWithoutSourceDocumentInput>
  }

  export type SourceDocumentCreateWithoutChunksInput = {
    id?: string
    title: string
    url?: string | null
    storageKey?: string | null
    publisher?: string | null
    publishedAt?: Date | string | null
    capturedAt?: Date | string | null
    methodNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    citations?: CitationCreateNestedManyWithoutSourceDocumentInput
    runInputs?: AIRunInputSourceCreateNestedManyWithoutSourceDocumentInput
    sourceLinks?: SourceDocumentLinkCreateNestedManyWithoutSourceDocumentInput
  }

  export type SourceDocumentUncheckedCreateWithoutChunksInput = {
    id?: string
    title: string
    url?: string | null
    storageKey?: string | null
    publisher?: string | null
    publishedAt?: Date | string | null
    capturedAt?: Date | string | null
    methodNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    citations?: CitationUncheckedCreateNestedManyWithoutSourceDocumentInput
    runInputs?: AIRunInputSourceUncheckedCreateNestedManyWithoutSourceDocumentInput
    sourceLinks?: SourceDocumentLinkUncheckedCreateNestedManyWithoutSourceDocumentInput
  }

  export type SourceDocumentCreateOrConnectWithoutChunksInput = {
    where: SourceDocumentWhereUniqueInput
    create: XOR<SourceDocumentCreateWithoutChunksInput, SourceDocumentUncheckedCreateWithoutChunksInput>
  }

  export type CitationCreateWithoutSourceChunkInput = {
    id?: string
    label?: string | null
    locatorJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    outputSection: AIOutputSectionCreateNestedOneWithoutCitationsInput
    sourceDocument?: SourceDocumentCreateNestedOneWithoutCitationsInput
  }

  export type CitationUncheckedCreateWithoutSourceChunkInput = {
    id?: string
    outputSectionId: string
    sourceDocumentId?: string | null
    label?: string | null
    locatorJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type CitationCreateOrConnectWithoutSourceChunkInput = {
    where: CitationWhereUniqueInput
    create: XOR<CitationCreateWithoutSourceChunkInput, CitationUncheckedCreateWithoutSourceChunkInput>
  }

  export type CitationCreateManySourceChunkInputEnvelope = {
    data: CitationCreateManySourceChunkInput | CitationCreateManySourceChunkInput[]
    skipDuplicates?: boolean
  }

  export type SourceDocumentUpsertWithoutChunksInput = {
    update: XOR<SourceDocumentUpdateWithoutChunksInput, SourceDocumentUncheckedUpdateWithoutChunksInput>
    create: XOR<SourceDocumentCreateWithoutChunksInput, SourceDocumentUncheckedCreateWithoutChunksInput>
    where?: SourceDocumentWhereInput
  }

  export type SourceDocumentUpdateToOneWithWhereWithoutChunksInput = {
    where?: SourceDocumentWhereInput
    data: XOR<SourceDocumentUpdateWithoutChunksInput, SourceDocumentUncheckedUpdateWithoutChunksInput>
  }

  export type SourceDocumentUpdateWithoutChunksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    methodNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    citations?: CitationUpdateManyWithoutSourceDocumentNestedInput
    runInputs?: AIRunInputSourceUpdateManyWithoutSourceDocumentNestedInput
    sourceLinks?: SourceDocumentLinkUpdateManyWithoutSourceDocumentNestedInput
  }

  export type SourceDocumentUncheckedUpdateWithoutChunksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    methodNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    citations?: CitationUncheckedUpdateManyWithoutSourceDocumentNestedInput
    runInputs?: AIRunInputSourceUncheckedUpdateManyWithoutSourceDocumentNestedInput
    sourceLinks?: SourceDocumentLinkUncheckedUpdateManyWithoutSourceDocumentNestedInput
  }

  export type CitationUpsertWithWhereUniqueWithoutSourceChunkInput = {
    where: CitationWhereUniqueInput
    update: XOR<CitationUpdateWithoutSourceChunkInput, CitationUncheckedUpdateWithoutSourceChunkInput>
    create: XOR<CitationCreateWithoutSourceChunkInput, CitationUncheckedCreateWithoutSourceChunkInput>
  }

  export type CitationUpdateWithWhereUniqueWithoutSourceChunkInput = {
    where: CitationWhereUniqueInput
    data: XOR<CitationUpdateWithoutSourceChunkInput, CitationUncheckedUpdateWithoutSourceChunkInput>
  }

  export type CitationUpdateManyWithWhereWithoutSourceChunkInput = {
    where: CitationScalarWhereInput
    data: XOR<CitationUpdateManyMutationInput, CitationUncheckedUpdateManyWithoutSourceChunkInput>
  }

  export type SourceDocumentCreateWithoutSourceLinksInput = {
    id?: string
    title: string
    url?: string | null
    storageKey?: string | null
    publisher?: string | null
    publishedAt?: Date | string | null
    capturedAt?: Date | string | null
    methodNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    chunks?: SourceChunkCreateNestedManyWithoutSourceDocumentInput
    citations?: CitationCreateNestedManyWithoutSourceDocumentInput
    runInputs?: AIRunInputSourceCreateNestedManyWithoutSourceDocumentInput
  }

  export type SourceDocumentUncheckedCreateWithoutSourceLinksInput = {
    id?: string
    title: string
    url?: string | null
    storageKey?: string | null
    publisher?: string | null
    publishedAt?: Date | string | null
    capturedAt?: Date | string | null
    methodNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    chunks?: SourceChunkUncheckedCreateNestedManyWithoutSourceDocumentInput
    citations?: CitationUncheckedCreateNestedManyWithoutSourceDocumentInput
    runInputs?: AIRunInputSourceUncheckedCreateNestedManyWithoutSourceDocumentInput
  }

  export type SourceDocumentCreateOrConnectWithoutSourceLinksInput = {
    where: SourceDocumentWhereUniqueInput
    create: XOR<SourceDocumentCreateWithoutSourceLinksInput, SourceDocumentUncheckedCreateWithoutSourceLinksInput>
  }

  export type CountyCreateWithoutSourceLinksInput = {
    id?: string
    name: string
    slug: string
    fipsCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blueprintSections?: BlueprintSectionCreateNestedManyWithoutCountyInput
    quotes?: QuoteCreateNestedManyWithoutCountyInput
    assets?: AssetCreateNestedManyWithoutCountyInput
    countyIssues?: CountyIssueCreateNestedManyWithoutCountyInput
    censusMetrics?: CensusMetricCreateNestedManyWithoutCountyInput
    blsMetrics?: BLSMetricCreateNestedManyWithoutCountyInput
    civicsOfficials?: CivicsOfficialCreateNestedManyWithoutCountyInput
    electionResults?: ElectionResultCreateNestedManyWithoutCountyInput
    surveyForms?: SurveyFormCreateNestedManyWithoutCountyInput
    surveyResponses?: SurveyResponseCreateNestedManyWithoutCountyInput
    aiOutputScopes?: AIOutputScopeCreateNestedManyWithoutCountyInput
  }

  export type CountyUncheckedCreateWithoutSourceLinksInput = {
    id?: string
    name: string
    slug: string
    fipsCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blueprintSections?: BlueprintSectionUncheckedCreateNestedManyWithoutCountyInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutCountyInput
    assets?: AssetUncheckedCreateNestedManyWithoutCountyInput
    countyIssues?: CountyIssueUncheckedCreateNestedManyWithoutCountyInput
    censusMetrics?: CensusMetricUncheckedCreateNestedManyWithoutCountyInput
    blsMetrics?: BLSMetricUncheckedCreateNestedManyWithoutCountyInput
    civicsOfficials?: CivicsOfficialUncheckedCreateNestedManyWithoutCountyInput
    electionResults?: ElectionResultUncheckedCreateNestedManyWithoutCountyInput
    surveyForms?: SurveyFormUncheckedCreateNestedManyWithoutCountyInput
    surveyResponses?: SurveyResponseUncheckedCreateNestedManyWithoutCountyInput
    aiOutputScopes?: AIOutputScopeUncheckedCreateNestedManyWithoutCountyInput
  }

  export type CountyCreateOrConnectWithoutSourceLinksInput = {
    where: CountyWhereUniqueInput
    create: XOR<CountyCreateWithoutSourceLinksInput, CountyUncheckedCreateWithoutSourceLinksInput>
  }

  export type IssueCreateWithoutSourceLinksInput = {
    id?: string
    name: string
    slug: string
    summary?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    countyIssues?: CountyIssueCreateNestedManyWithoutIssueInput
    blueprintSections?: BlueprintSectionCreateNestedManyWithoutIssueInput
    quotes?: QuoteCreateNestedManyWithoutIssueInput
    assets?: AssetCreateNestedManyWithoutIssueInput
    aiOutputScopes?: AIOutputScopeCreateNestedManyWithoutIssueInput
  }

  export type IssueUncheckedCreateWithoutSourceLinksInput = {
    id?: string
    name: string
    slug: string
    summary?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    countyIssues?: CountyIssueUncheckedCreateNestedManyWithoutIssueInput
    blueprintSections?: BlueprintSectionUncheckedCreateNestedManyWithoutIssueInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutIssueInput
    assets?: AssetUncheckedCreateNestedManyWithoutIssueInput
    aiOutputScopes?: AIOutputScopeUncheckedCreateNestedManyWithoutIssueInput
  }

  export type IssueCreateOrConnectWithoutSourceLinksInput = {
    where: IssueWhereUniqueInput
    create: XOR<IssueCreateWithoutSourceLinksInput, IssueUncheckedCreateWithoutSourceLinksInput>
  }

  export type BlueprintSectionCreateWithoutSourceLinksInput = {
    id?: string
    slug: string
    title: string
    bodyMd: string
    sortOrder?: number | null
    isPinned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    county?: CountyCreateNestedOneWithoutBlueprintSectionsInput
    issue?: IssueCreateNestedOneWithoutBlueprintSectionsInput
  }

  export type BlueprintSectionUncheckedCreateWithoutSourceLinksInput = {
    id?: string
    slug: string
    title: string
    bodyMd: string
    countyId?: string | null
    issueId?: string | null
    sortOrder?: number | null
    isPinned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlueprintSectionCreateOrConnectWithoutSourceLinksInput = {
    where: BlueprintSectionWhereUniqueInput
    create: XOR<BlueprintSectionCreateWithoutSourceLinksInput, BlueprintSectionUncheckedCreateWithoutSourceLinksInput>
  }

  export type QuoteCreateWithoutSourceLinksInput = {
    id?: string
    text: string
    attributionLabel?: string | null
    sourceNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    county: CountyCreateNestedOneWithoutQuotesInput
    issue?: IssueCreateNestedOneWithoutQuotesInput
  }

  export type QuoteUncheckedCreateWithoutSourceLinksInput = {
    id?: string
    text: string
    attributionLabel?: string | null
    countyId: string
    issueId?: string | null
    sourceNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuoteCreateOrConnectWithoutSourceLinksInput = {
    where: QuoteWhereUniqueInput
    create: XOR<QuoteCreateWithoutSourceLinksInput, QuoteUncheckedCreateWithoutSourceLinksInput>
  }

  export type AssetCreateWithoutSourceLinksInput = {
    id?: string
    assetType?: $Enums.AssetType
    title?: string | null
    caption?: string | null
    credit?: string | null
    license?: string | null
    url?: string | null
    storageKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    county?: CountyCreateNestedOneWithoutAssetsInput
    issue?: IssueCreateNestedOneWithoutAssetsInput
  }

  export type AssetUncheckedCreateWithoutSourceLinksInput = {
    id?: string
    assetType?: $Enums.AssetType
    title?: string | null
    caption?: string | null
    credit?: string | null
    license?: string | null
    url?: string | null
    storageKey?: string | null
    countyId?: string | null
    issueId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssetCreateOrConnectWithoutSourceLinksInput = {
    where: AssetWhereUniqueInput
    create: XOR<AssetCreateWithoutSourceLinksInput, AssetUncheckedCreateWithoutSourceLinksInput>
  }

  export type SurveyFormCreateWithoutSourceLinksInput = {
    id?: string
    title: string
    descriptionMd?: string | null
    slug: string
    status?: $Enums.SurveyFormStatus
    startAt?: Date | string | null
    endAt?: Date | string | null
    contextLabel?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    county?: CountyCreateNestedOneWithoutSurveyFormsInput
    questions?: SurveyQuestionCreateNestedManyWithoutFormInput
    responses?: SurveyResponseCreateNestedManyWithoutFormInput
  }

  export type SurveyFormUncheckedCreateWithoutSourceLinksInput = {
    id?: string
    title: string
    descriptionMd?: string | null
    slug: string
    status?: $Enums.SurveyFormStatus
    startAt?: Date | string | null
    endAt?: Date | string | null
    countyId?: string | null
    contextLabel?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: SurveyQuestionUncheckedCreateNestedManyWithoutFormInput
    responses?: SurveyResponseUncheckedCreateNestedManyWithoutFormInput
  }

  export type SurveyFormCreateOrConnectWithoutSourceLinksInput = {
    where: SurveyFormWhereUniqueInput
    create: XOR<SurveyFormCreateWithoutSourceLinksInput, SurveyFormUncheckedCreateWithoutSourceLinksInput>
  }

  export type SourceDocumentUpsertWithoutSourceLinksInput = {
    update: XOR<SourceDocumentUpdateWithoutSourceLinksInput, SourceDocumentUncheckedUpdateWithoutSourceLinksInput>
    create: XOR<SourceDocumentCreateWithoutSourceLinksInput, SourceDocumentUncheckedCreateWithoutSourceLinksInput>
    where?: SourceDocumentWhereInput
  }

  export type SourceDocumentUpdateToOneWithWhereWithoutSourceLinksInput = {
    where?: SourceDocumentWhereInput
    data: XOR<SourceDocumentUpdateWithoutSourceLinksInput, SourceDocumentUncheckedUpdateWithoutSourceLinksInput>
  }

  export type SourceDocumentUpdateWithoutSourceLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    methodNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chunks?: SourceChunkUpdateManyWithoutSourceDocumentNestedInput
    citations?: CitationUpdateManyWithoutSourceDocumentNestedInput
    runInputs?: AIRunInputSourceUpdateManyWithoutSourceDocumentNestedInput
  }

  export type SourceDocumentUncheckedUpdateWithoutSourceLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    methodNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chunks?: SourceChunkUncheckedUpdateManyWithoutSourceDocumentNestedInput
    citations?: CitationUncheckedUpdateManyWithoutSourceDocumentNestedInput
    runInputs?: AIRunInputSourceUncheckedUpdateManyWithoutSourceDocumentNestedInput
  }

  export type CountyUpsertWithoutSourceLinksInput = {
    update: XOR<CountyUpdateWithoutSourceLinksInput, CountyUncheckedUpdateWithoutSourceLinksInput>
    create: XOR<CountyCreateWithoutSourceLinksInput, CountyUncheckedCreateWithoutSourceLinksInput>
    where?: CountyWhereInput
  }

  export type CountyUpdateToOneWithWhereWithoutSourceLinksInput = {
    where?: CountyWhereInput
    data: XOR<CountyUpdateWithoutSourceLinksInput, CountyUncheckedUpdateWithoutSourceLinksInput>
  }

  export type CountyUpdateWithoutSourceLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fipsCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blueprintSections?: BlueprintSectionUpdateManyWithoutCountyNestedInput
    quotes?: QuoteUpdateManyWithoutCountyNestedInput
    assets?: AssetUpdateManyWithoutCountyNestedInput
    countyIssues?: CountyIssueUpdateManyWithoutCountyNestedInput
    censusMetrics?: CensusMetricUpdateManyWithoutCountyNestedInput
    blsMetrics?: BLSMetricUpdateManyWithoutCountyNestedInput
    civicsOfficials?: CivicsOfficialUpdateManyWithoutCountyNestedInput
    electionResults?: ElectionResultUpdateManyWithoutCountyNestedInput
    surveyForms?: SurveyFormUpdateManyWithoutCountyNestedInput
    surveyResponses?: SurveyResponseUpdateManyWithoutCountyNestedInput
    aiOutputScopes?: AIOutputScopeUpdateManyWithoutCountyNestedInput
  }

  export type CountyUncheckedUpdateWithoutSourceLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fipsCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blueprintSections?: BlueprintSectionUncheckedUpdateManyWithoutCountyNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutCountyNestedInput
    assets?: AssetUncheckedUpdateManyWithoutCountyNestedInput
    countyIssues?: CountyIssueUncheckedUpdateManyWithoutCountyNestedInput
    censusMetrics?: CensusMetricUncheckedUpdateManyWithoutCountyNestedInput
    blsMetrics?: BLSMetricUncheckedUpdateManyWithoutCountyNestedInput
    civicsOfficials?: CivicsOfficialUncheckedUpdateManyWithoutCountyNestedInput
    electionResults?: ElectionResultUncheckedUpdateManyWithoutCountyNestedInput
    surveyForms?: SurveyFormUncheckedUpdateManyWithoutCountyNestedInput
    surveyResponses?: SurveyResponseUncheckedUpdateManyWithoutCountyNestedInput
    aiOutputScopes?: AIOutputScopeUncheckedUpdateManyWithoutCountyNestedInput
  }

  export type IssueUpsertWithoutSourceLinksInput = {
    update: XOR<IssueUpdateWithoutSourceLinksInput, IssueUncheckedUpdateWithoutSourceLinksInput>
    create: XOR<IssueCreateWithoutSourceLinksInput, IssueUncheckedCreateWithoutSourceLinksInput>
    where?: IssueWhereInput
  }

  export type IssueUpdateToOneWithWhereWithoutSourceLinksInput = {
    where?: IssueWhereInput
    data: XOR<IssueUpdateWithoutSourceLinksInput, IssueUncheckedUpdateWithoutSourceLinksInput>
  }

  export type IssueUpdateWithoutSourceLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    countyIssues?: CountyIssueUpdateManyWithoutIssueNestedInput
    blueprintSections?: BlueprintSectionUpdateManyWithoutIssueNestedInput
    quotes?: QuoteUpdateManyWithoutIssueNestedInput
    assets?: AssetUpdateManyWithoutIssueNestedInput
    aiOutputScopes?: AIOutputScopeUpdateManyWithoutIssueNestedInput
  }

  export type IssueUncheckedUpdateWithoutSourceLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    countyIssues?: CountyIssueUncheckedUpdateManyWithoutIssueNestedInput
    blueprintSections?: BlueprintSectionUncheckedUpdateManyWithoutIssueNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutIssueNestedInput
    assets?: AssetUncheckedUpdateManyWithoutIssueNestedInput
    aiOutputScopes?: AIOutputScopeUncheckedUpdateManyWithoutIssueNestedInput
  }

  export type BlueprintSectionUpsertWithoutSourceLinksInput = {
    update: XOR<BlueprintSectionUpdateWithoutSourceLinksInput, BlueprintSectionUncheckedUpdateWithoutSourceLinksInput>
    create: XOR<BlueprintSectionCreateWithoutSourceLinksInput, BlueprintSectionUncheckedCreateWithoutSourceLinksInput>
    where?: BlueprintSectionWhereInput
  }

  export type BlueprintSectionUpdateToOneWithWhereWithoutSourceLinksInput = {
    where?: BlueprintSectionWhereInput
    data: XOR<BlueprintSectionUpdateWithoutSourceLinksInput, BlueprintSectionUncheckedUpdateWithoutSourceLinksInput>
  }

  export type BlueprintSectionUpdateWithoutSourceLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    bodyMd?: StringFieldUpdateOperationsInput | string
    sortOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    county?: CountyUpdateOneWithoutBlueprintSectionsNestedInput
    issue?: IssueUpdateOneWithoutBlueprintSectionsNestedInput
  }

  export type BlueprintSectionUncheckedUpdateWithoutSourceLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    bodyMd?: StringFieldUpdateOperationsInput | string
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    issueId?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteUpsertWithoutSourceLinksInput = {
    update: XOR<QuoteUpdateWithoutSourceLinksInput, QuoteUncheckedUpdateWithoutSourceLinksInput>
    create: XOR<QuoteCreateWithoutSourceLinksInput, QuoteUncheckedCreateWithoutSourceLinksInput>
    where?: QuoteWhereInput
  }

  export type QuoteUpdateToOneWithWhereWithoutSourceLinksInput = {
    where?: QuoteWhereInput
    data: XOR<QuoteUpdateWithoutSourceLinksInput, QuoteUncheckedUpdateWithoutSourceLinksInput>
  }

  export type QuoteUpdateWithoutSourceLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    attributionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    sourceNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    county?: CountyUpdateOneRequiredWithoutQuotesNestedInput
    issue?: IssueUpdateOneWithoutQuotesNestedInput
  }

  export type QuoteUncheckedUpdateWithoutSourceLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    attributionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    countyId?: StringFieldUpdateOperationsInput | string
    issueId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetUpsertWithoutSourceLinksInput = {
    update: XOR<AssetUpdateWithoutSourceLinksInput, AssetUncheckedUpdateWithoutSourceLinksInput>
    create: XOR<AssetCreateWithoutSourceLinksInput, AssetUncheckedCreateWithoutSourceLinksInput>
    where?: AssetWhereInput
  }

  export type AssetUpdateToOneWithWhereWithoutSourceLinksInput = {
    where?: AssetWhereInput
    data: XOR<AssetUpdateWithoutSourceLinksInput, AssetUncheckedUpdateWithoutSourceLinksInput>
  }

  export type AssetUpdateWithoutSourceLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetType?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    credit?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    county?: CountyUpdateOneWithoutAssetsNestedInput
    issue?: IssueUpdateOneWithoutAssetsNestedInput
  }

  export type AssetUncheckedUpdateWithoutSourceLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetType?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    credit?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    issueId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyFormUpsertWithoutSourceLinksInput = {
    update: XOR<SurveyFormUpdateWithoutSourceLinksInput, SurveyFormUncheckedUpdateWithoutSourceLinksInput>
    create: XOR<SurveyFormCreateWithoutSourceLinksInput, SurveyFormUncheckedCreateWithoutSourceLinksInput>
    where?: SurveyFormWhereInput
  }

  export type SurveyFormUpdateToOneWithWhereWithoutSourceLinksInput = {
    where?: SurveyFormWhereInput
    data: XOR<SurveyFormUpdateWithoutSourceLinksInput, SurveyFormUncheckedUpdateWithoutSourceLinksInput>
  }

  export type SurveyFormUpdateWithoutSourceLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    descriptionMd?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumSurveyFormStatusFieldUpdateOperationsInput | $Enums.SurveyFormStatus
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contextLabel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    county?: CountyUpdateOneWithoutSurveyFormsNestedInput
    questions?: SurveyQuestionUpdateManyWithoutFormNestedInput
    responses?: SurveyResponseUpdateManyWithoutFormNestedInput
  }

  export type SurveyFormUncheckedUpdateWithoutSourceLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    descriptionMd?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumSurveyFormStatusFieldUpdateOperationsInput | $Enums.SurveyFormStatus
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    contextLabel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: SurveyQuestionUncheckedUpdateManyWithoutFormNestedInput
    responses?: SurveyResponseUncheckedUpdateManyWithoutFormNestedInput
  }

  export type CensusMetricCreateWithoutGeoZipInput = {
    id?: string
    metricKey: string
    metricLabel?: string | null
    value?: number | null
    valueText?: string | null
    asOfDate?: Date | string | null
    sourceNote?: string | null
    createdAt?: Date | string
    county?: CountyCreateNestedOneWithoutCensusMetricsInput
  }

  export type CensusMetricUncheckedCreateWithoutGeoZipInput = {
    id?: string
    countyId?: string | null
    metricKey: string
    metricLabel?: string | null
    value?: number | null
    valueText?: string | null
    asOfDate?: Date | string | null
    sourceNote?: string | null
    createdAt?: Date | string
  }

  export type CensusMetricCreateOrConnectWithoutGeoZipInput = {
    where: CensusMetricWhereUniqueInput
    create: XOR<CensusMetricCreateWithoutGeoZipInput, CensusMetricUncheckedCreateWithoutGeoZipInput>
  }

  export type CensusMetricCreateManyGeoZipInputEnvelope = {
    data: CensusMetricCreateManyGeoZipInput | CensusMetricCreateManyGeoZipInput[]
    skipDuplicates?: boolean
  }

  export type AIOutputScopeCreateWithoutGeoZipInput = {
    id?: string
    scopeType: $Enums.AIScopeType
    customKey?: string | null
    createdAt?: Date | string
    output: AIOutputCreateNestedOneWithoutScopesInput
    county?: CountyCreateNestedOneWithoutAiOutputScopesInput
    issue?: IssueCreateNestedOneWithoutAiOutputScopesInput
    district?: GeoDistrictCreateNestedOneWithoutAiOutputScopesInput
  }

  export type AIOutputScopeUncheckedCreateWithoutGeoZipInput = {
    id?: string
    outputId: string
    scopeType: $Enums.AIScopeType
    countyId?: string | null
    issueId?: string | null
    districtId?: string | null
    customKey?: string | null
    createdAt?: Date | string
  }

  export type AIOutputScopeCreateOrConnectWithoutGeoZipInput = {
    where: AIOutputScopeWhereUniqueInput
    create: XOR<AIOutputScopeCreateWithoutGeoZipInput, AIOutputScopeUncheckedCreateWithoutGeoZipInput>
  }

  export type AIOutputScopeCreateManyGeoZipInputEnvelope = {
    data: AIOutputScopeCreateManyGeoZipInput | AIOutputScopeCreateManyGeoZipInput[]
    skipDuplicates?: boolean
  }

  export type ElectionResultCreateWithoutGeoZipInput = {
    id?: string
    choiceLabel: string
    votes?: number | null
    voteShare?: number | null
    createdAt?: Date | string
    election: ElectionCreateNestedOneWithoutResultsInput
    county?: CountyCreateNestedOneWithoutElectionResultsInput
    precinct?: GeoPrecinctCreateNestedOneWithoutElectionResultsInput
  }

  export type ElectionResultUncheckedCreateWithoutGeoZipInput = {
    id?: string
    electionId: string
    countyId?: string | null
    precinctId?: string | null
    choiceLabel: string
    votes?: number | null
    voteShare?: number | null
    createdAt?: Date | string
  }

  export type ElectionResultCreateOrConnectWithoutGeoZipInput = {
    where: ElectionResultWhereUniqueInput
    create: XOR<ElectionResultCreateWithoutGeoZipInput, ElectionResultUncheckedCreateWithoutGeoZipInput>
  }

  export type ElectionResultCreateManyGeoZipInputEnvelope = {
    data: ElectionResultCreateManyGeoZipInput | ElectionResultCreateManyGeoZipInput[]
    skipDuplicates?: boolean
  }

  export type CensusMetricUpsertWithWhereUniqueWithoutGeoZipInput = {
    where: CensusMetricWhereUniqueInput
    update: XOR<CensusMetricUpdateWithoutGeoZipInput, CensusMetricUncheckedUpdateWithoutGeoZipInput>
    create: XOR<CensusMetricCreateWithoutGeoZipInput, CensusMetricUncheckedCreateWithoutGeoZipInput>
  }

  export type CensusMetricUpdateWithWhereUniqueWithoutGeoZipInput = {
    where: CensusMetricWhereUniqueInput
    data: XOR<CensusMetricUpdateWithoutGeoZipInput, CensusMetricUncheckedUpdateWithoutGeoZipInput>
  }

  export type CensusMetricUpdateManyWithWhereWithoutGeoZipInput = {
    where: CensusMetricScalarWhereInput
    data: XOR<CensusMetricUpdateManyMutationInput, CensusMetricUncheckedUpdateManyWithoutGeoZipInput>
  }

  export type AIOutputScopeUpsertWithWhereUniqueWithoutGeoZipInput = {
    where: AIOutputScopeWhereUniqueInput
    update: XOR<AIOutputScopeUpdateWithoutGeoZipInput, AIOutputScopeUncheckedUpdateWithoutGeoZipInput>
    create: XOR<AIOutputScopeCreateWithoutGeoZipInput, AIOutputScopeUncheckedCreateWithoutGeoZipInput>
  }

  export type AIOutputScopeUpdateWithWhereUniqueWithoutGeoZipInput = {
    where: AIOutputScopeWhereUniqueInput
    data: XOR<AIOutputScopeUpdateWithoutGeoZipInput, AIOutputScopeUncheckedUpdateWithoutGeoZipInput>
  }

  export type AIOutputScopeUpdateManyWithWhereWithoutGeoZipInput = {
    where: AIOutputScopeScalarWhereInput
    data: XOR<AIOutputScopeUpdateManyMutationInput, AIOutputScopeUncheckedUpdateManyWithoutGeoZipInput>
  }

  export type ElectionResultUpsertWithWhereUniqueWithoutGeoZipInput = {
    where: ElectionResultWhereUniqueInput
    update: XOR<ElectionResultUpdateWithoutGeoZipInput, ElectionResultUncheckedUpdateWithoutGeoZipInput>
    create: XOR<ElectionResultCreateWithoutGeoZipInput, ElectionResultUncheckedCreateWithoutGeoZipInput>
  }

  export type ElectionResultUpdateWithWhereUniqueWithoutGeoZipInput = {
    where: ElectionResultWhereUniqueInput
    data: XOR<ElectionResultUpdateWithoutGeoZipInput, ElectionResultUncheckedUpdateWithoutGeoZipInput>
  }

  export type ElectionResultUpdateManyWithWhereWithoutGeoZipInput = {
    where: ElectionResultScalarWhereInput
    data: XOR<ElectionResultUpdateManyMutationInput, ElectionResultUncheckedUpdateManyWithoutGeoZipInput>
  }

  export type ElectionResultCreateWithoutPrecinctInput = {
    id?: string
    choiceLabel: string
    votes?: number | null
    voteShare?: number | null
    createdAt?: Date | string
    election: ElectionCreateNestedOneWithoutResultsInput
    county?: CountyCreateNestedOneWithoutElectionResultsInput
    geoZip?: GeoZipCreateNestedOneWithoutElectionResultsInput
  }

  export type ElectionResultUncheckedCreateWithoutPrecinctInput = {
    id?: string
    electionId: string
    countyId?: string | null
    geoZipId?: string | null
    choiceLabel: string
    votes?: number | null
    voteShare?: number | null
    createdAt?: Date | string
  }

  export type ElectionResultCreateOrConnectWithoutPrecinctInput = {
    where: ElectionResultWhereUniqueInput
    create: XOR<ElectionResultCreateWithoutPrecinctInput, ElectionResultUncheckedCreateWithoutPrecinctInput>
  }

  export type ElectionResultCreateManyPrecinctInputEnvelope = {
    data: ElectionResultCreateManyPrecinctInput | ElectionResultCreateManyPrecinctInput[]
    skipDuplicates?: boolean
  }

  export type ElectionResultUpsertWithWhereUniqueWithoutPrecinctInput = {
    where: ElectionResultWhereUniqueInput
    update: XOR<ElectionResultUpdateWithoutPrecinctInput, ElectionResultUncheckedUpdateWithoutPrecinctInput>
    create: XOR<ElectionResultCreateWithoutPrecinctInput, ElectionResultUncheckedCreateWithoutPrecinctInput>
  }

  export type ElectionResultUpdateWithWhereUniqueWithoutPrecinctInput = {
    where: ElectionResultWhereUniqueInput
    data: XOR<ElectionResultUpdateWithoutPrecinctInput, ElectionResultUncheckedUpdateWithoutPrecinctInput>
  }

  export type ElectionResultUpdateManyWithWhereWithoutPrecinctInput = {
    where: ElectionResultScalarWhereInput
    data: XOR<ElectionResultUpdateManyMutationInput, ElectionResultUncheckedUpdateManyWithoutPrecinctInput>
  }

  export type CivicsOfficialCreateWithoutDistrictInput = {
    id?: string
    name: string
    officeName: string
    party?: string | null
    phone?: string | null
    website?: string | null
    photoUrl?: string | null
    sourceNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    county?: CountyCreateNestedOneWithoutCivicsOfficialsInput
  }

  export type CivicsOfficialUncheckedCreateWithoutDistrictInput = {
    id?: string
    name: string
    officeName: string
    party?: string | null
    phone?: string | null
    website?: string | null
    photoUrl?: string | null
    countyId?: string | null
    sourceNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CivicsOfficialCreateOrConnectWithoutDistrictInput = {
    where: CivicsOfficialWhereUniqueInput
    create: XOR<CivicsOfficialCreateWithoutDistrictInput, CivicsOfficialUncheckedCreateWithoutDistrictInput>
  }

  export type CivicsOfficialCreateManyDistrictInputEnvelope = {
    data: CivicsOfficialCreateManyDistrictInput | CivicsOfficialCreateManyDistrictInput[]
    skipDuplicates?: boolean
  }

  export type AIOutputScopeCreateWithoutDistrictInput = {
    id?: string
    scopeType: $Enums.AIScopeType
    customKey?: string | null
    createdAt?: Date | string
    output: AIOutputCreateNestedOneWithoutScopesInput
    county?: CountyCreateNestedOneWithoutAiOutputScopesInput
    issue?: IssueCreateNestedOneWithoutAiOutputScopesInput
    geoZip?: GeoZipCreateNestedOneWithoutAiOutputScopesInput
  }

  export type AIOutputScopeUncheckedCreateWithoutDistrictInput = {
    id?: string
    outputId: string
    scopeType: $Enums.AIScopeType
    countyId?: string | null
    issueId?: string | null
    geoZipId?: string | null
    customKey?: string | null
    createdAt?: Date | string
  }

  export type AIOutputScopeCreateOrConnectWithoutDistrictInput = {
    where: AIOutputScopeWhereUniqueInput
    create: XOR<AIOutputScopeCreateWithoutDistrictInput, AIOutputScopeUncheckedCreateWithoutDistrictInput>
  }

  export type AIOutputScopeCreateManyDistrictInputEnvelope = {
    data: AIOutputScopeCreateManyDistrictInput | AIOutputScopeCreateManyDistrictInput[]
    skipDuplicates?: boolean
  }

  export type CivicsOfficialUpsertWithWhereUniqueWithoutDistrictInput = {
    where: CivicsOfficialWhereUniqueInput
    update: XOR<CivicsOfficialUpdateWithoutDistrictInput, CivicsOfficialUncheckedUpdateWithoutDistrictInput>
    create: XOR<CivicsOfficialCreateWithoutDistrictInput, CivicsOfficialUncheckedCreateWithoutDistrictInput>
  }

  export type CivicsOfficialUpdateWithWhereUniqueWithoutDistrictInput = {
    where: CivicsOfficialWhereUniqueInput
    data: XOR<CivicsOfficialUpdateWithoutDistrictInput, CivicsOfficialUncheckedUpdateWithoutDistrictInput>
  }

  export type CivicsOfficialUpdateManyWithWhereWithoutDistrictInput = {
    where: CivicsOfficialScalarWhereInput
    data: XOR<CivicsOfficialUpdateManyMutationInput, CivicsOfficialUncheckedUpdateManyWithoutDistrictInput>
  }

  export type AIOutputScopeUpsertWithWhereUniqueWithoutDistrictInput = {
    where: AIOutputScopeWhereUniqueInput
    update: XOR<AIOutputScopeUpdateWithoutDistrictInput, AIOutputScopeUncheckedUpdateWithoutDistrictInput>
    create: XOR<AIOutputScopeCreateWithoutDistrictInput, AIOutputScopeUncheckedCreateWithoutDistrictInput>
  }

  export type AIOutputScopeUpdateWithWhereUniqueWithoutDistrictInput = {
    where: AIOutputScopeWhereUniqueInput
    data: XOR<AIOutputScopeUpdateWithoutDistrictInput, AIOutputScopeUncheckedUpdateWithoutDistrictInput>
  }

  export type AIOutputScopeUpdateManyWithWhereWithoutDistrictInput = {
    where: AIOutputScopeScalarWhereInput
    data: XOR<AIOutputScopeUpdateManyMutationInput, AIOutputScopeUncheckedUpdateManyWithoutDistrictInput>
  }

  export type CountyCreateWithoutCensusMetricsInput = {
    id?: string
    name: string
    slug: string
    fipsCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blueprintSections?: BlueprintSectionCreateNestedManyWithoutCountyInput
    quotes?: QuoteCreateNestedManyWithoutCountyInput
    assets?: AssetCreateNestedManyWithoutCountyInput
    countyIssues?: CountyIssueCreateNestedManyWithoutCountyInput
    blsMetrics?: BLSMetricCreateNestedManyWithoutCountyInput
    civicsOfficials?: CivicsOfficialCreateNestedManyWithoutCountyInput
    electionResults?: ElectionResultCreateNestedManyWithoutCountyInput
    surveyForms?: SurveyFormCreateNestedManyWithoutCountyInput
    surveyResponses?: SurveyResponseCreateNestedManyWithoutCountyInput
    aiOutputScopes?: AIOutputScopeCreateNestedManyWithoutCountyInput
    sourceLinks?: SourceDocumentLinkCreateNestedManyWithoutCountyInput
  }

  export type CountyUncheckedCreateWithoutCensusMetricsInput = {
    id?: string
    name: string
    slug: string
    fipsCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blueprintSections?: BlueprintSectionUncheckedCreateNestedManyWithoutCountyInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutCountyInput
    assets?: AssetUncheckedCreateNestedManyWithoutCountyInput
    countyIssues?: CountyIssueUncheckedCreateNestedManyWithoutCountyInput
    blsMetrics?: BLSMetricUncheckedCreateNestedManyWithoutCountyInput
    civicsOfficials?: CivicsOfficialUncheckedCreateNestedManyWithoutCountyInput
    electionResults?: ElectionResultUncheckedCreateNestedManyWithoutCountyInput
    surveyForms?: SurveyFormUncheckedCreateNestedManyWithoutCountyInput
    surveyResponses?: SurveyResponseUncheckedCreateNestedManyWithoutCountyInput
    aiOutputScopes?: AIOutputScopeUncheckedCreateNestedManyWithoutCountyInput
    sourceLinks?: SourceDocumentLinkUncheckedCreateNestedManyWithoutCountyInput
  }

  export type CountyCreateOrConnectWithoutCensusMetricsInput = {
    where: CountyWhereUniqueInput
    create: XOR<CountyCreateWithoutCensusMetricsInput, CountyUncheckedCreateWithoutCensusMetricsInput>
  }

  export type GeoZipCreateWithoutCensusMetricsInput = {
    id?: string
    zipCode: string
    createdAt?: Date | string
    aiOutputScopes?: AIOutputScopeCreateNestedManyWithoutGeoZipInput
    electionResults?: ElectionResultCreateNestedManyWithoutGeoZipInput
  }

  export type GeoZipUncheckedCreateWithoutCensusMetricsInput = {
    id?: string
    zipCode: string
    createdAt?: Date | string
    aiOutputScopes?: AIOutputScopeUncheckedCreateNestedManyWithoutGeoZipInput
    electionResults?: ElectionResultUncheckedCreateNestedManyWithoutGeoZipInput
  }

  export type GeoZipCreateOrConnectWithoutCensusMetricsInput = {
    where: GeoZipWhereUniqueInput
    create: XOR<GeoZipCreateWithoutCensusMetricsInput, GeoZipUncheckedCreateWithoutCensusMetricsInput>
  }

  export type CountyUpsertWithoutCensusMetricsInput = {
    update: XOR<CountyUpdateWithoutCensusMetricsInput, CountyUncheckedUpdateWithoutCensusMetricsInput>
    create: XOR<CountyCreateWithoutCensusMetricsInput, CountyUncheckedCreateWithoutCensusMetricsInput>
    where?: CountyWhereInput
  }

  export type CountyUpdateToOneWithWhereWithoutCensusMetricsInput = {
    where?: CountyWhereInput
    data: XOR<CountyUpdateWithoutCensusMetricsInput, CountyUncheckedUpdateWithoutCensusMetricsInput>
  }

  export type CountyUpdateWithoutCensusMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fipsCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blueprintSections?: BlueprintSectionUpdateManyWithoutCountyNestedInput
    quotes?: QuoteUpdateManyWithoutCountyNestedInput
    assets?: AssetUpdateManyWithoutCountyNestedInput
    countyIssues?: CountyIssueUpdateManyWithoutCountyNestedInput
    blsMetrics?: BLSMetricUpdateManyWithoutCountyNestedInput
    civicsOfficials?: CivicsOfficialUpdateManyWithoutCountyNestedInput
    electionResults?: ElectionResultUpdateManyWithoutCountyNestedInput
    surveyForms?: SurveyFormUpdateManyWithoutCountyNestedInput
    surveyResponses?: SurveyResponseUpdateManyWithoutCountyNestedInput
    aiOutputScopes?: AIOutputScopeUpdateManyWithoutCountyNestedInput
    sourceLinks?: SourceDocumentLinkUpdateManyWithoutCountyNestedInput
  }

  export type CountyUncheckedUpdateWithoutCensusMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fipsCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blueprintSections?: BlueprintSectionUncheckedUpdateManyWithoutCountyNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutCountyNestedInput
    assets?: AssetUncheckedUpdateManyWithoutCountyNestedInput
    countyIssues?: CountyIssueUncheckedUpdateManyWithoutCountyNestedInput
    blsMetrics?: BLSMetricUncheckedUpdateManyWithoutCountyNestedInput
    civicsOfficials?: CivicsOfficialUncheckedUpdateManyWithoutCountyNestedInput
    electionResults?: ElectionResultUncheckedUpdateManyWithoutCountyNestedInput
    surveyForms?: SurveyFormUncheckedUpdateManyWithoutCountyNestedInput
    surveyResponses?: SurveyResponseUncheckedUpdateManyWithoutCountyNestedInput
    aiOutputScopes?: AIOutputScopeUncheckedUpdateManyWithoutCountyNestedInput
    sourceLinks?: SourceDocumentLinkUncheckedUpdateManyWithoutCountyNestedInput
  }

  export type GeoZipUpsertWithoutCensusMetricsInput = {
    update: XOR<GeoZipUpdateWithoutCensusMetricsInput, GeoZipUncheckedUpdateWithoutCensusMetricsInput>
    create: XOR<GeoZipCreateWithoutCensusMetricsInput, GeoZipUncheckedCreateWithoutCensusMetricsInput>
    where?: GeoZipWhereInput
  }

  export type GeoZipUpdateToOneWithWhereWithoutCensusMetricsInput = {
    where?: GeoZipWhereInput
    data: XOR<GeoZipUpdateWithoutCensusMetricsInput, GeoZipUncheckedUpdateWithoutCensusMetricsInput>
  }

  export type GeoZipUpdateWithoutCensusMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiOutputScopes?: AIOutputScopeUpdateManyWithoutGeoZipNestedInput
    electionResults?: ElectionResultUpdateManyWithoutGeoZipNestedInput
  }

  export type GeoZipUncheckedUpdateWithoutCensusMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiOutputScopes?: AIOutputScopeUncheckedUpdateManyWithoutGeoZipNestedInput
    electionResults?: ElectionResultUncheckedUpdateManyWithoutGeoZipNestedInput
  }

  export type CountyCreateWithoutBlsMetricsInput = {
    id?: string
    name: string
    slug: string
    fipsCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blueprintSections?: BlueprintSectionCreateNestedManyWithoutCountyInput
    quotes?: QuoteCreateNestedManyWithoutCountyInput
    assets?: AssetCreateNestedManyWithoutCountyInput
    countyIssues?: CountyIssueCreateNestedManyWithoutCountyInput
    censusMetrics?: CensusMetricCreateNestedManyWithoutCountyInput
    civicsOfficials?: CivicsOfficialCreateNestedManyWithoutCountyInput
    electionResults?: ElectionResultCreateNestedManyWithoutCountyInput
    surveyForms?: SurveyFormCreateNestedManyWithoutCountyInput
    surveyResponses?: SurveyResponseCreateNestedManyWithoutCountyInput
    aiOutputScopes?: AIOutputScopeCreateNestedManyWithoutCountyInput
    sourceLinks?: SourceDocumentLinkCreateNestedManyWithoutCountyInput
  }

  export type CountyUncheckedCreateWithoutBlsMetricsInput = {
    id?: string
    name: string
    slug: string
    fipsCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blueprintSections?: BlueprintSectionUncheckedCreateNestedManyWithoutCountyInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutCountyInput
    assets?: AssetUncheckedCreateNestedManyWithoutCountyInput
    countyIssues?: CountyIssueUncheckedCreateNestedManyWithoutCountyInput
    censusMetrics?: CensusMetricUncheckedCreateNestedManyWithoutCountyInput
    civicsOfficials?: CivicsOfficialUncheckedCreateNestedManyWithoutCountyInput
    electionResults?: ElectionResultUncheckedCreateNestedManyWithoutCountyInput
    surveyForms?: SurveyFormUncheckedCreateNestedManyWithoutCountyInput
    surveyResponses?: SurveyResponseUncheckedCreateNestedManyWithoutCountyInput
    aiOutputScopes?: AIOutputScopeUncheckedCreateNestedManyWithoutCountyInput
    sourceLinks?: SourceDocumentLinkUncheckedCreateNestedManyWithoutCountyInput
  }

  export type CountyCreateOrConnectWithoutBlsMetricsInput = {
    where: CountyWhereUniqueInput
    create: XOR<CountyCreateWithoutBlsMetricsInput, CountyUncheckedCreateWithoutBlsMetricsInput>
  }

  export type CountyUpsertWithoutBlsMetricsInput = {
    update: XOR<CountyUpdateWithoutBlsMetricsInput, CountyUncheckedUpdateWithoutBlsMetricsInput>
    create: XOR<CountyCreateWithoutBlsMetricsInput, CountyUncheckedCreateWithoutBlsMetricsInput>
    where?: CountyWhereInput
  }

  export type CountyUpdateToOneWithWhereWithoutBlsMetricsInput = {
    where?: CountyWhereInput
    data: XOR<CountyUpdateWithoutBlsMetricsInput, CountyUncheckedUpdateWithoutBlsMetricsInput>
  }

  export type CountyUpdateWithoutBlsMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fipsCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blueprintSections?: BlueprintSectionUpdateManyWithoutCountyNestedInput
    quotes?: QuoteUpdateManyWithoutCountyNestedInput
    assets?: AssetUpdateManyWithoutCountyNestedInput
    countyIssues?: CountyIssueUpdateManyWithoutCountyNestedInput
    censusMetrics?: CensusMetricUpdateManyWithoutCountyNestedInput
    civicsOfficials?: CivicsOfficialUpdateManyWithoutCountyNestedInput
    electionResults?: ElectionResultUpdateManyWithoutCountyNestedInput
    surveyForms?: SurveyFormUpdateManyWithoutCountyNestedInput
    surveyResponses?: SurveyResponseUpdateManyWithoutCountyNestedInput
    aiOutputScopes?: AIOutputScopeUpdateManyWithoutCountyNestedInput
    sourceLinks?: SourceDocumentLinkUpdateManyWithoutCountyNestedInput
  }

  export type CountyUncheckedUpdateWithoutBlsMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fipsCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blueprintSections?: BlueprintSectionUncheckedUpdateManyWithoutCountyNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutCountyNestedInput
    assets?: AssetUncheckedUpdateManyWithoutCountyNestedInput
    countyIssues?: CountyIssueUncheckedUpdateManyWithoutCountyNestedInput
    censusMetrics?: CensusMetricUncheckedUpdateManyWithoutCountyNestedInput
    civicsOfficials?: CivicsOfficialUncheckedUpdateManyWithoutCountyNestedInput
    electionResults?: ElectionResultUncheckedUpdateManyWithoutCountyNestedInput
    surveyForms?: SurveyFormUncheckedUpdateManyWithoutCountyNestedInput
    surveyResponses?: SurveyResponseUncheckedUpdateManyWithoutCountyNestedInput
    aiOutputScopes?: AIOutputScopeUncheckedUpdateManyWithoutCountyNestedInput
    sourceLinks?: SourceDocumentLinkUncheckedUpdateManyWithoutCountyNestedInput
  }

  export type CountyCreateWithoutCivicsOfficialsInput = {
    id?: string
    name: string
    slug: string
    fipsCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blueprintSections?: BlueprintSectionCreateNestedManyWithoutCountyInput
    quotes?: QuoteCreateNestedManyWithoutCountyInput
    assets?: AssetCreateNestedManyWithoutCountyInput
    countyIssues?: CountyIssueCreateNestedManyWithoutCountyInput
    censusMetrics?: CensusMetricCreateNestedManyWithoutCountyInput
    blsMetrics?: BLSMetricCreateNestedManyWithoutCountyInput
    electionResults?: ElectionResultCreateNestedManyWithoutCountyInput
    surveyForms?: SurveyFormCreateNestedManyWithoutCountyInput
    surveyResponses?: SurveyResponseCreateNestedManyWithoutCountyInput
    aiOutputScopes?: AIOutputScopeCreateNestedManyWithoutCountyInput
    sourceLinks?: SourceDocumentLinkCreateNestedManyWithoutCountyInput
  }

  export type CountyUncheckedCreateWithoutCivicsOfficialsInput = {
    id?: string
    name: string
    slug: string
    fipsCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blueprintSections?: BlueprintSectionUncheckedCreateNestedManyWithoutCountyInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutCountyInput
    assets?: AssetUncheckedCreateNestedManyWithoutCountyInput
    countyIssues?: CountyIssueUncheckedCreateNestedManyWithoutCountyInput
    censusMetrics?: CensusMetricUncheckedCreateNestedManyWithoutCountyInput
    blsMetrics?: BLSMetricUncheckedCreateNestedManyWithoutCountyInput
    electionResults?: ElectionResultUncheckedCreateNestedManyWithoutCountyInput
    surveyForms?: SurveyFormUncheckedCreateNestedManyWithoutCountyInput
    surveyResponses?: SurveyResponseUncheckedCreateNestedManyWithoutCountyInput
    aiOutputScopes?: AIOutputScopeUncheckedCreateNestedManyWithoutCountyInput
    sourceLinks?: SourceDocumentLinkUncheckedCreateNestedManyWithoutCountyInput
  }

  export type CountyCreateOrConnectWithoutCivicsOfficialsInput = {
    where: CountyWhereUniqueInput
    create: XOR<CountyCreateWithoutCivicsOfficialsInput, CountyUncheckedCreateWithoutCivicsOfficialsInput>
  }

  export type GeoDistrictCreateWithoutCivicsOfficialsInput = {
    id?: string
    districtCode: string
    districtType?: string | null
    createdAt?: Date | string
    aiOutputScopes?: AIOutputScopeCreateNestedManyWithoutDistrictInput
  }

  export type GeoDistrictUncheckedCreateWithoutCivicsOfficialsInput = {
    id?: string
    districtCode: string
    districtType?: string | null
    createdAt?: Date | string
    aiOutputScopes?: AIOutputScopeUncheckedCreateNestedManyWithoutDistrictInput
  }

  export type GeoDistrictCreateOrConnectWithoutCivicsOfficialsInput = {
    where: GeoDistrictWhereUniqueInput
    create: XOR<GeoDistrictCreateWithoutCivicsOfficialsInput, GeoDistrictUncheckedCreateWithoutCivicsOfficialsInput>
  }

  export type CountyUpsertWithoutCivicsOfficialsInput = {
    update: XOR<CountyUpdateWithoutCivicsOfficialsInput, CountyUncheckedUpdateWithoutCivicsOfficialsInput>
    create: XOR<CountyCreateWithoutCivicsOfficialsInput, CountyUncheckedCreateWithoutCivicsOfficialsInput>
    where?: CountyWhereInput
  }

  export type CountyUpdateToOneWithWhereWithoutCivicsOfficialsInput = {
    where?: CountyWhereInput
    data: XOR<CountyUpdateWithoutCivicsOfficialsInput, CountyUncheckedUpdateWithoutCivicsOfficialsInput>
  }

  export type CountyUpdateWithoutCivicsOfficialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fipsCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blueprintSections?: BlueprintSectionUpdateManyWithoutCountyNestedInput
    quotes?: QuoteUpdateManyWithoutCountyNestedInput
    assets?: AssetUpdateManyWithoutCountyNestedInput
    countyIssues?: CountyIssueUpdateManyWithoutCountyNestedInput
    censusMetrics?: CensusMetricUpdateManyWithoutCountyNestedInput
    blsMetrics?: BLSMetricUpdateManyWithoutCountyNestedInput
    electionResults?: ElectionResultUpdateManyWithoutCountyNestedInput
    surveyForms?: SurveyFormUpdateManyWithoutCountyNestedInput
    surveyResponses?: SurveyResponseUpdateManyWithoutCountyNestedInput
    aiOutputScopes?: AIOutputScopeUpdateManyWithoutCountyNestedInput
    sourceLinks?: SourceDocumentLinkUpdateManyWithoutCountyNestedInput
  }

  export type CountyUncheckedUpdateWithoutCivicsOfficialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fipsCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blueprintSections?: BlueprintSectionUncheckedUpdateManyWithoutCountyNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutCountyNestedInput
    assets?: AssetUncheckedUpdateManyWithoutCountyNestedInput
    countyIssues?: CountyIssueUncheckedUpdateManyWithoutCountyNestedInput
    censusMetrics?: CensusMetricUncheckedUpdateManyWithoutCountyNestedInput
    blsMetrics?: BLSMetricUncheckedUpdateManyWithoutCountyNestedInput
    electionResults?: ElectionResultUncheckedUpdateManyWithoutCountyNestedInput
    surveyForms?: SurveyFormUncheckedUpdateManyWithoutCountyNestedInput
    surveyResponses?: SurveyResponseUncheckedUpdateManyWithoutCountyNestedInput
    aiOutputScopes?: AIOutputScopeUncheckedUpdateManyWithoutCountyNestedInput
    sourceLinks?: SourceDocumentLinkUncheckedUpdateManyWithoutCountyNestedInput
  }

  export type GeoDistrictUpsertWithoutCivicsOfficialsInput = {
    update: XOR<GeoDistrictUpdateWithoutCivicsOfficialsInput, GeoDistrictUncheckedUpdateWithoutCivicsOfficialsInput>
    create: XOR<GeoDistrictCreateWithoutCivicsOfficialsInput, GeoDistrictUncheckedCreateWithoutCivicsOfficialsInput>
    where?: GeoDistrictWhereInput
  }

  export type GeoDistrictUpdateToOneWithWhereWithoutCivicsOfficialsInput = {
    where?: GeoDistrictWhereInput
    data: XOR<GeoDistrictUpdateWithoutCivicsOfficialsInput, GeoDistrictUncheckedUpdateWithoutCivicsOfficialsInput>
  }

  export type GeoDistrictUpdateWithoutCivicsOfficialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    districtCode?: StringFieldUpdateOperationsInput | string
    districtType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiOutputScopes?: AIOutputScopeUpdateManyWithoutDistrictNestedInput
  }

  export type GeoDistrictUncheckedUpdateWithoutCivicsOfficialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    districtCode?: StringFieldUpdateOperationsInput | string
    districtType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiOutputScopes?: AIOutputScopeUncheckedUpdateManyWithoutDistrictNestedInput
  }

  export type ElectionResultCreateWithoutElectionInput = {
    id?: string
    choiceLabel: string
    votes?: number | null
    voteShare?: number | null
    createdAt?: Date | string
    county?: CountyCreateNestedOneWithoutElectionResultsInput
    geoZip?: GeoZipCreateNestedOneWithoutElectionResultsInput
    precinct?: GeoPrecinctCreateNestedOneWithoutElectionResultsInput
  }

  export type ElectionResultUncheckedCreateWithoutElectionInput = {
    id?: string
    countyId?: string | null
    geoZipId?: string | null
    precinctId?: string | null
    choiceLabel: string
    votes?: number | null
    voteShare?: number | null
    createdAt?: Date | string
  }

  export type ElectionResultCreateOrConnectWithoutElectionInput = {
    where: ElectionResultWhereUniqueInput
    create: XOR<ElectionResultCreateWithoutElectionInput, ElectionResultUncheckedCreateWithoutElectionInput>
  }

  export type ElectionResultCreateManyElectionInputEnvelope = {
    data: ElectionResultCreateManyElectionInput | ElectionResultCreateManyElectionInput[]
    skipDuplicates?: boolean
  }

  export type ElectionResultUpsertWithWhereUniqueWithoutElectionInput = {
    where: ElectionResultWhereUniqueInput
    update: XOR<ElectionResultUpdateWithoutElectionInput, ElectionResultUncheckedUpdateWithoutElectionInput>
    create: XOR<ElectionResultCreateWithoutElectionInput, ElectionResultUncheckedCreateWithoutElectionInput>
  }

  export type ElectionResultUpdateWithWhereUniqueWithoutElectionInput = {
    where: ElectionResultWhereUniqueInput
    data: XOR<ElectionResultUpdateWithoutElectionInput, ElectionResultUncheckedUpdateWithoutElectionInput>
  }

  export type ElectionResultUpdateManyWithWhereWithoutElectionInput = {
    where: ElectionResultScalarWhereInput
    data: XOR<ElectionResultUpdateManyMutationInput, ElectionResultUncheckedUpdateManyWithoutElectionInput>
  }

  export type ElectionCreateWithoutResultsInput = {
    id?: string
    name: string
    electionDate: Date | string
    electionType?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type ElectionUncheckedCreateWithoutResultsInput = {
    id?: string
    name: string
    electionDate: Date | string
    electionType?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type ElectionCreateOrConnectWithoutResultsInput = {
    where: ElectionWhereUniqueInput
    create: XOR<ElectionCreateWithoutResultsInput, ElectionUncheckedCreateWithoutResultsInput>
  }

  export type CountyCreateWithoutElectionResultsInput = {
    id?: string
    name: string
    slug: string
    fipsCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blueprintSections?: BlueprintSectionCreateNestedManyWithoutCountyInput
    quotes?: QuoteCreateNestedManyWithoutCountyInput
    assets?: AssetCreateNestedManyWithoutCountyInput
    countyIssues?: CountyIssueCreateNestedManyWithoutCountyInput
    censusMetrics?: CensusMetricCreateNestedManyWithoutCountyInput
    blsMetrics?: BLSMetricCreateNestedManyWithoutCountyInput
    civicsOfficials?: CivicsOfficialCreateNestedManyWithoutCountyInput
    surveyForms?: SurveyFormCreateNestedManyWithoutCountyInput
    surveyResponses?: SurveyResponseCreateNestedManyWithoutCountyInput
    aiOutputScopes?: AIOutputScopeCreateNestedManyWithoutCountyInput
    sourceLinks?: SourceDocumentLinkCreateNestedManyWithoutCountyInput
  }

  export type CountyUncheckedCreateWithoutElectionResultsInput = {
    id?: string
    name: string
    slug: string
    fipsCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blueprintSections?: BlueprintSectionUncheckedCreateNestedManyWithoutCountyInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutCountyInput
    assets?: AssetUncheckedCreateNestedManyWithoutCountyInput
    countyIssues?: CountyIssueUncheckedCreateNestedManyWithoutCountyInput
    censusMetrics?: CensusMetricUncheckedCreateNestedManyWithoutCountyInput
    blsMetrics?: BLSMetricUncheckedCreateNestedManyWithoutCountyInput
    civicsOfficials?: CivicsOfficialUncheckedCreateNestedManyWithoutCountyInput
    surveyForms?: SurveyFormUncheckedCreateNestedManyWithoutCountyInput
    surveyResponses?: SurveyResponseUncheckedCreateNestedManyWithoutCountyInput
    aiOutputScopes?: AIOutputScopeUncheckedCreateNestedManyWithoutCountyInput
    sourceLinks?: SourceDocumentLinkUncheckedCreateNestedManyWithoutCountyInput
  }

  export type CountyCreateOrConnectWithoutElectionResultsInput = {
    where: CountyWhereUniqueInput
    create: XOR<CountyCreateWithoutElectionResultsInput, CountyUncheckedCreateWithoutElectionResultsInput>
  }

  export type GeoZipCreateWithoutElectionResultsInput = {
    id?: string
    zipCode: string
    createdAt?: Date | string
    censusMetrics?: CensusMetricCreateNestedManyWithoutGeoZipInput
    aiOutputScopes?: AIOutputScopeCreateNestedManyWithoutGeoZipInput
  }

  export type GeoZipUncheckedCreateWithoutElectionResultsInput = {
    id?: string
    zipCode: string
    createdAt?: Date | string
    censusMetrics?: CensusMetricUncheckedCreateNestedManyWithoutGeoZipInput
    aiOutputScopes?: AIOutputScopeUncheckedCreateNestedManyWithoutGeoZipInput
  }

  export type GeoZipCreateOrConnectWithoutElectionResultsInput = {
    where: GeoZipWhereUniqueInput
    create: XOR<GeoZipCreateWithoutElectionResultsInput, GeoZipUncheckedCreateWithoutElectionResultsInput>
  }

  export type GeoPrecinctCreateWithoutElectionResultsInput = {
    id?: string
    name?: string | null
    precinctCode?: string | null
    createdAt?: Date | string
  }

  export type GeoPrecinctUncheckedCreateWithoutElectionResultsInput = {
    id?: string
    name?: string | null
    precinctCode?: string | null
    createdAt?: Date | string
  }

  export type GeoPrecinctCreateOrConnectWithoutElectionResultsInput = {
    where: GeoPrecinctWhereUniqueInput
    create: XOR<GeoPrecinctCreateWithoutElectionResultsInput, GeoPrecinctUncheckedCreateWithoutElectionResultsInput>
  }

  export type ElectionUpsertWithoutResultsInput = {
    update: XOR<ElectionUpdateWithoutResultsInput, ElectionUncheckedUpdateWithoutResultsInput>
    create: XOR<ElectionCreateWithoutResultsInput, ElectionUncheckedCreateWithoutResultsInput>
    where?: ElectionWhereInput
  }

  export type ElectionUpdateToOneWithWhereWithoutResultsInput = {
    where?: ElectionWhereInput
    data: XOR<ElectionUpdateWithoutResultsInput, ElectionUncheckedUpdateWithoutResultsInput>
  }

  export type ElectionUpdateWithoutResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    electionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    electionType?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElectionUncheckedUpdateWithoutResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    electionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    electionType?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountyUpsertWithoutElectionResultsInput = {
    update: XOR<CountyUpdateWithoutElectionResultsInput, CountyUncheckedUpdateWithoutElectionResultsInput>
    create: XOR<CountyCreateWithoutElectionResultsInput, CountyUncheckedCreateWithoutElectionResultsInput>
    where?: CountyWhereInput
  }

  export type CountyUpdateToOneWithWhereWithoutElectionResultsInput = {
    where?: CountyWhereInput
    data: XOR<CountyUpdateWithoutElectionResultsInput, CountyUncheckedUpdateWithoutElectionResultsInput>
  }

  export type CountyUpdateWithoutElectionResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fipsCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blueprintSections?: BlueprintSectionUpdateManyWithoutCountyNestedInput
    quotes?: QuoteUpdateManyWithoutCountyNestedInput
    assets?: AssetUpdateManyWithoutCountyNestedInput
    countyIssues?: CountyIssueUpdateManyWithoutCountyNestedInput
    censusMetrics?: CensusMetricUpdateManyWithoutCountyNestedInput
    blsMetrics?: BLSMetricUpdateManyWithoutCountyNestedInput
    civicsOfficials?: CivicsOfficialUpdateManyWithoutCountyNestedInput
    surveyForms?: SurveyFormUpdateManyWithoutCountyNestedInput
    surveyResponses?: SurveyResponseUpdateManyWithoutCountyNestedInput
    aiOutputScopes?: AIOutputScopeUpdateManyWithoutCountyNestedInput
    sourceLinks?: SourceDocumentLinkUpdateManyWithoutCountyNestedInput
  }

  export type CountyUncheckedUpdateWithoutElectionResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fipsCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blueprintSections?: BlueprintSectionUncheckedUpdateManyWithoutCountyNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutCountyNestedInput
    assets?: AssetUncheckedUpdateManyWithoutCountyNestedInput
    countyIssues?: CountyIssueUncheckedUpdateManyWithoutCountyNestedInput
    censusMetrics?: CensusMetricUncheckedUpdateManyWithoutCountyNestedInput
    blsMetrics?: BLSMetricUncheckedUpdateManyWithoutCountyNestedInput
    civicsOfficials?: CivicsOfficialUncheckedUpdateManyWithoutCountyNestedInput
    surveyForms?: SurveyFormUncheckedUpdateManyWithoutCountyNestedInput
    surveyResponses?: SurveyResponseUncheckedUpdateManyWithoutCountyNestedInput
    aiOutputScopes?: AIOutputScopeUncheckedUpdateManyWithoutCountyNestedInput
    sourceLinks?: SourceDocumentLinkUncheckedUpdateManyWithoutCountyNestedInput
  }

  export type GeoZipUpsertWithoutElectionResultsInput = {
    update: XOR<GeoZipUpdateWithoutElectionResultsInput, GeoZipUncheckedUpdateWithoutElectionResultsInput>
    create: XOR<GeoZipCreateWithoutElectionResultsInput, GeoZipUncheckedCreateWithoutElectionResultsInput>
    where?: GeoZipWhereInput
  }

  export type GeoZipUpdateToOneWithWhereWithoutElectionResultsInput = {
    where?: GeoZipWhereInput
    data: XOR<GeoZipUpdateWithoutElectionResultsInput, GeoZipUncheckedUpdateWithoutElectionResultsInput>
  }

  export type GeoZipUpdateWithoutElectionResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    censusMetrics?: CensusMetricUpdateManyWithoutGeoZipNestedInput
    aiOutputScopes?: AIOutputScopeUpdateManyWithoutGeoZipNestedInput
  }

  export type GeoZipUncheckedUpdateWithoutElectionResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    censusMetrics?: CensusMetricUncheckedUpdateManyWithoutGeoZipNestedInput
    aiOutputScopes?: AIOutputScopeUncheckedUpdateManyWithoutGeoZipNestedInput
  }

  export type GeoPrecinctUpsertWithoutElectionResultsInput = {
    update: XOR<GeoPrecinctUpdateWithoutElectionResultsInput, GeoPrecinctUncheckedUpdateWithoutElectionResultsInput>
    create: XOR<GeoPrecinctCreateWithoutElectionResultsInput, GeoPrecinctUncheckedCreateWithoutElectionResultsInput>
    where?: GeoPrecinctWhereInput
  }

  export type GeoPrecinctUpdateToOneWithWhereWithoutElectionResultsInput = {
    where?: GeoPrecinctWhereInput
    data: XOR<GeoPrecinctUpdateWithoutElectionResultsInput, GeoPrecinctUncheckedUpdateWithoutElectionResultsInput>
  }

  export type GeoPrecinctUpdateWithoutElectionResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    precinctCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeoPrecinctUncheckedUpdateWithoutElectionResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    precinctCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIRunCreateWithoutPromptInput = {
    id?: string
    model: string
    paramsJson?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.AIRunStatus
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorText?: string | null
    inputSummary?: string | null
    createdAt?: Date | string
    outputs?: AIOutputCreateNestedManyWithoutRunInput
    inputSources?: AIRunInputSourceCreateNestedManyWithoutRunInput
    analyses?: AIAnalysisCreateNestedManyWithoutAiRunInput
  }

  export type AIRunUncheckedCreateWithoutPromptInput = {
    id?: string
    model: string
    paramsJson?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.AIRunStatus
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorText?: string | null
    inputSummary?: string | null
    createdAt?: Date | string
    outputs?: AIOutputUncheckedCreateNestedManyWithoutRunInput
    inputSources?: AIRunInputSourceUncheckedCreateNestedManyWithoutRunInput
    analyses?: AIAnalysisUncheckedCreateNestedManyWithoutAiRunInput
  }

  export type AIRunCreateOrConnectWithoutPromptInput = {
    where: AIRunWhereUniqueInput
    create: XOR<AIRunCreateWithoutPromptInput, AIRunUncheckedCreateWithoutPromptInput>
  }

  export type AIRunCreateManyPromptInputEnvelope = {
    data: AIRunCreateManyPromptInput | AIRunCreateManyPromptInput[]
    skipDuplicates?: boolean
  }

  export type AIRunUpsertWithWhereUniqueWithoutPromptInput = {
    where: AIRunWhereUniqueInput
    update: XOR<AIRunUpdateWithoutPromptInput, AIRunUncheckedUpdateWithoutPromptInput>
    create: XOR<AIRunCreateWithoutPromptInput, AIRunUncheckedCreateWithoutPromptInput>
  }

  export type AIRunUpdateWithWhereUniqueWithoutPromptInput = {
    where: AIRunWhereUniqueInput
    data: XOR<AIRunUpdateWithoutPromptInput, AIRunUncheckedUpdateWithoutPromptInput>
  }

  export type AIRunUpdateManyWithWhereWithoutPromptInput = {
    where: AIRunScalarWhereInput
    data: XOR<AIRunUpdateManyMutationInput, AIRunUncheckedUpdateManyWithoutPromptInput>
  }

  export type AIRunScalarWhereInput = {
    AND?: AIRunScalarWhereInput | AIRunScalarWhereInput[]
    OR?: AIRunScalarWhereInput[]
    NOT?: AIRunScalarWhereInput | AIRunScalarWhereInput[]
    id?: UuidFilter<"AIRun"> | string
    promptId?: UuidFilter<"AIRun"> | string
    model?: StringFilter<"AIRun"> | string
    paramsJson?: JsonNullableFilter<"AIRun">
    status?: EnumAIRunStatusFilter<"AIRun"> | $Enums.AIRunStatus
    startedAt?: DateTimeNullableFilter<"AIRun"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"AIRun"> | Date | string | null
    errorText?: StringNullableFilter<"AIRun"> | string | null
    inputSummary?: StringNullableFilter<"AIRun"> | string | null
    createdAt?: DateTimeFilter<"AIRun"> | Date | string
  }

  export type AIPromptCreateWithoutRunsInput = {
    id?: string
    promptKey: string
    version: number
    name: string
    description?: string | null
    template: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIPromptUncheckedCreateWithoutRunsInput = {
    id?: string
    promptKey: string
    version: number
    name: string
    description?: string | null
    template: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIPromptCreateOrConnectWithoutRunsInput = {
    where: AIPromptWhereUniqueInput
    create: XOR<AIPromptCreateWithoutRunsInput, AIPromptUncheckedCreateWithoutRunsInput>
  }

  export type AIOutputCreateWithoutRunInput = {
    id?: string
    outputType?: $Enums.AIOutputType
    status?: $Enums.PublishStatus
    title?: string | null
    summary?: string | null
    contentMd: string
    reviewedAt?: Date | string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sections?: AIOutputSectionCreateNestedManyWithoutOutputInput
    scopes?: AIOutputScopeCreateNestedManyWithoutOutputInput
  }

  export type AIOutputUncheckedCreateWithoutRunInput = {
    id?: string
    outputType?: $Enums.AIOutputType
    status?: $Enums.PublishStatus
    title?: string | null
    summary?: string | null
    contentMd: string
    reviewedAt?: Date | string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sections?: AIOutputSectionUncheckedCreateNestedManyWithoutOutputInput
    scopes?: AIOutputScopeUncheckedCreateNestedManyWithoutOutputInput
  }

  export type AIOutputCreateOrConnectWithoutRunInput = {
    where: AIOutputWhereUniqueInput
    create: XOR<AIOutputCreateWithoutRunInput, AIOutputUncheckedCreateWithoutRunInput>
  }

  export type AIOutputCreateManyRunInputEnvelope = {
    data: AIOutputCreateManyRunInput | AIOutputCreateManyRunInput[]
    skipDuplicates?: boolean
  }

  export type AIRunInputSourceCreateWithoutRunInput = {
    id?: string
    kind?: $Enums.AIRunInputKind
    externalKey?: string | null
    notes?: string | null
    createdAt?: Date | string
    sourceDocument?: SourceDocumentCreateNestedOneWithoutRunInputsInput
  }

  export type AIRunInputSourceUncheckedCreateWithoutRunInput = {
    id?: string
    kind?: $Enums.AIRunInputKind
    sourceDocumentId?: string | null
    externalKey?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type AIRunInputSourceCreateOrConnectWithoutRunInput = {
    where: AIRunInputSourceWhereUniqueInput
    create: XOR<AIRunInputSourceCreateWithoutRunInput, AIRunInputSourceUncheckedCreateWithoutRunInput>
  }

  export type AIRunInputSourceCreateManyRunInputEnvelope = {
    data: AIRunInputSourceCreateManyRunInput | AIRunInputSourceCreateManyRunInput[]
    skipDuplicates?: boolean
  }

  export type AIAnalysisCreateWithoutAiRunInput = {
    id?: string
    analysisType?: $Enums.AnalysisType
    contentJson: JsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
    transcript?: TranscriptCreateNestedOneWithoutAnalysesInput
    mediaAsset?: MediaAssetCreateNestedOneWithoutAnalysesInput
  }

  export type AIAnalysisUncheckedCreateWithoutAiRunInput = {
    id?: string
    transcriptId?: string | null
    mediaAssetId?: string | null
    analysisType?: $Enums.AnalysisType
    contentJson: JsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
  }

  export type AIAnalysisCreateOrConnectWithoutAiRunInput = {
    where: AIAnalysisWhereUniqueInput
    create: XOR<AIAnalysisCreateWithoutAiRunInput, AIAnalysisUncheckedCreateWithoutAiRunInput>
  }

  export type AIAnalysisCreateManyAiRunInputEnvelope = {
    data: AIAnalysisCreateManyAiRunInput | AIAnalysisCreateManyAiRunInput[]
    skipDuplicates?: boolean
  }

  export type AIPromptUpsertWithoutRunsInput = {
    update: XOR<AIPromptUpdateWithoutRunsInput, AIPromptUncheckedUpdateWithoutRunsInput>
    create: XOR<AIPromptCreateWithoutRunsInput, AIPromptUncheckedCreateWithoutRunsInput>
    where?: AIPromptWhereInput
  }

  export type AIPromptUpdateToOneWithWhereWithoutRunsInput = {
    where?: AIPromptWhereInput
    data: XOR<AIPromptUpdateWithoutRunsInput, AIPromptUncheckedUpdateWithoutRunsInput>
  }

  export type AIPromptUpdateWithoutRunsInput = {
    id?: StringFieldUpdateOperationsInput | string
    promptKey?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    template?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIPromptUncheckedUpdateWithoutRunsInput = {
    id?: StringFieldUpdateOperationsInput | string
    promptKey?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    template?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIOutputUpsertWithWhereUniqueWithoutRunInput = {
    where: AIOutputWhereUniqueInput
    update: XOR<AIOutputUpdateWithoutRunInput, AIOutputUncheckedUpdateWithoutRunInput>
    create: XOR<AIOutputCreateWithoutRunInput, AIOutputUncheckedCreateWithoutRunInput>
  }

  export type AIOutputUpdateWithWhereUniqueWithoutRunInput = {
    where: AIOutputWhereUniqueInput
    data: XOR<AIOutputUpdateWithoutRunInput, AIOutputUncheckedUpdateWithoutRunInput>
  }

  export type AIOutputUpdateManyWithWhereWithoutRunInput = {
    where: AIOutputScalarWhereInput
    data: XOR<AIOutputUpdateManyMutationInput, AIOutputUncheckedUpdateManyWithoutRunInput>
  }

  export type AIOutputScalarWhereInput = {
    AND?: AIOutputScalarWhereInput | AIOutputScalarWhereInput[]
    OR?: AIOutputScalarWhereInput[]
    NOT?: AIOutputScalarWhereInput | AIOutputScalarWhereInput[]
    id?: UuidFilter<"AIOutput"> | string
    runId?: UuidFilter<"AIOutput"> | string
    outputType?: EnumAIOutputTypeFilter<"AIOutput"> | $Enums.AIOutputType
    status?: EnumPublishStatusFilter<"AIOutput"> | $Enums.PublishStatus
    title?: StringNullableFilter<"AIOutput"> | string | null
    summary?: StringNullableFilter<"AIOutput"> | string | null
    contentMd?: StringFilter<"AIOutput"> | string
    reviewedAt?: DateTimeNullableFilter<"AIOutput"> | Date | string | null
    publishedAt?: DateTimeNullableFilter<"AIOutput"> | Date | string | null
    createdAt?: DateTimeFilter<"AIOutput"> | Date | string
    updatedAt?: DateTimeFilter<"AIOutput"> | Date | string
  }

  export type AIRunInputSourceUpsertWithWhereUniqueWithoutRunInput = {
    where: AIRunInputSourceWhereUniqueInput
    update: XOR<AIRunInputSourceUpdateWithoutRunInput, AIRunInputSourceUncheckedUpdateWithoutRunInput>
    create: XOR<AIRunInputSourceCreateWithoutRunInput, AIRunInputSourceUncheckedCreateWithoutRunInput>
  }

  export type AIRunInputSourceUpdateWithWhereUniqueWithoutRunInput = {
    where: AIRunInputSourceWhereUniqueInput
    data: XOR<AIRunInputSourceUpdateWithoutRunInput, AIRunInputSourceUncheckedUpdateWithoutRunInput>
  }

  export type AIRunInputSourceUpdateManyWithWhereWithoutRunInput = {
    where: AIRunInputSourceScalarWhereInput
    data: XOR<AIRunInputSourceUpdateManyMutationInput, AIRunInputSourceUncheckedUpdateManyWithoutRunInput>
  }

  export type AIAnalysisUpsertWithWhereUniqueWithoutAiRunInput = {
    where: AIAnalysisWhereUniqueInput
    update: XOR<AIAnalysisUpdateWithoutAiRunInput, AIAnalysisUncheckedUpdateWithoutAiRunInput>
    create: XOR<AIAnalysisCreateWithoutAiRunInput, AIAnalysisUncheckedCreateWithoutAiRunInput>
  }

  export type AIAnalysisUpdateWithWhereUniqueWithoutAiRunInput = {
    where: AIAnalysisWhereUniqueInput
    data: XOR<AIAnalysisUpdateWithoutAiRunInput, AIAnalysisUncheckedUpdateWithoutAiRunInput>
  }

  export type AIAnalysisUpdateManyWithWhereWithoutAiRunInput = {
    where: AIAnalysisScalarWhereInput
    data: XOR<AIAnalysisUpdateManyMutationInput, AIAnalysisUncheckedUpdateManyWithoutAiRunInput>
  }

  export type AIAnalysisScalarWhereInput = {
    AND?: AIAnalysisScalarWhereInput | AIAnalysisScalarWhereInput[]
    OR?: AIAnalysisScalarWhereInput[]
    NOT?: AIAnalysisScalarWhereInput | AIAnalysisScalarWhereInput[]
    id?: UuidFilter<"AIAnalysis"> | string
    transcriptId?: UuidNullableFilter<"AIAnalysis"> | string | null
    mediaAssetId?: UuidNullableFilter<"AIAnalysis"> | string | null
    aiRunId?: UuidNullableFilter<"AIAnalysis"> | string | null
    analysisType?: EnumAnalysisTypeFilter<"AIAnalysis"> | $Enums.AnalysisType
    contentJson?: JsonFilter<"AIAnalysis">
    notes?: StringNullableFilter<"AIAnalysis"> | string | null
    createdAt?: DateTimeFilter<"AIAnalysis"> | Date | string
  }

  export type AIRunCreateWithoutInputSourcesInput = {
    id?: string
    model: string
    paramsJson?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.AIRunStatus
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorText?: string | null
    inputSummary?: string | null
    createdAt?: Date | string
    prompt: AIPromptCreateNestedOneWithoutRunsInput
    outputs?: AIOutputCreateNestedManyWithoutRunInput
    analyses?: AIAnalysisCreateNestedManyWithoutAiRunInput
  }

  export type AIRunUncheckedCreateWithoutInputSourcesInput = {
    id?: string
    promptId: string
    model: string
    paramsJson?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.AIRunStatus
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorText?: string | null
    inputSummary?: string | null
    createdAt?: Date | string
    outputs?: AIOutputUncheckedCreateNestedManyWithoutRunInput
    analyses?: AIAnalysisUncheckedCreateNestedManyWithoutAiRunInput
  }

  export type AIRunCreateOrConnectWithoutInputSourcesInput = {
    where: AIRunWhereUniqueInput
    create: XOR<AIRunCreateWithoutInputSourcesInput, AIRunUncheckedCreateWithoutInputSourcesInput>
  }

  export type SourceDocumentCreateWithoutRunInputsInput = {
    id?: string
    title: string
    url?: string | null
    storageKey?: string | null
    publisher?: string | null
    publishedAt?: Date | string | null
    capturedAt?: Date | string | null
    methodNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    chunks?: SourceChunkCreateNestedManyWithoutSourceDocumentInput
    citations?: CitationCreateNestedManyWithoutSourceDocumentInput
    sourceLinks?: SourceDocumentLinkCreateNestedManyWithoutSourceDocumentInput
  }

  export type SourceDocumentUncheckedCreateWithoutRunInputsInput = {
    id?: string
    title: string
    url?: string | null
    storageKey?: string | null
    publisher?: string | null
    publishedAt?: Date | string | null
    capturedAt?: Date | string | null
    methodNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    chunks?: SourceChunkUncheckedCreateNestedManyWithoutSourceDocumentInput
    citations?: CitationUncheckedCreateNestedManyWithoutSourceDocumentInput
    sourceLinks?: SourceDocumentLinkUncheckedCreateNestedManyWithoutSourceDocumentInput
  }

  export type SourceDocumentCreateOrConnectWithoutRunInputsInput = {
    where: SourceDocumentWhereUniqueInput
    create: XOR<SourceDocumentCreateWithoutRunInputsInput, SourceDocumentUncheckedCreateWithoutRunInputsInput>
  }

  export type AIRunUpsertWithoutInputSourcesInput = {
    update: XOR<AIRunUpdateWithoutInputSourcesInput, AIRunUncheckedUpdateWithoutInputSourcesInput>
    create: XOR<AIRunCreateWithoutInputSourcesInput, AIRunUncheckedCreateWithoutInputSourcesInput>
    where?: AIRunWhereInput
  }

  export type AIRunUpdateToOneWithWhereWithoutInputSourcesInput = {
    where?: AIRunWhereInput
    data: XOR<AIRunUpdateWithoutInputSourcesInput, AIRunUncheckedUpdateWithoutInputSourcesInput>
  }

  export type AIRunUpdateWithoutInputSourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    paramsJson?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAIRunStatusFieldUpdateOperationsInput | $Enums.AIRunStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorText?: NullableStringFieldUpdateOperationsInput | string | null
    inputSummary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prompt?: AIPromptUpdateOneRequiredWithoutRunsNestedInput
    outputs?: AIOutputUpdateManyWithoutRunNestedInput
    analyses?: AIAnalysisUpdateManyWithoutAiRunNestedInput
  }

  export type AIRunUncheckedUpdateWithoutInputSourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    promptId?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    paramsJson?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAIRunStatusFieldUpdateOperationsInput | $Enums.AIRunStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorText?: NullableStringFieldUpdateOperationsInput | string | null
    inputSummary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    outputs?: AIOutputUncheckedUpdateManyWithoutRunNestedInput
    analyses?: AIAnalysisUncheckedUpdateManyWithoutAiRunNestedInput
  }

  export type SourceDocumentUpsertWithoutRunInputsInput = {
    update: XOR<SourceDocumentUpdateWithoutRunInputsInput, SourceDocumentUncheckedUpdateWithoutRunInputsInput>
    create: XOR<SourceDocumentCreateWithoutRunInputsInput, SourceDocumentUncheckedCreateWithoutRunInputsInput>
    where?: SourceDocumentWhereInput
  }

  export type SourceDocumentUpdateToOneWithWhereWithoutRunInputsInput = {
    where?: SourceDocumentWhereInput
    data: XOR<SourceDocumentUpdateWithoutRunInputsInput, SourceDocumentUncheckedUpdateWithoutRunInputsInput>
  }

  export type SourceDocumentUpdateWithoutRunInputsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    methodNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chunks?: SourceChunkUpdateManyWithoutSourceDocumentNestedInput
    citations?: CitationUpdateManyWithoutSourceDocumentNestedInput
    sourceLinks?: SourceDocumentLinkUpdateManyWithoutSourceDocumentNestedInput
  }

  export type SourceDocumentUncheckedUpdateWithoutRunInputsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    methodNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chunks?: SourceChunkUncheckedUpdateManyWithoutSourceDocumentNestedInput
    citations?: CitationUncheckedUpdateManyWithoutSourceDocumentNestedInput
    sourceLinks?: SourceDocumentLinkUncheckedUpdateManyWithoutSourceDocumentNestedInput
  }

  export type AIRunCreateWithoutOutputsInput = {
    id?: string
    model: string
    paramsJson?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.AIRunStatus
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorText?: string | null
    inputSummary?: string | null
    createdAt?: Date | string
    prompt: AIPromptCreateNestedOneWithoutRunsInput
    inputSources?: AIRunInputSourceCreateNestedManyWithoutRunInput
    analyses?: AIAnalysisCreateNestedManyWithoutAiRunInput
  }

  export type AIRunUncheckedCreateWithoutOutputsInput = {
    id?: string
    promptId: string
    model: string
    paramsJson?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.AIRunStatus
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorText?: string | null
    inputSummary?: string | null
    createdAt?: Date | string
    inputSources?: AIRunInputSourceUncheckedCreateNestedManyWithoutRunInput
    analyses?: AIAnalysisUncheckedCreateNestedManyWithoutAiRunInput
  }

  export type AIRunCreateOrConnectWithoutOutputsInput = {
    where: AIRunWhereUniqueInput
    create: XOR<AIRunCreateWithoutOutputsInput, AIRunUncheckedCreateWithoutOutputsInput>
  }

  export type AIOutputSectionCreateWithoutOutputInput = {
    id?: string
    sectionKey: string
    heading?: string | null
    order?: number
    contentMd: string
    createdAt?: Date | string
    updatedAt?: Date | string
    citations?: CitationCreateNestedManyWithoutOutputSectionInput
  }

  export type AIOutputSectionUncheckedCreateWithoutOutputInput = {
    id?: string
    sectionKey: string
    heading?: string | null
    order?: number
    contentMd: string
    createdAt?: Date | string
    updatedAt?: Date | string
    citations?: CitationUncheckedCreateNestedManyWithoutOutputSectionInput
  }

  export type AIOutputSectionCreateOrConnectWithoutOutputInput = {
    where: AIOutputSectionWhereUniqueInput
    create: XOR<AIOutputSectionCreateWithoutOutputInput, AIOutputSectionUncheckedCreateWithoutOutputInput>
  }

  export type AIOutputSectionCreateManyOutputInputEnvelope = {
    data: AIOutputSectionCreateManyOutputInput | AIOutputSectionCreateManyOutputInput[]
    skipDuplicates?: boolean
  }

  export type AIOutputScopeCreateWithoutOutputInput = {
    id?: string
    scopeType: $Enums.AIScopeType
    customKey?: string | null
    createdAt?: Date | string
    county?: CountyCreateNestedOneWithoutAiOutputScopesInput
    issue?: IssueCreateNestedOneWithoutAiOutputScopesInput
    geoZip?: GeoZipCreateNestedOneWithoutAiOutputScopesInput
    district?: GeoDistrictCreateNestedOneWithoutAiOutputScopesInput
  }

  export type AIOutputScopeUncheckedCreateWithoutOutputInput = {
    id?: string
    scopeType: $Enums.AIScopeType
    countyId?: string | null
    issueId?: string | null
    geoZipId?: string | null
    districtId?: string | null
    customKey?: string | null
    createdAt?: Date | string
  }

  export type AIOutputScopeCreateOrConnectWithoutOutputInput = {
    where: AIOutputScopeWhereUniqueInput
    create: XOR<AIOutputScopeCreateWithoutOutputInput, AIOutputScopeUncheckedCreateWithoutOutputInput>
  }

  export type AIOutputScopeCreateManyOutputInputEnvelope = {
    data: AIOutputScopeCreateManyOutputInput | AIOutputScopeCreateManyOutputInput[]
    skipDuplicates?: boolean
  }

  export type AIRunUpsertWithoutOutputsInput = {
    update: XOR<AIRunUpdateWithoutOutputsInput, AIRunUncheckedUpdateWithoutOutputsInput>
    create: XOR<AIRunCreateWithoutOutputsInput, AIRunUncheckedCreateWithoutOutputsInput>
    where?: AIRunWhereInput
  }

  export type AIRunUpdateToOneWithWhereWithoutOutputsInput = {
    where?: AIRunWhereInput
    data: XOR<AIRunUpdateWithoutOutputsInput, AIRunUncheckedUpdateWithoutOutputsInput>
  }

  export type AIRunUpdateWithoutOutputsInput = {
    id?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    paramsJson?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAIRunStatusFieldUpdateOperationsInput | $Enums.AIRunStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorText?: NullableStringFieldUpdateOperationsInput | string | null
    inputSummary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prompt?: AIPromptUpdateOneRequiredWithoutRunsNestedInput
    inputSources?: AIRunInputSourceUpdateManyWithoutRunNestedInput
    analyses?: AIAnalysisUpdateManyWithoutAiRunNestedInput
  }

  export type AIRunUncheckedUpdateWithoutOutputsInput = {
    id?: StringFieldUpdateOperationsInput | string
    promptId?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    paramsJson?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAIRunStatusFieldUpdateOperationsInput | $Enums.AIRunStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorText?: NullableStringFieldUpdateOperationsInput | string | null
    inputSummary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inputSources?: AIRunInputSourceUncheckedUpdateManyWithoutRunNestedInput
    analyses?: AIAnalysisUncheckedUpdateManyWithoutAiRunNestedInput
  }

  export type AIOutputSectionUpsertWithWhereUniqueWithoutOutputInput = {
    where: AIOutputSectionWhereUniqueInput
    update: XOR<AIOutputSectionUpdateWithoutOutputInput, AIOutputSectionUncheckedUpdateWithoutOutputInput>
    create: XOR<AIOutputSectionCreateWithoutOutputInput, AIOutputSectionUncheckedCreateWithoutOutputInput>
  }

  export type AIOutputSectionUpdateWithWhereUniqueWithoutOutputInput = {
    where: AIOutputSectionWhereUniqueInput
    data: XOR<AIOutputSectionUpdateWithoutOutputInput, AIOutputSectionUncheckedUpdateWithoutOutputInput>
  }

  export type AIOutputSectionUpdateManyWithWhereWithoutOutputInput = {
    where: AIOutputSectionScalarWhereInput
    data: XOR<AIOutputSectionUpdateManyMutationInput, AIOutputSectionUncheckedUpdateManyWithoutOutputInput>
  }

  export type AIOutputSectionScalarWhereInput = {
    AND?: AIOutputSectionScalarWhereInput | AIOutputSectionScalarWhereInput[]
    OR?: AIOutputSectionScalarWhereInput[]
    NOT?: AIOutputSectionScalarWhereInput | AIOutputSectionScalarWhereInput[]
    id?: UuidFilter<"AIOutputSection"> | string
    outputId?: UuidFilter<"AIOutputSection"> | string
    sectionKey?: StringFilter<"AIOutputSection"> | string
    heading?: StringNullableFilter<"AIOutputSection"> | string | null
    order?: IntFilter<"AIOutputSection"> | number
    contentMd?: StringFilter<"AIOutputSection"> | string
    createdAt?: DateTimeFilter<"AIOutputSection"> | Date | string
    updatedAt?: DateTimeFilter<"AIOutputSection"> | Date | string
  }

  export type AIOutputScopeUpsertWithWhereUniqueWithoutOutputInput = {
    where: AIOutputScopeWhereUniqueInput
    update: XOR<AIOutputScopeUpdateWithoutOutputInput, AIOutputScopeUncheckedUpdateWithoutOutputInput>
    create: XOR<AIOutputScopeCreateWithoutOutputInput, AIOutputScopeUncheckedCreateWithoutOutputInput>
  }

  export type AIOutputScopeUpdateWithWhereUniqueWithoutOutputInput = {
    where: AIOutputScopeWhereUniqueInput
    data: XOR<AIOutputScopeUpdateWithoutOutputInput, AIOutputScopeUncheckedUpdateWithoutOutputInput>
  }

  export type AIOutputScopeUpdateManyWithWhereWithoutOutputInput = {
    where: AIOutputScopeScalarWhereInput
    data: XOR<AIOutputScopeUpdateManyMutationInput, AIOutputScopeUncheckedUpdateManyWithoutOutputInput>
  }

  export type AIOutputCreateWithoutSectionsInput = {
    id?: string
    outputType?: $Enums.AIOutputType
    status?: $Enums.PublishStatus
    title?: string | null
    summary?: string | null
    contentMd: string
    reviewedAt?: Date | string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    run: AIRunCreateNestedOneWithoutOutputsInput
    scopes?: AIOutputScopeCreateNestedManyWithoutOutputInput
  }

  export type AIOutputUncheckedCreateWithoutSectionsInput = {
    id?: string
    runId: string
    outputType?: $Enums.AIOutputType
    status?: $Enums.PublishStatus
    title?: string | null
    summary?: string | null
    contentMd: string
    reviewedAt?: Date | string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    scopes?: AIOutputScopeUncheckedCreateNestedManyWithoutOutputInput
  }

  export type AIOutputCreateOrConnectWithoutSectionsInput = {
    where: AIOutputWhereUniqueInput
    create: XOR<AIOutputCreateWithoutSectionsInput, AIOutputUncheckedCreateWithoutSectionsInput>
  }

  export type CitationCreateWithoutOutputSectionInput = {
    id?: string
    label?: string | null
    locatorJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    sourceChunk?: SourceChunkCreateNestedOneWithoutCitationsInput
    sourceDocument?: SourceDocumentCreateNestedOneWithoutCitationsInput
  }

  export type CitationUncheckedCreateWithoutOutputSectionInput = {
    id?: string
    sourceChunkId?: string | null
    sourceDocumentId?: string | null
    label?: string | null
    locatorJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type CitationCreateOrConnectWithoutOutputSectionInput = {
    where: CitationWhereUniqueInput
    create: XOR<CitationCreateWithoutOutputSectionInput, CitationUncheckedCreateWithoutOutputSectionInput>
  }

  export type CitationCreateManyOutputSectionInputEnvelope = {
    data: CitationCreateManyOutputSectionInput | CitationCreateManyOutputSectionInput[]
    skipDuplicates?: boolean
  }

  export type AIOutputUpsertWithoutSectionsInput = {
    update: XOR<AIOutputUpdateWithoutSectionsInput, AIOutputUncheckedUpdateWithoutSectionsInput>
    create: XOR<AIOutputCreateWithoutSectionsInput, AIOutputUncheckedCreateWithoutSectionsInput>
    where?: AIOutputWhereInput
  }

  export type AIOutputUpdateToOneWithWhereWithoutSectionsInput = {
    where?: AIOutputWhereInput
    data: XOR<AIOutputUpdateWithoutSectionsInput, AIOutputUncheckedUpdateWithoutSectionsInput>
  }

  export type AIOutputUpdateWithoutSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    outputType?: EnumAIOutputTypeFieldUpdateOperationsInput | $Enums.AIOutputType
    status?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    title?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    contentMd?: StringFieldUpdateOperationsInput | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    run?: AIRunUpdateOneRequiredWithoutOutputsNestedInput
    scopes?: AIOutputScopeUpdateManyWithoutOutputNestedInput
  }

  export type AIOutputUncheckedUpdateWithoutSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    runId?: StringFieldUpdateOperationsInput | string
    outputType?: EnumAIOutputTypeFieldUpdateOperationsInput | $Enums.AIOutputType
    status?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    title?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    contentMd?: StringFieldUpdateOperationsInput | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scopes?: AIOutputScopeUncheckedUpdateManyWithoutOutputNestedInput
  }

  export type CitationUpsertWithWhereUniqueWithoutOutputSectionInput = {
    where: CitationWhereUniqueInput
    update: XOR<CitationUpdateWithoutOutputSectionInput, CitationUncheckedUpdateWithoutOutputSectionInput>
    create: XOR<CitationCreateWithoutOutputSectionInput, CitationUncheckedCreateWithoutOutputSectionInput>
  }

  export type CitationUpdateWithWhereUniqueWithoutOutputSectionInput = {
    where: CitationWhereUniqueInput
    data: XOR<CitationUpdateWithoutOutputSectionInput, CitationUncheckedUpdateWithoutOutputSectionInput>
  }

  export type CitationUpdateManyWithWhereWithoutOutputSectionInput = {
    where: CitationScalarWhereInput
    data: XOR<CitationUpdateManyMutationInput, CitationUncheckedUpdateManyWithoutOutputSectionInput>
  }

  export type AIOutputCreateWithoutScopesInput = {
    id?: string
    outputType?: $Enums.AIOutputType
    status?: $Enums.PublishStatus
    title?: string | null
    summary?: string | null
    contentMd: string
    reviewedAt?: Date | string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    run: AIRunCreateNestedOneWithoutOutputsInput
    sections?: AIOutputSectionCreateNestedManyWithoutOutputInput
  }

  export type AIOutputUncheckedCreateWithoutScopesInput = {
    id?: string
    runId: string
    outputType?: $Enums.AIOutputType
    status?: $Enums.PublishStatus
    title?: string | null
    summary?: string | null
    contentMd: string
    reviewedAt?: Date | string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sections?: AIOutputSectionUncheckedCreateNestedManyWithoutOutputInput
  }

  export type AIOutputCreateOrConnectWithoutScopesInput = {
    where: AIOutputWhereUniqueInput
    create: XOR<AIOutputCreateWithoutScopesInput, AIOutputUncheckedCreateWithoutScopesInput>
  }

  export type CountyCreateWithoutAiOutputScopesInput = {
    id?: string
    name: string
    slug: string
    fipsCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blueprintSections?: BlueprintSectionCreateNestedManyWithoutCountyInput
    quotes?: QuoteCreateNestedManyWithoutCountyInput
    assets?: AssetCreateNestedManyWithoutCountyInput
    countyIssues?: CountyIssueCreateNestedManyWithoutCountyInput
    censusMetrics?: CensusMetricCreateNestedManyWithoutCountyInput
    blsMetrics?: BLSMetricCreateNestedManyWithoutCountyInput
    civicsOfficials?: CivicsOfficialCreateNestedManyWithoutCountyInput
    electionResults?: ElectionResultCreateNestedManyWithoutCountyInput
    surveyForms?: SurveyFormCreateNestedManyWithoutCountyInput
    surveyResponses?: SurveyResponseCreateNestedManyWithoutCountyInput
    sourceLinks?: SourceDocumentLinkCreateNestedManyWithoutCountyInput
  }

  export type CountyUncheckedCreateWithoutAiOutputScopesInput = {
    id?: string
    name: string
    slug: string
    fipsCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blueprintSections?: BlueprintSectionUncheckedCreateNestedManyWithoutCountyInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutCountyInput
    assets?: AssetUncheckedCreateNestedManyWithoutCountyInput
    countyIssues?: CountyIssueUncheckedCreateNestedManyWithoutCountyInput
    censusMetrics?: CensusMetricUncheckedCreateNestedManyWithoutCountyInput
    blsMetrics?: BLSMetricUncheckedCreateNestedManyWithoutCountyInput
    civicsOfficials?: CivicsOfficialUncheckedCreateNestedManyWithoutCountyInput
    electionResults?: ElectionResultUncheckedCreateNestedManyWithoutCountyInput
    surveyForms?: SurveyFormUncheckedCreateNestedManyWithoutCountyInput
    surveyResponses?: SurveyResponseUncheckedCreateNestedManyWithoutCountyInput
    sourceLinks?: SourceDocumentLinkUncheckedCreateNestedManyWithoutCountyInput
  }

  export type CountyCreateOrConnectWithoutAiOutputScopesInput = {
    where: CountyWhereUniqueInput
    create: XOR<CountyCreateWithoutAiOutputScopesInput, CountyUncheckedCreateWithoutAiOutputScopesInput>
  }

  export type IssueCreateWithoutAiOutputScopesInput = {
    id?: string
    name: string
    slug: string
    summary?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    countyIssues?: CountyIssueCreateNestedManyWithoutIssueInput
    blueprintSections?: BlueprintSectionCreateNestedManyWithoutIssueInput
    quotes?: QuoteCreateNestedManyWithoutIssueInput
    assets?: AssetCreateNestedManyWithoutIssueInput
    sourceLinks?: SourceDocumentLinkCreateNestedManyWithoutIssueInput
  }

  export type IssueUncheckedCreateWithoutAiOutputScopesInput = {
    id?: string
    name: string
    slug: string
    summary?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    countyIssues?: CountyIssueUncheckedCreateNestedManyWithoutIssueInput
    blueprintSections?: BlueprintSectionUncheckedCreateNestedManyWithoutIssueInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutIssueInput
    assets?: AssetUncheckedCreateNestedManyWithoutIssueInput
    sourceLinks?: SourceDocumentLinkUncheckedCreateNestedManyWithoutIssueInput
  }

  export type IssueCreateOrConnectWithoutAiOutputScopesInput = {
    where: IssueWhereUniqueInput
    create: XOR<IssueCreateWithoutAiOutputScopesInput, IssueUncheckedCreateWithoutAiOutputScopesInput>
  }

  export type GeoZipCreateWithoutAiOutputScopesInput = {
    id?: string
    zipCode: string
    createdAt?: Date | string
    censusMetrics?: CensusMetricCreateNestedManyWithoutGeoZipInput
    electionResults?: ElectionResultCreateNestedManyWithoutGeoZipInput
  }

  export type GeoZipUncheckedCreateWithoutAiOutputScopesInput = {
    id?: string
    zipCode: string
    createdAt?: Date | string
    censusMetrics?: CensusMetricUncheckedCreateNestedManyWithoutGeoZipInput
    electionResults?: ElectionResultUncheckedCreateNestedManyWithoutGeoZipInput
  }

  export type GeoZipCreateOrConnectWithoutAiOutputScopesInput = {
    where: GeoZipWhereUniqueInput
    create: XOR<GeoZipCreateWithoutAiOutputScopesInput, GeoZipUncheckedCreateWithoutAiOutputScopesInput>
  }

  export type GeoDistrictCreateWithoutAiOutputScopesInput = {
    id?: string
    districtCode: string
    districtType?: string | null
    createdAt?: Date | string
    civicsOfficials?: CivicsOfficialCreateNestedManyWithoutDistrictInput
  }

  export type GeoDistrictUncheckedCreateWithoutAiOutputScopesInput = {
    id?: string
    districtCode: string
    districtType?: string | null
    createdAt?: Date | string
    civicsOfficials?: CivicsOfficialUncheckedCreateNestedManyWithoutDistrictInput
  }

  export type GeoDistrictCreateOrConnectWithoutAiOutputScopesInput = {
    where: GeoDistrictWhereUniqueInput
    create: XOR<GeoDistrictCreateWithoutAiOutputScopesInput, GeoDistrictUncheckedCreateWithoutAiOutputScopesInput>
  }

  export type AIOutputUpsertWithoutScopesInput = {
    update: XOR<AIOutputUpdateWithoutScopesInput, AIOutputUncheckedUpdateWithoutScopesInput>
    create: XOR<AIOutputCreateWithoutScopesInput, AIOutputUncheckedCreateWithoutScopesInput>
    where?: AIOutputWhereInput
  }

  export type AIOutputUpdateToOneWithWhereWithoutScopesInput = {
    where?: AIOutputWhereInput
    data: XOR<AIOutputUpdateWithoutScopesInput, AIOutputUncheckedUpdateWithoutScopesInput>
  }

  export type AIOutputUpdateWithoutScopesInput = {
    id?: StringFieldUpdateOperationsInput | string
    outputType?: EnumAIOutputTypeFieldUpdateOperationsInput | $Enums.AIOutputType
    status?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    title?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    contentMd?: StringFieldUpdateOperationsInput | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    run?: AIRunUpdateOneRequiredWithoutOutputsNestedInput
    sections?: AIOutputSectionUpdateManyWithoutOutputNestedInput
  }

  export type AIOutputUncheckedUpdateWithoutScopesInput = {
    id?: StringFieldUpdateOperationsInput | string
    runId?: StringFieldUpdateOperationsInput | string
    outputType?: EnumAIOutputTypeFieldUpdateOperationsInput | $Enums.AIOutputType
    status?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    title?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    contentMd?: StringFieldUpdateOperationsInput | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sections?: AIOutputSectionUncheckedUpdateManyWithoutOutputNestedInput
  }

  export type CountyUpsertWithoutAiOutputScopesInput = {
    update: XOR<CountyUpdateWithoutAiOutputScopesInput, CountyUncheckedUpdateWithoutAiOutputScopesInput>
    create: XOR<CountyCreateWithoutAiOutputScopesInput, CountyUncheckedCreateWithoutAiOutputScopesInput>
    where?: CountyWhereInput
  }

  export type CountyUpdateToOneWithWhereWithoutAiOutputScopesInput = {
    where?: CountyWhereInput
    data: XOR<CountyUpdateWithoutAiOutputScopesInput, CountyUncheckedUpdateWithoutAiOutputScopesInput>
  }

  export type CountyUpdateWithoutAiOutputScopesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fipsCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blueprintSections?: BlueprintSectionUpdateManyWithoutCountyNestedInput
    quotes?: QuoteUpdateManyWithoutCountyNestedInput
    assets?: AssetUpdateManyWithoutCountyNestedInput
    countyIssues?: CountyIssueUpdateManyWithoutCountyNestedInput
    censusMetrics?: CensusMetricUpdateManyWithoutCountyNestedInput
    blsMetrics?: BLSMetricUpdateManyWithoutCountyNestedInput
    civicsOfficials?: CivicsOfficialUpdateManyWithoutCountyNestedInput
    electionResults?: ElectionResultUpdateManyWithoutCountyNestedInput
    surveyForms?: SurveyFormUpdateManyWithoutCountyNestedInput
    surveyResponses?: SurveyResponseUpdateManyWithoutCountyNestedInput
    sourceLinks?: SourceDocumentLinkUpdateManyWithoutCountyNestedInput
  }

  export type CountyUncheckedUpdateWithoutAiOutputScopesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fipsCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blueprintSections?: BlueprintSectionUncheckedUpdateManyWithoutCountyNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutCountyNestedInput
    assets?: AssetUncheckedUpdateManyWithoutCountyNestedInput
    countyIssues?: CountyIssueUncheckedUpdateManyWithoutCountyNestedInput
    censusMetrics?: CensusMetricUncheckedUpdateManyWithoutCountyNestedInput
    blsMetrics?: BLSMetricUncheckedUpdateManyWithoutCountyNestedInput
    civicsOfficials?: CivicsOfficialUncheckedUpdateManyWithoutCountyNestedInput
    electionResults?: ElectionResultUncheckedUpdateManyWithoutCountyNestedInput
    surveyForms?: SurveyFormUncheckedUpdateManyWithoutCountyNestedInput
    surveyResponses?: SurveyResponseUncheckedUpdateManyWithoutCountyNestedInput
    sourceLinks?: SourceDocumentLinkUncheckedUpdateManyWithoutCountyNestedInput
  }

  export type IssueUpsertWithoutAiOutputScopesInput = {
    update: XOR<IssueUpdateWithoutAiOutputScopesInput, IssueUncheckedUpdateWithoutAiOutputScopesInput>
    create: XOR<IssueCreateWithoutAiOutputScopesInput, IssueUncheckedCreateWithoutAiOutputScopesInput>
    where?: IssueWhereInput
  }

  export type IssueUpdateToOneWithWhereWithoutAiOutputScopesInput = {
    where?: IssueWhereInput
    data: XOR<IssueUpdateWithoutAiOutputScopesInput, IssueUncheckedUpdateWithoutAiOutputScopesInput>
  }

  export type IssueUpdateWithoutAiOutputScopesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    countyIssues?: CountyIssueUpdateManyWithoutIssueNestedInput
    blueprintSections?: BlueprintSectionUpdateManyWithoutIssueNestedInput
    quotes?: QuoteUpdateManyWithoutIssueNestedInput
    assets?: AssetUpdateManyWithoutIssueNestedInput
    sourceLinks?: SourceDocumentLinkUpdateManyWithoutIssueNestedInput
  }

  export type IssueUncheckedUpdateWithoutAiOutputScopesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    countyIssues?: CountyIssueUncheckedUpdateManyWithoutIssueNestedInput
    blueprintSections?: BlueprintSectionUncheckedUpdateManyWithoutIssueNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutIssueNestedInput
    assets?: AssetUncheckedUpdateManyWithoutIssueNestedInput
    sourceLinks?: SourceDocumentLinkUncheckedUpdateManyWithoutIssueNestedInput
  }

  export type GeoZipUpsertWithoutAiOutputScopesInput = {
    update: XOR<GeoZipUpdateWithoutAiOutputScopesInput, GeoZipUncheckedUpdateWithoutAiOutputScopesInput>
    create: XOR<GeoZipCreateWithoutAiOutputScopesInput, GeoZipUncheckedCreateWithoutAiOutputScopesInput>
    where?: GeoZipWhereInput
  }

  export type GeoZipUpdateToOneWithWhereWithoutAiOutputScopesInput = {
    where?: GeoZipWhereInput
    data: XOR<GeoZipUpdateWithoutAiOutputScopesInput, GeoZipUncheckedUpdateWithoutAiOutputScopesInput>
  }

  export type GeoZipUpdateWithoutAiOutputScopesInput = {
    id?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    censusMetrics?: CensusMetricUpdateManyWithoutGeoZipNestedInput
    electionResults?: ElectionResultUpdateManyWithoutGeoZipNestedInput
  }

  export type GeoZipUncheckedUpdateWithoutAiOutputScopesInput = {
    id?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    censusMetrics?: CensusMetricUncheckedUpdateManyWithoutGeoZipNestedInput
    electionResults?: ElectionResultUncheckedUpdateManyWithoutGeoZipNestedInput
  }

  export type GeoDistrictUpsertWithoutAiOutputScopesInput = {
    update: XOR<GeoDistrictUpdateWithoutAiOutputScopesInput, GeoDistrictUncheckedUpdateWithoutAiOutputScopesInput>
    create: XOR<GeoDistrictCreateWithoutAiOutputScopesInput, GeoDistrictUncheckedCreateWithoutAiOutputScopesInput>
    where?: GeoDistrictWhereInput
  }

  export type GeoDistrictUpdateToOneWithWhereWithoutAiOutputScopesInput = {
    where?: GeoDistrictWhereInput
    data: XOR<GeoDistrictUpdateWithoutAiOutputScopesInput, GeoDistrictUncheckedUpdateWithoutAiOutputScopesInput>
  }

  export type GeoDistrictUpdateWithoutAiOutputScopesInput = {
    id?: StringFieldUpdateOperationsInput | string
    districtCode?: StringFieldUpdateOperationsInput | string
    districtType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    civicsOfficials?: CivicsOfficialUpdateManyWithoutDistrictNestedInput
  }

  export type GeoDistrictUncheckedUpdateWithoutAiOutputScopesInput = {
    id?: StringFieldUpdateOperationsInput | string
    districtCode?: StringFieldUpdateOperationsInput | string
    districtType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    civicsOfficials?: CivicsOfficialUncheckedUpdateManyWithoutDistrictNestedInput
  }

  export type AIOutputSectionCreateWithoutCitationsInput = {
    id?: string
    sectionKey: string
    heading?: string | null
    order?: number
    contentMd: string
    createdAt?: Date | string
    updatedAt?: Date | string
    output: AIOutputCreateNestedOneWithoutSectionsInput
  }

  export type AIOutputSectionUncheckedCreateWithoutCitationsInput = {
    id?: string
    outputId: string
    sectionKey: string
    heading?: string | null
    order?: number
    contentMd: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIOutputSectionCreateOrConnectWithoutCitationsInput = {
    where: AIOutputSectionWhereUniqueInput
    create: XOR<AIOutputSectionCreateWithoutCitationsInput, AIOutputSectionUncheckedCreateWithoutCitationsInput>
  }

  export type SourceChunkCreateWithoutCitationsInput = {
    id?: string
    chunkIndex: number
    content: string
    contentHash: string
    locatorJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    sourceDocument: SourceDocumentCreateNestedOneWithoutChunksInput
  }

  export type SourceChunkUncheckedCreateWithoutCitationsInput = {
    id?: string
    sourceDocumentId: string
    chunkIndex: number
    content: string
    contentHash: string
    locatorJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SourceChunkCreateOrConnectWithoutCitationsInput = {
    where: SourceChunkWhereUniqueInput
    create: XOR<SourceChunkCreateWithoutCitationsInput, SourceChunkUncheckedCreateWithoutCitationsInput>
  }

  export type SourceDocumentCreateWithoutCitationsInput = {
    id?: string
    title: string
    url?: string | null
    storageKey?: string | null
    publisher?: string | null
    publishedAt?: Date | string | null
    capturedAt?: Date | string | null
    methodNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    chunks?: SourceChunkCreateNestedManyWithoutSourceDocumentInput
    runInputs?: AIRunInputSourceCreateNestedManyWithoutSourceDocumentInput
    sourceLinks?: SourceDocumentLinkCreateNestedManyWithoutSourceDocumentInput
  }

  export type SourceDocumentUncheckedCreateWithoutCitationsInput = {
    id?: string
    title: string
    url?: string | null
    storageKey?: string | null
    publisher?: string | null
    publishedAt?: Date | string | null
    capturedAt?: Date | string | null
    methodNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    chunks?: SourceChunkUncheckedCreateNestedManyWithoutSourceDocumentInput
    runInputs?: AIRunInputSourceUncheckedCreateNestedManyWithoutSourceDocumentInput
    sourceLinks?: SourceDocumentLinkUncheckedCreateNestedManyWithoutSourceDocumentInput
  }

  export type SourceDocumentCreateOrConnectWithoutCitationsInput = {
    where: SourceDocumentWhereUniqueInput
    create: XOR<SourceDocumentCreateWithoutCitationsInput, SourceDocumentUncheckedCreateWithoutCitationsInput>
  }

  export type AIOutputSectionUpsertWithoutCitationsInput = {
    update: XOR<AIOutputSectionUpdateWithoutCitationsInput, AIOutputSectionUncheckedUpdateWithoutCitationsInput>
    create: XOR<AIOutputSectionCreateWithoutCitationsInput, AIOutputSectionUncheckedCreateWithoutCitationsInput>
    where?: AIOutputSectionWhereInput
  }

  export type AIOutputSectionUpdateToOneWithWhereWithoutCitationsInput = {
    where?: AIOutputSectionWhereInput
    data: XOR<AIOutputSectionUpdateWithoutCitationsInput, AIOutputSectionUncheckedUpdateWithoutCitationsInput>
  }

  export type AIOutputSectionUpdateWithoutCitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionKey?: StringFieldUpdateOperationsInput | string
    heading?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    contentMd?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    output?: AIOutputUpdateOneRequiredWithoutSectionsNestedInput
  }

  export type AIOutputSectionUncheckedUpdateWithoutCitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    outputId?: StringFieldUpdateOperationsInput | string
    sectionKey?: StringFieldUpdateOperationsInput | string
    heading?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    contentMd?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SourceChunkUpsertWithoutCitationsInput = {
    update: XOR<SourceChunkUpdateWithoutCitationsInput, SourceChunkUncheckedUpdateWithoutCitationsInput>
    create: XOR<SourceChunkCreateWithoutCitationsInput, SourceChunkUncheckedCreateWithoutCitationsInput>
    where?: SourceChunkWhereInput
  }

  export type SourceChunkUpdateToOneWithWhereWithoutCitationsInput = {
    where?: SourceChunkWhereInput
    data: XOR<SourceChunkUpdateWithoutCitationsInput, SourceChunkUncheckedUpdateWithoutCitationsInput>
  }

  export type SourceChunkUpdateWithoutCitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    locatorJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceDocument?: SourceDocumentUpdateOneRequiredWithoutChunksNestedInput
  }

  export type SourceChunkUncheckedUpdateWithoutCitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceDocumentId?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    locatorJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SourceDocumentUpsertWithoutCitationsInput = {
    update: XOR<SourceDocumentUpdateWithoutCitationsInput, SourceDocumentUncheckedUpdateWithoutCitationsInput>
    create: XOR<SourceDocumentCreateWithoutCitationsInput, SourceDocumentUncheckedCreateWithoutCitationsInput>
    where?: SourceDocumentWhereInput
  }

  export type SourceDocumentUpdateToOneWithWhereWithoutCitationsInput = {
    where?: SourceDocumentWhereInput
    data: XOR<SourceDocumentUpdateWithoutCitationsInput, SourceDocumentUncheckedUpdateWithoutCitationsInput>
  }

  export type SourceDocumentUpdateWithoutCitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    methodNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chunks?: SourceChunkUpdateManyWithoutSourceDocumentNestedInput
    runInputs?: AIRunInputSourceUpdateManyWithoutSourceDocumentNestedInput
    sourceLinks?: SourceDocumentLinkUpdateManyWithoutSourceDocumentNestedInput
  }

  export type SourceDocumentUncheckedUpdateWithoutCitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    methodNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chunks?: SourceChunkUncheckedUpdateManyWithoutSourceDocumentNestedInput
    runInputs?: AIRunInputSourceUncheckedUpdateManyWithoutSourceDocumentNestedInput
    sourceLinks?: SourceDocumentLinkUncheckedUpdateManyWithoutSourceDocumentNestedInput
  }

  export type CountyCreateWithoutSurveyFormsInput = {
    id?: string
    name: string
    slug: string
    fipsCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blueprintSections?: BlueprintSectionCreateNestedManyWithoutCountyInput
    quotes?: QuoteCreateNestedManyWithoutCountyInput
    assets?: AssetCreateNestedManyWithoutCountyInput
    countyIssues?: CountyIssueCreateNestedManyWithoutCountyInput
    censusMetrics?: CensusMetricCreateNestedManyWithoutCountyInput
    blsMetrics?: BLSMetricCreateNestedManyWithoutCountyInput
    civicsOfficials?: CivicsOfficialCreateNestedManyWithoutCountyInput
    electionResults?: ElectionResultCreateNestedManyWithoutCountyInput
    surveyResponses?: SurveyResponseCreateNestedManyWithoutCountyInput
    aiOutputScopes?: AIOutputScopeCreateNestedManyWithoutCountyInput
    sourceLinks?: SourceDocumentLinkCreateNestedManyWithoutCountyInput
  }

  export type CountyUncheckedCreateWithoutSurveyFormsInput = {
    id?: string
    name: string
    slug: string
    fipsCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blueprintSections?: BlueprintSectionUncheckedCreateNestedManyWithoutCountyInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutCountyInput
    assets?: AssetUncheckedCreateNestedManyWithoutCountyInput
    countyIssues?: CountyIssueUncheckedCreateNestedManyWithoutCountyInput
    censusMetrics?: CensusMetricUncheckedCreateNestedManyWithoutCountyInput
    blsMetrics?: BLSMetricUncheckedCreateNestedManyWithoutCountyInput
    civicsOfficials?: CivicsOfficialUncheckedCreateNestedManyWithoutCountyInput
    electionResults?: ElectionResultUncheckedCreateNestedManyWithoutCountyInput
    surveyResponses?: SurveyResponseUncheckedCreateNestedManyWithoutCountyInput
    aiOutputScopes?: AIOutputScopeUncheckedCreateNestedManyWithoutCountyInput
    sourceLinks?: SourceDocumentLinkUncheckedCreateNestedManyWithoutCountyInput
  }

  export type CountyCreateOrConnectWithoutSurveyFormsInput = {
    where: CountyWhereUniqueInput
    create: XOR<CountyCreateWithoutSurveyFormsInput, CountyUncheckedCreateWithoutSurveyFormsInput>
  }

  export type SurveyQuestionCreateWithoutFormInput = {
    id?: string
    questionKey: string
    prompt: string
    helpText?: string | null
    questionType: $Enums.SurveyQuestionType
    required?: boolean
    sortOrder?: number
    isActive?: boolean
    allowVoice?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    options?: SurveyQuestionOptionCreateNestedManyWithoutQuestionInput
    responseItems?: SurveyResponseItemCreateNestedManyWithoutQuestionInput
  }

  export type SurveyQuestionUncheckedCreateWithoutFormInput = {
    id?: string
    questionKey: string
    prompt: string
    helpText?: string | null
    questionType: $Enums.SurveyQuestionType
    required?: boolean
    sortOrder?: number
    isActive?: boolean
    allowVoice?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    options?: SurveyQuestionOptionUncheckedCreateNestedManyWithoutQuestionInput
    responseItems?: SurveyResponseItemUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type SurveyQuestionCreateOrConnectWithoutFormInput = {
    where: SurveyQuestionWhereUniqueInput
    create: XOR<SurveyQuestionCreateWithoutFormInput, SurveyQuestionUncheckedCreateWithoutFormInput>
  }

  export type SurveyQuestionCreateManyFormInputEnvelope = {
    data: SurveyQuestionCreateManyFormInput | SurveyQuestionCreateManyFormInput[]
    skipDuplicates?: boolean
  }

  export type SurveyResponseCreateWithoutFormInput = {
    id?: string
    sourceLabel?: string | null
    submittedAt?: Date | string
    ipHash?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    county?: CountyCreateNestedOneWithoutSurveyResponsesInput
    items?: SurveyResponseItemCreateNestedManyWithoutResponseInput
  }

  export type SurveyResponseUncheckedCreateWithoutFormInput = {
    id?: string
    countyId?: string | null
    sourceLabel?: string | null
    submittedAt?: Date | string
    ipHash?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    items?: SurveyResponseItemUncheckedCreateNestedManyWithoutResponseInput
  }

  export type SurveyResponseCreateOrConnectWithoutFormInput = {
    where: SurveyResponseWhereUniqueInput
    create: XOR<SurveyResponseCreateWithoutFormInput, SurveyResponseUncheckedCreateWithoutFormInput>
  }

  export type SurveyResponseCreateManyFormInputEnvelope = {
    data: SurveyResponseCreateManyFormInput | SurveyResponseCreateManyFormInput[]
    skipDuplicates?: boolean
  }

  export type SourceDocumentLinkCreateWithoutSurveyFormInput = {
    id?: string
    note?: string | null
    createdAt?: Date | string
    sourceDocument: SourceDocumentCreateNestedOneWithoutSourceLinksInput
    county?: CountyCreateNestedOneWithoutSourceLinksInput
    issue?: IssueCreateNestedOneWithoutSourceLinksInput
    blueprintSection?: BlueprintSectionCreateNestedOneWithoutSourceLinksInput
    quote?: QuoteCreateNestedOneWithoutSourceLinksInput
    asset?: AssetCreateNestedOneWithoutSourceLinksInput
  }

  export type SourceDocumentLinkUncheckedCreateWithoutSurveyFormInput = {
    id?: string
    sourceDocumentId: string
    countyId?: string | null
    issueId?: string | null
    blueprintSectionId?: string | null
    quoteId?: string | null
    assetId?: string | null
    note?: string | null
    createdAt?: Date | string
  }

  export type SourceDocumentLinkCreateOrConnectWithoutSurveyFormInput = {
    where: SourceDocumentLinkWhereUniqueInput
    create: XOR<SourceDocumentLinkCreateWithoutSurveyFormInput, SourceDocumentLinkUncheckedCreateWithoutSurveyFormInput>
  }

  export type SourceDocumentLinkCreateManySurveyFormInputEnvelope = {
    data: SourceDocumentLinkCreateManySurveyFormInput | SourceDocumentLinkCreateManySurveyFormInput[]
    skipDuplicates?: boolean
  }

  export type CountyUpsertWithoutSurveyFormsInput = {
    update: XOR<CountyUpdateWithoutSurveyFormsInput, CountyUncheckedUpdateWithoutSurveyFormsInput>
    create: XOR<CountyCreateWithoutSurveyFormsInput, CountyUncheckedCreateWithoutSurveyFormsInput>
    where?: CountyWhereInput
  }

  export type CountyUpdateToOneWithWhereWithoutSurveyFormsInput = {
    where?: CountyWhereInput
    data: XOR<CountyUpdateWithoutSurveyFormsInput, CountyUncheckedUpdateWithoutSurveyFormsInput>
  }

  export type CountyUpdateWithoutSurveyFormsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fipsCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blueprintSections?: BlueprintSectionUpdateManyWithoutCountyNestedInput
    quotes?: QuoteUpdateManyWithoutCountyNestedInput
    assets?: AssetUpdateManyWithoutCountyNestedInput
    countyIssues?: CountyIssueUpdateManyWithoutCountyNestedInput
    censusMetrics?: CensusMetricUpdateManyWithoutCountyNestedInput
    blsMetrics?: BLSMetricUpdateManyWithoutCountyNestedInput
    civicsOfficials?: CivicsOfficialUpdateManyWithoutCountyNestedInput
    electionResults?: ElectionResultUpdateManyWithoutCountyNestedInput
    surveyResponses?: SurveyResponseUpdateManyWithoutCountyNestedInput
    aiOutputScopes?: AIOutputScopeUpdateManyWithoutCountyNestedInput
    sourceLinks?: SourceDocumentLinkUpdateManyWithoutCountyNestedInput
  }

  export type CountyUncheckedUpdateWithoutSurveyFormsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fipsCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blueprintSections?: BlueprintSectionUncheckedUpdateManyWithoutCountyNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutCountyNestedInput
    assets?: AssetUncheckedUpdateManyWithoutCountyNestedInput
    countyIssues?: CountyIssueUncheckedUpdateManyWithoutCountyNestedInput
    censusMetrics?: CensusMetricUncheckedUpdateManyWithoutCountyNestedInput
    blsMetrics?: BLSMetricUncheckedUpdateManyWithoutCountyNestedInput
    civicsOfficials?: CivicsOfficialUncheckedUpdateManyWithoutCountyNestedInput
    electionResults?: ElectionResultUncheckedUpdateManyWithoutCountyNestedInput
    surveyResponses?: SurveyResponseUncheckedUpdateManyWithoutCountyNestedInput
    aiOutputScopes?: AIOutputScopeUncheckedUpdateManyWithoutCountyNestedInput
    sourceLinks?: SourceDocumentLinkUncheckedUpdateManyWithoutCountyNestedInput
  }

  export type SurveyQuestionUpsertWithWhereUniqueWithoutFormInput = {
    where: SurveyQuestionWhereUniqueInput
    update: XOR<SurveyQuestionUpdateWithoutFormInput, SurveyQuestionUncheckedUpdateWithoutFormInput>
    create: XOR<SurveyQuestionCreateWithoutFormInput, SurveyQuestionUncheckedCreateWithoutFormInput>
  }

  export type SurveyQuestionUpdateWithWhereUniqueWithoutFormInput = {
    where: SurveyQuestionWhereUniqueInput
    data: XOR<SurveyQuestionUpdateWithoutFormInput, SurveyQuestionUncheckedUpdateWithoutFormInput>
  }

  export type SurveyQuestionUpdateManyWithWhereWithoutFormInput = {
    where: SurveyQuestionScalarWhereInput
    data: XOR<SurveyQuestionUpdateManyMutationInput, SurveyQuestionUncheckedUpdateManyWithoutFormInput>
  }

  export type SurveyQuestionScalarWhereInput = {
    AND?: SurveyQuestionScalarWhereInput | SurveyQuestionScalarWhereInput[]
    OR?: SurveyQuestionScalarWhereInput[]
    NOT?: SurveyQuestionScalarWhereInput | SurveyQuestionScalarWhereInput[]
    id?: UuidFilter<"SurveyQuestion"> | string
    formId?: UuidFilter<"SurveyQuestion"> | string
    questionKey?: StringFilter<"SurveyQuestion"> | string
    prompt?: StringFilter<"SurveyQuestion"> | string
    helpText?: StringNullableFilter<"SurveyQuestion"> | string | null
    questionType?: EnumSurveyQuestionTypeFilter<"SurveyQuestion"> | $Enums.SurveyQuestionType
    required?: BoolFilter<"SurveyQuestion"> | boolean
    sortOrder?: IntFilter<"SurveyQuestion"> | number
    isActive?: BoolFilter<"SurveyQuestion"> | boolean
    allowVoice?: BoolFilter<"SurveyQuestion"> | boolean
    createdAt?: DateTimeFilter<"SurveyQuestion"> | Date | string
    updatedAt?: DateTimeFilter<"SurveyQuestion"> | Date | string
  }

  export type SurveyResponseUpsertWithWhereUniqueWithoutFormInput = {
    where: SurveyResponseWhereUniqueInput
    update: XOR<SurveyResponseUpdateWithoutFormInput, SurveyResponseUncheckedUpdateWithoutFormInput>
    create: XOR<SurveyResponseCreateWithoutFormInput, SurveyResponseUncheckedCreateWithoutFormInput>
  }

  export type SurveyResponseUpdateWithWhereUniqueWithoutFormInput = {
    where: SurveyResponseWhereUniqueInput
    data: XOR<SurveyResponseUpdateWithoutFormInput, SurveyResponseUncheckedUpdateWithoutFormInput>
  }

  export type SurveyResponseUpdateManyWithWhereWithoutFormInput = {
    where: SurveyResponseScalarWhereInput
    data: XOR<SurveyResponseUpdateManyMutationInput, SurveyResponseUncheckedUpdateManyWithoutFormInput>
  }

  export type SourceDocumentLinkUpsertWithWhereUniqueWithoutSurveyFormInput = {
    where: SourceDocumentLinkWhereUniqueInput
    update: XOR<SourceDocumentLinkUpdateWithoutSurveyFormInput, SourceDocumentLinkUncheckedUpdateWithoutSurveyFormInput>
    create: XOR<SourceDocumentLinkCreateWithoutSurveyFormInput, SourceDocumentLinkUncheckedCreateWithoutSurveyFormInput>
  }

  export type SourceDocumentLinkUpdateWithWhereUniqueWithoutSurveyFormInput = {
    where: SourceDocumentLinkWhereUniqueInput
    data: XOR<SourceDocumentLinkUpdateWithoutSurveyFormInput, SourceDocumentLinkUncheckedUpdateWithoutSurveyFormInput>
  }

  export type SourceDocumentLinkUpdateManyWithWhereWithoutSurveyFormInput = {
    where: SourceDocumentLinkScalarWhereInput
    data: XOR<SourceDocumentLinkUpdateManyMutationInput, SourceDocumentLinkUncheckedUpdateManyWithoutSurveyFormInput>
  }

  export type SurveyFormCreateWithoutQuestionsInput = {
    id?: string
    title: string
    descriptionMd?: string | null
    slug: string
    status?: $Enums.SurveyFormStatus
    startAt?: Date | string | null
    endAt?: Date | string | null
    contextLabel?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    county?: CountyCreateNestedOneWithoutSurveyFormsInput
    responses?: SurveyResponseCreateNestedManyWithoutFormInput
    sourceLinks?: SourceDocumentLinkCreateNestedManyWithoutSurveyFormInput
  }

  export type SurveyFormUncheckedCreateWithoutQuestionsInput = {
    id?: string
    title: string
    descriptionMd?: string | null
    slug: string
    status?: $Enums.SurveyFormStatus
    startAt?: Date | string | null
    endAt?: Date | string | null
    countyId?: string | null
    contextLabel?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    responses?: SurveyResponseUncheckedCreateNestedManyWithoutFormInput
    sourceLinks?: SourceDocumentLinkUncheckedCreateNestedManyWithoutSurveyFormInput
  }

  export type SurveyFormCreateOrConnectWithoutQuestionsInput = {
    where: SurveyFormWhereUniqueInput
    create: XOR<SurveyFormCreateWithoutQuestionsInput, SurveyFormUncheckedCreateWithoutQuestionsInput>
  }

  export type SurveyQuestionOptionCreateWithoutQuestionInput = {
    id?: string
    valueKey: string
    label: string
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    responseItemOptions?: SurveyResponseItemOptionCreateNestedManyWithoutOptionInput
    selectedByResponseItems?: SurveyResponseItemCreateNestedManyWithoutSelectedOptionInput
  }

  export type SurveyQuestionOptionUncheckedCreateWithoutQuestionInput = {
    id?: string
    valueKey: string
    label: string
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    responseItemOptions?: SurveyResponseItemOptionUncheckedCreateNestedManyWithoutOptionInput
    selectedByResponseItems?: SurveyResponseItemUncheckedCreateNestedManyWithoutSelectedOptionInput
  }

  export type SurveyQuestionOptionCreateOrConnectWithoutQuestionInput = {
    where: SurveyQuestionOptionWhereUniqueInput
    create: XOR<SurveyQuestionOptionCreateWithoutQuestionInput, SurveyQuestionOptionUncheckedCreateWithoutQuestionInput>
  }

  export type SurveyQuestionOptionCreateManyQuestionInputEnvelope = {
    data: SurveyQuestionOptionCreateManyQuestionInput | SurveyQuestionOptionCreateManyQuestionInput[]
    skipDuplicates?: boolean
  }

  export type SurveyResponseItemCreateWithoutQuestionInput = {
    id?: string
    valueText?: string | null
    valueNumber?: number | null
    valueBoolean?: boolean | null
    createdAt?: Date | string
    response: SurveyResponseCreateNestedOneWithoutItemsInput
    selectedOption?: SurveyQuestionOptionCreateNestedOneWithoutSelectedByResponseItemsInput
    mediaAsset?: MediaAssetCreateNestedOneWithoutSurveyResponseItemsInput
    multiSelectedOptions?: SurveyResponseItemOptionCreateNestedManyWithoutResponseItemInput
  }

  export type SurveyResponseItemUncheckedCreateWithoutQuestionInput = {
    id?: string
    responseId: string
    valueText?: string | null
    valueNumber?: number | null
    valueBoolean?: boolean | null
    selectedOptionId?: string | null
    mediaAssetId?: string | null
    createdAt?: Date | string
    multiSelectedOptions?: SurveyResponseItemOptionUncheckedCreateNestedManyWithoutResponseItemInput
  }

  export type SurveyResponseItemCreateOrConnectWithoutQuestionInput = {
    where: SurveyResponseItemWhereUniqueInput
    create: XOR<SurveyResponseItemCreateWithoutQuestionInput, SurveyResponseItemUncheckedCreateWithoutQuestionInput>
  }

  export type SurveyResponseItemCreateManyQuestionInputEnvelope = {
    data: SurveyResponseItemCreateManyQuestionInput | SurveyResponseItemCreateManyQuestionInput[]
    skipDuplicates?: boolean
  }

  export type SurveyFormUpsertWithoutQuestionsInput = {
    update: XOR<SurveyFormUpdateWithoutQuestionsInput, SurveyFormUncheckedUpdateWithoutQuestionsInput>
    create: XOR<SurveyFormCreateWithoutQuestionsInput, SurveyFormUncheckedCreateWithoutQuestionsInput>
    where?: SurveyFormWhereInput
  }

  export type SurveyFormUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: SurveyFormWhereInput
    data: XOR<SurveyFormUpdateWithoutQuestionsInput, SurveyFormUncheckedUpdateWithoutQuestionsInput>
  }

  export type SurveyFormUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    descriptionMd?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumSurveyFormStatusFieldUpdateOperationsInput | $Enums.SurveyFormStatus
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contextLabel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    county?: CountyUpdateOneWithoutSurveyFormsNestedInput
    responses?: SurveyResponseUpdateManyWithoutFormNestedInput
    sourceLinks?: SourceDocumentLinkUpdateManyWithoutSurveyFormNestedInput
  }

  export type SurveyFormUncheckedUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    descriptionMd?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumSurveyFormStatusFieldUpdateOperationsInput | $Enums.SurveyFormStatus
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    contextLabel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: SurveyResponseUncheckedUpdateManyWithoutFormNestedInput
    sourceLinks?: SourceDocumentLinkUncheckedUpdateManyWithoutSurveyFormNestedInput
  }

  export type SurveyQuestionOptionUpsertWithWhereUniqueWithoutQuestionInput = {
    where: SurveyQuestionOptionWhereUniqueInput
    update: XOR<SurveyQuestionOptionUpdateWithoutQuestionInput, SurveyQuestionOptionUncheckedUpdateWithoutQuestionInput>
    create: XOR<SurveyQuestionOptionCreateWithoutQuestionInput, SurveyQuestionOptionUncheckedCreateWithoutQuestionInput>
  }

  export type SurveyQuestionOptionUpdateWithWhereUniqueWithoutQuestionInput = {
    where: SurveyQuestionOptionWhereUniqueInput
    data: XOR<SurveyQuestionOptionUpdateWithoutQuestionInput, SurveyQuestionOptionUncheckedUpdateWithoutQuestionInput>
  }

  export type SurveyQuestionOptionUpdateManyWithWhereWithoutQuestionInput = {
    where: SurveyQuestionOptionScalarWhereInput
    data: XOR<SurveyQuestionOptionUpdateManyMutationInput, SurveyQuestionOptionUncheckedUpdateManyWithoutQuestionInput>
  }

  export type SurveyQuestionOptionScalarWhereInput = {
    AND?: SurveyQuestionOptionScalarWhereInput | SurveyQuestionOptionScalarWhereInput[]
    OR?: SurveyQuestionOptionScalarWhereInput[]
    NOT?: SurveyQuestionOptionScalarWhereInput | SurveyQuestionOptionScalarWhereInput[]
    id?: UuidFilter<"SurveyQuestionOption"> | string
    questionId?: UuidFilter<"SurveyQuestionOption"> | string
    valueKey?: StringFilter<"SurveyQuestionOption"> | string
    label?: StringFilter<"SurveyQuestionOption"> | string
    sortOrder?: IntFilter<"SurveyQuestionOption"> | number
    isActive?: BoolFilter<"SurveyQuestionOption"> | boolean
    createdAt?: DateTimeFilter<"SurveyQuestionOption"> | Date | string
  }

  export type SurveyResponseItemUpsertWithWhereUniqueWithoutQuestionInput = {
    where: SurveyResponseItemWhereUniqueInput
    update: XOR<SurveyResponseItemUpdateWithoutQuestionInput, SurveyResponseItemUncheckedUpdateWithoutQuestionInput>
    create: XOR<SurveyResponseItemCreateWithoutQuestionInput, SurveyResponseItemUncheckedCreateWithoutQuestionInput>
  }

  export type SurveyResponseItemUpdateWithWhereUniqueWithoutQuestionInput = {
    where: SurveyResponseItemWhereUniqueInput
    data: XOR<SurveyResponseItemUpdateWithoutQuestionInput, SurveyResponseItemUncheckedUpdateWithoutQuestionInput>
  }

  export type SurveyResponseItemUpdateManyWithWhereWithoutQuestionInput = {
    where: SurveyResponseItemScalarWhereInput
    data: XOR<SurveyResponseItemUpdateManyMutationInput, SurveyResponseItemUncheckedUpdateManyWithoutQuestionInput>
  }

  export type SurveyResponseItemScalarWhereInput = {
    AND?: SurveyResponseItemScalarWhereInput | SurveyResponseItemScalarWhereInput[]
    OR?: SurveyResponseItemScalarWhereInput[]
    NOT?: SurveyResponseItemScalarWhereInput | SurveyResponseItemScalarWhereInput[]
    id?: UuidFilter<"SurveyResponseItem"> | string
    responseId?: UuidFilter<"SurveyResponseItem"> | string
    questionId?: UuidFilter<"SurveyResponseItem"> | string
    valueText?: StringNullableFilter<"SurveyResponseItem"> | string | null
    valueNumber?: FloatNullableFilter<"SurveyResponseItem"> | number | null
    valueBoolean?: BoolNullableFilter<"SurveyResponseItem"> | boolean | null
    selectedOptionId?: UuidNullableFilter<"SurveyResponseItem"> | string | null
    mediaAssetId?: UuidNullableFilter<"SurveyResponseItem"> | string | null
    createdAt?: DateTimeFilter<"SurveyResponseItem"> | Date | string
  }

  export type SurveyQuestionCreateWithoutOptionsInput = {
    id?: string
    questionKey: string
    prompt: string
    helpText?: string | null
    questionType: $Enums.SurveyQuestionType
    required?: boolean
    sortOrder?: number
    isActive?: boolean
    allowVoice?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    form: SurveyFormCreateNestedOneWithoutQuestionsInput
    responseItems?: SurveyResponseItemCreateNestedManyWithoutQuestionInput
  }

  export type SurveyQuestionUncheckedCreateWithoutOptionsInput = {
    id?: string
    formId: string
    questionKey: string
    prompt: string
    helpText?: string | null
    questionType: $Enums.SurveyQuestionType
    required?: boolean
    sortOrder?: number
    isActive?: boolean
    allowVoice?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    responseItems?: SurveyResponseItemUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type SurveyQuestionCreateOrConnectWithoutOptionsInput = {
    where: SurveyQuestionWhereUniqueInput
    create: XOR<SurveyQuestionCreateWithoutOptionsInput, SurveyQuestionUncheckedCreateWithoutOptionsInput>
  }

  export type SurveyResponseItemOptionCreateWithoutOptionInput = {
    id?: string
    createdAt?: Date | string
    responseItem: SurveyResponseItemCreateNestedOneWithoutMultiSelectedOptionsInput
  }

  export type SurveyResponseItemOptionUncheckedCreateWithoutOptionInput = {
    id?: string
    responseItemId: string
    createdAt?: Date | string
  }

  export type SurveyResponseItemOptionCreateOrConnectWithoutOptionInput = {
    where: SurveyResponseItemOptionWhereUniqueInput
    create: XOR<SurveyResponseItemOptionCreateWithoutOptionInput, SurveyResponseItemOptionUncheckedCreateWithoutOptionInput>
  }

  export type SurveyResponseItemOptionCreateManyOptionInputEnvelope = {
    data: SurveyResponseItemOptionCreateManyOptionInput | SurveyResponseItemOptionCreateManyOptionInput[]
    skipDuplicates?: boolean
  }

  export type SurveyResponseItemCreateWithoutSelectedOptionInput = {
    id?: string
    valueText?: string | null
    valueNumber?: number | null
    valueBoolean?: boolean | null
    createdAt?: Date | string
    response: SurveyResponseCreateNestedOneWithoutItemsInput
    question: SurveyQuestionCreateNestedOneWithoutResponseItemsInput
    mediaAsset?: MediaAssetCreateNestedOneWithoutSurveyResponseItemsInput
    multiSelectedOptions?: SurveyResponseItemOptionCreateNestedManyWithoutResponseItemInput
  }

  export type SurveyResponseItemUncheckedCreateWithoutSelectedOptionInput = {
    id?: string
    responseId: string
    questionId: string
    valueText?: string | null
    valueNumber?: number | null
    valueBoolean?: boolean | null
    mediaAssetId?: string | null
    createdAt?: Date | string
    multiSelectedOptions?: SurveyResponseItemOptionUncheckedCreateNestedManyWithoutResponseItemInput
  }

  export type SurveyResponseItemCreateOrConnectWithoutSelectedOptionInput = {
    where: SurveyResponseItemWhereUniqueInput
    create: XOR<SurveyResponseItemCreateWithoutSelectedOptionInput, SurveyResponseItemUncheckedCreateWithoutSelectedOptionInput>
  }

  export type SurveyResponseItemCreateManySelectedOptionInputEnvelope = {
    data: SurveyResponseItemCreateManySelectedOptionInput | SurveyResponseItemCreateManySelectedOptionInput[]
    skipDuplicates?: boolean
  }

  export type SurveyQuestionUpsertWithoutOptionsInput = {
    update: XOR<SurveyQuestionUpdateWithoutOptionsInput, SurveyQuestionUncheckedUpdateWithoutOptionsInput>
    create: XOR<SurveyQuestionCreateWithoutOptionsInput, SurveyQuestionUncheckedCreateWithoutOptionsInput>
    where?: SurveyQuestionWhereInput
  }

  export type SurveyQuestionUpdateToOneWithWhereWithoutOptionsInput = {
    where?: SurveyQuestionWhereInput
    data: XOR<SurveyQuestionUpdateWithoutOptionsInput, SurveyQuestionUncheckedUpdateWithoutOptionsInput>
  }

  export type SurveyQuestionUpdateWithoutOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionKey?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    helpText?: NullableStringFieldUpdateOperationsInput | string | null
    questionType?: EnumSurveyQuestionTypeFieldUpdateOperationsInput | $Enums.SurveyQuestionType
    required?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    allowVoice?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    form?: SurveyFormUpdateOneRequiredWithoutQuestionsNestedInput
    responseItems?: SurveyResponseItemUpdateManyWithoutQuestionNestedInput
  }

  export type SurveyQuestionUncheckedUpdateWithoutOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    questionKey?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    helpText?: NullableStringFieldUpdateOperationsInput | string | null
    questionType?: EnumSurveyQuestionTypeFieldUpdateOperationsInput | $Enums.SurveyQuestionType
    required?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    allowVoice?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responseItems?: SurveyResponseItemUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type SurveyResponseItemOptionUpsertWithWhereUniqueWithoutOptionInput = {
    where: SurveyResponseItemOptionWhereUniqueInput
    update: XOR<SurveyResponseItemOptionUpdateWithoutOptionInput, SurveyResponseItemOptionUncheckedUpdateWithoutOptionInput>
    create: XOR<SurveyResponseItemOptionCreateWithoutOptionInput, SurveyResponseItemOptionUncheckedCreateWithoutOptionInput>
  }

  export type SurveyResponseItemOptionUpdateWithWhereUniqueWithoutOptionInput = {
    where: SurveyResponseItemOptionWhereUniqueInput
    data: XOR<SurveyResponseItemOptionUpdateWithoutOptionInput, SurveyResponseItemOptionUncheckedUpdateWithoutOptionInput>
  }

  export type SurveyResponseItemOptionUpdateManyWithWhereWithoutOptionInput = {
    where: SurveyResponseItemOptionScalarWhereInput
    data: XOR<SurveyResponseItemOptionUpdateManyMutationInput, SurveyResponseItemOptionUncheckedUpdateManyWithoutOptionInput>
  }

  export type SurveyResponseItemOptionScalarWhereInput = {
    AND?: SurveyResponseItemOptionScalarWhereInput | SurveyResponseItemOptionScalarWhereInput[]
    OR?: SurveyResponseItemOptionScalarWhereInput[]
    NOT?: SurveyResponseItemOptionScalarWhereInput | SurveyResponseItemOptionScalarWhereInput[]
    id?: UuidFilter<"SurveyResponseItemOption"> | string
    responseItemId?: UuidFilter<"SurveyResponseItemOption"> | string
    optionId?: UuidFilter<"SurveyResponseItemOption"> | string
    createdAt?: DateTimeFilter<"SurveyResponseItemOption"> | Date | string
  }

  export type SurveyResponseItemUpsertWithWhereUniqueWithoutSelectedOptionInput = {
    where: SurveyResponseItemWhereUniqueInput
    update: XOR<SurveyResponseItemUpdateWithoutSelectedOptionInput, SurveyResponseItemUncheckedUpdateWithoutSelectedOptionInput>
    create: XOR<SurveyResponseItemCreateWithoutSelectedOptionInput, SurveyResponseItemUncheckedCreateWithoutSelectedOptionInput>
  }

  export type SurveyResponseItemUpdateWithWhereUniqueWithoutSelectedOptionInput = {
    where: SurveyResponseItemWhereUniqueInput
    data: XOR<SurveyResponseItemUpdateWithoutSelectedOptionInput, SurveyResponseItemUncheckedUpdateWithoutSelectedOptionInput>
  }

  export type SurveyResponseItemUpdateManyWithWhereWithoutSelectedOptionInput = {
    where: SurveyResponseItemScalarWhereInput
    data: XOR<SurveyResponseItemUpdateManyMutationInput, SurveyResponseItemUncheckedUpdateManyWithoutSelectedOptionInput>
  }

  export type SurveyFormCreateWithoutResponsesInput = {
    id?: string
    title: string
    descriptionMd?: string | null
    slug: string
    status?: $Enums.SurveyFormStatus
    startAt?: Date | string | null
    endAt?: Date | string | null
    contextLabel?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    county?: CountyCreateNestedOneWithoutSurveyFormsInput
    questions?: SurveyQuestionCreateNestedManyWithoutFormInput
    sourceLinks?: SourceDocumentLinkCreateNestedManyWithoutSurveyFormInput
  }

  export type SurveyFormUncheckedCreateWithoutResponsesInput = {
    id?: string
    title: string
    descriptionMd?: string | null
    slug: string
    status?: $Enums.SurveyFormStatus
    startAt?: Date | string | null
    endAt?: Date | string | null
    countyId?: string | null
    contextLabel?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: SurveyQuestionUncheckedCreateNestedManyWithoutFormInput
    sourceLinks?: SourceDocumentLinkUncheckedCreateNestedManyWithoutSurveyFormInput
  }

  export type SurveyFormCreateOrConnectWithoutResponsesInput = {
    where: SurveyFormWhereUniqueInput
    create: XOR<SurveyFormCreateWithoutResponsesInput, SurveyFormUncheckedCreateWithoutResponsesInput>
  }

  export type CountyCreateWithoutSurveyResponsesInput = {
    id?: string
    name: string
    slug: string
    fipsCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blueprintSections?: BlueprintSectionCreateNestedManyWithoutCountyInput
    quotes?: QuoteCreateNestedManyWithoutCountyInput
    assets?: AssetCreateNestedManyWithoutCountyInput
    countyIssues?: CountyIssueCreateNestedManyWithoutCountyInput
    censusMetrics?: CensusMetricCreateNestedManyWithoutCountyInput
    blsMetrics?: BLSMetricCreateNestedManyWithoutCountyInput
    civicsOfficials?: CivicsOfficialCreateNestedManyWithoutCountyInput
    electionResults?: ElectionResultCreateNestedManyWithoutCountyInput
    surveyForms?: SurveyFormCreateNestedManyWithoutCountyInput
    aiOutputScopes?: AIOutputScopeCreateNestedManyWithoutCountyInput
    sourceLinks?: SourceDocumentLinkCreateNestedManyWithoutCountyInput
  }

  export type CountyUncheckedCreateWithoutSurveyResponsesInput = {
    id?: string
    name: string
    slug: string
    fipsCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blueprintSections?: BlueprintSectionUncheckedCreateNestedManyWithoutCountyInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutCountyInput
    assets?: AssetUncheckedCreateNestedManyWithoutCountyInput
    countyIssues?: CountyIssueUncheckedCreateNestedManyWithoutCountyInput
    censusMetrics?: CensusMetricUncheckedCreateNestedManyWithoutCountyInput
    blsMetrics?: BLSMetricUncheckedCreateNestedManyWithoutCountyInput
    civicsOfficials?: CivicsOfficialUncheckedCreateNestedManyWithoutCountyInput
    electionResults?: ElectionResultUncheckedCreateNestedManyWithoutCountyInput
    surveyForms?: SurveyFormUncheckedCreateNestedManyWithoutCountyInput
    aiOutputScopes?: AIOutputScopeUncheckedCreateNestedManyWithoutCountyInput
    sourceLinks?: SourceDocumentLinkUncheckedCreateNestedManyWithoutCountyInput
  }

  export type CountyCreateOrConnectWithoutSurveyResponsesInput = {
    where: CountyWhereUniqueInput
    create: XOR<CountyCreateWithoutSurveyResponsesInput, CountyUncheckedCreateWithoutSurveyResponsesInput>
  }

  export type SurveyResponseItemCreateWithoutResponseInput = {
    id?: string
    valueText?: string | null
    valueNumber?: number | null
    valueBoolean?: boolean | null
    createdAt?: Date | string
    question: SurveyQuestionCreateNestedOneWithoutResponseItemsInput
    selectedOption?: SurveyQuestionOptionCreateNestedOneWithoutSelectedByResponseItemsInput
    mediaAsset?: MediaAssetCreateNestedOneWithoutSurveyResponseItemsInput
    multiSelectedOptions?: SurveyResponseItemOptionCreateNestedManyWithoutResponseItemInput
  }

  export type SurveyResponseItemUncheckedCreateWithoutResponseInput = {
    id?: string
    questionId: string
    valueText?: string | null
    valueNumber?: number | null
    valueBoolean?: boolean | null
    selectedOptionId?: string | null
    mediaAssetId?: string | null
    createdAt?: Date | string
    multiSelectedOptions?: SurveyResponseItemOptionUncheckedCreateNestedManyWithoutResponseItemInput
  }

  export type SurveyResponseItemCreateOrConnectWithoutResponseInput = {
    where: SurveyResponseItemWhereUniqueInput
    create: XOR<SurveyResponseItemCreateWithoutResponseInput, SurveyResponseItemUncheckedCreateWithoutResponseInput>
  }

  export type SurveyResponseItemCreateManyResponseInputEnvelope = {
    data: SurveyResponseItemCreateManyResponseInput | SurveyResponseItemCreateManyResponseInput[]
    skipDuplicates?: boolean
  }

  export type SurveyFormUpsertWithoutResponsesInput = {
    update: XOR<SurveyFormUpdateWithoutResponsesInput, SurveyFormUncheckedUpdateWithoutResponsesInput>
    create: XOR<SurveyFormCreateWithoutResponsesInput, SurveyFormUncheckedCreateWithoutResponsesInput>
    where?: SurveyFormWhereInput
  }

  export type SurveyFormUpdateToOneWithWhereWithoutResponsesInput = {
    where?: SurveyFormWhereInput
    data: XOR<SurveyFormUpdateWithoutResponsesInput, SurveyFormUncheckedUpdateWithoutResponsesInput>
  }

  export type SurveyFormUpdateWithoutResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    descriptionMd?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumSurveyFormStatusFieldUpdateOperationsInput | $Enums.SurveyFormStatus
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contextLabel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    county?: CountyUpdateOneWithoutSurveyFormsNestedInput
    questions?: SurveyQuestionUpdateManyWithoutFormNestedInput
    sourceLinks?: SourceDocumentLinkUpdateManyWithoutSurveyFormNestedInput
  }

  export type SurveyFormUncheckedUpdateWithoutResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    descriptionMd?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumSurveyFormStatusFieldUpdateOperationsInput | $Enums.SurveyFormStatus
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    contextLabel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: SurveyQuestionUncheckedUpdateManyWithoutFormNestedInput
    sourceLinks?: SourceDocumentLinkUncheckedUpdateManyWithoutSurveyFormNestedInput
  }

  export type CountyUpsertWithoutSurveyResponsesInput = {
    update: XOR<CountyUpdateWithoutSurveyResponsesInput, CountyUncheckedUpdateWithoutSurveyResponsesInput>
    create: XOR<CountyCreateWithoutSurveyResponsesInput, CountyUncheckedCreateWithoutSurveyResponsesInput>
    where?: CountyWhereInput
  }

  export type CountyUpdateToOneWithWhereWithoutSurveyResponsesInput = {
    where?: CountyWhereInput
    data: XOR<CountyUpdateWithoutSurveyResponsesInput, CountyUncheckedUpdateWithoutSurveyResponsesInput>
  }

  export type CountyUpdateWithoutSurveyResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fipsCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blueprintSections?: BlueprintSectionUpdateManyWithoutCountyNestedInput
    quotes?: QuoteUpdateManyWithoutCountyNestedInput
    assets?: AssetUpdateManyWithoutCountyNestedInput
    countyIssues?: CountyIssueUpdateManyWithoutCountyNestedInput
    censusMetrics?: CensusMetricUpdateManyWithoutCountyNestedInput
    blsMetrics?: BLSMetricUpdateManyWithoutCountyNestedInput
    civicsOfficials?: CivicsOfficialUpdateManyWithoutCountyNestedInput
    electionResults?: ElectionResultUpdateManyWithoutCountyNestedInput
    surveyForms?: SurveyFormUpdateManyWithoutCountyNestedInput
    aiOutputScopes?: AIOutputScopeUpdateManyWithoutCountyNestedInput
    sourceLinks?: SourceDocumentLinkUpdateManyWithoutCountyNestedInput
  }

  export type CountyUncheckedUpdateWithoutSurveyResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fipsCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blueprintSections?: BlueprintSectionUncheckedUpdateManyWithoutCountyNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutCountyNestedInput
    assets?: AssetUncheckedUpdateManyWithoutCountyNestedInput
    countyIssues?: CountyIssueUncheckedUpdateManyWithoutCountyNestedInput
    censusMetrics?: CensusMetricUncheckedUpdateManyWithoutCountyNestedInput
    blsMetrics?: BLSMetricUncheckedUpdateManyWithoutCountyNestedInput
    civicsOfficials?: CivicsOfficialUncheckedUpdateManyWithoutCountyNestedInput
    electionResults?: ElectionResultUncheckedUpdateManyWithoutCountyNestedInput
    surveyForms?: SurveyFormUncheckedUpdateManyWithoutCountyNestedInput
    aiOutputScopes?: AIOutputScopeUncheckedUpdateManyWithoutCountyNestedInput
    sourceLinks?: SourceDocumentLinkUncheckedUpdateManyWithoutCountyNestedInput
  }

  export type SurveyResponseItemUpsertWithWhereUniqueWithoutResponseInput = {
    where: SurveyResponseItemWhereUniqueInput
    update: XOR<SurveyResponseItemUpdateWithoutResponseInput, SurveyResponseItemUncheckedUpdateWithoutResponseInput>
    create: XOR<SurveyResponseItemCreateWithoutResponseInput, SurveyResponseItemUncheckedCreateWithoutResponseInput>
  }

  export type SurveyResponseItemUpdateWithWhereUniqueWithoutResponseInput = {
    where: SurveyResponseItemWhereUniqueInput
    data: XOR<SurveyResponseItemUpdateWithoutResponseInput, SurveyResponseItemUncheckedUpdateWithoutResponseInput>
  }

  export type SurveyResponseItemUpdateManyWithWhereWithoutResponseInput = {
    where: SurveyResponseItemScalarWhereInput
    data: XOR<SurveyResponseItemUpdateManyMutationInput, SurveyResponseItemUncheckedUpdateManyWithoutResponseInput>
  }

  export type SurveyResponseCreateWithoutItemsInput = {
    id?: string
    sourceLabel?: string | null
    submittedAt?: Date | string
    ipHash?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    form: SurveyFormCreateNestedOneWithoutResponsesInput
    county?: CountyCreateNestedOneWithoutSurveyResponsesInput
  }

  export type SurveyResponseUncheckedCreateWithoutItemsInput = {
    id?: string
    formId: string
    countyId?: string | null
    sourceLabel?: string | null
    submittedAt?: Date | string
    ipHash?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type SurveyResponseCreateOrConnectWithoutItemsInput = {
    where: SurveyResponseWhereUniqueInput
    create: XOR<SurveyResponseCreateWithoutItemsInput, SurveyResponseUncheckedCreateWithoutItemsInput>
  }

  export type SurveyQuestionCreateWithoutResponseItemsInput = {
    id?: string
    questionKey: string
    prompt: string
    helpText?: string | null
    questionType: $Enums.SurveyQuestionType
    required?: boolean
    sortOrder?: number
    isActive?: boolean
    allowVoice?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    form: SurveyFormCreateNestedOneWithoutQuestionsInput
    options?: SurveyQuestionOptionCreateNestedManyWithoutQuestionInput
  }

  export type SurveyQuestionUncheckedCreateWithoutResponseItemsInput = {
    id?: string
    formId: string
    questionKey: string
    prompt: string
    helpText?: string | null
    questionType: $Enums.SurveyQuestionType
    required?: boolean
    sortOrder?: number
    isActive?: boolean
    allowVoice?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    options?: SurveyQuestionOptionUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type SurveyQuestionCreateOrConnectWithoutResponseItemsInput = {
    where: SurveyQuestionWhereUniqueInput
    create: XOR<SurveyQuestionCreateWithoutResponseItemsInput, SurveyQuestionUncheckedCreateWithoutResponseItemsInput>
  }

  export type SurveyQuestionOptionCreateWithoutSelectedByResponseItemsInput = {
    id?: string
    valueKey: string
    label: string
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    question: SurveyQuestionCreateNestedOneWithoutOptionsInput
    responseItemOptions?: SurveyResponseItemOptionCreateNestedManyWithoutOptionInput
  }

  export type SurveyQuestionOptionUncheckedCreateWithoutSelectedByResponseItemsInput = {
    id?: string
    questionId: string
    valueKey: string
    label: string
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    responseItemOptions?: SurveyResponseItemOptionUncheckedCreateNestedManyWithoutOptionInput
  }

  export type SurveyQuestionOptionCreateOrConnectWithoutSelectedByResponseItemsInput = {
    where: SurveyQuestionOptionWhereUniqueInput
    create: XOR<SurveyQuestionOptionCreateWithoutSelectedByResponseItemsInput, SurveyQuestionOptionUncheckedCreateWithoutSelectedByResponseItemsInput>
  }

  export type MediaAssetCreateWithoutSurveyResponseItemsInput = {
    id?: string
    assetType?: $Enums.AssetType
    storageProvider?: string | null
    storageKey?: string | null
    url?: string | null
    mimeType?: string | null
    sizeBytes?: number | null
    durationMs?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transcripts?: TranscriptCreateNestedManyWithoutMediaAssetInput
    analyses?: AIAnalysisCreateNestedManyWithoutMediaAssetInput
  }

  export type MediaAssetUncheckedCreateWithoutSurveyResponseItemsInput = {
    id?: string
    assetType?: $Enums.AssetType
    storageProvider?: string | null
    storageKey?: string | null
    url?: string | null
    mimeType?: string | null
    sizeBytes?: number | null
    durationMs?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transcripts?: TranscriptUncheckedCreateNestedManyWithoutMediaAssetInput
    analyses?: AIAnalysisUncheckedCreateNestedManyWithoutMediaAssetInput
  }

  export type MediaAssetCreateOrConnectWithoutSurveyResponseItemsInput = {
    where: MediaAssetWhereUniqueInput
    create: XOR<MediaAssetCreateWithoutSurveyResponseItemsInput, MediaAssetUncheckedCreateWithoutSurveyResponseItemsInput>
  }

  export type SurveyResponseItemOptionCreateWithoutResponseItemInput = {
    id?: string
    createdAt?: Date | string
    option: SurveyQuestionOptionCreateNestedOneWithoutResponseItemOptionsInput
  }

  export type SurveyResponseItemOptionUncheckedCreateWithoutResponseItemInput = {
    id?: string
    optionId: string
    createdAt?: Date | string
  }

  export type SurveyResponseItemOptionCreateOrConnectWithoutResponseItemInput = {
    where: SurveyResponseItemOptionWhereUniqueInput
    create: XOR<SurveyResponseItemOptionCreateWithoutResponseItemInput, SurveyResponseItemOptionUncheckedCreateWithoutResponseItemInput>
  }

  export type SurveyResponseItemOptionCreateManyResponseItemInputEnvelope = {
    data: SurveyResponseItemOptionCreateManyResponseItemInput | SurveyResponseItemOptionCreateManyResponseItemInput[]
    skipDuplicates?: boolean
  }

  export type SurveyResponseUpsertWithoutItemsInput = {
    update: XOR<SurveyResponseUpdateWithoutItemsInput, SurveyResponseUncheckedUpdateWithoutItemsInput>
    create: XOR<SurveyResponseCreateWithoutItemsInput, SurveyResponseUncheckedCreateWithoutItemsInput>
    where?: SurveyResponseWhereInput
  }

  export type SurveyResponseUpdateToOneWithWhereWithoutItemsInput = {
    where?: SurveyResponseWhereInput
    data: XOR<SurveyResponseUpdateWithoutItemsInput, SurveyResponseUncheckedUpdateWithoutItemsInput>
  }

  export type SurveyResponseUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceLabel?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipHash?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    form?: SurveyFormUpdateOneRequiredWithoutResponsesNestedInput
    county?: CountyUpdateOneWithoutSurveyResponsesNestedInput
  }

  export type SurveyResponseUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLabel?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipHash?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyQuestionUpsertWithoutResponseItemsInput = {
    update: XOR<SurveyQuestionUpdateWithoutResponseItemsInput, SurveyQuestionUncheckedUpdateWithoutResponseItemsInput>
    create: XOR<SurveyQuestionCreateWithoutResponseItemsInput, SurveyQuestionUncheckedCreateWithoutResponseItemsInput>
    where?: SurveyQuestionWhereInput
  }

  export type SurveyQuestionUpdateToOneWithWhereWithoutResponseItemsInput = {
    where?: SurveyQuestionWhereInput
    data: XOR<SurveyQuestionUpdateWithoutResponseItemsInput, SurveyQuestionUncheckedUpdateWithoutResponseItemsInput>
  }

  export type SurveyQuestionUpdateWithoutResponseItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionKey?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    helpText?: NullableStringFieldUpdateOperationsInput | string | null
    questionType?: EnumSurveyQuestionTypeFieldUpdateOperationsInput | $Enums.SurveyQuestionType
    required?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    allowVoice?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    form?: SurveyFormUpdateOneRequiredWithoutQuestionsNestedInput
    options?: SurveyQuestionOptionUpdateManyWithoutQuestionNestedInput
  }

  export type SurveyQuestionUncheckedUpdateWithoutResponseItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    questionKey?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    helpText?: NullableStringFieldUpdateOperationsInput | string | null
    questionType?: EnumSurveyQuestionTypeFieldUpdateOperationsInput | $Enums.SurveyQuestionType
    required?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    allowVoice?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: SurveyQuestionOptionUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type SurveyQuestionOptionUpsertWithoutSelectedByResponseItemsInput = {
    update: XOR<SurveyQuestionOptionUpdateWithoutSelectedByResponseItemsInput, SurveyQuestionOptionUncheckedUpdateWithoutSelectedByResponseItemsInput>
    create: XOR<SurveyQuestionOptionCreateWithoutSelectedByResponseItemsInput, SurveyQuestionOptionUncheckedCreateWithoutSelectedByResponseItemsInput>
    where?: SurveyQuestionOptionWhereInput
  }

  export type SurveyQuestionOptionUpdateToOneWithWhereWithoutSelectedByResponseItemsInput = {
    where?: SurveyQuestionOptionWhereInput
    data: XOR<SurveyQuestionOptionUpdateWithoutSelectedByResponseItemsInput, SurveyQuestionOptionUncheckedUpdateWithoutSelectedByResponseItemsInput>
  }

  export type SurveyQuestionOptionUpdateWithoutSelectedByResponseItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    valueKey?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: SurveyQuestionUpdateOneRequiredWithoutOptionsNestedInput
    responseItemOptions?: SurveyResponseItemOptionUpdateManyWithoutOptionNestedInput
  }

  export type SurveyQuestionOptionUncheckedUpdateWithoutSelectedByResponseItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    valueKey?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responseItemOptions?: SurveyResponseItemOptionUncheckedUpdateManyWithoutOptionNestedInput
  }

  export type MediaAssetUpsertWithoutSurveyResponseItemsInput = {
    update: XOR<MediaAssetUpdateWithoutSurveyResponseItemsInput, MediaAssetUncheckedUpdateWithoutSurveyResponseItemsInput>
    create: XOR<MediaAssetCreateWithoutSurveyResponseItemsInput, MediaAssetUncheckedCreateWithoutSurveyResponseItemsInput>
    where?: MediaAssetWhereInput
  }

  export type MediaAssetUpdateToOneWithWhereWithoutSurveyResponseItemsInput = {
    where?: MediaAssetWhereInput
    data: XOR<MediaAssetUpdateWithoutSurveyResponseItemsInput, MediaAssetUncheckedUpdateWithoutSurveyResponseItemsInput>
  }

  export type MediaAssetUpdateWithoutSurveyResponseItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetType?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    storageProvider?: NullableStringFieldUpdateOperationsInput | string | null
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transcripts?: TranscriptUpdateManyWithoutMediaAssetNestedInput
    analyses?: AIAnalysisUpdateManyWithoutMediaAssetNestedInput
  }

  export type MediaAssetUncheckedUpdateWithoutSurveyResponseItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetType?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    storageProvider?: NullableStringFieldUpdateOperationsInput | string | null
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transcripts?: TranscriptUncheckedUpdateManyWithoutMediaAssetNestedInput
    analyses?: AIAnalysisUncheckedUpdateManyWithoutMediaAssetNestedInput
  }

  export type SurveyResponseItemOptionUpsertWithWhereUniqueWithoutResponseItemInput = {
    where: SurveyResponseItemOptionWhereUniqueInput
    update: XOR<SurveyResponseItemOptionUpdateWithoutResponseItemInput, SurveyResponseItemOptionUncheckedUpdateWithoutResponseItemInput>
    create: XOR<SurveyResponseItemOptionCreateWithoutResponseItemInput, SurveyResponseItemOptionUncheckedCreateWithoutResponseItemInput>
  }

  export type SurveyResponseItemOptionUpdateWithWhereUniqueWithoutResponseItemInput = {
    where: SurveyResponseItemOptionWhereUniqueInput
    data: XOR<SurveyResponseItemOptionUpdateWithoutResponseItemInput, SurveyResponseItemOptionUncheckedUpdateWithoutResponseItemInput>
  }

  export type SurveyResponseItemOptionUpdateManyWithWhereWithoutResponseItemInput = {
    where: SurveyResponseItemOptionScalarWhereInput
    data: XOR<SurveyResponseItemOptionUpdateManyMutationInput, SurveyResponseItemOptionUncheckedUpdateManyWithoutResponseItemInput>
  }

  export type SurveyResponseItemCreateWithoutMultiSelectedOptionsInput = {
    id?: string
    valueText?: string | null
    valueNumber?: number | null
    valueBoolean?: boolean | null
    createdAt?: Date | string
    response: SurveyResponseCreateNestedOneWithoutItemsInput
    question: SurveyQuestionCreateNestedOneWithoutResponseItemsInput
    selectedOption?: SurveyQuestionOptionCreateNestedOneWithoutSelectedByResponseItemsInput
    mediaAsset?: MediaAssetCreateNestedOneWithoutSurveyResponseItemsInput
  }

  export type SurveyResponseItemUncheckedCreateWithoutMultiSelectedOptionsInput = {
    id?: string
    responseId: string
    questionId: string
    valueText?: string | null
    valueNumber?: number | null
    valueBoolean?: boolean | null
    selectedOptionId?: string | null
    mediaAssetId?: string | null
    createdAt?: Date | string
  }

  export type SurveyResponseItemCreateOrConnectWithoutMultiSelectedOptionsInput = {
    where: SurveyResponseItemWhereUniqueInput
    create: XOR<SurveyResponseItemCreateWithoutMultiSelectedOptionsInput, SurveyResponseItemUncheckedCreateWithoutMultiSelectedOptionsInput>
  }

  export type SurveyQuestionOptionCreateWithoutResponseItemOptionsInput = {
    id?: string
    valueKey: string
    label: string
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    question: SurveyQuestionCreateNestedOneWithoutOptionsInput
    selectedByResponseItems?: SurveyResponseItemCreateNestedManyWithoutSelectedOptionInput
  }

  export type SurveyQuestionOptionUncheckedCreateWithoutResponseItemOptionsInput = {
    id?: string
    questionId: string
    valueKey: string
    label: string
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    selectedByResponseItems?: SurveyResponseItemUncheckedCreateNestedManyWithoutSelectedOptionInput
  }

  export type SurveyQuestionOptionCreateOrConnectWithoutResponseItemOptionsInput = {
    where: SurveyQuestionOptionWhereUniqueInput
    create: XOR<SurveyQuestionOptionCreateWithoutResponseItemOptionsInput, SurveyQuestionOptionUncheckedCreateWithoutResponseItemOptionsInput>
  }

  export type SurveyResponseItemUpsertWithoutMultiSelectedOptionsInput = {
    update: XOR<SurveyResponseItemUpdateWithoutMultiSelectedOptionsInput, SurveyResponseItemUncheckedUpdateWithoutMultiSelectedOptionsInput>
    create: XOR<SurveyResponseItemCreateWithoutMultiSelectedOptionsInput, SurveyResponseItemUncheckedCreateWithoutMultiSelectedOptionsInput>
    where?: SurveyResponseItemWhereInput
  }

  export type SurveyResponseItemUpdateToOneWithWhereWithoutMultiSelectedOptionsInput = {
    where?: SurveyResponseItemWhereInput
    data: XOR<SurveyResponseItemUpdateWithoutMultiSelectedOptionsInput, SurveyResponseItemUncheckedUpdateWithoutMultiSelectedOptionsInput>
  }

  export type SurveyResponseItemUpdateWithoutMultiSelectedOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    valueText?: NullableStringFieldUpdateOperationsInput | string | null
    valueNumber?: NullableFloatFieldUpdateOperationsInput | number | null
    valueBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    response?: SurveyResponseUpdateOneRequiredWithoutItemsNestedInput
    question?: SurveyQuestionUpdateOneRequiredWithoutResponseItemsNestedInput
    selectedOption?: SurveyQuestionOptionUpdateOneWithoutSelectedByResponseItemsNestedInput
    mediaAsset?: MediaAssetUpdateOneWithoutSurveyResponseItemsNestedInput
  }

  export type SurveyResponseItemUncheckedUpdateWithoutMultiSelectedOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    responseId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    valueText?: NullableStringFieldUpdateOperationsInput | string | null
    valueNumber?: NullableFloatFieldUpdateOperationsInput | number | null
    valueBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
    selectedOptionId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaAssetId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyQuestionOptionUpsertWithoutResponseItemOptionsInput = {
    update: XOR<SurveyQuestionOptionUpdateWithoutResponseItemOptionsInput, SurveyQuestionOptionUncheckedUpdateWithoutResponseItemOptionsInput>
    create: XOR<SurveyQuestionOptionCreateWithoutResponseItemOptionsInput, SurveyQuestionOptionUncheckedCreateWithoutResponseItemOptionsInput>
    where?: SurveyQuestionOptionWhereInput
  }

  export type SurveyQuestionOptionUpdateToOneWithWhereWithoutResponseItemOptionsInput = {
    where?: SurveyQuestionOptionWhereInput
    data: XOR<SurveyQuestionOptionUpdateWithoutResponseItemOptionsInput, SurveyQuestionOptionUncheckedUpdateWithoutResponseItemOptionsInput>
  }

  export type SurveyQuestionOptionUpdateWithoutResponseItemOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    valueKey?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: SurveyQuestionUpdateOneRequiredWithoutOptionsNestedInput
    selectedByResponseItems?: SurveyResponseItemUpdateManyWithoutSelectedOptionNestedInput
  }

  export type SurveyQuestionOptionUncheckedUpdateWithoutResponseItemOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    valueKey?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    selectedByResponseItems?: SurveyResponseItemUncheckedUpdateManyWithoutSelectedOptionNestedInput
  }

  export type SurveyResponseItemCreateWithoutMediaAssetInput = {
    id?: string
    valueText?: string | null
    valueNumber?: number | null
    valueBoolean?: boolean | null
    createdAt?: Date | string
    response: SurveyResponseCreateNestedOneWithoutItemsInput
    question: SurveyQuestionCreateNestedOneWithoutResponseItemsInput
    selectedOption?: SurveyQuestionOptionCreateNestedOneWithoutSelectedByResponseItemsInput
    multiSelectedOptions?: SurveyResponseItemOptionCreateNestedManyWithoutResponseItemInput
  }

  export type SurveyResponseItemUncheckedCreateWithoutMediaAssetInput = {
    id?: string
    responseId: string
    questionId: string
    valueText?: string | null
    valueNumber?: number | null
    valueBoolean?: boolean | null
    selectedOptionId?: string | null
    createdAt?: Date | string
    multiSelectedOptions?: SurveyResponseItemOptionUncheckedCreateNestedManyWithoutResponseItemInput
  }

  export type SurveyResponseItemCreateOrConnectWithoutMediaAssetInput = {
    where: SurveyResponseItemWhereUniqueInput
    create: XOR<SurveyResponseItemCreateWithoutMediaAssetInput, SurveyResponseItemUncheckedCreateWithoutMediaAssetInput>
  }

  export type SurveyResponseItemCreateManyMediaAssetInputEnvelope = {
    data: SurveyResponseItemCreateManyMediaAssetInput | SurveyResponseItemCreateManyMediaAssetInput[]
    skipDuplicates?: boolean
  }

  export type TranscriptCreateWithoutMediaAssetInput = {
    id?: string
    provider?: string | null
    providerVersion?: string | null
    language?: string | null
    transcriptText: string
    segmentsJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    analyses?: AIAnalysisCreateNestedManyWithoutTranscriptInput
  }

  export type TranscriptUncheckedCreateWithoutMediaAssetInput = {
    id?: string
    provider?: string | null
    providerVersion?: string | null
    language?: string | null
    transcriptText: string
    segmentsJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    analyses?: AIAnalysisUncheckedCreateNestedManyWithoutTranscriptInput
  }

  export type TranscriptCreateOrConnectWithoutMediaAssetInput = {
    where: TranscriptWhereUniqueInput
    create: XOR<TranscriptCreateWithoutMediaAssetInput, TranscriptUncheckedCreateWithoutMediaAssetInput>
  }

  export type TranscriptCreateManyMediaAssetInputEnvelope = {
    data: TranscriptCreateManyMediaAssetInput | TranscriptCreateManyMediaAssetInput[]
    skipDuplicates?: boolean
  }

  export type AIAnalysisCreateWithoutMediaAssetInput = {
    id?: string
    analysisType?: $Enums.AnalysisType
    contentJson: JsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
    transcript?: TranscriptCreateNestedOneWithoutAnalysesInput
    aiRun?: AIRunCreateNestedOneWithoutAnalysesInput
  }

  export type AIAnalysisUncheckedCreateWithoutMediaAssetInput = {
    id?: string
    transcriptId?: string | null
    aiRunId?: string | null
    analysisType?: $Enums.AnalysisType
    contentJson: JsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
  }

  export type AIAnalysisCreateOrConnectWithoutMediaAssetInput = {
    where: AIAnalysisWhereUniqueInput
    create: XOR<AIAnalysisCreateWithoutMediaAssetInput, AIAnalysisUncheckedCreateWithoutMediaAssetInput>
  }

  export type AIAnalysisCreateManyMediaAssetInputEnvelope = {
    data: AIAnalysisCreateManyMediaAssetInput | AIAnalysisCreateManyMediaAssetInput[]
    skipDuplicates?: boolean
  }

  export type SurveyResponseItemUpsertWithWhereUniqueWithoutMediaAssetInput = {
    where: SurveyResponseItemWhereUniqueInput
    update: XOR<SurveyResponseItemUpdateWithoutMediaAssetInput, SurveyResponseItemUncheckedUpdateWithoutMediaAssetInput>
    create: XOR<SurveyResponseItemCreateWithoutMediaAssetInput, SurveyResponseItemUncheckedCreateWithoutMediaAssetInput>
  }

  export type SurveyResponseItemUpdateWithWhereUniqueWithoutMediaAssetInput = {
    where: SurveyResponseItemWhereUniqueInput
    data: XOR<SurveyResponseItemUpdateWithoutMediaAssetInput, SurveyResponseItemUncheckedUpdateWithoutMediaAssetInput>
  }

  export type SurveyResponseItemUpdateManyWithWhereWithoutMediaAssetInput = {
    where: SurveyResponseItemScalarWhereInput
    data: XOR<SurveyResponseItemUpdateManyMutationInput, SurveyResponseItemUncheckedUpdateManyWithoutMediaAssetInput>
  }

  export type TranscriptUpsertWithWhereUniqueWithoutMediaAssetInput = {
    where: TranscriptWhereUniqueInput
    update: XOR<TranscriptUpdateWithoutMediaAssetInput, TranscriptUncheckedUpdateWithoutMediaAssetInput>
    create: XOR<TranscriptCreateWithoutMediaAssetInput, TranscriptUncheckedCreateWithoutMediaAssetInput>
  }

  export type TranscriptUpdateWithWhereUniqueWithoutMediaAssetInput = {
    where: TranscriptWhereUniqueInput
    data: XOR<TranscriptUpdateWithoutMediaAssetInput, TranscriptUncheckedUpdateWithoutMediaAssetInput>
  }

  export type TranscriptUpdateManyWithWhereWithoutMediaAssetInput = {
    where: TranscriptScalarWhereInput
    data: XOR<TranscriptUpdateManyMutationInput, TranscriptUncheckedUpdateManyWithoutMediaAssetInput>
  }

  export type TranscriptScalarWhereInput = {
    AND?: TranscriptScalarWhereInput | TranscriptScalarWhereInput[]
    OR?: TranscriptScalarWhereInput[]
    NOT?: TranscriptScalarWhereInput | TranscriptScalarWhereInput[]
    id?: UuidFilter<"Transcript"> | string
    mediaAssetId?: UuidFilter<"Transcript"> | string
    provider?: StringNullableFilter<"Transcript"> | string | null
    providerVersion?: StringNullableFilter<"Transcript"> | string | null
    language?: StringNullableFilter<"Transcript"> | string | null
    transcriptText?: StringFilter<"Transcript"> | string
    segmentsJson?: JsonNullableFilter<"Transcript">
    createdAt?: DateTimeFilter<"Transcript"> | Date | string
  }

  export type AIAnalysisUpsertWithWhereUniqueWithoutMediaAssetInput = {
    where: AIAnalysisWhereUniqueInput
    update: XOR<AIAnalysisUpdateWithoutMediaAssetInput, AIAnalysisUncheckedUpdateWithoutMediaAssetInput>
    create: XOR<AIAnalysisCreateWithoutMediaAssetInput, AIAnalysisUncheckedCreateWithoutMediaAssetInput>
  }

  export type AIAnalysisUpdateWithWhereUniqueWithoutMediaAssetInput = {
    where: AIAnalysisWhereUniqueInput
    data: XOR<AIAnalysisUpdateWithoutMediaAssetInput, AIAnalysisUncheckedUpdateWithoutMediaAssetInput>
  }

  export type AIAnalysisUpdateManyWithWhereWithoutMediaAssetInput = {
    where: AIAnalysisScalarWhereInput
    data: XOR<AIAnalysisUpdateManyMutationInput, AIAnalysisUncheckedUpdateManyWithoutMediaAssetInput>
  }

  export type MediaAssetCreateWithoutTranscriptsInput = {
    id?: string
    assetType?: $Enums.AssetType
    storageProvider?: string | null
    storageKey?: string | null
    url?: string | null
    mimeType?: string | null
    sizeBytes?: number | null
    durationMs?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    surveyResponseItems?: SurveyResponseItemCreateNestedManyWithoutMediaAssetInput
    analyses?: AIAnalysisCreateNestedManyWithoutMediaAssetInput
  }

  export type MediaAssetUncheckedCreateWithoutTranscriptsInput = {
    id?: string
    assetType?: $Enums.AssetType
    storageProvider?: string | null
    storageKey?: string | null
    url?: string | null
    mimeType?: string | null
    sizeBytes?: number | null
    durationMs?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    surveyResponseItems?: SurveyResponseItemUncheckedCreateNestedManyWithoutMediaAssetInput
    analyses?: AIAnalysisUncheckedCreateNestedManyWithoutMediaAssetInput
  }

  export type MediaAssetCreateOrConnectWithoutTranscriptsInput = {
    where: MediaAssetWhereUniqueInput
    create: XOR<MediaAssetCreateWithoutTranscriptsInput, MediaAssetUncheckedCreateWithoutTranscriptsInput>
  }

  export type AIAnalysisCreateWithoutTranscriptInput = {
    id?: string
    analysisType?: $Enums.AnalysisType
    contentJson: JsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
    mediaAsset?: MediaAssetCreateNestedOneWithoutAnalysesInput
    aiRun?: AIRunCreateNestedOneWithoutAnalysesInput
  }

  export type AIAnalysisUncheckedCreateWithoutTranscriptInput = {
    id?: string
    mediaAssetId?: string | null
    aiRunId?: string | null
    analysisType?: $Enums.AnalysisType
    contentJson: JsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
  }

  export type AIAnalysisCreateOrConnectWithoutTranscriptInput = {
    where: AIAnalysisWhereUniqueInput
    create: XOR<AIAnalysisCreateWithoutTranscriptInput, AIAnalysisUncheckedCreateWithoutTranscriptInput>
  }

  export type AIAnalysisCreateManyTranscriptInputEnvelope = {
    data: AIAnalysisCreateManyTranscriptInput | AIAnalysisCreateManyTranscriptInput[]
    skipDuplicates?: boolean
  }

  export type MediaAssetUpsertWithoutTranscriptsInput = {
    update: XOR<MediaAssetUpdateWithoutTranscriptsInput, MediaAssetUncheckedUpdateWithoutTranscriptsInput>
    create: XOR<MediaAssetCreateWithoutTranscriptsInput, MediaAssetUncheckedCreateWithoutTranscriptsInput>
    where?: MediaAssetWhereInput
  }

  export type MediaAssetUpdateToOneWithWhereWithoutTranscriptsInput = {
    where?: MediaAssetWhereInput
    data: XOR<MediaAssetUpdateWithoutTranscriptsInput, MediaAssetUncheckedUpdateWithoutTranscriptsInput>
  }

  export type MediaAssetUpdateWithoutTranscriptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetType?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    storageProvider?: NullableStringFieldUpdateOperationsInput | string | null
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surveyResponseItems?: SurveyResponseItemUpdateManyWithoutMediaAssetNestedInput
    analyses?: AIAnalysisUpdateManyWithoutMediaAssetNestedInput
  }

  export type MediaAssetUncheckedUpdateWithoutTranscriptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetType?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    storageProvider?: NullableStringFieldUpdateOperationsInput | string | null
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surveyResponseItems?: SurveyResponseItemUncheckedUpdateManyWithoutMediaAssetNestedInput
    analyses?: AIAnalysisUncheckedUpdateManyWithoutMediaAssetNestedInput
  }

  export type AIAnalysisUpsertWithWhereUniqueWithoutTranscriptInput = {
    where: AIAnalysisWhereUniqueInput
    update: XOR<AIAnalysisUpdateWithoutTranscriptInput, AIAnalysisUncheckedUpdateWithoutTranscriptInput>
    create: XOR<AIAnalysisCreateWithoutTranscriptInput, AIAnalysisUncheckedCreateWithoutTranscriptInput>
  }

  export type AIAnalysisUpdateWithWhereUniqueWithoutTranscriptInput = {
    where: AIAnalysisWhereUniqueInput
    data: XOR<AIAnalysisUpdateWithoutTranscriptInput, AIAnalysisUncheckedUpdateWithoutTranscriptInput>
  }

  export type AIAnalysisUpdateManyWithWhereWithoutTranscriptInput = {
    where: AIAnalysisScalarWhereInput
    data: XOR<AIAnalysisUpdateManyMutationInput, AIAnalysisUncheckedUpdateManyWithoutTranscriptInput>
  }

  export type TranscriptCreateWithoutAnalysesInput = {
    id?: string
    provider?: string | null
    providerVersion?: string | null
    language?: string | null
    transcriptText: string
    segmentsJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    mediaAsset: MediaAssetCreateNestedOneWithoutTranscriptsInput
  }

  export type TranscriptUncheckedCreateWithoutAnalysesInput = {
    id?: string
    mediaAssetId: string
    provider?: string | null
    providerVersion?: string | null
    language?: string | null
    transcriptText: string
    segmentsJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type TranscriptCreateOrConnectWithoutAnalysesInput = {
    where: TranscriptWhereUniqueInput
    create: XOR<TranscriptCreateWithoutAnalysesInput, TranscriptUncheckedCreateWithoutAnalysesInput>
  }

  export type MediaAssetCreateWithoutAnalysesInput = {
    id?: string
    assetType?: $Enums.AssetType
    storageProvider?: string | null
    storageKey?: string | null
    url?: string | null
    mimeType?: string | null
    sizeBytes?: number | null
    durationMs?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    surveyResponseItems?: SurveyResponseItemCreateNestedManyWithoutMediaAssetInput
    transcripts?: TranscriptCreateNestedManyWithoutMediaAssetInput
  }

  export type MediaAssetUncheckedCreateWithoutAnalysesInput = {
    id?: string
    assetType?: $Enums.AssetType
    storageProvider?: string | null
    storageKey?: string | null
    url?: string | null
    mimeType?: string | null
    sizeBytes?: number | null
    durationMs?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    surveyResponseItems?: SurveyResponseItemUncheckedCreateNestedManyWithoutMediaAssetInput
    transcripts?: TranscriptUncheckedCreateNestedManyWithoutMediaAssetInput
  }

  export type MediaAssetCreateOrConnectWithoutAnalysesInput = {
    where: MediaAssetWhereUniqueInput
    create: XOR<MediaAssetCreateWithoutAnalysesInput, MediaAssetUncheckedCreateWithoutAnalysesInput>
  }

  export type AIRunCreateWithoutAnalysesInput = {
    id?: string
    model: string
    paramsJson?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.AIRunStatus
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorText?: string | null
    inputSummary?: string | null
    createdAt?: Date | string
    prompt: AIPromptCreateNestedOneWithoutRunsInput
    outputs?: AIOutputCreateNestedManyWithoutRunInput
    inputSources?: AIRunInputSourceCreateNestedManyWithoutRunInput
  }

  export type AIRunUncheckedCreateWithoutAnalysesInput = {
    id?: string
    promptId: string
    model: string
    paramsJson?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.AIRunStatus
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorText?: string | null
    inputSummary?: string | null
    createdAt?: Date | string
    outputs?: AIOutputUncheckedCreateNestedManyWithoutRunInput
    inputSources?: AIRunInputSourceUncheckedCreateNestedManyWithoutRunInput
  }

  export type AIRunCreateOrConnectWithoutAnalysesInput = {
    where: AIRunWhereUniqueInput
    create: XOR<AIRunCreateWithoutAnalysesInput, AIRunUncheckedCreateWithoutAnalysesInput>
  }

  export type TranscriptUpsertWithoutAnalysesInput = {
    update: XOR<TranscriptUpdateWithoutAnalysesInput, TranscriptUncheckedUpdateWithoutAnalysesInput>
    create: XOR<TranscriptCreateWithoutAnalysesInput, TranscriptUncheckedCreateWithoutAnalysesInput>
    where?: TranscriptWhereInput
  }

  export type TranscriptUpdateToOneWithWhereWithoutAnalysesInput = {
    where?: TranscriptWhereInput
    data: XOR<TranscriptUpdateWithoutAnalysesInput, TranscriptUncheckedUpdateWithoutAnalysesInput>
  }

  export type TranscriptUpdateWithoutAnalysesInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerVersion?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptText?: StringFieldUpdateOperationsInput | string
    segmentsJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaAsset?: MediaAssetUpdateOneRequiredWithoutTranscriptsNestedInput
  }

  export type TranscriptUncheckedUpdateWithoutAnalysesInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaAssetId?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerVersion?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptText?: StringFieldUpdateOperationsInput | string
    segmentsJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaAssetUpsertWithoutAnalysesInput = {
    update: XOR<MediaAssetUpdateWithoutAnalysesInput, MediaAssetUncheckedUpdateWithoutAnalysesInput>
    create: XOR<MediaAssetCreateWithoutAnalysesInput, MediaAssetUncheckedCreateWithoutAnalysesInput>
    where?: MediaAssetWhereInput
  }

  export type MediaAssetUpdateToOneWithWhereWithoutAnalysesInput = {
    where?: MediaAssetWhereInput
    data: XOR<MediaAssetUpdateWithoutAnalysesInput, MediaAssetUncheckedUpdateWithoutAnalysesInput>
  }

  export type MediaAssetUpdateWithoutAnalysesInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetType?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    storageProvider?: NullableStringFieldUpdateOperationsInput | string | null
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surveyResponseItems?: SurveyResponseItemUpdateManyWithoutMediaAssetNestedInput
    transcripts?: TranscriptUpdateManyWithoutMediaAssetNestedInput
  }

  export type MediaAssetUncheckedUpdateWithoutAnalysesInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetType?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    storageProvider?: NullableStringFieldUpdateOperationsInput | string | null
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surveyResponseItems?: SurveyResponseItemUncheckedUpdateManyWithoutMediaAssetNestedInput
    transcripts?: TranscriptUncheckedUpdateManyWithoutMediaAssetNestedInput
  }

  export type AIRunUpsertWithoutAnalysesInput = {
    update: XOR<AIRunUpdateWithoutAnalysesInput, AIRunUncheckedUpdateWithoutAnalysesInput>
    create: XOR<AIRunCreateWithoutAnalysesInput, AIRunUncheckedCreateWithoutAnalysesInput>
    where?: AIRunWhereInput
  }

  export type AIRunUpdateToOneWithWhereWithoutAnalysesInput = {
    where?: AIRunWhereInput
    data: XOR<AIRunUpdateWithoutAnalysesInput, AIRunUncheckedUpdateWithoutAnalysesInput>
  }

  export type AIRunUpdateWithoutAnalysesInput = {
    id?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    paramsJson?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAIRunStatusFieldUpdateOperationsInput | $Enums.AIRunStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorText?: NullableStringFieldUpdateOperationsInput | string | null
    inputSummary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prompt?: AIPromptUpdateOneRequiredWithoutRunsNestedInput
    outputs?: AIOutputUpdateManyWithoutRunNestedInput
    inputSources?: AIRunInputSourceUpdateManyWithoutRunNestedInput
  }

  export type AIRunUncheckedUpdateWithoutAnalysesInput = {
    id?: StringFieldUpdateOperationsInput | string
    promptId?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    paramsJson?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAIRunStatusFieldUpdateOperationsInput | $Enums.AIRunStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorText?: NullableStringFieldUpdateOperationsInput | string | null
    inputSummary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    outputs?: AIOutputUncheckedUpdateManyWithoutRunNestedInput
    inputSources?: AIRunInputSourceUncheckedUpdateManyWithoutRunNestedInput
  }

  export type VoteHistoryCreateWithoutVoterInput = {
    id?: string
    electionDate?: Date | string | null
    electionName?: string | null
    voteType?: string | null
    createdAt?: Date | string
  }

  export type VoteHistoryUncheckedCreateWithoutVoterInput = {
    id?: string
    electionDate?: Date | string | null
    electionName?: string | null
    voteType?: string | null
    createdAt?: Date | string
  }

  export type VoteHistoryCreateOrConnectWithoutVoterInput = {
    where: VoteHistoryWhereUniqueInput
    create: XOR<VoteHistoryCreateWithoutVoterInput, VoteHistoryUncheckedCreateWithoutVoterInput>
  }

  export type VoteHistoryCreateManyVoterInputEnvelope = {
    data: VoteHistoryCreateManyVoterInput | VoteHistoryCreateManyVoterInput[]
    skipDuplicates?: boolean
  }

  export type SegmentMemberCreateWithoutVoterInput = {
    id?: string
    createdAt?: Date | string
    segment: SegmentCreateNestedOneWithoutMembersInput
  }

  export type SegmentMemberUncheckedCreateWithoutVoterInput = {
    id?: string
    segmentId: string
    createdAt?: Date | string
  }

  export type SegmentMemberCreateOrConnectWithoutVoterInput = {
    where: SegmentMemberWhereUniqueInput
    create: XOR<SegmentMemberCreateWithoutVoterInput, SegmentMemberUncheckedCreateWithoutVoterInput>
  }

  export type SegmentMemberCreateManyVoterInputEnvelope = {
    data: SegmentMemberCreateManyVoterInput | SegmentMemberCreateManyVoterInput[]
    skipDuplicates?: boolean
  }

  export type VoteHistoryUpsertWithWhereUniqueWithoutVoterInput = {
    where: VoteHistoryWhereUniqueInput
    update: XOR<VoteHistoryUpdateWithoutVoterInput, VoteHistoryUncheckedUpdateWithoutVoterInput>
    create: XOR<VoteHistoryCreateWithoutVoterInput, VoteHistoryUncheckedCreateWithoutVoterInput>
  }

  export type VoteHistoryUpdateWithWhereUniqueWithoutVoterInput = {
    where: VoteHistoryWhereUniqueInput
    data: XOR<VoteHistoryUpdateWithoutVoterInput, VoteHistoryUncheckedUpdateWithoutVoterInput>
  }

  export type VoteHistoryUpdateManyWithWhereWithoutVoterInput = {
    where: VoteHistoryScalarWhereInput
    data: XOR<VoteHistoryUpdateManyMutationInput, VoteHistoryUncheckedUpdateManyWithoutVoterInput>
  }

  export type VoteHistoryScalarWhereInput = {
    AND?: VoteHistoryScalarWhereInput | VoteHistoryScalarWhereInput[]
    OR?: VoteHistoryScalarWhereInput[]
    NOT?: VoteHistoryScalarWhereInput | VoteHistoryScalarWhereInput[]
    id?: UuidFilter<"VoteHistory"> | string
    voterId?: UuidFilter<"VoteHistory"> | string
    electionDate?: DateTimeNullableFilter<"VoteHistory"> | Date | string | null
    electionName?: StringNullableFilter<"VoteHistory"> | string | null
    voteType?: StringNullableFilter<"VoteHistory"> | string | null
    createdAt?: DateTimeFilter<"VoteHistory"> | Date | string
  }

  export type SegmentMemberUpsertWithWhereUniqueWithoutVoterInput = {
    where: SegmentMemberWhereUniqueInput
    update: XOR<SegmentMemberUpdateWithoutVoterInput, SegmentMemberUncheckedUpdateWithoutVoterInput>
    create: XOR<SegmentMemberCreateWithoutVoterInput, SegmentMemberUncheckedCreateWithoutVoterInput>
  }

  export type SegmentMemberUpdateWithWhereUniqueWithoutVoterInput = {
    where: SegmentMemberWhereUniqueInput
    data: XOR<SegmentMemberUpdateWithoutVoterInput, SegmentMemberUncheckedUpdateWithoutVoterInput>
  }

  export type SegmentMemberUpdateManyWithWhereWithoutVoterInput = {
    where: SegmentMemberScalarWhereInput
    data: XOR<SegmentMemberUpdateManyMutationInput, SegmentMemberUncheckedUpdateManyWithoutVoterInput>
  }

  export type SegmentMemberScalarWhereInput = {
    AND?: SegmentMemberScalarWhereInput | SegmentMemberScalarWhereInput[]
    OR?: SegmentMemberScalarWhereInput[]
    NOT?: SegmentMemberScalarWhereInput | SegmentMemberScalarWhereInput[]
    id?: UuidFilter<"SegmentMember"> | string
    segmentId?: UuidFilter<"SegmentMember"> | string
    voterId?: UuidFilter<"SegmentMember"> | string
    createdAt?: DateTimeFilter<"SegmentMember"> | Date | string
  }

  export type VoterRegistrationCreateWithoutVoteHistoryInput = {
    id?: string
    stateVoterId: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    suffix?: string | null
    dateOfBirth?: Date | string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    party?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    segmentMemberships?: SegmentMemberCreateNestedManyWithoutVoterInput
  }

  export type VoterRegistrationUncheckedCreateWithoutVoteHistoryInput = {
    id?: string
    stateVoterId: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    suffix?: string | null
    dateOfBirth?: Date | string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    party?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    segmentMemberships?: SegmentMemberUncheckedCreateNestedManyWithoutVoterInput
  }

  export type VoterRegistrationCreateOrConnectWithoutVoteHistoryInput = {
    where: VoterRegistrationWhereUniqueInput
    create: XOR<VoterRegistrationCreateWithoutVoteHistoryInput, VoterRegistrationUncheckedCreateWithoutVoteHistoryInput>
  }

  export type VoterRegistrationUpsertWithoutVoteHistoryInput = {
    update: XOR<VoterRegistrationUpdateWithoutVoteHistoryInput, VoterRegistrationUncheckedUpdateWithoutVoteHistoryInput>
    create: XOR<VoterRegistrationCreateWithoutVoteHistoryInput, VoterRegistrationUncheckedCreateWithoutVoteHistoryInput>
    where?: VoterRegistrationWhereInput
  }

  export type VoterRegistrationUpdateToOneWithWhereWithoutVoteHistoryInput = {
    where?: VoterRegistrationWhereInput
    data: XOR<VoterRegistrationUpdateWithoutVoteHistoryInput, VoterRegistrationUncheckedUpdateWithoutVoteHistoryInput>
  }

  export type VoterRegistrationUpdateWithoutVoteHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    stateVoterId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    suffix?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    party?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    segmentMemberships?: SegmentMemberUpdateManyWithoutVoterNestedInput
  }

  export type VoterRegistrationUncheckedUpdateWithoutVoteHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    stateVoterId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    suffix?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    party?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    segmentMemberships?: SegmentMemberUncheckedUpdateManyWithoutVoterNestedInput
  }

  export type SegmentMemberCreateWithoutSegmentInput = {
    id?: string
    createdAt?: Date | string
    voter: VoterRegistrationCreateNestedOneWithoutSegmentMembershipsInput
  }

  export type SegmentMemberUncheckedCreateWithoutSegmentInput = {
    id?: string
    voterId: string
    createdAt?: Date | string
  }

  export type SegmentMemberCreateOrConnectWithoutSegmentInput = {
    where: SegmentMemberWhereUniqueInput
    create: XOR<SegmentMemberCreateWithoutSegmentInput, SegmentMemberUncheckedCreateWithoutSegmentInput>
  }

  export type SegmentMemberCreateManySegmentInputEnvelope = {
    data: SegmentMemberCreateManySegmentInput | SegmentMemberCreateManySegmentInput[]
    skipDuplicates?: boolean
  }

  export type SegmentMemberUpsertWithWhereUniqueWithoutSegmentInput = {
    where: SegmentMemberWhereUniqueInput
    update: XOR<SegmentMemberUpdateWithoutSegmentInput, SegmentMemberUncheckedUpdateWithoutSegmentInput>
    create: XOR<SegmentMemberCreateWithoutSegmentInput, SegmentMemberUncheckedCreateWithoutSegmentInput>
  }

  export type SegmentMemberUpdateWithWhereUniqueWithoutSegmentInput = {
    where: SegmentMemberWhereUniqueInput
    data: XOR<SegmentMemberUpdateWithoutSegmentInput, SegmentMemberUncheckedUpdateWithoutSegmentInput>
  }

  export type SegmentMemberUpdateManyWithWhereWithoutSegmentInput = {
    where: SegmentMemberScalarWhereInput
    data: XOR<SegmentMemberUpdateManyMutationInput, SegmentMemberUncheckedUpdateManyWithoutSegmentInput>
  }

  export type SegmentCreateWithoutMembersInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SegmentUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SegmentCreateOrConnectWithoutMembersInput = {
    where: SegmentWhereUniqueInput
    create: XOR<SegmentCreateWithoutMembersInput, SegmentUncheckedCreateWithoutMembersInput>
  }

  export type VoterRegistrationCreateWithoutSegmentMembershipsInput = {
    id?: string
    stateVoterId: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    suffix?: string | null
    dateOfBirth?: Date | string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    party?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    voteHistory?: VoteHistoryCreateNestedManyWithoutVoterInput
  }

  export type VoterRegistrationUncheckedCreateWithoutSegmentMembershipsInput = {
    id?: string
    stateVoterId: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    suffix?: string | null
    dateOfBirth?: Date | string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    party?: string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    voteHistory?: VoteHistoryUncheckedCreateNestedManyWithoutVoterInput
  }

  export type VoterRegistrationCreateOrConnectWithoutSegmentMembershipsInput = {
    where: VoterRegistrationWhereUniqueInput
    create: XOR<VoterRegistrationCreateWithoutSegmentMembershipsInput, VoterRegistrationUncheckedCreateWithoutSegmentMembershipsInput>
  }

  export type SegmentUpsertWithoutMembersInput = {
    update: XOR<SegmentUpdateWithoutMembersInput, SegmentUncheckedUpdateWithoutMembersInput>
    create: XOR<SegmentCreateWithoutMembersInput, SegmentUncheckedCreateWithoutMembersInput>
    where?: SegmentWhereInput
  }

  export type SegmentUpdateToOneWithWhereWithoutMembersInput = {
    where?: SegmentWhereInput
    data: XOR<SegmentUpdateWithoutMembersInput, SegmentUncheckedUpdateWithoutMembersInput>
  }

  export type SegmentUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SegmentUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoterRegistrationUpsertWithoutSegmentMembershipsInput = {
    update: XOR<VoterRegistrationUpdateWithoutSegmentMembershipsInput, VoterRegistrationUncheckedUpdateWithoutSegmentMembershipsInput>
    create: XOR<VoterRegistrationCreateWithoutSegmentMembershipsInput, VoterRegistrationUncheckedCreateWithoutSegmentMembershipsInput>
    where?: VoterRegistrationWhereInput
  }

  export type VoterRegistrationUpdateToOneWithWhereWithoutSegmentMembershipsInput = {
    where?: VoterRegistrationWhereInput
    data: XOR<VoterRegistrationUpdateWithoutSegmentMembershipsInput, VoterRegistrationUncheckedUpdateWithoutSegmentMembershipsInput>
  }

  export type VoterRegistrationUpdateWithoutSegmentMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    stateVoterId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    suffix?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    party?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    voteHistory?: VoteHistoryUpdateManyWithoutVoterNestedInput
  }

  export type VoterRegistrationUncheckedUpdateWithoutSegmentMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    stateVoterId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    suffix?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    party?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    voteHistory?: VoteHistoryUncheckedUpdateManyWithoutVoterNestedInput
  }

  export type AuditLogCreateWithoutImportJobInput = {
    id?: string
    actorLabel?: string | null
    action: string
    entityType?: string | null
    entityId?: string | null
    metadataJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutImportJobInput = {
    id?: string
    actorLabel?: string | null
    action: string
    entityType?: string | null
    entityId?: string | null
    metadataJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutImportJobInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutImportJobInput, AuditLogUncheckedCreateWithoutImportJobInput>
  }

  export type AuditLogCreateManyImportJobInputEnvelope = {
    data: AuditLogCreateManyImportJobInput | AuditLogCreateManyImportJobInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogUpsertWithWhereUniqueWithoutImportJobInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutImportJobInput, AuditLogUncheckedUpdateWithoutImportJobInput>
    create: XOR<AuditLogCreateWithoutImportJobInput, AuditLogUncheckedCreateWithoutImportJobInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutImportJobInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutImportJobInput, AuditLogUncheckedUpdateWithoutImportJobInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutImportJobInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutImportJobInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: UuidFilter<"AuditLog"> | string
    actorLabel?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringNullableFilter<"AuditLog"> | string | null
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    metadataJson?: JsonNullableFilter<"AuditLog">
    importJobId?: UuidNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type ImportJobCreateWithoutAuditLogsInput = {
    id?: string
    kind?: $Enums.ImportJobKind
    status?: $Enums.ImportJobStatus
    fileName?: string | null
    fileHash?: string | null
    rowCount?: number | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorText?: string | null
    createdAt?: Date | string
  }

  export type ImportJobUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    kind?: $Enums.ImportJobKind
    status?: $Enums.ImportJobStatus
    fileName?: string | null
    fileHash?: string | null
    rowCount?: number | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorText?: string | null
    createdAt?: Date | string
  }

  export type ImportJobCreateOrConnectWithoutAuditLogsInput = {
    where: ImportJobWhereUniqueInput
    create: XOR<ImportJobCreateWithoutAuditLogsInput, ImportJobUncheckedCreateWithoutAuditLogsInput>
  }

  export type ImportJobUpsertWithoutAuditLogsInput = {
    update: XOR<ImportJobUpdateWithoutAuditLogsInput, ImportJobUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<ImportJobCreateWithoutAuditLogsInput, ImportJobUncheckedCreateWithoutAuditLogsInput>
    where?: ImportJobWhereInput
  }

  export type ImportJobUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: ImportJobWhereInput
    data: XOR<ImportJobUpdateWithoutAuditLogsInput, ImportJobUncheckedUpdateWithoutAuditLogsInput>
  }

  export type ImportJobUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumImportJobKindFieldUpdateOperationsInput | $Enums.ImportJobKind
    status?: EnumImportJobStatusFieldUpdateOperationsInput | $Enums.ImportJobStatus
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileHash?: NullableStringFieldUpdateOperationsInput | string | null
    rowCount?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImportJobUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumImportJobKindFieldUpdateOperationsInput | $Enums.ImportJobKind
    status?: EnumImportJobStatusFieldUpdateOperationsInput | $Enums.ImportJobStatus
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileHash?: NullableStringFieldUpdateOperationsInput | string | null
    rowCount?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlueprintSectionCreateManyCountyInput = {
    id?: string
    slug: string
    title: string
    bodyMd: string
    issueId?: string | null
    sortOrder?: number | null
    isPinned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuoteCreateManyCountyInput = {
    id?: string
    text: string
    attributionLabel?: string | null
    issueId?: string | null
    sourceNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssetCreateManyCountyInput = {
    id?: string
    assetType?: $Enums.AssetType
    title?: string | null
    caption?: string | null
    credit?: string | null
    license?: string | null
    url?: string | null
    storageKey?: string | null
    issueId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CountyIssueCreateManyCountyInput = {
    id?: string
    issueId: string
    featured?: boolean
    sortOrder?: number | null
    createdAt?: Date | string
  }

  export type CensusMetricCreateManyCountyInput = {
    id?: string
    geoZipId?: string | null
    metricKey: string
    metricLabel?: string | null
    value?: number | null
    valueText?: string | null
    asOfDate?: Date | string | null
    sourceNote?: string | null
    createdAt?: Date | string
  }

  export type BLSMetricCreateManyCountyInput = {
    id?: string
    seriesKey: string
    seriesLabel?: string | null
    value?: number | null
    asOfDate?: Date | string | null
    sourceNote?: string | null
    createdAt?: Date | string
  }

  export type CivicsOfficialCreateManyCountyInput = {
    id?: string
    name: string
    officeName: string
    party?: string | null
    phone?: string | null
    website?: string | null
    photoUrl?: string | null
    districtId?: string | null
    sourceNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ElectionResultCreateManyCountyInput = {
    id?: string
    electionId: string
    geoZipId?: string | null
    precinctId?: string | null
    choiceLabel: string
    votes?: number | null
    voteShare?: number | null
    createdAt?: Date | string
  }

  export type SurveyFormCreateManyCountyInput = {
    id?: string
    title: string
    descriptionMd?: string | null
    slug: string
    status?: $Enums.SurveyFormStatus
    startAt?: Date | string | null
    endAt?: Date | string | null
    contextLabel?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SurveyResponseCreateManyCountyInput = {
    id?: string
    formId: string
    sourceLabel?: string | null
    submittedAt?: Date | string
    ipHash?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AIOutputScopeCreateManyCountyInput = {
    id?: string
    outputId: string
    scopeType: $Enums.AIScopeType
    issueId?: string | null
    geoZipId?: string | null
    districtId?: string | null
    customKey?: string | null
    createdAt?: Date | string
  }

  export type SourceDocumentLinkCreateManyCountyInput = {
    id?: string
    sourceDocumentId: string
    issueId?: string | null
    blueprintSectionId?: string | null
    quoteId?: string | null
    assetId?: string | null
    surveyFormId?: string | null
    note?: string | null
    createdAt?: Date | string
  }

  export type BlueprintSectionUpdateWithoutCountyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    bodyMd?: StringFieldUpdateOperationsInput | string
    sortOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    issue?: IssueUpdateOneWithoutBlueprintSectionsNestedInput
    sourceLinks?: SourceDocumentLinkUpdateManyWithoutBlueprintSectionNestedInput
  }

  export type BlueprintSectionUncheckedUpdateWithoutCountyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    bodyMd?: StringFieldUpdateOperationsInput | string
    issueId?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceLinks?: SourceDocumentLinkUncheckedUpdateManyWithoutBlueprintSectionNestedInput
  }

  export type BlueprintSectionUncheckedUpdateManyWithoutCountyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    bodyMd?: StringFieldUpdateOperationsInput | string
    issueId?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteUpdateWithoutCountyInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    attributionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    sourceNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    issue?: IssueUpdateOneWithoutQuotesNestedInput
    sourceLinks?: SourceDocumentLinkUpdateManyWithoutQuoteNestedInput
  }

  export type QuoteUncheckedUpdateWithoutCountyInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    attributionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    issueId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceLinks?: SourceDocumentLinkUncheckedUpdateManyWithoutQuoteNestedInput
  }

  export type QuoteUncheckedUpdateManyWithoutCountyInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    attributionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    issueId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetUpdateWithoutCountyInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetType?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    credit?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    issue?: IssueUpdateOneWithoutAssetsNestedInput
    sourceLinks?: SourceDocumentLinkUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateWithoutCountyInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetType?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    credit?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    issueId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceLinks?: SourceDocumentLinkUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateManyWithoutCountyInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetType?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    credit?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    issueId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountyIssueUpdateWithoutCountyInput = {
    id?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    issue?: IssueUpdateOneRequiredWithoutCountyIssuesNestedInput
  }

  export type CountyIssueUncheckedUpdateWithoutCountyInput = {
    id?: StringFieldUpdateOperationsInput | string
    issueId?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountyIssueUncheckedUpdateManyWithoutCountyInput = {
    id?: StringFieldUpdateOperationsInput | string
    issueId?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CensusMetricUpdateWithoutCountyInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricKey?: StringFieldUpdateOperationsInput | string
    metricLabel?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    valueText?: NullableStringFieldUpdateOperationsInput | string | null
    asOfDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    geoZip?: GeoZipUpdateOneWithoutCensusMetricsNestedInput
  }

  export type CensusMetricUncheckedUpdateWithoutCountyInput = {
    id?: StringFieldUpdateOperationsInput | string
    geoZipId?: NullableStringFieldUpdateOperationsInput | string | null
    metricKey?: StringFieldUpdateOperationsInput | string
    metricLabel?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    valueText?: NullableStringFieldUpdateOperationsInput | string | null
    asOfDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CensusMetricUncheckedUpdateManyWithoutCountyInput = {
    id?: StringFieldUpdateOperationsInput | string
    geoZipId?: NullableStringFieldUpdateOperationsInput | string | null
    metricKey?: StringFieldUpdateOperationsInput | string
    metricLabel?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    valueText?: NullableStringFieldUpdateOperationsInput | string | null
    asOfDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BLSMetricUpdateWithoutCountyInput = {
    id?: StringFieldUpdateOperationsInput | string
    seriesKey?: StringFieldUpdateOperationsInput | string
    seriesLabel?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    asOfDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BLSMetricUncheckedUpdateWithoutCountyInput = {
    id?: StringFieldUpdateOperationsInput | string
    seriesKey?: StringFieldUpdateOperationsInput | string
    seriesLabel?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    asOfDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BLSMetricUncheckedUpdateManyWithoutCountyInput = {
    id?: StringFieldUpdateOperationsInput | string
    seriesKey?: StringFieldUpdateOperationsInput | string
    seriesLabel?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    asOfDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CivicsOfficialUpdateWithoutCountyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    officeName?: StringFieldUpdateOperationsInput | string
    party?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    sourceNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    district?: GeoDistrictUpdateOneWithoutCivicsOfficialsNestedInput
  }

  export type CivicsOfficialUncheckedUpdateWithoutCountyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    officeName?: StringFieldUpdateOperationsInput | string
    party?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    districtId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CivicsOfficialUncheckedUpdateManyWithoutCountyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    officeName?: StringFieldUpdateOperationsInput | string
    party?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    districtId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElectionResultUpdateWithoutCountyInput = {
    id?: StringFieldUpdateOperationsInput | string
    choiceLabel?: StringFieldUpdateOperationsInput | string
    votes?: NullableIntFieldUpdateOperationsInput | number | null
    voteShare?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    election?: ElectionUpdateOneRequiredWithoutResultsNestedInput
    geoZip?: GeoZipUpdateOneWithoutElectionResultsNestedInput
    precinct?: GeoPrecinctUpdateOneWithoutElectionResultsNestedInput
  }

  export type ElectionResultUncheckedUpdateWithoutCountyInput = {
    id?: StringFieldUpdateOperationsInput | string
    electionId?: StringFieldUpdateOperationsInput | string
    geoZipId?: NullableStringFieldUpdateOperationsInput | string | null
    precinctId?: NullableStringFieldUpdateOperationsInput | string | null
    choiceLabel?: StringFieldUpdateOperationsInput | string
    votes?: NullableIntFieldUpdateOperationsInput | number | null
    voteShare?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElectionResultUncheckedUpdateManyWithoutCountyInput = {
    id?: StringFieldUpdateOperationsInput | string
    electionId?: StringFieldUpdateOperationsInput | string
    geoZipId?: NullableStringFieldUpdateOperationsInput | string | null
    precinctId?: NullableStringFieldUpdateOperationsInput | string | null
    choiceLabel?: StringFieldUpdateOperationsInput | string
    votes?: NullableIntFieldUpdateOperationsInput | number | null
    voteShare?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyFormUpdateWithoutCountyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    descriptionMd?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumSurveyFormStatusFieldUpdateOperationsInput | $Enums.SurveyFormStatus
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contextLabel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: SurveyQuestionUpdateManyWithoutFormNestedInput
    responses?: SurveyResponseUpdateManyWithoutFormNestedInput
    sourceLinks?: SourceDocumentLinkUpdateManyWithoutSurveyFormNestedInput
  }

  export type SurveyFormUncheckedUpdateWithoutCountyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    descriptionMd?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumSurveyFormStatusFieldUpdateOperationsInput | $Enums.SurveyFormStatus
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contextLabel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: SurveyQuestionUncheckedUpdateManyWithoutFormNestedInput
    responses?: SurveyResponseUncheckedUpdateManyWithoutFormNestedInput
    sourceLinks?: SourceDocumentLinkUncheckedUpdateManyWithoutSurveyFormNestedInput
  }

  export type SurveyFormUncheckedUpdateManyWithoutCountyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    descriptionMd?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumSurveyFormStatusFieldUpdateOperationsInput | $Enums.SurveyFormStatus
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contextLabel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyResponseUpdateWithoutCountyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceLabel?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipHash?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    form?: SurveyFormUpdateOneRequiredWithoutResponsesNestedInput
    items?: SurveyResponseItemUpdateManyWithoutResponseNestedInput
  }

  export type SurveyResponseUncheckedUpdateWithoutCountyInput = {
    id?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    sourceLabel?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipHash?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: SurveyResponseItemUncheckedUpdateManyWithoutResponseNestedInput
  }

  export type SurveyResponseUncheckedUpdateManyWithoutCountyInput = {
    id?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    sourceLabel?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipHash?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIOutputScopeUpdateWithoutCountyInput = {
    id?: StringFieldUpdateOperationsInput | string
    scopeType?: EnumAIScopeTypeFieldUpdateOperationsInput | $Enums.AIScopeType
    customKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    output?: AIOutputUpdateOneRequiredWithoutScopesNestedInput
    issue?: IssueUpdateOneWithoutAiOutputScopesNestedInput
    geoZip?: GeoZipUpdateOneWithoutAiOutputScopesNestedInput
    district?: GeoDistrictUpdateOneWithoutAiOutputScopesNestedInput
  }

  export type AIOutputScopeUncheckedUpdateWithoutCountyInput = {
    id?: StringFieldUpdateOperationsInput | string
    outputId?: StringFieldUpdateOperationsInput | string
    scopeType?: EnumAIScopeTypeFieldUpdateOperationsInput | $Enums.AIScopeType
    issueId?: NullableStringFieldUpdateOperationsInput | string | null
    geoZipId?: NullableStringFieldUpdateOperationsInput | string | null
    districtId?: NullableStringFieldUpdateOperationsInput | string | null
    customKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIOutputScopeUncheckedUpdateManyWithoutCountyInput = {
    id?: StringFieldUpdateOperationsInput | string
    outputId?: StringFieldUpdateOperationsInput | string
    scopeType?: EnumAIScopeTypeFieldUpdateOperationsInput | $Enums.AIScopeType
    issueId?: NullableStringFieldUpdateOperationsInput | string | null
    geoZipId?: NullableStringFieldUpdateOperationsInput | string | null
    districtId?: NullableStringFieldUpdateOperationsInput | string | null
    customKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SourceDocumentLinkUpdateWithoutCountyInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceDocument?: SourceDocumentUpdateOneRequiredWithoutSourceLinksNestedInput
    issue?: IssueUpdateOneWithoutSourceLinksNestedInput
    blueprintSection?: BlueprintSectionUpdateOneWithoutSourceLinksNestedInput
    quote?: QuoteUpdateOneWithoutSourceLinksNestedInput
    asset?: AssetUpdateOneWithoutSourceLinksNestedInput
    surveyForm?: SurveyFormUpdateOneWithoutSourceLinksNestedInput
  }

  export type SourceDocumentLinkUncheckedUpdateWithoutCountyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceDocumentId?: StringFieldUpdateOperationsInput | string
    issueId?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintSectionId?: NullableStringFieldUpdateOperationsInput | string | null
    quoteId?: NullableStringFieldUpdateOperationsInput | string | null
    assetId?: NullableStringFieldUpdateOperationsInput | string | null
    surveyFormId?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SourceDocumentLinkUncheckedUpdateManyWithoutCountyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceDocumentId?: StringFieldUpdateOperationsInput | string
    issueId?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintSectionId?: NullableStringFieldUpdateOperationsInput | string | null
    quoteId?: NullableStringFieldUpdateOperationsInput | string | null
    assetId?: NullableStringFieldUpdateOperationsInput | string | null
    surveyFormId?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountyIssueCreateManyIssueInput = {
    id?: string
    countyId: string
    featured?: boolean
    sortOrder?: number | null
    createdAt?: Date | string
  }

  export type BlueprintSectionCreateManyIssueInput = {
    id?: string
    slug: string
    title: string
    bodyMd: string
    countyId?: string | null
    sortOrder?: number | null
    isPinned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuoteCreateManyIssueInput = {
    id?: string
    text: string
    attributionLabel?: string | null
    countyId: string
    sourceNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssetCreateManyIssueInput = {
    id?: string
    assetType?: $Enums.AssetType
    title?: string | null
    caption?: string | null
    credit?: string | null
    license?: string | null
    url?: string | null
    storageKey?: string | null
    countyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIOutputScopeCreateManyIssueInput = {
    id?: string
    outputId: string
    scopeType: $Enums.AIScopeType
    countyId?: string | null
    geoZipId?: string | null
    districtId?: string | null
    customKey?: string | null
    createdAt?: Date | string
  }

  export type SourceDocumentLinkCreateManyIssueInput = {
    id?: string
    sourceDocumentId: string
    countyId?: string | null
    blueprintSectionId?: string | null
    quoteId?: string | null
    assetId?: string | null
    surveyFormId?: string | null
    note?: string | null
    createdAt?: Date | string
  }

  export type CountyIssueUpdateWithoutIssueInput = {
    id?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    county?: CountyUpdateOneRequiredWithoutCountyIssuesNestedInput
  }

  export type CountyIssueUncheckedUpdateWithoutIssueInput = {
    id?: StringFieldUpdateOperationsInput | string
    countyId?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountyIssueUncheckedUpdateManyWithoutIssueInput = {
    id?: StringFieldUpdateOperationsInput | string
    countyId?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlueprintSectionUpdateWithoutIssueInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    bodyMd?: StringFieldUpdateOperationsInput | string
    sortOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    county?: CountyUpdateOneWithoutBlueprintSectionsNestedInput
    sourceLinks?: SourceDocumentLinkUpdateManyWithoutBlueprintSectionNestedInput
  }

  export type BlueprintSectionUncheckedUpdateWithoutIssueInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    bodyMd?: StringFieldUpdateOperationsInput | string
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceLinks?: SourceDocumentLinkUncheckedUpdateManyWithoutBlueprintSectionNestedInput
  }

  export type BlueprintSectionUncheckedUpdateManyWithoutIssueInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    bodyMd?: StringFieldUpdateOperationsInput | string
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteUpdateWithoutIssueInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    attributionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    sourceNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    county?: CountyUpdateOneRequiredWithoutQuotesNestedInput
    sourceLinks?: SourceDocumentLinkUpdateManyWithoutQuoteNestedInput
  }

  export type QuoteUncheckedUpdateWithoutIssueInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    attributionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    countyId?: StringFieldUpdateOperationsInput | string
    sourceNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceLinks?: SourceDocumentLinkUncheckedUpdateManyWithoutQuoteNestedInput
  }

  export type QuoteUncheckedUpdateManyWithoutIssueInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    attributionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    countyId?: StringFieldUpdateOperationsInput | string
    sourceNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetUpdateWithoutIssueInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetType?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    credit?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    county?: CountyUpdateOneWithoutAssetsNestedInput
    sourceLinks?: SourceDocumentLinkUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateWithoutIssueInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetType?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    credit?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceLinks?: SourceDocumentLinkUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateManyWithoutIssueInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetType?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    credit?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIOutputScopeUpdateWithoutIssueInput = {
    id?: StringFieldUpdateOperationsInput | string
    scopeType?: EnumAIScopeTypeFieldUpdateOperationsInput | $Enums.AIScopeType
    customKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    output?: AIOutputUpdateOneRequiredWithoutScopesNestedInput
    county?: CountyUpdateOneWithoutAiOutputScopesNestedInput
    geoZip?: GeoZipUpdateOneWithoutAiOutputScopesNestedInput
    district?: GeoDistrictUpdateOneWithoutAiOutputScopesNestedInput
  }

  export type AIOutputScopeUncheckedUpdateWithoutIssueInput = {
    id?: StringFieldUpdateOperationsInput | string
    outputId?: StringFieldUpdateOperationsInput | string
    scopeType?: EnumAIScopeTypeFieldUpdateOperationsInput | $Enums.AIScopeType
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    geoZipId?: NullableStringFieldUpdateOperationsInput | string | null
    districtId?: NullableStringFieldUpdateOperationsInput | string | null
    customKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIOutputScopeUncheckedUpdateManyWithoutIssueInput = {
    id?: StringFieldUpdateOperationsInput | string
    outputId?: StringFieldUpdateOperationsInput | string
    scopeType?: EnumAIScopeTypeFieldUpdateOperationsInput | $Enums.AIScopeType
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    geoZipId?: NullableStringFieldUpdateOperationsInput | string | null
    districtId?: NullableStringFieldUpdateOperationsInput | string | null
    customKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SourceDocumentLinkUpdateWithoutIssueInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceDocument?: SourceDocumentUpdateOneRequiredWithoutSourceLinksNestedInput
    county?: CountyUpdateOneWithoutSourceLinksNestedInput
    blueprintSection?: BlueprintSectionUpdateOneWithoutSourceLinksNestedInput
    quote?: QuoteUpdateOneWithoutSourceLinksNestedInput
    asset?: AssetUpdateOneWithoutSourceLinksNestedInput
    surveyForm?: SurveyFormUpdateOneWithoutSourceLinksNestedInput
  }

  export type SourceDocumentLinkUncheckedUpdateWithoutIssueInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceDocumentId?: StringFieldUpdateOperationsInput | string
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintSectionId?: NullableStringFieldUpdateOperationsInput | string | null
    quoteId?: NullableStringFieldUpdateOperationsInput | string | null
    assetId?: NullableStringFieldUpdateOperationsInput | string | null
    surveyFormId?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SourceDocumentLinkUncheckedUpdateManyWithoutIssueInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceDocumentId?: StringFieldUpdateOperationsInput | string
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintSectionId?: NullableStringFieldUpdateOperationsInput | string | null
    quoteId?: NullableStringFieldUpdateOperationsInput | string | null
    assetId?: NullableStringFieldUpdateOperationsInput | string | null
    surveyFormId?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SourceDocumentLinkCreateManyBlueprintSectionInput = {
    id?: string
    sourceDocumentId: string
    countyId?: string | null
    issueId?: string | null
    quoteId?: string | null
    assetId?: string | null
    surveyFormId?: string | null
    note?: string | null
    createdAt?: Date | string
  }

  export type SourceDocumentLinkUpdateWithoutBlueprintSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceDocument?: SourceDocumentUpdateOneRequiredWithoutSourceLinksNestedInput
    county?: CountyUpdateOneWithoutSourceLinksNestedInput
    issue?: IssueUpdateOneWithoutSourceLinksNestedInput
    quote?: QuoteUpdateOneWithoutSourceLinksNestedInput
    asset?: AssetUpdateOneWithoutSourceLinksNestedInput
    surveyForm?: SurveyFormUpdateOneWithoutSourceLinksNestedInput
  }

  export type SourceDocumentLinkUncheckedUpdateWithoutBlueprintSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceDocumentId?: StringFieldUpdateOperationsInput | string
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    issueId?: NullableStringFieldUpdateOperationsInput | string | null
    quoteId?: NullableStringFieldUpdateOperationsInput | string | null
    assetId?: NullableStringFieldUpdateOperationsInput | string | null
    surveyFormId?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SourceDocumentLinkUncheckedUpdateManyWithoutBlueprintSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceDocumentId?: StringFieldUpdateOperationsInput | string
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    issueId?: NullableStringFieldUpdateOperationsInput | string | null
    quoteId?: NullableStringFieldUpdateOperationsInput | string | null
    assetId?: NullableStringFieldUpdateOperationsInput | string | null
    surveyFormId?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SourceDocumentLinkCreateManyQuoteInput = {
    id?: string
    sourceDocumentId: string
    countyId?: string | null
    issueId?: string | null
    blueprintSectionId?: string | null
    assetId?: string | null
    surveyFormId?: string | null
    note?: string | null
    createdAt?: Date | string
  }

  export type SourceDocumentLinkUpdateWithoutQuoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceDocument?: SourceDocumentUpdateOneRequiredWithoutSourceLinksNestedInput
    county?: CountyUpdateOneWithoutSourceLinksNestedInput
    issue?: IssueUpdateOneWithoutSourceLinksNestedInput
    blueprintSection?: BlueprintSectionUpdateOneWithoutSourceLinksNestedInput
    asset?: AssetUpdateOneWithoutSourceLinksNestedInput
    surveyForm?: SurveyFormUpdateOneWithoutSourceLinksNestedInput
  }

  export type SourceDocumentLinkUncheckedUpdateWithoutQuoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceDocumentId?: StringFieldUpdateOperationsInput | string
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    issueId?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintSectionId?: NullableStringFieldUpdateOperationsInput | string | null
    assetId?: NullableStringFieldUpdateOperationsInput | string | null
    surveyFormId?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SourceDocumentLinkUncheckedUpdateManyWithoutQuoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceDocumentId?: StringFieldUpdateOperationsInput | string
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    issueId?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintSectionId?: NullableStringFieldUpdateOperationsInput | string | null
    assetId?: NullableStringFieldUpdateOperationsInput | string | null
    surveyFormId?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SourceDocumentLinkCreateManyAssetInput = {
    id?: string
    sourceDocumentId: string
    countyId?: string | null
    issueId?: string | null
    blueprintSectionId?: string | null
    quoteId?: string | null
    surveyFormId?: string | null
    note?: string | null
    createdAt?: Date | string
  }

  export type SourceDocumentLinkUpdateWithoutAssetInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceDocument?: SourceDocumentUpdateOneRequiredWithoutSourceLinksNestedInput
    county?: CountyUpdateOneWithoutSourceLinksNestedInput
    issue?: IssueUpdateOneWithoutSourceLinksNestedInput
    blueprintSection?: BlueprintSectionUpdateOneWithoutSourceLinksNestedInput
    quote?: QuoteUpdateOneWithoutSourceLinksNestedInput
    surveyForm?: SurveyFormUpdateOneWithoutSourceLinksNestedInput
  }

  export type SourceDocumentLinkUncheckedUpdateWithoutAssetInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceDocumentId?: StringFieldUpdateOperationsInput | string
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    issueId?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintSectionId?: NullableStringFieldUpdateOperationsInput | string | null
    quoteId?: NullableStringFieldUpdateOperationsInput | string | null
    surveyFormId?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SourceDocumentLinkUncheckedUpdateManyWithoutAssetInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceDocumentId?: StringFieldUpdateOperationsInput | string
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    issueId?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintSectionId?: NullableStringFieldUpdateOperationsInput | string | null
    quoteId?: NullableStringFieldUpdateOperationsInput | string | null
    surveyFormId?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SourceChunkCreateManySourceDocumentInput = {
    id?: string
    chunkIndex: number
    content: string
    contentHash: string
    locatorJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type CitationCreateManySourceDocumentInput = {
    id?: string
    outputSectionId: string
    sourceChunkId?: string | null
    label?: string | null
    locatorJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AIRunInputSourceCreateManySourceDocumentInput = {
    id?: string
    runId: string
    kind?: $Enums.AIRunInputKind
    externalKey?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type SourceDocumentLinkCreateManySourceDocumentInput = {
    id?: string
    countyId?: string | null
    issueId?: string | null
    blueprintSectionId?: string | null
    quoteId?: string | null
    assetId?: string | null
    surveyFormId?: string | null
    note?: string | null
    createdAt?: Date | string
  }

  export type SourceChunkUpdateWithoutSourceDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    locatorJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    citations?: CitationUpdateManyWithoutSourceChunkNestedInput
  }

  export type SourceChunkUncheckedUpdateWithoutSourceDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    locatorJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    citations?: CitationUncheckedUpdateManyWithoutSourceChunkNestedInput
  }

  export type SourceChunkUncheckedUpdateManyWithoutSourceDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    locatorJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CitationUpdateWithoutSourceDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    locatorJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    outputSection?: AIOutputSectionUpdateOneRequiredWithoutCitationsNestedInput
    sourceChunk?: SourceChunkUpdateOneWithoutCitationsNestedInput
  }

  export type CitationUncheckedUpdateWithoutSourceDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    outputSectionId?: StringFieldUpdateOperationsInput | string
    sourceChunkId?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    locatorJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CitationUncheckedUpdateManyWithoutSourceDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    outputSectionId?: StringFieldUpdateOperationsInput | string
    sourceChunkId?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    locatorJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIRunInputSourceUpdateWithoutSourceDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumAIRunInputKindFieldUpdateOperationsInput | $Enums.AIRunInputKind
    externalKey?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    run?: AIRunUpdateOneRequiredWithoutInputSourcesNestedInput
  }

  export type AIRunInputSourceUncheckedUpdateWithoutSourceDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    runId?: StringFieldUpdateOperationsInput | string
    kind?: EnumAIRunInputKindFieldUpdateOperationsInput | $Enums.AIRunInputKind
    externalKey?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIRunInputSourceUncheckedUpdateManyWithoutSourceDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    runId?: StringFieldUpdateOperationsInput | string
    kind?: EnumAIRunInputKindFieldUpdateOperationsInput | $Enums.AIRunInputKind
    externalKey?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SourceDocumentLinkUpdateWithoutSourceDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    county?: CountyUpdateOneWithoutSourceLinksNestedInput
    issue?: IssueUpdateOneWithoutSourceLinksNestedInput
    blueprintSection?: BlueprintSectionUpdateOneWithoutSourceLinksNestedInput
    quote?: QuoteUpdateOneWithoutSourceLinksNestedInput
    asset?: AssetUpdateOneWithoutSourceLinksNestedInput
    surveyForm?: SurveyFormUpdateOneWithoutSourceLinksNestedInput
  }

  export type SourceDocumentLinkUncheckedUpdateWithoutSourceDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    issueId?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintSectionId?: NullableStringFieldUpdateOperationsInput | string | null
    quoteId?: NullableStringFieldUpdateOperationsInput | string | null
    assetId?: NullableStringFieldUpdateOperationsInput | string | null
    surveyFormId?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SourceDocumentLinkUncheckedUpdateManyWithoutSourceDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    issueId?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintSectionId?: NullableStringFieldUpdateOperationsInput | string | null
    quoteId?: NullableStringFieldUpdateOperationsInput | string | null
    assetId?: NullableStringFieldUpdateOperationsInput | string | null
    surveyFormId?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CitationCreateManySourceChunkInput = {
    id?: string
    outputSectionId: string
    sourceDocumentId?: string | null
    label?: string | null
    locatorJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type CitationUpdateWithoutSourceChunkInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    locatorJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    outputSection?: AIOutputSectionUpdateOneRequiredWithoutCitationsNestedInput
    sourceDocument?: SourceDocumentUpdateOneWithoutCitationsNestedInput
  }

  export type CitationUncheckedUpdateWithoutSourceChunkInput = {
    id?: StringFieldUpdateOperationsInput | string
    outputSectionId?: StringFieldUpdateOperationsInput | string
    sourceDocumentId?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    locatorJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CitationUncheckedUpdateManyWithoutSourceChunkInput = {
    id?: StringFieldUpdateOperationsInput | string
    outputSectionId?: StringFieldUpdateOperationsInput | string
    sourceDocumentId?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    locatorJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CensusMetricCreateManyGeoZipInput = {
    id?: string
    countyId?: string | null
    metricKey: string
    metricLabel?: string | null
    value?: number | null
    valueText?: string | null
    asOfDate?: Date | string | null
    sourceNote?: string | null
    createdAt?: Date | string
  }

  export type AIOutputScopeCreateManyGeoZipInput = {
    id?: string
    outputId: string
    scopeType: $Enums.AIScopeType
    countyId?: string | null
    issueId?: string | null
    districtId?: string | null
    customKey?: string | null
    createdAt?: Date | string
  }

  export type ElectionResultCreateManyGeoZipInput = {
    id?: string
    electionId: string
    countyId?: string | null
    precinctId?: string | null
    choiceLabel: string
    votes?: number | null
    voteShare?: number | null
    createdAt?: Date | string
  }

  export type CensusMetricUpdateWithoutGeoZipInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricKey?: StringFieldUpdateOperationsInput | string
    metricLabel?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    valueText?: NullableStringFieldUpdateOperationsInput | string | null
    asOfDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    county?: CountyUpdateOneWithoutCensusMetricsNestedInput
  }

  export type CensusMetricUncheckedUpdateWithoutGeoZipInput = {
    id?: StringFieldUpdateOperationsInput | string
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    metricKey?: StringFieldUpdateOperationsInput | string
    metricLabel?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    valueText?: NullableStringFieldUpdateOperationsInput | string | null
    asOfDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CensusMetricUncheckedUpdateManyWithoutGeoZipInput = {
    id?: StringFieldUpdateOperationsInput | string
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    metricKey?: StringFieldUpdateOperationsInput | string
    metricLabel?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    valueText?: NullableStringFieldUpdateOperationsInput | string | null
    asOfDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIOutputScopeUpdateWithoutGeoZipInput = {
    id?: StringFieldUpdateOperationsInput | string
    scopeType?: EnumAIScopeTypeFieldUpdateOperationsInput | $Enums.AIScopeType
    customKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    output?: AIOutputUpdateOneRequiredWithoutScopesNestedInput
    county?: CountyUpdateOneWithoutAiOutputScopesNestedInput
    issue?: IssueUpdateOneWithoutAiOutputScopesNestedInput
    district?: GeoDistrictUpdateOneWithoutAiOutputScopesNestedInput
  }

  export type AIOutputScopeUncheckedUpdateWithoutGeoZipInput = {
    id?: StringFieldUpdateOperationsInput | string
    outputId?: StringFieldUpdateOperationsInput | string
    scopeType?: EnumAIScopeTypeFieldUpdateOperationsInput | $Enums.AIScopeType
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    issueId?: NullableStringFieldUpdateOperationsInput | string | null
    districtId?: NullableStringFieldUpdateOperationsInput | string | null
    customKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIOutputScopeUncheckedUpdateManyWithoutGeoZipInput = {
    id?: StringFieldUpdateOperationsInput | string
    outputId?: StringFieldUpdateOperationsInput | string
    scopeType?: EnumAIScopeTypeFieldUpdateOperationsInput | $Enums.AIScopeType
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    issueId?: NullableStringFieldUpdateOperationsInput | string | null
    districtId?: NullableStringFieldUpdateOperationsInput | string | null
    customKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElectionResultUpdateWithoutGeoZipInput = {
    id?: StringFieldUpdateOperationsInput | string
    choiceLabel?: StringFieldUpdateOperationsInput | string
    votes?: NullableIntFieldUpdateOperationsInput | number | null
    voteShare?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    election?: ElectionUpdateOneRequiredWithoutResultsNestedInput
    county?: CountyUpdateOneWithoutElectionResultsNestedInput
    precinct?: GeoPrecinctUpdateOneWithoutElectionResultsNestedInput
  }

  export type ElectionResultUncheckedUpdateWithoutGeoZipInput = {
    id?: StringFieldUpdateOperationsInput | string
    electionId?: StringFieldUpdateOperationsInput | string
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    precinctId?: NullableStringFieldUpdateOperationsInput | string | null
    choiceLabel?: StringFieldUpdateOperationsInput | string
    votes?: NullableIntFieldUpdateOperationsInput | number | null
    voteShare?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElectionResultUncheckedUpdateManyWithoutGeoZipInput = {
    id?: StringFieldUpdateOperationsInput | string
    electionId?: StringFieldUpdateOperationsInput | string
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    precinctId?: NullableStringFieldUpdateOperationsInput | string | null
    choiceLabel?: StringFieldUpdateOperationsInput | string
    votes?: NullableIntFieldUpdateOperationsInput | number | null
    voteShare?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElectionResultCreateManyPrecinctInput = {
    id?: string
    electionId: string
    countyId?: string | null
    geoZipId?: string | null
    choiceLabel: string
    votes?: number | null
    voteShare?: number | null
    createdAt?: Date | string
  }

  export type ElectionResultUpdateWithoutPrecinctInput = {
    id?: StringFieldUpdateOperationsInput | string
    choiceLabel?: StringFieldUpdateOperationsInput | string
    votes?: NullableIntFieldUpdateOperationsInput | number | null
    voteShare?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    election?: ElectionUpdateOneRequiredWithoutResultsNestedInput
    county?: CountyUpdateOneWithoutElectionResultsNestedInput
    geoZip?: GeoZipUpdateOneWithoutElectionResultsNestedInput
  }

  export type ElectionResultUncheckedUpdateWithoutPrecinctInput = {
    id?: StringFieldUpdateOperationsInput | string
    electionId?: StringFieldUpdateOperationsInput | string
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    geoZipId?: NullableStringFieldUpdateOperationsInput | string | null
    choiceLabel?: StringFieldUpdateOperationsInput | string
    votes?: NullableIntFieldUpdateOperationsInput | number | null
    voteShare?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElectionResultUncheckedUpdateManyWithoutPrecinctInput = {
    id?: StringFieldUpdateOperationsInput | string
    electionId?: StringFieldUpdateOperationsInput | string
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    geoZipId?: NullableStringFieldUpdateOperationsInput | string | null
    choiceLabel?: StringFieldUpdateOperationsInput | string
    votes?: NullableIntFieldUpdateOperationsInput | number | null
    voteShare?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CivicsOfficialCreateManyDistrictInput = {
    id?: string
    name: string
    officeName: string
    party?: string | null
    phone?: string | null
    website?: string | null
    photoUrl?: string | null
    countyId?: string | null
    sourceNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIOutputScopeCreateManyDistrictInput = {
    id?: string
    outputId: string
    scopeType: $Enums.AIScopeType
    countyId?: string | null
    issueId?: string | null
    geoZipId?: string | null
    customKey?: string | null
    createdAt?: Date | string
  }

  export type CivicsOfficialUpdateWithoutDistrictInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    officeName?: StringFieldUpdateOperationsInput | string
    party?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    sourceNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    county?: CountyUpdateOneWithoutCivicsOfficialsNestedInput
  }

  export type CivicsOfficialUncheckedUpdateWithoutDistrictInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    officeName?: StringFieldUpdateOperationsInput | string
    party?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CivicsOfficialUncheckedUpdateManyWithoutDistrictInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    officeName?: StringFieldUpdateOperationsInput | string
    party?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIOutputScopeUpdateWithoutDistrictInput = {
    id?: StringFieldUpdateOperationsInput | string
    scopeType?: EnumAIScopeTypeFieldUpdateOperationsInput | $Enums.AIScopeType
    customKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    output?: AIOutputUpdateOneRequiredWithoutScopesNestedInput
    county?: CountyUpdateOneWithoutAiOutputScopesNestedInput
    issue?: IssueUpdateOneWithoutAiOutputScopesNestedInput
    geoZip?: GeoZipUpdateOneWithoutAiOutputScopesNestedInput
  }

  export type AIOutputScopeUncheckedUpdateWithoutDistrictInput = {
    id?: StringFieldUpdateOperationsInput | string
    outputId?: StringFieldUpdateOperationsInput | string
    scopeType?: EnumAIScopeTypeFieldUpdateOperationsInput | $Enums.AIScopeType
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    issueId?: NullableStringFieldUpdateOperationsInput | string | null
    geoZipId?: NullableStringFieldUpdateOperationsInput | string | null
    customKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIOutputScopeUncheckedUpdateManyWithoutDistrictInput = {
    id?: StringFieldUpdateOperationsInput | string
    outputId?: StringFieldUpdateOperationsInput | string
    scopeType?: EnumAIScopeTypeFieldUpdateOperationsInput | $Enums.AIScopeType
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    issueId?: NullableStringFieldUpdateOperationsInput | string | null
    geoZipId?: NullableStringFieldUpdateOperationsInput | string | null
    customKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElectionResultCreateManyElectionInput = {
    id?: string
    countyId?: string | null
    geoZipId?: string | null
    precinctId?: string | null
    choiceLabel: string
    votes?: number | null
    voteShare?: number | null
    createdAt?: Date | string
  }

  export type ElectionResultUpdateWithoutElectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    choiceLabel?: StringFieldUpdateOperationsInput | string
    votes?: NullableIntFieldUpdateOperationsInput | number | null
    voteShare?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    county?: CountyUpdateOneWithoutElectionResultsNestedInput
    geoZip?: GeoZipUpdateOneWithoutElectionResultsNestedInput
    precinct?: GeoPrecinctUpdateOneWithoutElectionResultsNestedInput
  }

  export type ElectionResultUncheckedUpdateWithoutElectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    geoZipId?: NullableStringFieldUpdateOperationsInput | string | null
    precinctId?: NullableStringFieldUpdateOperationsInput | string | null
    choiceLabel?: StringFieldUpdateOperationsInput | string
    votes?: NullableIntFieldUpdateOperationsInput | number | null
    voteShare?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElectionResultUncheckedUpdateManyWithoutElectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    geoZipId?: NullableStringFieldUpdateOperationsInput | string | null
    precinctId?: NullableStringFieldUpdateOperationsInput | string | null
    choiceLabel?: StringFieldUpdateOperationsInput | string
    votes?: NullableIntFieldUpdateOperationsInput | number | null
    voteShare?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIRunCreateManyPromptInput = {
    id?: string
    model: string
    paramsJson?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.AIRunStatus
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorText?: string | null
    inputSummary?: string | null
    createdAt?: Date | string
  }

  export type AIRunUpdateWithoutPromptInput = {
    id?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    paramsJson?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAIRunStatusFieldUpdateOperationsInput | $Enums.AIRunStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorText?: NullableStringFieldUpdateOperationsInput | string | null
    inputSummary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    outputs?: AIOutputUpdateManyWithoutRunNestedInput
    inputSources?: AIRunInputSourceUpdateManyWithoutRunNestedInput
    analyses?: AIAnalysisUpdateManyWithoutAiRunNestedInput
  }

  export type AIRunUncheckedUpdateWithoutPromptInput = {
    id?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    paramsJson?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAIRunStatusFieldUpdateOperationsInput | $Enums.AIRunStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorText?: NullableStringFieldUpdateOperationsInput | string | null
    inputSummary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    outputs?: AIOutputUncheckedUpdateManyWithoutRunNestedInput
    inputSources?: AIRunInputSourceUncheckedUpdateManyWithoutRunNestedInput
    analyses?: AIAnalysisUncheckedUpdateManyWithoutAiRunNestedInput
  }

  export type AIRunUncheckedUpdateManyWithoutPromptInput = {
    id?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    paramsJson?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumAIRunStatusFieldUpdateOperationsInput | $Enums.AIRunStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorText?: NullableStringFieldUpdateOperationsInput | string | null
    inputSummary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIOutputCreateManyRunInput = {
    id?: string
    outputType?: $Enums.AIOutputType
    status?: $Enums.PublishStatus
    title?: string | null
    summary?: string | null
    contentMd: string
    reviewedAt?: Date | string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIRunInputSourceCreateManyRunInput = {
    id?: string
    kind?: $Enums.AIRunInputKind
    sourceDocumentId?: string | null
    externalKey?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type AIAnalysisCreateManyAiRunInput = {
    id?: string
    transcriptId?: string | null
    mediaAssetId?: string | null
    analysisType?: $Enums.AnalysisType
    contentJson: JsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
  }

  export type AIOutputUpdateWithoutRunInput = {
    id?: StringFieldUpdateOperationsInput | string
    outputType?: EnumAIOutputTypeFieldUpdateOperationsInput | $Enums.AIOutputType
    status?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    title?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    contentMd?: StringFieldUpdateOperationsInput | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sections?: AIOutputSectionUpdateManyWithoutOutputNestedInput
    scopes?: AIOutputScopeUpdateManyWithoutOutputNestedInput
  }

  export type AIOutputUncheckedUpdateWithoutRunInput = {
    id?: StringFieldUpdateOperationsInput | string
    outputType?: EnumAIOutputTypeFieldUpdateOperationsInput | $Enums.AIOutputType
    status?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    title?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    contentMd?: StringFieldUpdateOperationsInput | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sections?: AIOutputSectionUncheckedUpdateManyWithoutOutputNestedInput
    scopes?: AIOutputScopeUncheckedUpdateManyWithoutOutputNestedInput
  }

  export type AIOutputUncheckedUpdateManyWithoutRunInput = {
    id?: StringFieldUpdateOperationsInput | string
    outputType?: EnumAIOutputTypeFieldUpdateOperationsInput | $Enums.AIOutputType
    status?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    title?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    contentMd?: StringFieldUpdateOperationsInput | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIRunInputSourceUpdateWithoutRunInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumAIRunInputKindFieldUpdateOperationsInput | $Enums.AIRunInputKind
    externalKey?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceDocument?: SourceDocumentUpdateOneWithoutRunInputsNestedInput
  }

  export type AIRunInputSourceUncheckedUpdateWithoutRunInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumAIRunInputKindFieldUpdateOperationsInput | $Enums.AIRunInputKind
    sourceDocumentId?: NullableStringFieldUpdateOperationsInput | string | null
    externalKey?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIRunInputSourceUncheckedUpdateManyWithoutRunInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumAIRunInputKindFieldUpdateOperationsInput | $Enums.AIRunInputKind
    sourceDocumentId?: NullableStringFieldUpdateOperationsInput | string | null
    externalKey?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIAnalysisUpdateWithoutAiRunInput = {
    id?: StringFieldUpdateOperationsInput | string
    analysisType?: EnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType
    contentJson?: JsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transcript?: TranscriptUpdateOneWithoutAnalysesNestedInput
    mediaAsset?: MediaAssetUpdateOneWithoutAnalysesNestedInput
  }

  export type AIAnalysisUncheckedUpdateWithoutAiRunInput = {
    id?: StringFieldUpdateOperationsInput | string
    transcriptId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaAssetId?: NullableStringFieldUpdateOperationsInput | string | null
    analysisType?: EnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType
    contentJson?: JsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIAnalysisUncheckedUpdateManyWithoutAiRunInput = {
    id?: StringFieldUpdateOperationsInput | string
    transcriptId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaAssetId?: NullableStringFieldUpdateOperationsInput | string | null
    analysisType?: EnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType
    contentJson?: JsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIOutputSectionCreateManyOutputInput = {
    id?: string
    sectionKey: string
    heading?: string | null
    order?: number
    contentMd: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIOutputScopeCreateManyOutputInput = {
    id?: string
    scopeType: $Enums.AIScopeType
    countyId?: string | null
    issueId?: string | null
    geoZipId?: string | null
    districtId?: string | null
    customKey?: string | null
    createdAt?: Date | string
  }

  export type AIOutputSectionUpdateWithoutOutputInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionKey?: StringFieldUpdateOperationsInput | string
    heading?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    contentMd?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    citations?: CitationUpdateManyWithoutOutputSectionNestedInput
  }

  export type AIOutputSectionUncheckedUpdateWithoutOutputInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionKey?: StringFieldUpdateOperationsInput | string
    heading?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    contentMd?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    citations?: CitationUncheckedUpdateManyWithoutOutputSectionNestedInput
  }

  export type AIOutputSectionUncheckedUpdateManyWithoutOutputInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionKey?: StringFieldUpdateOperationsInput | string
    heading?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    contentMd?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIOutputScopeUpdateWithoutOutputInput = {
    id?: StringFieldUpdateOperationsInput | string
    scopeType?: EnumAIScopeTypeFieldUpdateOperationsInput | $Enums.AIScopeType
    customKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    county?: CountyUpdateOneWithoutAiOutputScopesNestedInput
    issue?: IssueUpdateOneWithoutAiOutputScopesNestedInput
    geoZip?: GeoZipUpdateOneWithoutAiOutputScopesNestedInput
    district?: GeoDistrictUpdateOneWithoutAiOutputScopesNestedInput
  }

  export type AIOutputScopeUncheckedUpdateWithoutOutputInput = {
    id?: StringFieldUpdateOperationsInput | string
    scopeType?: EnumAIScopeTypeFieldUpdateOperationsInput | $Enums.AIScopeType
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    issueId?: NullableStringFieldUpdateOperationsInput | string | null
    geoZipId?: NullableStringFieldUpdateOperationsInput | string | null
    districtId?: NullableStringFieldUpdateOperationsInput | string | null
    customKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIOutputScopeUncheckedUpdateManyWithoutOutputInput = {
    id?: StringFieldUpdateOperationsInput | string
    scopeType?: EnumAIScopeTypeFieldUpdateOperationsInput | $Enums.AIScopeType
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    issueId?: NullableStringFieldUpdateOperationsInput | string | null
    geoZipId?: NullableStringFieldUpdateOperationsInput | string | null
    districtId?: NullableStringFieldUpdateOperationsInput | string | null
    customKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CitationCreateManyOutputSectionInput = {
    id?: string
    sourceChunkId?: string | null
    sourceDocumentId?: string | null
    label?: string | null
    locatorJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type CitationUpdateWithoutOutputSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    locatorJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceChunk?: SourceChunkUpdateOneWithoutCitationsNestedInput
    sourceDocument?: SourceDocumentUpdateOneWithoutCitationsNestedInput
  }

  export type CitationUncheckedUpdateWithoutOutputSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceChunkId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceDocumentId?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    locatorJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CitationUncheckedUpdateManyWithoutOutputSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceChunkId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceDocumentId?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    locatorJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyQuestionCreateManyFormInput = {
    id?: string
    questionKey: string
    prompt: string
    helpText?: string | null
    questionType: $Enums.SurveyQuestionType
    required?: boolean
    sortOrder?: number
    isActive?: boolean
    allowVoice?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SurveyResponseCreateManyFormInput = {
    id?: string
    countyId?: string | null
    sourceLabel?: string | null
    submittedAt?: Date | string
    ipHash?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type SourceDocumentLinkCreateManySurveyFormInput = {
    id?: string
    sourceDocumentId: string
    countyId?: string | null
    issueId?: string | null
    blueprintSectionId?: string | null
    quoteId?: string | null
    assetId?: string | null
    note?: string | null
    createdAt?: Date | string
  }

  export type SurveyQuestionUpdateWithoutFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionKey?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    helpText?: NullableStringFieldUpdateOperationsInput | string | null
    questionType?: EnumSurveyQuestionTypeFieldUpdateOperationsInput | $Enums.SurveyQuestionType
    required?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    allowVoice?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: SurveyQuestionOptionUpdateManyWithoutQuestionNestedInput
    responseItems?: SurveyResponseItemUpdateManyWithoutQuestionNestedInput
  }

  export type SurveyQuestionUncheckedUpdateWithoutFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionKey?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    helpText?: NullableStringFieldUpdateOperationsInput | string | null
    questionType?: EnumSurveyQuestionTypeFieldUpdateOperationsInput | $Enums.SurveyQuestionType
    required?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    allowVoice?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: SurveyQuestionOptionUncheckedUpdateManyWithoutQuestionNestedInput
    responseItems?: SurveyResponseItemUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type SurveyQuestionUncheckedUpdateManyWithoutFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionKey?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    helpText?: NullableStringFieldUpdateOperationsInput | string | null
    questionType?: EnumSurveyQuestionTypeFieldUpdateOperationsInput | $Enums.SurveyQuestionType
    required?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    allowVoice?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyResponseUpdateWithoutFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceLabel?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipHash?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    county?: CountyUpdateOneWithoutSurveyResponsesNestedInput
    items?: SurveyResponseItemUpdateManyWithoutResponseNestedInput
  }

  export type SurveyResponseUncheckedUpdateWithoutFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLabel?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipHash?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: SurveyResponseItemUncheckedUpdateManyWithoutResponseNestedInput
  }

  export type SurveyResponseUncheckedUpdateManyWithoutFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLabel?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipHash?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SourceDocumentLinkUpdateWithoutSurveyFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceDocument?: SourceDocumentUpdateOneRequiredWithoutSourceLinksNestedInput
    county?: CountyUpdateOneWithoutSourceLinksNestedInput
    issue?: IssueUpdateOneWithoutSourceLinksNestedInput
    blueprintSection?: BlueprintSectionUpdateOneWithoutSourceLinksNestedInput
    quote?: QuoteUpdateOneWithoutSourceLinksNestedInput
    asset?: AssetUpdateOneWithoutSourceLinksNestedInput
  }

  export type SourceDocumentLinkUncheckedUpdateWithoutSurveyFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceDocumentId?: StringFieldUpdateOperationsInput | string
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    issueId?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintSectionId?: NullableStringFieldUpdateOperationsInput | string | null
    quoteId?: NullableStringFieldUpdateOperationsInput | string | null
    assetId?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SourceDocumentLinkUncheckedUpdateManyWithoutSurveyFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceDocumentId?: StringFieldUpdateOperationsInput | string
    countyId?: NullableStringFieldUpdateOperationsInput | string | null
    issueId?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintSectionId?: NullableStringFieldUpdateOperationsInput | string | null
    quoteId?: NullableStringFieldUpdateOperationsInput | string | null
    assetId?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyQuestionOptionCreateManyQuestionInput = {
    id?: string
    valueKey: string
    label: string
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type SurveyResponseItemCreateManyQuestionInput = {
    id?: string
    responseId: string
    valueText?: string | null
    valueNumber?: number | null
    valueBoolean?: boolean | null
    selectedOptionId?: string | null
    mediaAssetId?: string | null
    createdAt?: Date | string
  }

  export type SurveyQuestionOptionUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    valueKey?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responseItemOptions?: SurveyResponseItemOptionUpdateManyWithoutOptionNestedInput
    selectedByResponseItems?: SurveyResponseItemUpdateManyWithoutSelectedOptionNestedInput
  }

  export type SurveyQuestionOptionUncheckedUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    valueKey?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responseItemOptions?: SurveyResponseItemOptionUncheckedUpdateManyWithoutOptionNestedInput
    selectedByResponseItems?: SurveyResponseItemUncheckedUpdateManyWithoutSelectedOptionNestedInput
  }

  export type SurveyQuestionOptionUncheckedUpdateManyWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    valueKey?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyResponseItemUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    valueText?: NullableStringFieldUpdateOperationsInput | string | null
    valueNumber?: NullableFloatFieldUpdateOperationsInput | number | null
    valueBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    response?: SurveyResponseUpdateOneRequiredWithoutItemsNestedInput
    selectedOption?: SurveyQuestionOptionUpdateOneWithoutSelectedByResponseItemsNestedInput
    mediaAsset?: MediaAssetUpdateOneWithoutSurveyResponseItemsNestedInput
    multiSelectedOptions?: SurveyResponseItemOptionUpdateManyWithoutResponseItemNestedInput
  }

  export type SurveyResponseItemUncheckedUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    responseId?: StringFieldUpdateOperationsInput | string
    valueText?: NullableStringFieldUpdateOperationsInput | string | null
    valueNumber?: NullableFloatFieldUpdateOperationsInput | number | null
    valueBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
    selectedOptionId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaAssetId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    multiSelectedOptions?: SurveyResponseItemOptionUncheckedUpdateManyWithoutResponseItemNestedInput
  }

  export type SurveyResponseItemUncheckedUpdateManyWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    responseId?: StringFieldUpdateOperationsInput | string
    valueText?: NullableStringFieldUpdateOperationsInput | string | null
    valueNumber?: NullableFloatFieldUpdateOperationsInput | number | null
    valueBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
    selectedOptionId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaAssetId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyResponseItemOptionCreateManyOptionInput = {
    id?: string
    responseItemId: string
    createdAt?: Date | string
  }

  export type SurveyResponseItemCreateManySelectedOptionInput = {
    id?: string
    responseId: string
    questionId: string
    valueText?: string | null
    valueNumber?: number | null
    valueBoolean?: boolean | null
    mediaAssetId?: string | null
    createdAt?: Date | string
  }

  export type SurveyResponseItemOptionUpdateWithoutOptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responseItem?: SurveyResponseItemUpdateOneRequiredWithoutMultiSelectedOptionsNestedInput
  }

  export type SurveyResponseItemOptionUncheckedUpdateWithoutOptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    responseItemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyResponseItemOptionUncheckedUpdateManyWithoutOptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    responseItemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyResponseItemUpdateWithoutSelectedOptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    valueText?: NullableStringFieldUpdateOperationsInput | string | null
    valueNumber?: NullableFloatFieldUpdateOperationsInput | number | null
    valueBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    response?: SurveyResponseUpdateOneRequiredWithoutItemsNestedInput
    question?: SurveyQuestionUpdateOneRequiredWithoutResponseItemsNestedInput
    mediaAsset?: MediaAssetUpdateOneWithoutSurveyResponseItemsNestedInput
    multiSelectedOptions?: SurveyResponseItemOptionUpdateManyWithoutResponseItemNestedInput
  }

  export type SurveyResponseItemUncheckedUpdateWithoutSelectedOptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    responseId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    valueText?: NullableStringFieldUpdateOperationsInput | string | null
    valueNumber?: NullableFloatFieldUpdateOperationsInput | number | null
    valueBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
    mediaAssetId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    multiSelectedOptions?: SurveyResponseItemOptionUncheckedUpdateManyWithoutResponseItemNestedInput
  }

  export type SurveyResponseItemUncheckedUpdateManyWithoutSelectedOptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    responseId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    valueText?: NullableStringFieldUpdateOperationsInput | string | null
    valueNumber?: NullableFloatFieldUpdateOperationsInput | number | null
    valueBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
    mediaAssetId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyResponseItemCreateManyResponseInput = {
    id?: string
    questionId: string
    valueText?: string | null
    valueNumber?: number | null
    valueBoolean?: boolean | null
    selectedOptionId?: string | null
    mediaAssetId?: string | null
    createdAt?: Date | string
  }

  export type SurveyResponseItemUpdateWithoutResponseInput = {
    id?: StringFieldUpdateOperationsInput | string
    valueText?: NullableStringFieldUpdateOperationsInput | string | null
    valueNumber?: NullableFloatFieldUpdateOperationsInput | number | null
    valueBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: SurveyQuestionUpdateOneRequiredWithoutResponseItemsNestedInput
    selectedOption?: SurveyQuestionOptionUpdateOneWithoutSelectedByResponseItemsNestedInput
    mediaAsset?: MediaAssetUpdateOneWithoutSurveyResponseItemsNestedInput
    multiSelectedOptions?: SurveyResponseItemOptionUpdateManyWithoutResponseItemNestedInput
  }

  export type SurveyResponseItemUncheckedUpdateWithoutResponseInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    valueText?: NullableStringFieldUpdateOperationsInput | string | null
    valueNumber?: NullableFloatFieldUpdateOperationsInput | number | null
    valueBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
    selectedOptionId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaAssetId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    multiSelectedOptions?: SurveyResponseItemOptionUncheckedUpdateManyWithoutResponseItemNestedInput
  }

  export type SurveyResponseItemUncheckedUpdateManyWithoutResponseInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    valueText?: NullableStringFieldUpdateOperationsInput | string | null
    valueNumber?: NullableFloatFieldUpdateOperationsInput | number | null
    valueBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
    selectedOptionId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaAssetId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyResponseItemOptionCreateManyResponseItemInput = {
    id?: string
    optionId: string
    createdAt?: Date | string
  }

  export type SurveyResponseItemOptionUpdateWithoutResponseItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    option?: SurveyQuestionOptionUpdateOneRequiredWithoutResponseItemOptionsNestedInput
  }

  export type SurveyResponseItemOptionUncheckedUpdateWithoutResponseItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    optionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyResponseItemOptionUncheckedUpdateManyWithoutResponseItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    optionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyResponseItemCreateManyMediaAssetInput = {
    id?: string
    responseId: string
    questionId: string
    valueText?: string | null
    valueNumber?: number | null
    valueBoolean?: boolean | null
    selectedOptionId?: string | null
    createdAt?: Date | string
  }

  export type TranscriptCreateManyMediaAssetInput = {
    id?: string
    provider?: string | null
    providerVersion?: string | null
    language?: string | null
    transcriptText: string
    segmentsJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AIAnalysisCreateManyMediaAssetInput = {
    id?: string
    transcriptId?: string | null
    aiRunId?: string | null
    analysisType?: $Enums.AnalysisType
    contentJson: JsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
  }

  export type SurveyResponseItemUpdateWithoutMediaAssetInput = {
    id?: StringFieldUpdateOperationsInput | string
    valueText?: NullableStringFieldUpdateOperationsInput | string | null
    valueNumber?: NullableFloatFieldUpdateOperationsInput | number | null
    valueBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    response?: SurveyResponseUpdateOneRequiredWithoutItemsNestedInput
    question?: SurveyQuestionUpdateOneRequiredWithoutResponseItemsNestedInput
    selectedOption?: SurveyQuestionOptionUpdateOneWithoutSelectedByResponseItemsNestedInput
    multiSelectedOptions?: SurveyResponseItemOptionUpdateManyWithoutResponseItemNestedInput
  }

  export type SurveyResponseItemUncheckedUpdateWithoutMediaAssetInput = {
    id?: StringFieldUpdateOperationsInput | string
    responseId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    valueText?: NullableStringFieldUpdateOperationsInput | string | null
    valueNumber?: NullableFloatFieldUpdateOperationsInput | number | null
    valueBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
    selectedOptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    multiSelectedOptions?: SurveyResponseItemOptionUncheckedUpdateManyWithoutResponseItemNestedInput
  }

  export type SurveyResponseItemUncheckedUpdateManyWithoutMediaAssetInput = {
    id?: StringFieldUpdateOperationsInput | string
    responseId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    valueText?: NullableStringFieldUpdateOperationsInput | string | null
    valueNumber?: NullableFloatFieldUpdateOperationsInput | number | null
    valueBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
    selectedOptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranscriptUpdateWithoutMediaAssetInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerVersion?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptText?: StringFieldUpdateOperationsInput | string
    segmentsJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: AIAnalysisUpdateManyWithoutTranscriptNestedInput
  }

  export type TranscriptUncheckedUpdateWithoutMediaAssetInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerVersion?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptText?: StringFieldUpdateOperationsInput | string
    segmentsJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analyses?: AIAnalysisUncheckedUpdateManyWithoutTranscriptNestedInput
  }

  export type TranscriptUncheckedUpdateManyWithoutMediaAssetInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerVersion?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptText?: StringFieldUpdateOperationsInput | string
    segmentsJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIAnalysisUpdateWithoutMediaAssetInput = {
    id?: StringFieldUpdateOperationsInput | string
    analysisType?: EnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType
    contentJson?: JsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transcript?: TranscriptUpdateOneWithoutAnalysesNestedInput
    aiRun?: AIRunUpdateOneWithoutAnalysesNestedInput
  }

  export type AIAnalysisUncheckedUpdateWithoutMediaAssetInput = {
    id?: StringFieldUpdateOperationsInput | string
    transcriptId?: NullableStringFieldUpdateOperationsInput | string | null
    aiRunId?: NullableStringFieldUpdateOperationsInput | string | null
    analysisType?: EnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType
    contentJson?: JsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIAnalysisUncheckedUpdateManyWithoutMediaAssetInput = {
    id?: StringFieldUpdateOperationsInput | string
    transcriptId?: NullableStringFieldUpdateOperationsInput | string | null
    aiRunId?: NullableStringFieldUpdateOperationsInput | string | null
    analysisType?: EnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType
    contentJson?: JsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIAnalysisCreateManyTranscriptInput = {
    id?: string
    mediaAssetId?: string | null
    aiRunId?: string | null
    analysisType?: $Enums.AnalysisType
    contentJson: JsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
  }

  export type AIAnalysisUpdateWithoutTranscriptInput = {
    id?: StringFieldUpdateOperationsInput | string
    analysisType?: EnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType
    contentJson?: JsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaAsset?: MediaAssetUpdateOneWithoutAnalysesNestedInput
    aiRun?: AIRunUpdateOneWithoutAnalysesNestedInput
  }

  export type AIAnalysisUncheckedUpdateWithoutTranscriptInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaAssetId?: NullableStringFieldUpdateOperationsInput | string | null
    aiRunId?: NullableStringFieldUpdateOperationsInput | string | null
    analysisType?: EnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType
    contentJson?: JsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIAnalysisUncheckedUpdateManyWithoutTranscriptInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaAssetId?: NullableStringFieldUpdateOperationsInput | string | null
    aiRunId?: NullableStringFieldUpdateOperationsInput | string | null
    analysisType?: EnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType
    contentJson?: JsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoteHistoryCreateManyVoterInput = {
    id?: string
    electionDate?: Date | string | null
    electionName?: string | null
    voteType?: string | null
    createdAt?: Date | string
  }

  export type SegmentMemberCreateManyVoterInput = {
    id?: string
    segmentId: string
    createdAt?: Date | string
  }

  export type VoteHistoryUpdateWithoutVoterInput = {
    id?: StringFieldUpdateOperationsInput | string
    electionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    electionName?: NullableStringFieldUpdateOperationsInput | string | null
    voteType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoteHistoryUncheckedUpdateWithoutVoterInput = {
    id?: StringFieldUpdateOperationsInput | string
    electionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    electionName?: NullableStringFieldUpdateOperationsInput | string | null
    voteType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoteHistoryUncheckedUpdateManyWithoutVoterInput = {
    id?: StringFieldUpdateOperationsInput | string
    electionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    electionName?: NullableStringFieldUpdateOperationsInput | string | null
    voteType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SegmentMemberUpdateWithoutVoterInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    segment?: SegmentUpdateOneRequiredWithoutMembersNestedInput
  }

  export type SegmentMemberUncheckedUpdateWithoutVoterInput = {
    id?: StringFieldUpdateOperationsInput | string
    segmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SegmentMemberUncheckedUpdateManyWithoutVoterInput = {
    id?: StringFieldUpdateOperationsInput | string
    segmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SegmentMemberCreateManySegmentInput = {
    id?: string
    voterId: string
    createdAt?: Date | string
  }

  export type SegmentMemberUpdateWithoutSegmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    voter?: VoterRegistrationUpdateOneRequiredWithoutSegmentMembershipsNestedInput
  }

  export type SegmentMemberUncheckedUpdateWithoutSegmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    voterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SegmentMemberUncheckedUpdateManyWithoutSegmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    voterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyImportJobInput = {
    id?: string
    actorLabel?: string | null
    action: string
    entityType?: string | null
    entityId?: string | null
    metadataJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateWithoutImportJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorLabel?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadataJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutImportJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorLabel?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadataJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutImportJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorLabel?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadataJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}